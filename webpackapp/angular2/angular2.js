(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(130);
	__webpack_require__(132);
	module.exports = __webpack_require__(155);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _schedulersVirtualTimeScheduler = __webpack_require__(13);

	var _schedulersVirtualTimeScheduler2 = _interopRequireDefault(_schedulersVirtualTimeScheduler);

	var _schedulersTestScheduler = __webpack_require__(14);

	var _schedulersTestScheduler2 = _interopRequireDefault(_schedulersTestScheduler);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var _Observable = __webpack_require__(3);

	var _Observable2 = _interopRequireDefault(_Observable);

	var _Subscriber = __webpack_require__(4);

	var _Subscriber2 = _interopRequireDefault(_Subscriber);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _Notification = __webpack_require__(15);

	var _Notification2 = _interopRequireDefault(_Notification);

	var _subjectsReplaySubject = __webpack_require__(26);

	var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);

	var _subjectsBehaviorSubject = __webpack_require__(27);

	var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);

	var _observablesConnectableObservable = __webpack_require__(28);

	var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);

	var _observablesArrayObservable = __webpack_require__(29);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _observablesDeferObservable = __webpack_require__(32);

	var _observablesDeferObservable2 = _interopRequireDefault(_observablesDeferObservable);

	var _observablesEmptyObservable = __webpack_require__(31);

	var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);

	var _observablesErrorObservable = __webpack_require__(35);

	var _observablesErrorObservable2 = _interopRequireDefault(_observablesErrorObservable);

	var _observablesInfiniteObservable = __webpack_require__(36);

	var _observablesInfiniteObservable2 = _interopRequireDefault(_observablesInfiniteObservable);

	var _observablesIntervalObservable = __webpack_require__(37);

	var _observablesIntervalObservable2 = _interopRequireDefault(_observablesIntervalObservable);

	var _observablesPromiseObservable = __webpack_require__(39);

	var _observablesPromiseObservable2 = _interopRequireDefault(_observablesPromiseObservable);

	var _observablesRangeObservable = __webpack_require__(40);

	var _observablesRangeObservable2 = _interopRequireDefault(_observablesRangeObservable);

	var _observablesTimerObservable = __webpack_require__(41);

	var _observablesTimerObservable2 = _interopRequireDefault(_observablesTimerObservable);

	var _observablesFromEventPatternObservable = __webpack_require__(42);

	var _observablesFromEventPatternObservable2 = _interopRequireDefault(_observablesFromEventPatternObservable);

	var _observablesFromEventObservable = __webpack_require__(43);

	var _observablesFromEventObservable2 = _interopRequireDefault(_observablesFromEventObservable);

	var _observablesForkJoinObservable = __webpack_require__(44);

	var _observablesForkJoinObservable2 = _interopRequireDefault(_observablesForkJoinObservable);

	var _observablesFromObservable = __webpack_require__(45);

	var _observablesFromObservable2 = _interopRequireDefault(_observablesFromObservable);

	var _operatorsConcatStatic = __webpack_require__(49);

	var _operatorsConcatStatic2 = _interopRequireDefault(_operatorsConcatStatic);

	var _operatorsConcat = __webpack_require__(52);

	var _operatorsConcat2 = _interopRequireDefault(_operatorsConcat);

	var _operatorsConcatAll = __webpack_require__(53);

	var _operatorsConcatAll2 = _interopRequireDefault(_operatorsConcatAll);

	var _operatorsConcatMap = __webpack_require__(54);

	var _operatorsConcatMap2 = _interopRequireDefault(_operatorsConcatMap);

	var _operatorsConcatMapTo = __webpack_require__(56);

	var _operatorsConcatMapTo2 = _interopRequireDefault(_operatorsConcatMapTo);

	var _operatorsMerge = __webpack_require__(58);

	var _operatorsMerge2 = _interopRequireDefault(_operatorsMerge);

	var _operatorsMergeStatic = __webpack_require__(50);

	var _operatorsMergeStatic2 = _interopRequireDefault(_operatorsMergeStatic);

	var _operatorsMergeAll = __webpack_require__(59);

	var _operatorsMergeAll2 = _interopRequireDefault(_operatorsMergeAll);

	var _operatorsFlatMap = __webpack_require__(60);

	var _operatorsFlatMap2 = _interopRequireDefault(_operatorsFlatMap);

	var _operatorsFlatMapTo = __webpack_require__(61);

	var _operatorsFlatMapTo2 = _interopRequireDefault(_operatorsFlatMapTo);

	var _operatorsSwitchAll = __webpack_require__(62);

	var _operatorsSwitchAll2 = _interopRequireDefault(_operatorsSwitchAll);

	var _operatorsSwitchLatest = __webpack_require__(63);

	var _operatorsSwitchLatest2 = _interopRequireDefault(_operatorsSwitchLatest);

	var _operatorsSwitchLatestTo = __webpack_require__(64);

	var _operatorsSwitchLatestTo2 = _interopRequireDefault(_operatorsSwitchLatestTo);

	var _operatorsExpand = __webpack_require__(65);

	var _operatorsExpand2 = _interopRequireDefault(_operatorsExpand);

	var _operatorsDo = __webpack_require__(66);

	var _operatorsDo2 = _interopRequireDefault(_operatorsDo);

	var _operatorsMap = __webpack_require__(67);

	var _operatorsMap2 = _interopRequireDefault(_operatorsMap);

	var _operatorsMapTo = __webpack_require__(69);

	var _operatorsMapTo2 = _interopRequireDefault(_operatorsMapTo);

	var _operatorsToArray = __webpack_require__(70);

	var _operatorsToArray2 = _interopRequireDefault(_operatorsToArray);

	var _operatorsCount = __webpack_require__(71);

	var _operatorsCount2 = _interopRequireDefault(_operatorsCount);

	var _operatorsScan = __webpack_require__(72);

	var _operatorsScan2 = _interopRequireDefault(_operatorsScan);

	var _operatorsReduce = __webpack_require__(73);

	var _operatorsReduce2 = _interopRequireDefault(_operatorsReduce);

	var _operatorsStartWith = __webpack_require__(74);

	var _operatorsStartWith2 = _interopRequireDefault(_operatorsStartWith);

	var _operatorsTake = __webpack_require__(75);

	var _operatorsTake2 = _interopRequireDefault(_operatorsTake);

	var _operatorsSkip = __webpack_require__(76);

	var _operatorsSkip2 = _interopRequireDefault(_operatorsSkip);

	var _operatorsSkipUntil = __webpack_require__(77);

	var _operatorsSkipUntil2 = _interopRequireDefault(_operatorsSkipUntil);

	var _operatorsTakeUntil = __webpack_require__(78);

	var _operatorsTakeUntil2 = _interopRequireDefault(_operatorsTakeUntil);

	var _operatorsFilter = __webpack_require__(79);

	var _operatorsFilter2 = _interopRequireDefault(_operatorsFilter);

	var _operatorsDistinctUntilChanged = __webpack_require__(80);

	var _operatorsDistinctUntilChanged2 = _interopRequireDefault(_operatorsDistinctUntilChanged);

	var _operatorsDistinctUntilKeyChanged = __webpack_require__(81);

	var _operatorsDistinctUntilKeyChanged2 = _interopRequireDefault(_operatorsDistinctUntilKeyChanged);

	var _operatorsCombineLatest = __webpack_require__(82);

	var _operatorsCombineLatest2 = _interopRequireDefault(_operatorsCombineLatest);

	var _operatorsCombineLatestStatic = __webpack_require__(85);

	var _operatorsCombineLatestStatic2 = _interopRequireDefault(_operatorsCombineLatestStatic);

	var _operatorsCombineAll = __webpack_require__(86);

	var _operatorsCombineAll2 = _interopRequireDefault(_operatorsCombineAll);

	var _operatorsWithLatestFrom = __webpack_require__(87);

	var _operatorsWithLatestFrom2 = _interopRequireDefault(_operatorsWithLatestFrom);

	var _operatorsZip = __webpack_require__(88);

	var _operatorsZip2 = _interopRequireDefault(_operatorsZip);

	var _operatorsZipStatic = __webpack_require__(89);

	var _operatorsZipStatic2 = _interopRequireDefault(_operatorsZipStatic);

	var _operatorsZipAll = __webpack_require__(90);

	var _operatorsZipAll2 = _interopRequireDefault(_operatorsZipAll);

	var _operatorsPublish = __webpack_require__(91);

	var _operatorsPublish2 = _interopRequireDefault(_operatorsPublish);

	var _operatorsPublishBehavior = __webpack_require__(93);

	var _operatorsPublishBehavior2 = _interopRequireDefault(_operatorsPublishBehavior);

	var _operatorsPublishReplay = __webpack_require__(94);

	var _operatorsPublishReplay2 = _interopRequireDefault(_operatorsPublishReplay);

	var _operatorsMulticast = __webpack_require__(92);

	var _operatorsMulticast2 = _interopRequireDefault(_operatorsMulticast);

	var _operatorsObserveOn = __webpack_require__(95);

	var _operatorsObserveOn2 = _interopRequireDefault(_operatorsObserveOn);

	var _operatorsSubscribeOn = __webpack_require__(96);

	var _operatorsSubscribeOn2 = _interopRequireDefault(_operatorsSubscribeOn);

	var _operatorsPartition = __webpack_require__(98);

	var _operatorsPartition2 = _interopRequireDefault(_operatorsPartition);

	var _operatorsToPromise = __webpack_require__(100);

	var _operatorsToPromise2 = _interopRequireDefault(_operatorsToPromise);

	var _operatorsDefaultIfEmpty = __webpack_require__(101);

	var _operatorsDefaultIfEmpty2 = _interopRequireDefault(_operatorsDefaultIfEmpty);

	var _operatorsMaterialize = __webpack_require__(102);

	var _operatorsMaterialize2 = _interopRequireDefault(_operatorsMaterialize);

	var _operatorsCatch = __webpack_require__(103);

	var _operatorsCatch2 = _interopRequireDefault(_operatorsCatch);

	var _operatorsRetry = __webpack_require__(104);

	var _operatorsRetry2 = _interopRequireDefault(_operatorsRetry);

	var _operatorsRetryWhen = __webpack_require__(105);

	var _operatorsRetryWhen2 = _interopRequireDefault(_operatorsRetryWhen);

	var _operatorsRepeat = __webpack_require__(106);

	var _operatorsRepeat2 = _interopRequireDefault(_operatorsRepeat);

	var _operatorsFinally = __webpack_require__(107);

	var _operatorsFinally2 = _interopRequireDefault(_operatorsFinally);

	var _operatorsTimeout = __webpack_require__(108);

	var _operatorsTimeout2 = _interopRequireDefault(_operatorsTimeout);

	var _operatorsTimeoutWith = __webpack_require__(110);

	var _operatorsTimeoutWith2 = _interopRequireDefault(_operatorsTimeoutWith);

	var _operatorsGroupBy = __webpack_require__(111);

	var _operatorsGroupBy2 = _interopRequireDefault(_operatorsGroupBy);

	var _operatorsWindow = __webpack_require__(115);

	var _operatorsWindow2 = _interopRequireDefault(_operatorsWindow);

	var _operatorsWindowWhen = __webpack_require__(116);

	var _operatorsWindowWhen2 = _interopRequireDefault(_operatorsWindowWhen);

	var _operatorsWindowToggle = __webpack_require__(117);

	var _operatorsWindowToggle2 = _interopRequireDefault(_operatorsWindowToggle);

	var _operatorsWindowTime = __webpack_require__(118);

	var _operatorsWindowTime2 = _interopRequireDefault(_operatorsWindowTime);

	var _operatorsWindowCount = __webpack_require__(119);

	var _operatorsWindowCount2 = _interopRequireDefault(_operatorsWindowCount);

	var _operatorsDelay = __webpack_require__(120);

	var _operatorsDelay2 = _interopRequireDefault(_operatorsDelay);

	var _operatorsThrottle = __webpack_require__(121);

	var _operatorsThrottle2 = _interopRequireDefault(_operatorsThrottle);

	var _operatorsDebounce = __webpack_require__(122);

	var _operatorsDebounce2 = _interopRequireDefault(_operatorsDebounce);

	var _operatorsBuffer = __webpack_require__(123);

	var _operatorsBuffer2 = _interopRequireDefault(_operatorsBuffer);

	var _operatorsBufferCount = __webpack_require__(124);

	var _operatorsBufferCount2 = _interopRequireDefault(_operatorsBufferCount);

	var _operatorsBufferTime = __webpack_require__(125);

	var _operatorsBufferTime2 = _interopRequireDefault(_operatorsBufferTime);

	var _operatorsBufferToggle = __webpack_require__(126);

	var _operatorsBufferToggle2 = _interopRequireDefault(_operatorsBufferToggle);

	var _operatorsBufferWhen = __webpack_require__(127);

	var _operatorsBufferWhen2 = _interopRequireDefault(_operatorsBufferWhen);

	var _operatorsSample = __webpack_require__(128);

	var _operatorsSample2 = _interopRequireDefault(_operatorsSample);

	var _operatorsSampleTime = __webpack_require__(129);

	var _operatorsSampleTime2 = _interopRequireDefault(_operatorsSampleTime);

	_Observable2['default'].defer = _observablesDeferObservable2['default'].create;
	_Observable2['default'].from = _observablesFromObservable2['default'].create;
	_Observable2['default'].fromArray = _observablesArrayObservable2['default'].create;
	_Observable2['default'].fromPromise = _observablesPromiseObservable2['default'].create;
	_Observable2['default'].of = _observablesArrayObservable2['default'].of;
	_Observable2['default'].range = _observablesRangeObservable2['default'].create;
	_Observable2['default'].fromEventPattern = _observablesFromEventPatternObservable2['default'].create;
	_Observable2['default'].forkJoin = _observablesForkJoinObservable2['default'].create;
	_Observable2['default']['throw'] = _observablesErrorObservable2['default'].create;
	_Observable2['default'].empty = _observablesEmptyObservable2['default'].create;
	_Observable2['default'].never = _observablesInfiniteObservable2['default'].create;
	_Observable2['default'].timer = _observablesTimerObservable2['default'].create;
	_Observable2['default'].interval = _observablesIntervalObservable2['default'].create;
	_Observable2['default'].fromEvent = _observablesFromEventObservable2['default'].create;
	var observableProto = _Observable2['default'].prototype;

	_Observable2['default'].concat = _operatorsConcatStatic2['default'];
	observableProto.concat = _operatorsConcat2['default'];
	observableProto.concatAll = _operatorsConcatAll2['default'];
	observableProto.concatMap = _operatorsConcatMap2['default'];
	observableProto.concatMapTo = _operatorsConcatMapTo2['default'];

	_Observable2['default'].merge = _operatorsMergeStatic2['default'];
	observableProto.merge = _operatorsMerge2['default'];
	observableProto.mergeAll = _operatorsMergeAll2['default'];
	observableProto.flatMap = _operatorsFlatMap2['default'];
	observableProto.flatMapTo = _operatorsFlatMapTo2['default'];
	observableProto.switchAll = _operatorsSwitchAll2['default'];
	observableProto.switchLatest = _operatorsSwitchLatest2['default'];
	observableProto.switchLatestTo = _operatorsSwitchLatestTo2['default'];
	observableProto.expand = _operatorsExpand2['default'];

	observableProto['do'] = _operatorsDo2['default'];
	observableProto.map = _operatorsMap2['default'];
	observableProto.mapTo = _operatorsMapTo2['default'];
	observableProto.toArray = _operatorsToArray2['default'];
	observableProto.count = _operatorsCount2['default'];
	observableProto.scan = _operatorsScan2['default'];
	observableProto.reduce = _operatorsReduce2['default'];
	observableProto.startWith = _operatorsStartWith2['default'];

	observableProto.take = _operatorsTake2['default'];
	observableProto.skip = _operatorsSkip2['default'];
	observableProto.takeUntil = _operatorsTakeUntil2['default'];
	observableProto.skipUntil = _operatorsSkipUntil2['default'];
	observableProto.filter = _operatorsFilter2['default'];
	observableProto.distinctUntilChanged = _operatorsDistinctUntilChanged2['default'];
	observableProto.distinctUntilKeyChanged = _operatorsDistinctUntilKeyChanged2['default'];

	_Observable2['default'].combineLatest = _operatorsCombineLatestStatic2['default'];
	observableProto.combineLatest = _operatorsCombineLatest2['default'];
	observableProto.combineAll = _operatorsCombineAll2['default'];
	observableProto.withLatestFrom = _operatorsWithLatestFrom2['default'];

	_Observable2['default'].zip = _operatorsZipStatic2['default'];
	observableProto.zip = _operatorsZip2['default'];
	observableProto.zipAll = _operatorsZipAll2['default'];

	observableProto.publish = _operatorsPublish2['default'];
	observableProto.publishBehavior = _operatorsPublishBehavior2['default'];
	observableProto.publishReplay = _operatorsPublishReplay2['default'];
	observableProto.multicast = _operatorsMulticast2['default'];

	observableProto.observeOn = _operatorsObserveOn2['default'];
	observableProto.subscribeOn = _operatorsSubscribeOn2['default'];

	observableProto.partition = _operatorsPartition2['default'];
	observableProto.toPromise = _operatorsToPromise2['default'];
	observableProto.defaultIfEmpty = _operatorsDefaultIfEmpty2['default'];
	observableProto.materialize = _operatorsMaterialize2['default'];

	observableProto['catch'] = _operatorsCatch2['default'];
	observableProto.retry = _operatorsRetry2['default'];
	observableProto.retryWhen = _operatorsRetryWhen2['default'];
	observableProto.repeat = _operatorsRepeat2['default'];

	observableProto['finally'] = _operatorsFinally2['default'];
	observableProto.timeout = _operatorsTimeout2['default'];
	observableProto.timeoutWith = _operatorsTimeoutWith2['default'];

	observableProto.groupBy = _operatorsGroupBy2['default'];
	observableProto.window = _operatorsWindow2['default'];
	observableProto.windowWhen = _operatorsWindowWhen2['default'];
	observableProto.windowToggle = _operatorsWindowToggle2['default'];
	observableProto.windowTime = _operatorsWindowTime2['default'];
	observableProto.windowCount = _operatorsWindowCount2['default'];

	observableProto.delay = _operatorsDelay2['default'];
	observableProto.throttle = _operatorsThrottle2['default'];
	observableProto.debounce = _operatorsDebounce2['default'];

	observableProto.buffer = _operatorsBuffer2['default'];
	observableProto.bufferCount = _operatorsBufferCount2['default'];
	observableProto.bufferTime = _operatorsBufferTime2['default'];
	observableProto.bufferToggle = _operatorsBufferToggle2['default'];
	observableProto.bufferWhen = _operatorsBufferWhen2['default'];

	observableProto.sample = _operatorsSample2['default'];
	observableProto.sampleTime = _operatorsSampleTime2['default'];
	var Scheduler = {
	    nextTick: _schedulersNextTick2['default'],
	    immediate: _schedulersImmediate2['default']
	};
	exports.Subject = _Subject2['default'];
	exports.Scheduler = Scheduler;
	exports.Observable = _Observable2['default'];
	exports.Subscriber = _Subscriber2['default'];
	exports.Subscription = _Subscription2['default'];
	exports.ReplaySubject = _subjectsReplaySubject2['default'];
	exports.BehaviorSubject = _subjectsBehaviorSubject2['default'];
	exports.ConnectableObservable = _observablesConnectableObservable2['default'];
	exports.Notification = _Notification2['default'];
	exports.VirtualTimeScheduler = _schedulersVirtualTimeScheduler2['default'];
	exports.TestScheduler = _schedulersTestScheduler2['default'];

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscriber = __webpack_require__(4);

	var _Subscriber2 = _interopRequireDefault(_Subscriber);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _subjectsSubjectSubscription = __webpack_require__(12);

	var _subjectsSubjectSubscription2 = _interopRequireDefault(_subjectsSubjectSubscription);

	var subscriptionAdd = _Subscription2['default'].prototype.add;
	var subscriptionRemove = _Subscription2['default'].prototype.remove;
	var subscriptionUnsubscribe = _Subscription2['default'].prototype.unsubscribe;
	var subscriberNext = _Subscriber2['default'].prototype.next;
	var subscriberError = _Subscriber2['default'].prototype.error;
	var subscriberComplete = _Subscriber2['default'].prototype.complete;
	var _subscriberNext = _Subscriber2['default'].prototype._next;
	var _subscriberError = _Subscriber2['default'].prototype._error;
	var _subscriberComplete = _Subscriber2['default'].prototype._complete;
	var _observableSubscribe = _Observable3['default'].prototype._subscribe;

	var Subject = (function (_Observable) {
	    _inherits(Subject, _Observable);

	    function Subject() {
	        _classCallCheck(this, Subject);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        _Observable.call.apply(_Observable, [this].concat(args));
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.dispatching = false;
	        this.errorSignal = false;
	        this.completeSignal = false;
	    }

	    Subject.create = function create(source, destination) {
	        return new BidirectionalSubject(source, destination);
	    };

	    Subject.prototype.lift = function lift(operator) {
	        var subject = new BidirectionalSubject(this, this.destination || this);
	        subject.operator = operator;
	        return subject;
	    };

	    Subject.prototype._subscribe = function _subscribe(subscriber) {
	        if (subscriber.isUnsubscribed) {
	            return;
	        } else if (this.errorSignal) {
	            subscriber.error(this.errorInstance);
	            return;
	        } else if (this.completeSignal) {
	            subscriber.complete();
	            return;
	        } else if (this.isUnsubscribed) {
	            throw new Error("Cannot subscribe to a disposed Subject.");
	        }
	        this.observers.push(subscriber);
	        return new _subjectsSubjectSubscription2['default'](this, subscriber);
	    };

	    Subject.prototype.add = function add(subscription) {
	        subscriptionAdd.call(this, subscription);
	    };

	    Subject.prototype.remove = function remove(subscription) {
	        subscriptionRemove.call(this, subscription);
	    };

	    Subject.prototype.unsubscribe = function unsubscribe() {
	        this.observers = void 0;
	        subscriptionUnsubscribe.call(this);
	    };

	    Subject.prototype.next = function next(value) {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.dispatching = true;
	        this._next(value);
	        this.dispatching = false;
	        if (this.errorSignal) {
	            this.error(this.errorInstance);
	        } else if (this.completeSignal) {
	            this.complete();
	        }
	    };

	    Subject.prototype.error = function error(_error) {
	        if (this.isUnsubscribed || this.completeSignal) {
	            return;
	        }
	        this.errorSignal = true;
	        this.errorInstance = _error;
	        if (this.dispatching) {
	            return;
	        }
	        this._error(_error);
	        this.unsubscribe();
	    };

	    Subject.prototype.complete = function complete() {
	        if (this.isUnsubscribed || this.errorSignal) {
	            return;
	        }
	        this.completeSignal = true;
	        if (this.dispatching) {
	            return;
	        }
	        this._complete();
	        this.unsubscribe();
	    };

	    Subject.prototype._next = function _next(value) {
	        var index = -1;
	        var observers = this.observers.slice(0);
	        var len = observers.length;
	        while (++index < len) {
	            observers[index].next(value);
	        }
	    };

	    Subject.prototype._error = function _error(error) {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization -- block next, complete, and unsubscribe while dispatching
	        this.observers = void 0;
	        this.isUnsubscribed = true;
	        while (++index < len) {
	            observers[index].error(error);
	        }
	        this.isUnsubscribed = false;
	    };

	    Subject.prototype._complete = function _complete() {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization -- block next, complete, and unsubscribe while dispatching
	        this.observers = void 0; // optimization
	        this.isUnsubscribed = true;
	        while (++index < len) {
	            observers[index].complete();
	        }
	        this.isUnsubscribed = false;
	    };

	    return Subject;
	})(_Observable3['default']);

	exports['default'] = Subject;

	var BidirectionalSubject = (function (_Subject) {
	    _inherits(BidirectionalSubject, _Subject);

	    function BidirectionalSubject(source, destination) {
	        _classCallCheck(this, BidirectionalSubject);

	        _Subject.call(this);
	        this.source = source;
	        this.destination = destination;
	    }

	    BidirectionalSubject.prototype._subscribe = function _subscribe(subscriber) {
	        return _observableSubscribe.call(this, subscriber);
	    };

	    BidirectionalSubject.prototype.next = function next(x) {
	        subscriberNext.call(this, x);
	    };

	    BidirectionalSubject.prototype.error = function error(e) {
	        subscriberError.call(this, e);
	    };

	    BidirectionalSubject.prototype.complete = function complete() {
	        subscriberComplete.call(this);
	    };

	    BidirectionalSubject.prototype._next = function _next(x) {
	        _subscriberNext.call(this, x);
	    };

	    BidirectionalSubject.prototype._error = function _error(e) {
	        _subscriberError.call(this, e);
	    };

	    BidirectionalSubject.prototype._complete = function _complete() {
	        _subscriberComplete.call(this);
	    };

	    return BidirectionalSubject;
	})(Subject);

	module.exports = exports['default'];

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber = __webpack_require__(4);

	var _Subscriber2 = _interopRequireDefault(_Subscriber);

	var _utilSymbol_observable = __webpack_require__(9);

	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */

	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is
	     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify
	     * of a succesful completion.
	     */

	    function Observable(subscribe) {
	        _classCallCheck(this, Observable);

	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }

	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature.
	    /**
	     * @static
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @returns {Observable} a new cold observable
	     * @description creates a new cold Observable by calling the Observable constructor
	     */

	    /**
	     * @method lift
	     * @param {Operator} the operator defining the operation to take on the observable
	     * @returns {Observable} a new observable with the Operator applied
	     * @description creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     */

	    Observable.prototype.lift = function lift(operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };

	    /**
	     * @method Symbol.observable
	     * @returns {Observable} this instance of the observable
	     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     */

	    Observable.prototype[_utilSymbol_observable2['default']] = function () {
	        return this;
	    };

	    /**
	     * @method subscribe
	     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @returns {Subscription} a subscription reference to the registered handlers
	     * @description registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     */

	    Observable.prototype.subscribe = function subscribe(observerOrNext, error, complete) {
	        var subscriber = undefined;
	        if (observerOrNext && typeof observerOrNext === "object") {
	            if (observerOrNext instanceof _Subscriber2['default']) {
	                subscriber = observerOrNext;
	            } else {
	                subscriber = new _Subscriber2['default'](observerOrNext);
	            }
	        } else {
	            var next = observerOrNext;
	            subscriber = _Subscriber2['default'].create(next, error, complete);
	        }
	        subscriber.add(this._subscribe(subscriber));
	        return subscriber;
	    };

	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @returns {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */

	    Observable.prototype.forEach = function forEach(next) {
	        var _this = this;

	        return new Promise(function (resolve, reject) {
	            _this.subscribe(next, reject, resolve);
	        });
	    };

	    Observable.prototype._subscribe = function _subscribe(subscriber) {
	        return this.source._subscribe(this.operator.call(subscriber));
	    };

	    return Observable;
	})();

	exports['default'] = Observable;
	Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	};
	module.exports = exports['default'];

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilNoop = __webpack_require__(5);

	var _utilNoop2 = _interopRequireDefault(_utilNoop);

	var _utilThrowError = __webpack_require__(6);

	var _utilThrowError2 = _interopRequireDefault(_utilThrowError);

	var _utilTryOrOnError = __webpack_require__(7);

	var _utilTryOrOnError2 = _interopRequireDefault(_utilTryOrOnError);

	var _Subscription2 = __webpack_require__(8);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var Subscriber = (function (_Subscription) {
	    _inherits(Subscriber, _Subscription);

	    function Subscriber(destination) {
	        _classCallCheck(this, Subscriber);

	        _Subscription.call(this);
	        this._isUnsubscribed = false;
	        this.destination = destination;
	        if (!destination) {
	            return;
	        }
	        var subscription = destination._subscription;
	        if (subscription) {
	            this._subscription = subscription;
	        } else if (destination instanceof Subscriber) {
	            this._subscription = destination;
	        }
	    }

	    Subscriber.create = function create(next, error, complete) {
	        var subscriber = new Subscriber();
	        subscriber._next = typeof next === "function" && _utilTryOrOnError2['default'](next) || _utilNoop2['default'];
	        subscriber._error = typeof error === "function" && error || _utilThrowError2['default'];
	        subscriber._complete = typeof complete === "function" && complete || _utilNoop2['default'];
	        return subscriber;
	    };

	    Subscriber.prototype._next = function _next(value) {
	        this.destination.next(value);
	    };

	    Subscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };

	    Subscriber.prototype._complete = function _complete() {
	        this.destination.complete();
	    };

	    Subscriber.prototype.add = function add(sub) {
	        // route add to the shared Subscription if it exists
	        var _subscription = this._subscription;
	        if (_subscription) {
	            _subscription.add(sub);
	        } else {
	            _Subscription.prototype.add.call(this, sub);
	        }
	    };

	    Subscriber.prototype.remove = function remove(sub) {
	        // route remove to the shared Subscription if it exists
	        if (this._subscription) {
	            this._subscription.remove(sub);
	        } else {
	            _Subscription.prototype.remove.call(this, sub);
	        }
	    };

	    Subscriber.prototype.unsubscribe = function unsubscribe() {
	        if (this._isUnsubscribed) {
	            return;
	        } else if (this._subscription) {
	            this._isUnsubscribed = true;
	        } else {
	            _Subscription.prototype.unsubscribe.call(this);
	        }
	    };

	    Subscriber.prototype.next = function next(value) {
	        if (!this.isUnsubscribed) {
	            this._next(value);
	        }
	    };

	    Subscriber.prototype.error = function error(_error2) {
	        if (!this.isUnsubscribed) {
	            this._error(_error2);
	            this.unsubscribe();
	        }
	    };

	    Subscriber.prototype.complete = function complete() {
	        if (!this.isUnsubscribed) {
	            this._complete();
	            this.unsubscribe();
	        }
	    };

	    _createClass(Subscriber, [{
	        key: 'isUnsubscribed',
	        get: function get() {
	            var subscription = this._subscription;
	            if (subscription) {
	                // route to the shared Subscription if it exists
	                return this._isUnsubscribed || subscription.isUnsubscribed;
	            } else {
	                return this._isUnsubscribed;
	            }
	        },
	        set: function set(value) {
	            var subscription = this._subscription;
	            if (subscription) {
	                // route to the shared Subscription if it exists
	                subscription.isUnsubscribed = Boolean(value);
	            } else {
	                this._isUnsubscribed = Boolean(value);
	            }
	        }
	    }]);

	    return Subscriber;
	})(_Subscription3['default']);

	exports['default'] = Subscriber;
	module.exports = exports['default'];

/***/ },
/* 5 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = noop;

	function noop() {}

	module.exports = exports["default"];

/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = throwError;

	function throwError(e) {
	  throw e;
	}

	module.exports = exports["default"];

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = tryOrOnError;

	function tryOrOnError(target) {
	    function tryCatcher() {
	        try {
	            tryCatcher.target.apply(this, arguments);
	        } catch (e) {
	            this.error(e);
	        }
	    }
	    tryCatcher.target = target;
	    return tryCatcher;
	}

	module.exports = exports["default"];

/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Subscription = (function () {
	    function Subscription(_unsubscribe) {
	        _classCallCheck(this, Subscription);

	        this.isUnsubscribed = false;
	        if (_unsubscribe) {
	            this._unsubscribe = _unsubscribe;
	        }
	    }

	    Subscription.prototype._unsubscribe = function _unsubscribe() {};

	    Subscription.prototype.unsubscribe = function unsubscribe() {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var unsubscribe = this._unsubscribe;
	        var subscriptions = this._subscriptions;
	        this._subscriptions = void 0;
	        if (unsubscribe) {
	            unsubscribe.call(this);
	        }
	        if (subscriptions != null) {
	            var index = -1;
	            var len = subscriptions.length;
	            while (++index < len) {
	                subscriptions[index].unsubscribe();
	            }
	        }
	    };

	    Subscription.prototype.add = function add(subscription) {
	        // return early if:
	        //  1. the subscription is null
	        //  2. we're attempting to add our this
	        //  3. we're attempting to add the static `empty` Subscription
	        if (!subscription || subscription === this || subscription === Subscription.EMPTY) {
	            return;
	        }
	        var sub = subscription;
	        switch (typeof subscription) {
	            case "function":
	                sub = new Subscription(subscription);
	            case "object":
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== "function") {
	                    break;
	                } else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                } else {
	                    var subscriptions = this._subscriptions || (this._subscriptions = []);
	                    subscriptions.push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');
	        }
	    };

	    Subscription.prototype.remove = function remove(subscription) {
	        // return early if:
	        //  1. the subscription is null
	        //  2. we're attempting to remove ourthis
	        //  3. we're attempting to remove the static `empty` Subscription
	        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };

	    return Subscription;
	})();

	exports["default"] = Subscription;

	Subscription.EMPTY = (function (empty) {
	    empty.isUnsubscribed = true;
	    return empty;
	})(new Subscription());
	module.exports = exports["default"];

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _root = __webpack_require__(10);

	if (!_root.root.Symbol) {
	    _root.root.Symbol = {};
	}
	if (!_root.root.Symbol.observable) {
	    if (typeof _root.root.Symbol['for'] === 'function') {
	        _root.root.Symbol.observable = _root.root.Symbol['for']('observable');
	    } else {
	        _root.root.Symbol.observable = '@@observable';
	    }
	}
	exports['default'] = _root.root.Symbol.observable;
	module.exports = exports['default'];

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	exports.__esModule = true;
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	var root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;
	exports.root = root;
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = root = freeGlobal;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)(module), (function() { return this; }())))

/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subscription2 = __webpack_require__(8);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var SubjectSubscription = (function (_Subscription) {
	    _inherits(SubjectSubscription, _Subscription);

	    function SubjectSubscription(subject, observer) {
	        _classCallCheck(this, SubjectSubscription);

	        _Subscription.call(this);
	        this.subject = subject;
	        this.observer = observer;
	        this.isUnsubscribed = false;
	    }

	    SubjectSubscription.prototype.unsubscribe = function unsubscribe() {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = void 0;
	        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.observer);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };

	    return SubjectSubscription;
	})(_Subscription3['default']);

	exports['default'] = SubjectSubscription;
	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _Subscription2 = __webpack_require__(8);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var VirtualTimeScheduler = (function () {
	    function VirtualTimeScheduler() {
	        _classCallCheck(this, VirtualTimeScheduler);

	        this.actions = [];
	        this.active = false;
	        this.scheduled = false;
	        this.index = 0;
	        this.sorted = false;
	        this.frame = 0;
	    }

	    VirtualTimeScheduler.prototype.now = function now() {
	        return 0;
	    };

	    VirtualTimeScheduler.prototype.sortActions = function sortActions() {
	        if (!this.sorted) {
	            this.actions.sort(function (a, b) {
	                return a.delay === b.delay ? a.index > b.index ? 1 : -1 : a.delay > b.delay ? 1 : -1;
	            });
	            this.sorted = true;
	        }
	    };

	    VirtualTimeScheduler.prototype.flush = function flush() {
	        this.sortActions();
	        var actions = this.actions;
	        while (actions.length > 0) {
	            var action = actions.shift();
	            this.frame = action.delay;
	            action.execute();
	        }
	        this.frame = 0;
	    };

	    VirtualTimeScheduler.prototype.schedule = function schedule(work, delay, state) {
	        if (delay === undefined) delay = 0;

	        this.sorted = false;
	        return new VirtualAction(this, work, this.index++).schedule(state, delay);
	    };

	    return VirtualTimeScheduler;
	})();

	exports["default"] = VirtualTimeScheduler;

	var VirtualAction = (function (_Subscription) {
	    _inherits(VirtualAction, _Subscription);

	    function VirtualAction(scheduler, work, index) {
	        _classCallCheck(this, VirtualAction);

	        _Subscription.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.index = index;
	    }

	    VirtualAction.prototype.schedule = function schedule(state) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        if (this.isUnsubscribed) {
	            return this;
	        }
	        var scheduler = this.scheduler;
	        var action = scheduler.frame === this.delay ? this : new VirtualAction(scheduler, this.work, scheduler.index += 1);
	        action.state = state;
	        action.delay = scheduler.frame + delay;
	        scheduler.actions.push(action);
	        return this;
	    };

	    VirtualAction.prototype.execute = function execute() {
	        if (this.isUnsubscribed) {
	            throw new Error("How did did we execute a canceled Action?");
	        }
	        this.work(this.state);
	    };

	    VirtualAction.prototype.unsubscribe = function unsubscribe() {
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = void 0;
	        this.state = void 0;
	        this.scheduler = void 0;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        _Subscription.prototype.unsubscribe.call(this);
	    };

	    return VirtualAction;
	})(_Subscription3["default"]);

	module.exports = exports["default"];

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable = __webpack_require__(3);

	var _Observable2 = _interopRequireDefault(_Observable);

	var _VirtualTimeScheduler2 = __webpack_require__(13);

	var _VirtualTimeScheduler3 = _interopRequireDefault(_VirtualTimeScheduler2);

	var _Notification = __webpack_require__(15);

	var _Notification2 = _interopRequireDefault(_Notification);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var TestScheduler = (function (_VirtualTimeScheduler) {
	    _inherits(TestScheduler, _VirtualTimeScheduler);

	    function TestScheduler(assertDeepEqual) {
	        _classCallCheck(this, TestScheduler);

	        _VirtualTimeScheduler.call(this);
	        this.assertDeepEqual = assertDeepEqual;
	        this.flushTests = [];
	    }

	    TestScheduler.prototype.createColdObservable = function createColdObservable(marbles, values, error) {
	        var _this = this;

	        if (marbles.indexOf('^') !== -1) {
	            throw new Error('cold observable cannot have subscription offset "^"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        return _Observable2['default'].create(function (subscriber) {
	            messages.forEach(function (_ref) {
	                var notification = _ref.notification;
	                var frame = _ref.frame;

	                _this.schedule(function () {
	                    notification.observe(subscriber);
	                }, frame);
	            }, _this);
	        });
	    };

	    TestScheduler.prototype.createHotObservable = function createHotObservable(marbles, values, error) {
	        var _this2 = this;

	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var subject = new _Subject2['default']();
	        messages.forEach(function (_ref2) {
	            var notification = _ref2.notification;
	            var frame = _ref2.frame;

	            _this2.schedule(function () {
	                notification.observe(subject);
	            }, frame);
	        }, this);
	        return subject;
	    };

	    TestScheduler.prototype.expect = function expect(observable) {
	        var _this3 = this;

	        var actual = [];
	        var flushTest = {
	            observable: observable, actual: actual, marbles: null, ready: false
	        };
	        this.schedule(function () {
	            observable.subscribe(function (value) {
	                actual.push({ frame: _this3.frame, notification: _Notification2['default'].createNext(value) });
	            }, function (err) {
	                actual.push({ frame: _this3.frame, notification: _Notification2['default'].createError(err) });
	            }, function () {
	                actual.push({ frame: _this3.frame, notification: _Notification2['default'].createComplete() });
	            });
	        }, 0);
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function toBe(marbles, values, errorValue) {
	                flushTest.ready = true;
	                flushTest.marbles = marbles;
	                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue);
	            }
	        };
	    };

	    TestScheduler.prototype.flush = function flush() {
	        _VirtualTimeScheduler.prototype.flush.call(this);
	        var flushTests = this.flushTests.filter(function (test) {
	            return test.ready;
	        });
	        while (flushTests.length > 0) {
	            var test = flushTests.shift();
	            this.assertDeepEqual(test.actual, test.expected);
	        }
	    };

	    TestScheduler.parseMarbles = function parseMarbles(marbles, values, errorValue) {
	        var len = marbles.length;
	        var results = [];
	        var subIndex = marbles.indexOf('^');
	        var frameOffset = subIndex === -1 ? 0 : subIndex * -10;
	        for (var i = 0; i < len; i++) {
	            var frame = i * 10;
	            var notification = undefined;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                    break;
	                case '|':
	                    notification = _Notification2['default'].createComplete();
	                    break;
	                case '^':
	                    break;
	                case '#':
	                    notification = _Notification2['default'].createError(errorValue || 'error');
	                    break;
	                default:
	                    notification = _Notification2['default'].createNext(values[c]);
	                    break;
	            }
	            frame += frameOffset;
	            if (notification) {
	                results.push({ notification: notification, frame: frame });
	            }
	        }
	        return results;
	    };

	    return TestScheduler;
	})(_VirtualTimeScheduler3['default']);

	exports['default'] = TestScheduler;
	module.exports = exports['default'];

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Observable = __webpack_require__(3);

	var _Observable2 = _interopRequireDefault(_Observable);

	var Notification = (function () {
	    function Notification(kind, value, exception) {
	        _classCallCheck(this, Notification);

	        this.kind = kind;
	        this.value = value;
	        this.exception = exception;
	        this.hasValue = kind === 'N';
	    }

	    Notification.prototype.observe = function observe(observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next(this.value);
	            case 'E':
	                return observer.error(this.exception);
	            case 'C':
	                return observer.complete();
	        }
	    };

	    Notification.prototype['do'] = function _do(next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next(this.value);
	            case 'E':
	                return error(this.exception);
	            case 'C':
	                return complete();
	        }
	    };

	    Notification.prototype.accept = function accept(nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        } else {
	            return this['do'](nextOrObserver, error, complete);
	        }
	    };

	    Notification.prototype.toObservable = function toObservable() {
	        var kind = this.kind;
	        var value = this.value;
	        switch (kind) {
	            case 'N':
	                return _Observable2['default'].of(value);
	            case 'E':
	                return _Observable2['default']['throw'](value);
	            case 'C':
	                return _Observable2['default'].empty();
	        }
	    };

	    Notification.createNext = function createNext(value) {
	        return new Notification('N', value);
	    };

	    Notification.createError = function createError(err) {
	        return new Notification('E', undefined, err);
	    };

	    Notification.createComplete = function createComplete() {
	        return new Notification('C');
	    };

	    return Notification;
	})();

	exports['default'] = Notification;
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _ImmediateScheduler = __webpack_require__(17);

	var _ImmediateScheduler2 = _interopRequireDefault(_ImmediateScheduler);

	exports['default'] = new _ImmediateScheduler2['default']();
	module.exports = exports['default'];

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _ImmediateAction = __webpack_require__(18);

	var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);

	var _FutureAction = __webpack_require__(19);

	var _FutureAction2 = _interopRequireDefault(_FutureAction);

	var ImmediateScheduler = (function () {
	    function ImmediateScheduler() {
	        _classCallCheck(this, ImmediateScheduler);

	        this.actions = [];
	        this.active = false;
	        this.scheduled = false;
	    }

	    ImmediateScheduler.prototype.now = function now() {
	        return Date.now();
	    };

	    ImmediateScheduler.prototype.flush = function flush() {
	        if (this.active || this.scheduled) {
	            return;
	        }
	        this.active = true;
	        var actions = this.actions;
	        for (var action = undefined; action = actions.shift();) {
	            action.execute();
	        }
	        this.active = false;
	    };

	    ImmediateScheduler.prototype.schedule = function schedule(work, delay, state) {
	        if (delay === undefined) delay = 0;

	        return delay <= 0 ? this.scheduleNow(work, state) : this.scheduleLater(work, delay, state);
	    };

	    ImmediateScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
	        return new _ImmediateAction2['default'](this, work).schedule(state);
	    };

	    ImmediateScheduler.prototype.scheduleLater = function scheduleLater(work, delay, state) {
	        return new _FutureAction2['default'](this, work).schedule(state, delay);
	    };

	    return ImmediateScheduler;
	})();

	exports['default'] = ImmediateScheduler;
	module.exports = exports['default'];

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subscription2 = __webpack_require__(8);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var ImmediateAction = (function (_Subscription) {
	    _inherits(ImmediateAction, _Subscription);

	    function ImmediateAction(scheduler, work) {
	        _classCallCheck(this, ImmediateAction);

	        _Subscription.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	    }

	    ImmediateAction.prototype.schedule = function schedule(state) {
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        scheduler.flush();
	        return this;
	    };

	    ImmediateAction.prototype.execute = function execute() {
	        if (this.isUnsubscribed) {
	            throw new Error("How did did we execute a canceled Action?");
	        }
	        this.work(this.state);
	    };

	    ImmediateAction.prototype.unsubscribe = function unsubscribe() {
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = void 0;
	        this.state = void 0;
	        this.scheduler = void 0;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        _Subscription.prototype.unsubscribe.call(this);
	    };

	    return ImmediateAction;
	})(_Subscription3["default"]);

	exports["default"] = ImmediateAction;
	module.exports = exports["default"];

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ImmediateAction2 = __webpack_require__(18);

	var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);

	var FutureAction = (function (_ImmediateAction) {
	    _inherits(FutureAction, _ImmediateAction);

	    function FutureAction(scheduler, work) {
	        _classCallCheck(this, FutureAction);

	        _ImmediateAction.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }

	    FutureAction.prototype.schedule = function schedule(state) {
	        var _this = this;

	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.delay = delay;
	        this.state = state;
	        var id = this.id;
	        if (id != null) {
	            this.id = undefined;
	            clearTimeout(id);
	        }
	        var scheduler = this.scheduler;
	        this.id = setTimeout(function () {
	            _this.id = void 0;
	            scheduler.actions.push(_this);
	            scheduler.flush();
	        }, this.delay);
	        return this;
	    };

	    FutureAction.prototype.unsubscribe = function unsubscribe() {
	        var id = this.id;
	        if (id != null) {
	            this.id = void 0;
	            clearTimeout(id);
	        }
	        _ImmediateAction.prototype.unsubscribe.call(this);
	    };

	    return FutureAction;
	})(_ImmediateAction3['default']);

	exports['default'] = FutureAction;
	module.exports = exports['default'];

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _NextTickScheduler = __webpack_require__(21);

	var _NextTickScheduler2 = _interopRequireDefault(_NextTickScheduler);

	exports['default'] = new _NextTickScheduler2['default']();
	module.exports = exports['default'];

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ImmediateScheduler2 = __webpack_require__(17);

	var _ImmediateScheduler3 = _interopRequireDefault(_ImmediateScheduler2);

	var _NextTickAction = __webpack_require__(22);

	var _NextTickAction2 = _interopRequireDefault(_NextTickAction);

	var _ImmediateAction = __webpack_require__(18);

	var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);

	var NextTickScheduler = (function (_ImmediateScheduler) {
	    _inherits(NextTickScheduler, _ImmediateScheduler);

	    function NextTickScheduler() {
	        _classCallCheck(this, NextTickScheduler);

	        _ImmediateScheduler.apply(this, arguments);
	    }

	    NextTickScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
	        return (this.scheduled ? new _ImmediateAction2['default'](this, work) : new _NextTickAction2['default'](this, work)).schedule(state);
	    };

	    return NextTickScheduler;
	})(_ImmediateScheduler3['default']);

	exports['default'] = NextTickScheduler;
	module.exports = exports['default'];

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilImmediate = __webpack_require__(23);

	var _ImmediateAction2 = __webpack_require__(18);

	var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);

	var NextTickAction = (function (_ImmediateAction) {
	    _inherits(NextTickAction, _ImmediateAction);

	    function NextTickAction() {
	        _classCallCheck(this, NextTickAction);

	        _ImmediateAction.apply(this, arguments);
	    }

	    NextTickAction.prototype.schedule = function schedule(state) {
	        var _this = this;

	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        if (!scheduler.scheduled) {
	            scheduler.scheduled = true;
	            this.id = _utilImmediate.Immediate.setImmediate(function () {
	                _this.id = void 0;
	                _this.scheduler.scheduled = false;
	                _this.scheduler.flush();
	            });
	        }
	        return this;
	    };

	    NextTickAction.prototype.unsubscribe = function unsubscribe() {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        _ImmediateAction.prototype.unsubscribe.call(this);
	        if (scheduler.actions.length === 0) {
	            scheduler.active = false;
	            scheduler.scheduled = false;
	            if (id) {
	                this.id = void 0;
	                _utilImmediate.Immediate.clearImmediate(id);
	            }
	        }
	    };

	    return NextTickAction;
	})(_ImmediateAction3['default']);

	exports['default'] = NextTickAction;
	module.exports = exports['default'];

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate) {/**
	All credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	"use strict";

	exports.__esModule = true;

	var _root = __webpack_require__(10);

	var Immediate = {
	    setImmediate: function setImmediate(x) {
	        return 0;
	    },
	    clearImmediate: function clearImmediate(id) {}
	};
	exports.Immediate = Immediate;
	if (_root.root && _root.root.setImmediate) {
	    Immediate.setImmediate = _root.root.setImmediate;
	    Immediate.clearImmediate = _root.root.clearImmediate;
	} else {
	    exports.Immediate = Immediate = (function (global, Immediate) {
	        var nextHandle = 1,
	            // Spec says greater than zero
	        tasksByHandle = {},
	            currentlyRunningATask = false,
	            doc = global.document,
	            setImmediate;
	        // Don't get fooled by e.g. browserify environments.
	        if (({}).toString.call(global.process) === "[object process]") {
	            // For Node.js before 0.9
	            setImmediate = installNextTickImplementation();
	        } else if (canUsePostMessage()) {
	            // For non-IE10 modern browsers
	            setImmediate = installPostMessageImplementation();
	        } else if (global.MessageChannel) {
	            // For web workers, where supported
	            setImmediate = installMessageChannelImplementation();
	        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	            // For IE 68
	            setImmediate = installReadyStateChangeImplementation();
	        } else {
	            // For older browsers
	            setImmediate = installSetTimeoutImplementation();
	        }
	        Immediate.setImmediate = setImmediate;
	        Immediate.clearImmediate = clearImmediate;
	        return Immediate;
	        function clearImmediate(handle) {
	            delete tasksByHandle[handle];
	        }
	        function addFromSetImmediateArguments(args) {
	            tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
	            return nextHandle++;
	        }
	        // This function accepts the same arguments as setImmediate, but
	        // returns a function that requires no arguments.
	        function partiallyApplied(handler) {
	            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                args[_key - 1] = arguments[_key];
	            }

	            return function () {
	                if (typeof handler === "function") {
	                    handler.apply(undefined, args);
	                } else {
	                    new Function("" + handler)();
	                }
	            };
	        }
	        function runIfPresent(handle) {
	            // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	            // So if we're currently running a task, we'll need to delay this invocation.
	            if (currentlyRunningATask) {
	                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	                // "too much recursion" error.
	                setTimeout(partiallyApplied(runIfPresent, handle), 0);
	            } else {
	                var task = tasksByHandle[handle];
	                if (task) {
	                    currentlyRunningATask = true;
	                    try {
	                        task();
	                    } finally {
	                        clearImmediate(handle);
	                        currentlyRunningATask = false;
	                    }
	                }
	            }
	        }
	        function installNextTickImplementation() {
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                global.process.nextTick(partiallyApplied(runIfPresent, handle));
	                return handle;
	            };
	        }
	        function canUsePostMessage() {
	            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	            // where `global.postMessage` means something completely different and can't be used for this purpose.
	            if (global.postMessage && !global.importScripts) {
	                var postMessageIsAsynchronous = true;
	                var oldOnMessage = global.onmessage;
	                global.onmessage = function () {
	                    postMessageIsAsynchronous = false;
	                };
	                global.postMessage("", "*");
	                global.onmessage = oldOnMessage;
	                return postMessageIsAsynchronous;
	            }
	        }
	        function installPostMessageImplementation() {
	            // Installs an event handler on `global` for the `message` event: see
	            // * https://developer.mozilla.org/en/DOM/window.postMessage
	            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	            var messagePrefix = "setImmediate$" + Math.random() + "$";
	            var onGlobalMessage = function onGlobalMessage(event) {
	                if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
	                    runIfPresent(+event.data.slice(messagePrefix.length));
	                }
	            };
	            if (global.addEventListener) {
	                global.addEventListener("message", onGlobalMessage, false);
	            } else {
	                global.attachEvent("onmessage", onGlobalMessage);
	            }
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                global.postMessage(messagePrefix + handle, "*");
	                return handle;
	            };
	        }
	        function installMessageChannelImplementation() {
	            var channel = new MessageChannel();
	            channel.port1.onmessage = function (event) {
	                var handle = event.data;
	                runIfPresent(handle);
	            };
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                channel.port2.postMessage(handle);
	                return handle;
	            };
	        }
	        function installReadyStateChangeImplementation() {
	            var html = doc.documentElement;
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	                var script = doc.createElement("script");
	                script.onreadystatechange = function () {
	                    runIfPresent(handle);
	                    script.onreadystatechange = null;
	                    html.removeChild(script);
	                    script = null;
	                };
	                html.appendChild(script);
	                return handle;
	            };
	        }
	        function installSetTimeoutImplementation() {
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                setTimeout(partiallyApplied(runIfPresent, handle), 0);
	                return handle;
	            };
	        }
	    })(_root.root, Immediate);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24).clearImmediate))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(25).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24).setImmediate, __webpack_require__(24).clearImmediate))

/***/ },
/* 25 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subject2 = __webpack_require__(2);

	var _Subject3 = _interopRequireDefault(_Subject2);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var ReplaySubject = (function (_Subject) {
	    _inherits(ReplaySubject, _Subject);

	    function ReplaySubject(bufferSize, _windowTime, scheduler) {
	        if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	        if (_windowTime === undefined) _windowTime = Number.POSITIVE_INFINITY;

	        _classCallCheck(this, ReplaySubject);

	        _Subject.call(this);
	        this.events = [];
	        this.bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = _windowTime < 1 ? 1 : _windowTime;
	        this.scheduler = scheduler;
	    }

	    ReplaySubject.prototype._next = function _next(value) {
	        var now = this._getNow();
	        this.events.push(new ReplayEvent(now, value));
	        this._getEvents(now);
	        _Subject.prototype._next.call(this, value);
	    };

	    ReplaySubject.prototype._subscribe = function _subscribe(subscriber) {
	        var events = this._getEvents(this._getNow());
	        var index = -1;
	        var len = events.length;
	        while (!subscriber.isUnsubscribed && ++index < len) {
	            subscriber.next(events[index].value);
	        }
	        return _Subject.prototype._subscribe.call(this, subscriber);
	    };

	    ReplaySubject.prototype._getNow = function _getNow() {
	        return (this.scheduler || _schedulersImmediate2['default']).now();
	    };

	    ReplaySubject.prototype._getEvents = function _getEvents(now) {
	        var bufferSize = this.bufferSize;
	        var _windowTime = this._windowTime;
	        var events = this.events;
	        var eventsCount = events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if (now - events[spliceCount].time < _windowTime) {
	                break;
	            }
	            spliceCount += 1;
	        }
	        if (eventsCount > bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - bufferSize);
	        }
	        if (spliceCount > 0) {
	            events.splice(0, spliceCount);
	        }
	        return events;
	    };

	    return ReplaySubject;
	})(_Subject3['default']);

	exports['default'] = ReplaySubject;

	var ReplayEvent = function ReplayEvent(time, value) {
	    _classCallCheck(this, ReplayEvent);

	    this.time = time;
	    this.value = value;
	};

	module.exports = exports['default'];

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subject2 = __webpack_require__(2);

	var _Subject3 = _interopRequireDefault(_Subject2);

	var BehaviorSubject = (function (_Subject) {
	    _inherits(BehaviorSubject, _Subject);

	    function BehaviorSubject(value) {
	        _classCallCheck(this, BehaviorSubject);

	        _Subject.call(this);
	        this.value = value;
	    }

	    BehaviorSubject.prototype._subscribe = function _subscribe(subscriber) {
	        var subscription = _Subject.prototype._subscribe.call(this, subscriber);
	        if (!subscription) {
	            return;
	        } else if (!subscription.isUnsubscribed) {
	            subscriber.next(this.value);
	        }
	        return subscription;
	    };

	    BehaviorSubject.prototype._next = function _next(value) {
	        _Subject.prototype._next.call(this, this.value = value);
	    };

	    return BehaviorSubject;
	})(_Subject3['default']);

	exports['default'] = BehaviorSubject;
	module.exports = exports['default'];

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable3 = __webpack_require__(3);

	var _Observable4 = _interopRequireDefault(_Observable3);

	var _Subscription3 = __webpack_require__(8);

	var _Subscription4 = _interopRequireDefault(_Subscription3);

	var ConnectableObservable = (function (_Observable) {
	    _inherits(ConnectableObservable, _Observable);

	    function ConnectableObservable(source, subjectFactory) {
	        _classCallCheck(this, ConnectableObservable);

	        _Observable.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	    }

	    ConnectableObservable.prototype._subscribe = function _subscribe(subscriber) {
	        return this._getSubject().subscribe(subscriber);
	    };

	    ConnectableObservable.prototype._getSubject = function _getSubject() {
	        var subject = this.subject;
	        if (subject && !subject.isUnsubscribed) {
	            return subject;
	        }
	        return this.subject = this.subjectFactory();
	    };

	    ConnectableObservable.prototype.connect = function connect() {
	        var source = this.source;
	        var subscription = this.subscription;
	        if (subscription && !subscription.isUnsubscribed) {
	            return subscription;
	        }
	        subscription = source.subscribe(this._getSubject());
	        subscription.add(new ConnectableSubscription(this));
	        return this.subscription = subscription;
	    };

	    ConnectableObservable.prototype.refCount = function refCount() {
	        return new RefCountObservable(this);
	    };

	    return ConnectableObservable;
	})(_Observable4['default']);

	exports['default'] = ConnectableObservable;

	var ConnectableSubscription = (function (_Subscription) {
	    _inherits(ConnectableSubscription, _Subscription);

	    function ConnectableSubscription(connectable) {
	        _classCallCheck(this, ConnectableSubscription);

	        _Subscription.call(this);
	        this.connectable = connectable;
	    }

	    ConnectableSubscription.prototype._unsubscribe = function _unsubscribe() {
	        var connectable = this.connectable;
	        connectable.subject = void 0;
	        connectable.subscription = void 0;
	        this.connectable = void 0;
	    };

	    return ConnectableSubscription;
	})(_Subscription4['default']);

	var RefCountObservable = (function (_Observable2) {
	    _inherits(RefCountObservable, _Observable2);

	    function RefCountObservable(connectable) {
	        var refCount = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        _classCallCheck(this, RefCountObservable);

	        _Observable2.call(this);
	        this.connectable = connectable;
	        this.refCount = refCount;
	    }

	    RefCountObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var connectable = this.connectable;
	        var subscription = connectable.subscribe(subscriber);
	        if (++this.refCount === 1) {
	            this.connection = connectable.connect();
	        }
	        subscription.add(new RefCountSubscription(this));
	        return subscription;
	    };

	    return RefCountObservable;
	})(_Observable4['default']);

	var RefCountSubscription = (function (_Subscription2) {
	    _inherits(RefCountSubscription, _Subscription2);

	    function RefCountSubscription(refCountObservable) {
	        _classCallCheck(this, RefCountSubscription);

	        _Subscription2.call(this);
	        this.refCountObservable = refCountObservable;
	    }

	    RefCountSubscription.prototype._unsubscribe = function _unsubscribe() {
	        var observable = this.refCountObservable;
	        if (--observable.refCount === 0) {
	            observable.connection.unsubscribe();
	            observable.connection = void 0;
	        }
	    };

	    return RefCountSubscription;
	})(_Subscription4['default']);

	module.exports = exports['default'];

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _ScalarObservable = __webpack_require__(30);

	var _ScalarObservable2 = _interopRequireDefault(_ScalarObservable);

	var _EmptyObservable = __webpack_require__(31);

	var _EmptyObservable2 = _interopRequireDefault(_EmptyObservable);

	var ArrayObservable = (function (_Observable) {
	    _inherits(ArrayObservable, _Observable);

	    function ArrayObservable(array, scheduler) {
	        _classCallCheck(this, ArrayObservable);

	        _Observable.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	    }

	    ArrayObservable.create = function create(array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };

	    ArrayObservable.of = function of() {
	        for (var _len = arguments.length, array = Array(_len), _key = 0; _key < _len; _key++) {
	            array[_key] = arguments[_key];
	        }

	        var scheduler = array[array.length - 1];
	        if (scheduler && typeof scheduler.schedule === "function") {
	            array.pop();
	        } else {
	            scheduler = void 0;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        } else if (len === 1) {
	            return new _ScalarObservable2['default'](array[0], scheduler);
	        } else {
	            return new _EmptyObservable2['default'](scheduler);
	        }
	    };

	    ArrayObservable.dispatch = function dispatch(state) {
	        var array = state.array;
	        var index = state.index;
	        var count = state.count;
	        var subscriber = state.subscriber;

	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };

	    ArrayObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            }));
	        } else {
	            do {
	                if (index >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(array[index++]);
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };

	    return ArrayObservable;
	})(_Observable3['default']);

	exports['default'] = ArrayObservable;
	module.exports = exports['default'];

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var ScalarObservable = (function (_Observable) {
	    _inherits(ScalarObservable, _Observable);

	    function ScalarObservable(value, scheduler) {
	        _classCallCheck(this, ScalarObservable);

	        _Observable.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	    }

	    ScalarObservable.create = function create(value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };

	    ScalarObservable.dispatch = function dispatch(state) {
	        var done = state.done;
	        var value = state.value;
	        var subscriber = state.subscriber;

	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };

	    ScalarObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            }));
	        } else {
	            subscriber.next(value);
	            if (!subscriber.isUnsubscribed) {
	                subscriber.complete();
	            }
	        }
	    };

	    return ScalarObservable;
	})(_Observable3['default']);

	exports['default'] = ScalarObservable;
	module.exports = exports['default'];

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var EmptyObservable = (function (_Observable) {
	    _inherits(EmptyObservable, _Observable);

	    function EmptyObservable(scheduler) {
	        _classCallCheck(this, EmptyObservable);

	        _Observable.call(this);
	        this.scheduler = scheduler;
	    }

	    EmptyObservable.create = function create(scheduler) {
	        return new EmptyObservable(scheduler);
	    };

	    EmptyObservable.dispatch = function dispatch(_ref) {
	        var subscriber = _ref.subscriber;

	        subscriber.complete();
	    };

	    EmptyObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber }));
	        } else {
	            subscriber.complete();
	        }
	    };

	    return EmptyObservable;
	})(_Observable3['default']);

	exports['default'] = EmptyObservable;
	module.exports = exports['default'];

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var DeferObservable = (function (_Observable) {
	    _inherits(DeferObservable, _Observable);

	    function DeferObservable(observableFactory) {
	        _classCallCheck(this, DeferObservable);

	        _Observable.call(this);
	        this.observableFactory = observableFactory;
	    }

	    DeferObservable.create = function create(observableFactory) {
	        return new DeferObservable(observableFactory);
	    };

	    DeferObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var result = _utilTryCatch2['default'](this.observableFactory)();
	        if (result === _utilErrorObject.errorObject) {
	            subscriber.error(_utilErrorObject.errorObject.e);
	        } else {
	            result.subscribe(subscriber);
	        }
	    };

	    return DeferObservable;
	})(_Observable3['default']);

	exports['default'] = DeferObservable;
	module.exports = exports['default'];

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = tryCatch;

	var _errorObject = __webpack_require__(34);

	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        _errorObject.errorObject.e = e;
	        return _errorObject.errorObject;
	    }
	}

	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	;
	module.exports = exports['default'];

/***/ },
/* 34 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	var errorObject = { e: {} };
	exports.errorObject = errorObject;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var ErrorObservable = (function (_Observable) {
	    _inherits(ErrorObservable, _Observable);

	    function ErrorObservable(error, scheduler) {
	        _classCallCheck(this, ErrorObservable);

	        _Observable.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }

	    ErrorObservable.create = function create(error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };

	    ErrorObservable.dispatch = function dispatch(_ref) {
	        var error = _ref.error;
	        var subscriber = _ref.subscriber;

	        subscriber.error(error);
	    };

	    ErrorObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            }));
	        } else {
	            subscriber.error(error);
	        }
	    };

	    return ErrorObservable;
	})(_Observable3['default']);

	exports['default'] = ErrorObservable;
	module.exports = exports['default'];

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var InfiniteObservable = (function (_Observable) {
	    _inherits(InfiniteObservable, _Observable);

	    function InfiniteObservable() {
	        _classCallCheck(this, InfiniteObservable);

	        _Observable.call(this);
	    }

	    InfiniteObservable.create = function create() {
	        return new InfiniteObservable();
	    };

	    InfiniteObservable.prototype._subscribe = function _subscribe(subscriber) {};

	    return InfiniteObservable;
	})(_Observable3['default']);

	exports['default'] = InfiniteObservable;
	module.exports = exports['default'];

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilIsNumeric = __webpack_require__(38);

	var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var IntervalObservable = (function (_Observable) {
	    _inherits(IntervalObservable, _Observable);

	    function IntervalObservable() {
	        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	        _classCallCheck(this, IntervalObservable);

	        _Observable.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!_utilIsNumeric2['default'](period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== "function") {
	            this.scheduler = _schedulersNextTick2['default'];
	        }
	    }

	    IntervalObservable.create = function create() {
	        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	        return new IntervalObservable(period, scheduler);
	    };

	    IntervalObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var subscriber = state.subscriber;
	        var period = state.period;

	        subscriber.next(index);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };

	    IntervalObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };

	    return IntervalObservable;
	})(_Observable3['default']);

	exports['default'] = IntervalObservable;
	module.exports = exports['default'];

/***/ },
/* 38 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = isNumeric;
	var is_array = Array.isArray;

	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !is_array(val) && val - parseFloat(val) + 1 >= 0;
	}

	;
	module.exports = exports["default"];

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var PromiseObservable = (function (_Observable) {
	    _inherits(PromiseObservable, _Observable);

	    function PromiseObservable(promise, scheduler) {
	        _classCallCheck(this, PromiseObservable);

	        _Observable.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	        this._isScalar = false;
	    }

	    PromiseObservable.create = function create(promise) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

	        return new PromiseObservable(promise, scheduler);
	    };

	    PromiseObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var _this = this;

	        var scheduler = this.scheduler;
	        var promise = this.promise;
	        if (scheduler === _schedulersImmediate2['default']) {
	            if (this._isScalar) {
	                subscriber.next(this.value);
	                subscriber.complete();
	            } else {
	                promise.then(function (value) {
	                    _this._isScalar = true;
	                    _this.value = value;
	                    subscriber.next(value);
	                    subscriber.complete();
	                }, function (err) {
	                    return subscriber.error(err);
	                });
	            }
	        } else {
	            var _ret = (function () {
	                var subscription = new _Subscription2['default']();
	                if (_this._isScalar) {
	                    var value = _this.value;
	                    subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                } else {
	                    promise.then(function (value) {
	                        _this._isScalar = true;
	                        _this.value = value;
	                        subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }, function (err) {
	                        return subscription.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    });
	                }
	                return {
	                    v: subscription
	                };
	            })();

	            if (typeof _ret === 'object') return _ret.v;
	        }
	    };

	    return PromiseObservable;
	})(_Observable3['default']);

	exports['default'] = PromiseObservable;

	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;

	    subscriber.next(value);
	    subscriber.complete();
	}
	function dispatchError(_ref2) {
	    var err = _ref2.err;
	    var subscriber = _ref2.subscriber;

	    subscriber.error(err);
	}
	module.exports = exports['default'];

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var RangeObservable = (function (_Observable) {
	    _inherits(RangeObservable, _Observable);

	    function RangeObservable(start, end, scheduler) {
	        _classCallCheck(this, RangeObservable);

	        _Observable.call(this);
	        this.start = start;
	        this.end = end;
	        this.scheduler = scheduler;
	    }

	    RangeObservable.create = function create(start, end, scheduler) {
	        if (start === undefined) start = 0;
	        if (end === undefined) end = 0;

	        return new RangeObservable(start, end, scheduler);
	    };

	    RangeObservable.dispatch = function dispatch(state) {
	        var start = state.start;
	        var index = state.index;
	        var end = state.end;
	        var subscriber = state.subscriber;

	        if (index >= end) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };

	    RangeObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var start = this.start;
	        var end = this.end;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, end: end, start: start, subscriber: subscriber
	            }));
	        } else {
	            do {
	                if (index++ >= end) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };

	    return RangeObservable;
	})(_Observable3['default']);

	exports['default'] = RangeObservable;
	module.exports = exports['default'];

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilIsNumeric = __webpack_require__(38);

	var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var TimerObservable = (function (_Observable) {
	    _inherits(TimerObservable, _Observable);

	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === undefined) dueTime = 0;

	        _classCallCheck(this, TimerObservable);

	        _Observable.call(this);
	        this.dueTime = dueTime;
	        this.period = period;
	        this.scheduler = scheduler;
	        if (_utilIsNumeric2['default'](period)) {
	            this._period = Number(period) < 1 && 1 || Number(period);
	        } else if (period && typeof period.schedule === "function") {
	            scheduler = period;
	        }
	        if (!scheduler || typeof scheduler.schedule !== "function") {
	            scheduler = _schedulersNextTick2['default'];
	        }
	        this.scheduler = scheduler;
	    }

	    TimerObservable.create = function create(dueTime, period, scheduler) {
	        if (dueTime === undefined) dueTime = 0;

	        return new TimerObservable(dueTime, period, scheduler);
	    };

	    TimerObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var period = state.period;
	        var subscriber = state.subscriber;

	        var action = this;
	        subscriber.next(index);
	        if (typeof period === "undefined") {
	            subscriber.complete();
	            return;
	        } else if (subscriber.isUnsubscribed) {
	            return;
	        }
	        if (typeof action.delay === 'undefined') {
	            action.add(action.scheduler.schedule(TimerObservable.dispatch, period, {
	                index: index + 1, period: period, subscriber: subscriber
	            }));
	        } else {
	            state.index = index + 1;
	            action.schedule(state, period);
	        }
	    };

	    TimerObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var period = this._period;
	        var dueTime = this.dueTime;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(TimerObservable.dispatch, dueTime, { index: index, period: period, subscriber: subscriber }));
	    };

	    return TimerObservable;
	})(_Observable3['default']);

	exports['default'] = TimerObservable;
	module.exports = exports['default'];

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var FromEventPatternObservable = (function (_Observable) {
	    _inherits(FromEventPatternObservable, _Observable);

	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _classCallCheck(this, FromEventPatternObservable);

	        _Observable.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }

	    FromEventPatternObservable.create = function create(addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	        ;
	    };

	    FromEventPatternObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var addHandler = this.addHandler;
	        var removeHandler = this.removeHandler;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = _utilTryCatch2['default'](selector).apply(null, arguments);
	            if (result === _utilErrorObject.errorObject) {
	                subscriber.error(result.e);
	            } else {
	                subscriber.next(result);
	            }
	        } : function (e) {
	            subscriber.next(e);
	        };
	        var result = _utilTryCatch2['default'](addHandler)(handler);
	        if (result === _utilErrorObject.errorObject) {
	            subscriber.error(result.e);
	        }
	        subscriber.add(new _Subscription2['default'](function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler);
	        }));
	    };

	    return FromEventPatternObservable;
	})(_Observable3['default']);

	exports['default'] = FromEventPatternObservable;
	module.exports = exports['default'];

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var FromEventObservable = (function (_Observable) {
	    _inherits(FromEventObservable, _Observable);

	    function FromEventObservable(sourceObj, eventName, selector) {
	        _classCallCheck(this, FromEventObservable);

	        _Observable.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	    }

	    FromEventObservable.create = function create(sourceObj, eventName, selector) {
	        return new FromEventObservable(sourceObj, eventName, selector);
	    };

	    FromEventObservable.setupSubscription = function setupSubscription(sourceObj, eventName, handler, subscriber) {
	        var unsubscribe = undefined;
	        var tag = sourceObj.toString();
	        if (tag === '[object NodeList]' || tag === '[object HTMLCollection]') {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
	            }
	        } else if (typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function') {
	            sourceObj.addEventListener(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.removeEventListener(eventName, handler);
	            };
	        } else if (typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function') {
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.off(eventName, handler);
	            };
	        } else if (typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function') {
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.removeListener(eventName, handler);
	            };
	        }
	        subscriber.add(new _Subscription2['default'](unsubscribe));
	    };

	    FromEventObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = _utilTryCatch2['default'](selector)(e);
	            if (result === _utilErrorObject.errorObject) {
	                subscriber.error(result.e);
	            } else {
	                subscriber.next(result);
	            }
	        } : function (e) {
	            return subscriber.next(e);
	        };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
	    };

	    return FromEventObservable;
	})(_Observable3['default']);

	exports['default'] = FromEventObservable;
	module.exports = exports['default'];

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var ForkJoinObservable = (function (_Observable) {
	    _inherits(ForkJoinObservable, _Observable);

	    function ForkJoinObservable(observables) {
	        _classCallCheck(this, ForkJoinObservable);

	        _Observable.call(this);
	        this.observables = observables;
	    }

	    ForkJoinObservable.create = function create() {
	        for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	            observables[_key] = arguments[_key];
	        }

	        return new ForkJoinObservable(observables);
	    };

	    ForkJoinObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var observables = this.observables;
	        var len = observables.length;
	        var context = { complete: 0, total: len, values: emptyArray(len) };
	        for (var i = 0; i < len; i++) {
	            observables[i].subscribe(new AllSubscriber(subscriber, this, i, context));
	        }
	    };

	    return ForkJoinObservable;
	})(_Observable3['default']);

	exports['default'] = ForkJoinObservable;

	var AllSubscriber = (function (_Subscriber) {
	    _inherits(AllSubscriber, _Subscriber);

	    function AllSubscriber(destination, parent, index, context) {
	        _classCallCheck(this, AllSubscriber);

	        _Subscriber.call(this, destination);
	        this.parent = parent;
	        this.index = index;
	        this.context = context;
	    }

	    AllSubscriber.prototype._next = function _next(value) {
	        this._value = value;
	    };

	    AllSubscriber.prototype._complete = function _complete() {
	        var context = this.context;
	        context.values[this.index] = this._value;
	        if (context.values.every(hasValue)) {
	            this.destination.next(context.values);
	            this.destination.complete();
	        }
	    };

	    return AllSubscriber;
	})(_Subscriber3['default']);

	function hasValue(x) {
	    return x !== null;
	}
	function emptyArray(len) {
	    var arr = [];
	    for (var i = 0; i < len; i++) {
	        arr.push(null);
	    }
	    return arr;
	}
	module.exports = exports['default'];

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _PromiseObservable = __webpack_require__(39);

	var _PromiseObservable2 = _interopRequireDefault(_PromiseObservable);

	var _IteratorObservable = __webpack_require__(46);

	var _IteratorObservable2 = _interopRequireDefault(_IteratorObservable);

	var _ArrayObservable = __webpack_require__(29);

	var _ArrayObservable2 = _interopRequireDefault(_ArrayObservable);

	var _utilSymbol_observable = __webpack_require__(9);

	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

	var _utilSymbol_iterator = __webpack_require__(47);

	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _operatorsObserveOnSupport = __webpack_require__(48);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var isArray = Array.isArray;

	var FromObservable = (function (_Observable) {
	    _inherits(FromObservable, _Observable);

	    function FromObservable(ish, scheduler) {
	        _classCallCheck(this, FromObservable);

	        _Observable.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }

	    FromObservable.create = function create(ish) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

	        if (ish) {
	            if (isArray(ish)) {
	                return new _ArrayObservable2['default'](ish, scheduler);
	            } else if (typeof ish.then === 'function') {
	                return new _PromiseObservable2['default'](ish, scheduler);
	            } else if (typeof ish[_utilSymbol_observable2['default']] === 'function') {
	                if (ish instanceof _Observable3['default']) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            } else if (typeof ish[_utilSymbol_iterator2['default']] === 'function') {
	                return new _IteratorObservable2['default'](ish, null, null, scheduler);
	            }
	        }
	        throw new TypeError(typeof ish + ' is not observable');
	    };

	    FromObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler === _schedulersImmediate2['default']) {
	            return this.ish[_utilSymbol_observable2['default']]().subscribe(subscriber);
	        } else {
	            return this.ish[_utilSymbol_observable2['default']]().subscribe(new _operatorsObserveOnSupport.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };

	    return FromObservable;
	})(_Observable3['default']);

	exports['default'] = FromObservable;
	module.exports = exports['default'];

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _utilRoot = __webpack_require__(10);

	var _utilSymbol_iterator = __webpack_require__(47);

	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var IteratorObservable = (function (_Observable) {
	    _inherits(IteratorObservable, _Observable);

	    function IteratorObservable(iterator, project, thisArg, scheduler) {
	        _classCallCheck(this, IteratorObservable);

	        _Observable.call(this);
	        this.iterator = iterator;
	        this.project = project;
	        this.thisArg = thisArg;
	        this.scheduler = scheduler;
	    }

	    IteratorObservable.create = function create(iterator, project, thisArg, scheduler) {
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        if (project && typeof project !== "function") {
	            throw new Error('When provided, `project` must be a function.');
	        }
	        return new IteratorObservable(iterator, project, thisArg, scheduler);
	    };

	    IteratorObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var hasError = state.hasError;
	        var thisArg = state.thisArg;
	        var project = state.project;
	        var iterator = state.iterator;
	        var subscriber = state.subscriber;

	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        if (project) {
	            result = _utilTryCatch2['default'](project).call(thisArg, result.value, index);
	            if (result === _utilErrorObject.errorObject) {
	                state.error = _utilErrorObject.errorObject.e;
	                state.hasError = true;
	            } else {
	                subscriber.next(result);
	                state.index = index + 1;
	            }
	        } else {
	            subscriber.next(result.value);
	            state.index = index + 1;
	        }
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        this.schedule(state);
	    };

	    IteratorObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var project = this.project;
	        var thisArg = this.thisArg;
	        var iterator = getIterator(Object(this.iterator));
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, thisArg: thisArg, project: project, iterator: iterator, subscriber: subscriber
	            }));
	        } else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                } else if (project) {
	                    result = _utilTryCatch2['default'](project).call(thisArg, result.value, index++);
	                    if (result === _utilErrorObject.errorObject) {
	                        subscriber.error(_utilErrorObject.errorObject.e);
	                        break;
	                    }
	                    subscriber.next(result);
	                } else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };

	    return IteratorObservable;
	})(_Observable3['default']);

	exports['default'] = IteratorObservable;

	var maxSafeInteger = Math.pow(2, 53) - 1;

	var StringIterator = (function () {
	    function StringIterator(str) {
	        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var len = arguments.length <= 2 || arguments[2] === undefined ? str.length : arguments[2];
	        return (function () {
	            _classCallCheck(this, StringIterator);

	            this.str = str;
	            this.idx = idx;
	            this.len = len;
	        }).apply(this, arguments);
	    }

	    StringIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };

	    StringIterator.prototype.next = function next() {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };

	    return StringIterator;
	})();

	var ArrayIterator = (function () {
	    function ArrayIterator(arr) {
	        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var len = arguments.length <= 2 || arguments[2] === undefined ? toLength(arr) : arguments[2];
	        return (function () {
	            _classCallCheck(this, ArrayIterator);

	            this.arr = arr;
	            this.idx = idx;
	            this.len = len;
	        }).apply(this, arguments);
	    }

	    ArrayIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };

	    ArrayIterator.prototype.next = function next() {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };

	    return ArrayIterator;
	})();

	function getIterator(o) {
	    var i = o[_utilSymbol_iterator2['default']];
	    if (!i && typeof o === 'string') {
	        return new StringIterator(o);
	    }
	    if (!i && o.length !== undefined) {
	        return new ArrayIterator(o);
	    }
	    if (!i) {
	        throw new TypeError('Object is not iterable');
	    }
	    return o[_utilSymbol_iterator2['default']]();
	}
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && _utilRoot.root.isFinite(value);
	}
	function isNan(n) {
	    return n !== n;
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	module.exports = exports['default'];

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _root = __webpack_require__(10);

	if (!_root.root.Symbol) {
	    _root.root.Symbol = {};
	}
	if (!_root.root.Symbol.iterator) {
	    if (typeof _root.root.Symbol['for'] === 'function') {
	        _root.root.Symbol.iterator = _root.root.Symbol['for']('iterator');
	    } else if (_root.root.Set && typeof new _root.root.Set()['@@iterator'] === 'function') {
	        _root.root.Symbol.iterator = '@@iterator';
	    } else {
	        _root.root.Symbol.iterator = '_es6shim_iterator_';
	    }
	}
	exports['default'] = _root.root.Symbol.iterator;

	// // Shim in iterator support
	// export var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
	// // Bug for mozilla version
	// if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
	//     $iterator$ = '@@iterator';
	// }
	module.exports = exports['default'];

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Notification = __webpack_require__(15);

	var _Notification2 = _interopRequireDefault(_Notification);

	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        _classCallCheck(this, ObserveOnOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ObserveOnOperator.prototype.call = function call(subscriber) {
	        return new ObserveOnSubscriber(subscriber, this.scheduler, this.delay);
	    };

	    return ObserveOnOperator;
	})();

	exports.ObserveOnOperator = ObserveOnOperator;

	var ObserveOnSubscriber = (function (_Subscriber) {
	    _inherits(ObserveOnSubscriber, _Subscriber);

	    function ObserveOnSubscriber(destination, scheduler) {
	        var delay = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	        _classCallCheck(this, ObserveOnSubscriber);

	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ObserveOnSubscriber.dispatch = function dispatch(_ref) {
	        var notification = _ref.notification;
	        var destination = _ref.destination;

	        notification.observe(destination);
	    };

	    ObserveOnSubscriber.prototype._next = function _next(x) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createNext(x), this.destination)));
	    };

	    ObserveOnSubscriber.prototype._error = function _error(e) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createError(e), this.destination)));
	    };

	    ObserveOnSubscriber.prototype._complete = function _complete() {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createComplete(), this.destination)));
	    };

	    return ObserveOnSubscriber;
	})(_Subscriber3['default']);

	exports.ObserveOnSubscriber = ObserveOnSubscriber;

	var ObserveOnMessage = function ObserveOnMessage(notification, destination) {
	    _classCallCheck(this, ObserveOnMessage);

	    this.notification = notification;
	    this.destination = destination;
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concat;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mergeStatic = __webpack_require__(50);

	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	function concat() {
	    var scheduler = _schedulersImmediate2['default'];

	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var len = observables.length;
	    if (typeof observables[observables.length - 1].schedule === 'function') {
	        scheduler = observables.pop();
	        observables.push(1, scheduler);
	    }
	    return _mergeStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = merge;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(29);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _mergeSupport = __webpack_require__(51);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	function merge() {
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = _schedulersImmediate2['default'];

	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var last = observables[observables.length - 1];
	    if (typeof last.schedule === 'function') {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    } else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (observables.length === 1) {
	        return observables[0];
	    }
	    return new _observablesArrayObservable2['default'](observables, scheduler).lift(new _mergeSupport.MergeOperator(concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var MergeOperator = (function () {
	    function MergeOperator() {
	        var concurrent = arguments.length <= 0 || arguments[0] === undefined ? Number.POSITIVE_INFINITY : arguments[0];

	        _classCallCheck(this, MergeOperator);

	        this.concurrent = concurrent;
	    }

	    MergeOperator.prototype.call = function call(subscriber) {
	        return new MergeSubscriber(subscriber, this.concurrent);
	    };

	    return MergeOperator;
	})();

	exports.MergeOperator = MergeOperator;

	var MergeSubscriber = (function (_Subscriber) {
	    _inherits(MergeSubscriber, _Subscriber);

	    function MergeSubscriber(destination, concurrent) {
	        _classCallCheck(this, MergeSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.active = 0;
	        this.stopped = false;
	        this.buffer = [];
	        this.concurrent = concurrent;
	    }

	    MergeSubscriber.prototype._next = function _next(value) {
	        var active = this.active;
	        if (active < this.concurrent) {
	            var index = this.count;
	            var observable = this._project(value, index);
	            if (observable) {
	                this.count = index + 1;
	                this.active = active + 1;
	                this.add(this._subscribeInner(observable, value, index));
	            }
	        } else {
	            this._buffer(value);
	        }
	    };

	    MergeSubscriber.prototype.complete = function complete() {
	        this.stopped = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            _Subscriber.prototype.complete.call(this);
	        }
	    };

	    MergeSubscriber.prototype._unsubscribe = function _unsubscribe() {
	        this.buffer = void 0;
	    };

	    MergeSubscriber.prototype._project = function _project(value, index) {
	        return value;
	    };

	    MergeSubscriber.prototype._buffer = function _buffer(value) {
	        this.buffer.push(value);
	    };

	    MergeSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        var destination = this.destination;
	        if (observable._isScalar) {
	            destination.next(observable.value);
	            this._innerComplete();
	        } else {
	            var subscriber = new MergeInnerSubscriber(destination, this);
	            observable._subscribe(subscriber);
	            return subscriber;
	        }
	    };

	    MergeSubscriber.prototype._innerComplete = function _innerComplete() {
	        var buffer = this.buffer;
	        var active = this.active -= 1;
	        var stopped = this.stopped;
	        var pending = buffer.length;
	        if (stopped && active === 0 && pending === 0) {
	            _Subscriber.prototype.complete.call(this);
	        } else if (active < this.concurrent && pending > 0) {
	            this._next(buffer.shift());
	        }
	    };

	    return MergeSubscriber;
	})(_Subscriber4['default']);

	exports.MergeSubscriber = MergeSubscriber;

	var MergeInnerSubscriber = (function (_Subscriber2) {
	    _inherits(MergeInnerSubscriber, _Subscriber2);

	    function MergeInnerSubscriber(destination, parent) {
	        _classCallCheck(this, MergeInnerSubscriber);

	        _Subscriber2.call(this, destination);
	        this.parent = parent;
	    }

	    MergeInnerSubscriber.prototype._complete = function _complete() {
	        this.parent._innerComplete();
	    };

	    return MergeInnerSubscriber;
	})(_Subscriber4['default']);

	exports.MergeInnerSubscriber = MergeInnerSubscriber;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatProto;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mergeStatic = __webpack_require__(50);

	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

	function concatProto() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    observables.unshift(this);
	    observables.push(1);
	    return _mergeStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatAll;

	var _mergeSupport = __webpack_require__(51);

	function concatAll() {
	    return this.lift(new _mergeSupport.MergeOperator(1));
	}

	module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatMap;

	var _flatMapSupport = __webpack_require__(55);

	function concatMap(project, projectResult) {
	    return this.lift(new _flatMapSupport.FlatMapOperator(project, projectResult, 1));
	}

	module.exports = exports['default'];

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _mergeSupport = __webpack_require__(51);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var FlatMapOperator = (function () {
	    function FlatMapOperator(project, projectResult) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

	        _classCallCheck(this, FlatMapOperator);

	        this.project = project;
	        this.projectResult = projectResult;
	        this.concurrent = concurrent;
	    }

	    FlatMapOperator.prototype.call = function call(subscriber) {
	        return new FlatMapSubscriber(subscriber, this.concurrent, this.project, this.projectResult);
	    };

	    return FlatMapOperator;
	})();

	exports.FlatMapOperator = FlatMapOperator;

	var FlatMapSubscriber = (function (_MergeSubscriber) {
	    _inherits(FlatMapSubscriber, _MergeSubscriber);

	    function FlatMapSubscriber(destination, concurrent, project, projectResult) {
	        _classCallCheck(this, FlatMapSubscriber);

	        _MergeSubscriber.call(this, destination, concurrent);
	        this.project = project;
	        this.projectResult = projectResult;
	    }

	    FlatMapSubscriber.prototype._project = function _project(value, index) {
	        var observable = _utilTryCatch2['default'](this.project).call(this, value, index);
	        if (observable === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	            return null;
	        }
	        return observable;
	    };

	    FlatMapSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        var projectResult = this.projectResult;
	        if (projectResult) {
	            return observable._subscribe(new FlatMapInnerSubscriber(this.destination, this, value, index, projectResult));
	        } else if (observable._isScalar) {
	            this.destination.next(observable.value);
	            this._innerComplete();
	        } else {
	            return observable._subscribe(new _mergeSupport.MergeInnerSubscriber(this.destination, this));
	        }
	    };

	    return FlatMapSubscriber;
	})(_mergeSupport.MergeSubscriber);

	exports.FlatMapSubscriber = FlatMapSubscriber;

	var FlatMapInnerSubscriber = (function (_MergeInnerSubscriber) {
	    _inherits(FlatMapInnerSubscriber, _MergeInnerSubscriber);

	    function FlatMapInnerSubscriber(destination, parent, value, index, project) {
	        _classCallCheck(this, FlatMapInnerSubscriber);

	        _MergeInnerSubscriber.call(this, destination, parent);
	        this.count = 0;
	        this.value = value;
	        this.index = index;
	        this.project = project;
	    }

	    FlatMapInnerSubscriber.prototype._next = function _next(value) {
	        var result = value;
	        var index = this.count++;
	        result = _utilTryCatch2['default'](this.project).call(this, this.value, value, this.index, index);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(result);
	        }
	    };

	    return FlatMapInnerSubscriber;
	})(_mergeSupport.MergeInnerSubscriber);

	exports.FlatMapInnerSubscriber = FlatMapInnerSubscriber;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatMapTo;

	var _flatMapToSupport = __webpack_require__(57);

	function concatMapTo(observable, projectResult) {
	    return this.lift(new _flatMapToSupport.FlatMapToOperator(observable, projectResult, 1));
	}

	module.exports = exports['default'];

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _flatMapSupport = __webpack_require__(55);

	var FlatMapToOperator = (function () {
	    function FlatMapToOperator(observable, projectResult) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

	        _classCallCheck(this, FlatMapToOperator);

	        this.observable = observable;
	        this.projectResult = projectResult;
	        this.concurrent = concurrent;
	    }

	    FlatMapToOperator.prototype.call = function call(subscriber) {
	        return new FlatMapToSubscriber(subscriber, this.concurrent, this.observable, this.projectResult);
	    };

	    return FlatMapToOperator;
	})();

	exports.FlatMapToOperator = FlatMapToOperator;

	var FlatMapToSubscriber = (function (_FlatMapSubscriber) {
	    _inherits(FlatMapToSubscriber, _FlatMapSubscriber);

	    function FlatMapToSubscriber(destination, concurrent, observable, projectResult) {
	        _classCallCheck(this, FlatMapToSubscriber);

	        _FlatMapSubscriber.call(this, destination, concurrent, null, projectResult);
	        this.observable = observable;
	    }

	    FlatMapToSubscriber.prototype._project = function _project(value, index) {
	        return this.observable;
	    };

	    return FlatMapToSubscriber;
	})(_flatMapSupport.FlatMapSubscriber);

	exports.FlatMapToSubscriber = FlatMapToSubscriber;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = merge;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mergeStatic = __webpack_require__(50);

	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

	function merge() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    observables.unshift(this);
	    return _mergeStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = mergeAll;

	var _mergeSupport = __webpack_require__(51);

	function mergeAll(concurrent) {
	    return this.lift(new _mergeSupport.MergeOperator(concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = flatMap;

	var _flatMapSupport = __webpack_require__(55);

	function flatMap(project, projectResult, concurrent) {
	    return this.lift(new _flatMapSupport.FlatMapOperator(project, projectResult, concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = flatMapTo;

	var _flatMapToSupport = __webpack_require__(57);

	function flatMapTo(observable, projectResult, concurrent) {
	    return this.lift(new _flatMapToSupport.FlatMapToOperator(observable, projectResult, concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = switchAll;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _mergeSupport = __webpack_require__(51);

	function switchAll() {
	    return this.lift(new SwitchOperator());
	}

	var SwitchOperator = (function () {
	    function SwitchOperator() {
	        _classCallCheck(this, SwitchOperator);
	    }

	    SwitchOperator.prototype.call = function call(subscriber) {
	        return new SwitchSubscriber(subscriber);
	    };

	    return SwitchOperator;
	})();

	var SwitchSubscriber = (function (_MergeSubscriber) {
	    _inherits(SwitchSubscriber, _MergeSubscriber);

	    function SwitchSubscriber(destination) {
	        _classCallCheck(this, SwitchSubscriber);

	        _MergeSubscriber.call(this, destination, 1);
	    }

	    SwitchSubscriber.prototype._buffer = function _buffer(value) {
	        var active = this.active;
	        if (active > 0) {
	            this.active = active - 1;
	            var inner = this.innerSubscription;
	            if (inner) {
	                inner.unsubscribe();
	                this.innerSubscription = null;
	            }
	        }
	        this._next(value);
	    };

	    SwitchSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        this.innerSubscription = new _Subscription2['default']();
	        this.innerSubscription.add(_MergeSubscriber.prototype._subscribeInner.call(this, observable, value, index));
	        return this.innerSubscription;
	    };

	    return SwitchSubscriber;
	})(_mergeSupport.MergeSubscriber);

	module.exports = exports['default'];

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = switchLatest;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _flatMapSupport = __webpack_require__(55);

	function switchLatest(project, projectResult) {
	    return this.lift(new SwitchLatestOperator(project, projectResult));
	}

	var SwitchLatestOperator = (function (_FlatMapOperator) {
	    _inherits(SwitchLatestOperator, _FlatMapOperator);

	    function SwitchLatestOperator(project, projectResult) {
	        _classCallCheck(this, SwitchLatestOperator);

	        _FlatMapOperator.call(this, project, projectResult, 1);
	    }

	    SwitchLatestOperator.prototype.call = function call(subscriber) {
	        return new SwitchLatestSubscriber(subscriber, this.project, this.projectResult);
	    };

	    return SwitchLatestOperator;
	})(_flatMapSupport.FlatMapOperator);

	var SwitchLatestSubscriber = (function (_FlatMapSubscriber) {
	    _inherits(SwitchLatestSubscriber, _FlatMapSubscriber);

	    function SwitchLatestSubscriber(destination, project, projectResult) {
	        _classCallCheck(this, SwitchLatestSubscriber);

	        _FlatMapSubscriber.call(this, destination, 1, project, projectResult);
	    }

	    SwitchLatestSubscriber.prototype._buffer = function _buffer(value) {
	        var active = this.active;
	        if (active > 0) {
	            this.active = active - 1;
	            var inner = this.innerSubscription;
	            if (inner) {
	                inner.unsubscribe();
	            }
	        }
	        this._next(value);
	    };

	    SwitchLatestSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        this.innerSubscription = new _Subscription2['default']();
	        this.innerSubscription.add(_FlatMapSubscriber.prototype._subscribeInner.call(this, observable, value, index));
	        return this.innerSubscription;
	    };

	    return SwitchLatestSubscriber;
	})(_flatMapSupport.FlatMapSubscriber);

	module.exports = exports['default'];

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = switchLatestTo;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _flatMapToSupport = __webpack_require__(57);

	function switchLatestTo(observable, projectResult) {
	    return this.lift(new SwitchLatestToOperator(observable, projectResult));
	}

	var SwitchLatestToOperator = (function (_FlatMapToOperator) {
	    _inherits(SwitchLatestToOperator, _FlatMapToOperator);

	    function SwitchLatestToOperator(observable, projectResult) {
	        _classCallCheck(this, SwitchLatestToOperator);

	        _FlatMapToOperator.call(this, observable, projectResult, 1);
	    }

	    SwitchLatestToOperator.prototype.call = function call(subscriber) {
	        return new SwitchLatestToSubscriber(subscriber, this.observable, this.projectResult);
	    };

	    return SwitchLatestToOperator;
	})(_flatMapToSupport.FlatMapToOperator);

	var SwitchLatestToSubscriber = (function (_FlatMapToSubscriber) {
	    _inherits(SwitchLatestToSubscriber, _FlatMapToSubscriber);

	    function SwitchLatestToSubscriber(destination, observable, projectResult) {
	        _classCallCheck(this, SwitchLatestToSubscriber);

	        _FlatMapToSubscriber.call(this, destination, 1, observable, projectResult);
	    }

	    SwitchLatestToSubscriber.prototype._buffer = function _buffer(value) {
	        var active = this.active;
	        if (active > 0) {
	            this.active = active - 1;
	            var inner = this.innerSubscription;
	            if (inner) {
	                inner.unsubscribe();
	            }
	        }
	        this._next(value);
	    };

	    SwitchLatestToSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        return this.innerSubscription = _FlatMapToSubscriber.prototype._subscribeInner.call(this, observable, value, index);
	    };

	    return SwitchLatestToSubscriber;
	})(_flatMapToSupport.FlatMapToSubscriber);

	module.exports = exports['default'];

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = expand;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _mergeSupport = __webpack_require__(51);

	var _observablesEmptyObservable = __webpack_require__(31);

	var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function expand(project) {
	    return this.lift(new ExpandOperator(project));
	}

	var ExpandOperator = (function () {
	    function ExpandOperator(project) {
	        _classCallCheck(this, ExpandOperator);

	        this.project = project;
	    }

	    ExpandOperator.prototype.call = function call(subscriber) {
	        return new ExpandSubscriber(subscriber, this.project);
	    };

	    return ExpandOperator;
	})();

	var ExpandSubscriber = (function (_MergeSubscriber) {
	    _inherits(ExpandSubscriber, _MergeSubscriber);

	    function ExpandSubscriber(destination, project) {
	        _classCallCheck(this, ExpandSubscriber);

	        _MergeSubscriber.call(this, destination, Number.POSITIVE_INFINITY);
	        this.project = project;
	    }

	    ExpandSubscriber.prototype._project = function _project(value, index) {
	        var observable = _utilTryCatch2['default'](this.project).call(this, value, index);
	        if (observable === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	            return null;
	        }
	        return observable;
	    };

	    ExpandSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        if (observable._isScalar) {
	            this.destination.next(observable.value);
	            this._innerComplete();
	            this._next(observable.value);
	        } else if (observable instanceof _observablesEmptyObservable2['default']) {
	            this._innerComplete();
	        } else {
	            return observable._subscribe(new ExpandInnerSubscriber(this.destination, this));
	        }
	    };

	    return ExpandSubscriber;
	})(_mergeSupport.MergeSubscriber);

	var ExpandInnerSubscriber = (function (_MergeInnerSubscriber) {
	    _inherits(ExpandInnerSubscriber, _MergeInnerSubscriber);

	    function ExpandInnerSubscriber(destination, parent) {
	        _classCallCheck(this, ExpandInnerSubscriber);

	        _MergeInnerSubscriber.call(this, destination, parent);
	    }

	    ExpandInnerSubscriber.prototype._next = function _next(value) {
	        this.destination.next(value);
	        this.parent.next(value);
	    };

	    return ExpandInnerSubscriber;
	})(_mergeSupport.MergeInnerSubscriber);

	module.exports = exports['default'];

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = _do;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilNoop = __webpack_require__(5);

	var _utilNoop2 = _interopRequireDefault(_utilNoop);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function _do(next, error, complete) {
	    return this.lift(new DoOperator(next || _utilNoop2['default'], error || _utilNoop2['default'], complete || _utilNoop2['default']));
	}

	var DoOperator = (function () {
	    function DoOperator(next, error, complete) {
	        _classCallCheck(this, DoOperator);

	        this.next = next;
	        this.error = error;
	        this.complete = complete;
	    }

	    DoOperator.prototype.call = function call(subscriber) {
	        return new DoSubscriber(subscriber, this.next, this.error, this.complete);
	    };

	    return DoOperator;
	})();

	var DoSubscriber = (function (_Subscriber) {
	    _inherits(DoSubscriber, _Subscriber);

	    function DoSubscriber(destination, next, error, complete) {
	        _classCallCheck(this, DoSubscriber);

	        _Subscriber.call(this, destination);
	        this.__next = next;
	        this.__error = error;
	        this.__complete = complete;
	    }

	    DoSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.__next)(x);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(x);
	        }
	    };

	    DoSubscriber.prototype._error = function _error(e) {
	        var result = _utilTryCatch2['default'](this.__error)(e);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.error(e);
	        }
	    };

	    DoSubscriber.prototype._complete = function _complete() {
	        var result = _utilTryCatch2['default'](this.__complete)();
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.complete();
	        }
	    };

	    return DoSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = map;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var _utilBindCallback = __webpack_require__(68);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	/**
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the returned observable
	 *
	 * @param {Function} project the function to create projection
	 * @param {any} [thisArg] an optional argument to define what `this` is in the project function
	 * @returns {Observable} a observable of projected values
	 */

	function map(project, thisArg) {
	    return this.lift(new MapOperator(project, thisArg));
	}

	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        _classCallCheck(this, MapOperator);

	        this.project = _utilBindCallback2['default'](project, thisArg, 2);
	    }

	    MapOperator.prototype.call = function call(subscriber) {
	        return new MapSubscriber(subscriber, this.project);
	    };

	    return MapOperator;
	})();

	var MapSubscriber = (function (_Subscriber) {
	    _inherits(MapSubscriber, _Subscriber);

	    function MapSubscriber(destination, project) {
	        _classCallCheck(this, MapSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.project = project;
	    }

	    MapSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.project)(x, this.count++);
	        if (result === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(result);
	        }
	    };

	    return MapSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 68 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bindCallback;

	function bindCallback(func, thisArg, argCount) {
	    if (typeof thisArg === 'undefined') {
	        return func;
	    }
	    switch (argCount) {
	        case 0:
	            return function () {
	                return func.call(thisArg);
	            };
	        case 1:
	            return function (arg) {
	                return func.call(thisArg, arg);
	            };
	        case 2:
	            return function (value, index) {
	                return func.call(thisArg, value, index);
	            };
	        case 3:
	            return function (value, index, collection) {
	                return func.call(thisArg, value, index, collection);
	            };
	    }
	    return function () {
	        return func.apply(thisArg, arguments);
	    };
	}

	;
	module.exports = exports['default'];

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = mapTo;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	/**
	 * Maps every value to the same value every time.
	 * @param {any} value the value to map each incoming value to
	 * @returns {Observable} an observable of the passed value that emits everytime the source does
	 */

	function mapTo(value) {
	    return this.lift(new MapToOperator(value));
	}

	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        _classCallCheck(this, MapToOperator);

	        this.value = value;
	    }

	    MapToOperator.prototype.call = function call(subscriber) {
	        return new MapToSubscriber(subscriber, this.value);
	    };

	    return MapToOperator;
	})();

	var MapToSubscriber = (function (_Subscriber) {
	    _inherits(MapToSubscriber, _Subscriber);

	    function MapToSubscriber(destination, value) {
	        _classCallCheck(this, MapToSubscriber);

	        _Subscriber.call(this, destination);
	        this.value = value;
	    }

	    MapToSubscriber.prototype._next = function _next(x) {
	        this.destination.next(this.value);
	    };

	    return MapToSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = toArray;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function toArray() {
	    return this.lift(new ToArrayOperator());
	}

	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	        _classCallCheck(this, ToArrayOperator);
	    }

	    ToArrayOperator.prototype.call = function call(subscriber) {
	        return new ToArraySubscriber(subscriber);
	    };

	    return ToArrayOperator;
	})();

	var ToArraySubscriber = (function (_Subscriber) {
	    _inherits(ToArraySubscriber, _Subscriber);

	    function ToArraySubscriber(destination) {
	        _classCallCheck(this, ToArraySubscriber);

	        _Subscriber.call(this, destination);
	        this.array = [];
	    }

	    ToArraySubscriber.prototype._next = function _next(x) {
	        this.array.push(x);
	    };

	    ToArraySubscriber.prototype._complete = function _complete() {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };

	    return ToArraySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = count;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function count() {
	    return this.lift(new CountOperator());
	}

	var CountOperator = (function () {
	    function CountOperator() {
	        _classCallCheck(this, CountOperator);
	    }

	    CountOperator.prototype.call = function call(subscriber) {
	        return new CountSubscriber(subscriber);
	    };

	    return CountOperator;
	})();

	var CountSubscriber = (function (_Subscriber) {
	    _inherits(CountSubscriber, _Subscriber);

	    function CountSubscriber(destination) {
	        _classCallCheck(this, CountSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	    }

	    CountSubscriber.prototype._next = function _next(x) {
	        this.count += 1;
	    };

	    CountSubscriber.prototype._complete = function _complete() {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };

	    return CountSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = scan;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function scan(project, acc) {
	    return this.lift(new ScanOperator(project));
	}

	var ScanOperator = (function () {
	    function ScanOperator(project, acc) {
	        _classCallCheck(this, ScanOperator);

	        this.acc = acc;
	        this.project = project;
	    }

	    ScanOperator.prototype.call = function call(subscriber) {
	        return new ScanSubscriber(subscriber, this.project, this.acc);
	    };

	    return ScanOperator;
	})();

	var ScanSubscriber = (function (_Subscriber) {
	    _inherits(ScanSubscriber, _Subscriber);

	    function ScanSubscriber(destination, project, acc) {
	        _classCallCheck(this, ScanSubscriber);

	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        this.acc = acc;
	        this.project = project;
	        this.hasSeed = typeof acc !== "undefined";
	    }

	    ScanSubscriber.prototype._next = function _next(x) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.destination.next(this.acc = result);
	            }
	        } else {
	            return this.destination.next((this.hasValue = true) && (this.acc = x));
	        }
	    };

	    ScanSubscriber.prototype._complete = function _complete() {
	        if (!this.hasValue && this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };

	    return ScanSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = reduce;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function reduce(project, acc) {
	    return this.lift(new ReduceOperator(project, acc));
	}

	var ReduceOperator = (function () {
	    function ReduceOperator(project, acc) {
	        _classCallCheck(this, ReduceOperator);

	        this.acc = acc;
	        this.project = project;
	    }

	    ReduceOperator.prototype.call = function call(subscriber) {
	        return new ReduceSubscriber(subscriber, this.project, this.acc);
	    };

	    return ReduceOperator;
	})();

	var ReduceSubscriber = (function (_Subscriber) {
	    _inherits(ReduceSubscriber, _Subscriber);

	    function ReduceSubscriber(destination, project, acc) {
	        _classCallCheck(this, ReduceSubscriber);

	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        this.acc = acc;
	        this.project = project;
	        this.hasSeed = typeof acc !== "undefined";
	    }

	    ReduceSubscriber.prototype._next = function _next(x) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.acc = result;
	            }
	        } else {
	            this.acc = x;
	            this.hasValue = true;
	        }
	    };

	    ReduceSubscriber.prototype._complete = function _complete() {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };

	    return ReduceSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = startWith;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesScalarObservable = __webpack_require__(30);

	var _observablesScalarObservable2 = _interopRequireDefault(_observablesScalarObservable);

	var _concatStatic = __webpack_require__(49);

	var _concatStatic2 = _interopRequireDefault(_concatStatic);

	function startWith(x) {
	    return _concatStatic2['default'](new _observablesScalarObservable2['default'](x), this);
	}

	module.exports = exports['default'];

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = take;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function take(total) {
	    return this.lift(new TakeOperator(total));
	}

	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        _classCallCheck(this, TakeOperator);

	        this.total = total;
	    }

	    TakeOperator.prototype.call = function call(subscriber) {
	        return new TakeSubscriber(subscriber, this.total);
	    };

	    return TakeOperator;
	})();

	var TakeSubscriber = (function (_Subscriber) {
	    _inherits(TakeSubscriber, _Subscriber);

	    function TakeSubscriber(destination, total) {
	        _classCallCheck(this, TakeSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.total = total;
	    }

	    TakeSubscriber.prototype._next = function _next(x) {
	        var total = this.total;
	        if (++this.count <= total) {
	            this.destination.next(x);
	            if (this.count === total) {
	                this.destination.complete();
	            }
	        }
	    };

	    return TakeSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = skip;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function skip(total) {
	    return this.lift(new SkipOperator(total));
	}

	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        _classCallCheck(this, SkipOperator);

	        this.total = total;
	    }

	    SkipOperator.prototype.call = function call(subscriber) {
	        return new SkipSubscriber(subscriber, this.total);
	    };

	    return SkipOperator;
	})();

	var SkipSubscriber = (function (_Subscriber) {
	    _inherits(SkipSubscriber, _Subscriber);

	    function SkipSubscriber(destination, total) {
	        _classCallCheck(this, SkipSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.total = total;
	    }

	    SkipSubscriber.prototype._next = function _next(x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };

	    return SkipSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = skipUntil;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	function skipUntil(total) {
	    return this.lift(new SkipUntilOperator(total));
	}

	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        _classCallCheck(this, SkipUntilOperator);

	        this.notifier = notifier;
	    }

	    SkipUntilOperator.prototype.call = function call(subscriber) {
	        return new SkipUntilSubscriber(subscriber, this.notifier);
	    };

	    return SkipUntilOperator;
	})();

	var SkipUntilSubscriber = (function (_Subscriber) {
	    _inherits(SkipUntilSubscriber, _Subscriber);

	    function SkipUntilSubscriber(destination, notifier) {
	        _classCallCheck(this, SkipUntilSubscriber);

	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.notificationSubscriber = new NotificationSubscriber();
	        this.add(this.notifier.subscribe(this.notificationSubscriber));
	    }

	    SkipUntilSubscriber.prototype._next = function _next(x) {
	        if (this.notificationSubscriber.hasNotified) {
	            this.destination.next(x);
	        }
	    };

	    return SkipUntilSubscriber;
	})(_Subscriber4['default']);

	var NotificationSubscriber = (function (_Subscriber2) {
	    _inherits(NotificationSubscriber, _Subscriber2);

	    function NotificationSubscriber() {
	        _classCallCheck(this, NotificationSubscriber);

	        _Subscriber2.call(this, null);
	        this.hasNotified = false;
	    }

	    NotificationSubscriber.prototype._next = function _next() {
	        this.hasNotified = true;
	        this.unsubscribe();
	    };

	    return NotificationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = takeUntil;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	function takeUntil(observable) {
	    return this.lift(new TakeUntilOperator(observable));
	}

	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(observable) {
	        _classCallCheck(this, TakeUntilOperator);

	        this.observable = observable;
	    }

	    TakeUntilOperator.prototype.call = function call(subscriber) {
	        return new TakeUntilSubscriber(subscriber, this.observable);
	    };

	    return TakeUntilOperator;
	})();

	var TakeUntilSubscriber = (function (_Subscriber) {
	    _inherits(TakeUntilSubscriber, _Subscriber);

	    function TakeUntilSubscriber(destination, observable) {
	        _classCallCheck(this, TakeUntilSubscriber);

	        _Subscriber.call(this, destination);
	        this.add(observable._subscribe(new TakeUntilInnerSubscriber(destination)));
	    }

	    return TakeUntilSubscriber;
	})(_Subscriber4['default']);

	var TakeUntilInnerSubscriber = (function (_Subscriber2) {
	    _inherits(TakeUntilInnerSubscriber, _Subscriber2);

	    function TakeUntilInnerSubscriber(destination) {
	        _classCallCheck(this, TakeUntilInnerSubscriber);

	        _Subscriber2.call(this, destination);
	    }

	    TakeUntilInnerSubscriber.prototype._next = function _next() {
	        this.destination.complete();
	    };

	    TakeUntilInnerSubscriber.prototype._error = function _error(e) {
	        this.destination.error(e);
	    };

	    TakeUntilInnerSubscriber.prototype._complete = function _complete() {};

	    return TakeUntilInnerSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = filter;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var _utilBindCallback = __webpack_require__(68);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	/**
	 * Similar to the well-known `Array.prototype.filter` method, this operator filters values down to a set
	 * allowed by a `select` function
	 *
	 * @param {Function} select a function that is used to select the resulting values
	 *  if it returns `true`, the value is emitted, if `false` the value is not passed to the resulting observable
	 * @param {any} [thisArg] an optional argument to determine the value of `this` in the `select` function
	 * @returns {Observable} an observable of values allowed by the select function
	 */

	function filter(select, thisArg) {
	    return this.lift(new FilterOperator(select, thisArg));
	}

	var FilterOperator = (function () {
	    function FilterOperator(select, thisArg) {
	        _classCallCheck(this, FilterOperator);

	        this.select = _utilBindCallback2['default'](select, thisArg, 2);
	    }

	    FilterOperator.prototype.call = function call(subscriber) {
	        return new FilterSubscriber(subscriber, this.select);
	    };

	    return FilterOperator;
	})();

	var FilterSubscriber = (function (_Subscriber) {
	    _inherits(FilterSubscriber, _Subscriber);

	    function FilterSubscriber(destination, select) {
	        _classCallCheck(this, FilterSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.select = select;
	    }

	    FilterSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.select)(x, this.count++);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else if (Boolean(result)) {
	            this.destination.next(x);
	        }
	    };

	    return FilterSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = distinctUntilChanged;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var _utilBindCallback = __webpack_require__(68);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	function distinctUntilChanged(compare, thisArg) {
	    return this.lift(new DistinctUntilChangedOperator(thisArg ? _utilBindCallback2['default'](compare, thisArg, 2) : compare));
	}

	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare) {
	        _classCallCheck(this, DistinctUntilChangedOperator);

	        this.compare = compare;
	    }

	    DistinctUntilChangedOperator.prototype.call = function call(subscriber) {
	        return new DistinctUntilChangedSubscriber(subscriber, this.compare);
	    };

	    return DistinctUntilChangedOperator;
	})();

	var DistinctUntilChangedSubscriber = (function (_Subscriber) {
	    _inherits(DistinctUntilChangedSubscriber, _Subscriber);

	    function DistinctUntilChangedSubscriber(destination, compare) {
	        _classCallCheck(this, DistinctUntilChangedSubscriber);

	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        if (typeof compare === "function") {
	            this.compare = compare;
	        }
	    }

	    DistinctUntilChangedSubscriber.prototype.compare = function compare(x, y) {
	        return x === y;
	    };

	    DistinctUntilChangedSubscriber.prototype._next = function _next(x) {
	        var result = false;
	        if (this.hasValue) {
	            result = _utilTryCatch2['default'](this.compare)(this.value, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	                return;
	            }
	        } else {
	            this.hasValue = true;
	        }
	        if (Boolean(result) === false) {
	            this.value = x;
	            this.destination.next(x);
	        }
	    };

	    return DistinctUntilChangedSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = distinctUntilKeyChanged;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _distinctUntilChanged = __webpack_require__(80);

	var _distinctUntilChanged2 = _interopRequireDefault(_distinctUntilChanged);

	function distinctUntilKeyChanged(key, compare, thisArg) {
	    return _distinctUntilChanged2['default'].call(this, function (x, y) {
	        if (compare) {
	            return compare.call(thisArg, x[key], y[key]);
	        }
	        return x[key] === y[key];
	    });
	}

	module.exports = exports['default'];

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = combineLatest;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(29);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _combineLatestSupport = __webpack_require__(83);

	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    observables.unshift(this);
	    return new _observablesArrayObservable2['default'](observables).lift(new _combineLatestSupport.CombineLatestOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.combineLatest = combineLatest;
	exports.combineLatestProto = combineLatestProto;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _observablesArrayObservable = __webpack_require__(29);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _zipSupport = __webpack_require__(84);

	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new CombineLatestOperator(project));
	}

	function combineLatestProto() {
	    for (var _len2 = arguments.length, observables = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        observables[_key2] = arguments[_key2];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    observables.unshift(this);
	    return new _observablesArrayObservable2['default'](observables).lift(new CombineLatestOperator(project));
	}

	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        _classCallCheck(this, CombineLatestOperator);

	        this.project = project;
	    }

	    CombineLatestOperator.prototype.call = function call(subscriber) {
	        return new CombineLatestSubscriber(subscriber, this.project);
	    };

	    return CombineLatestOperator;
	})();

	exports.CombineLatestOperator = CombineLatestOperator;

	var CombineLatestSubscriber = (function (_ZipSubscriber) {
	    _inherits(CombineLatestSubscriber, _ZipSubscriber);

	    function CombineLatestSubscriber(destination, project) {
	        _classCallCheck(this, CombineLatestSubscriber);

	        _ZipSubscriber.call(this, destination, project, []);
	        this.limit = 0;
	    }

	    CombineLatestSubscriber.prototype._subscribeInner = function _subscribeInner(observable, values, index, total) {
	        return observable._subscribe(new CombineLatestInnerSubscriber(this.destination, this, values, index, total));
	    };

	    CombineLatestSubscriber.prototype._innerComplete = function _innerComplete(innerSubscriber) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };

	    return CombineLatestSubscriber;
	})(_zipSupport.ZipSubscriber);

	exports.CombineLatestSubscriber = CombineLatestSubscriber;

	var CombineLatestInnerSubscriber = (function (_ZipInnerSubscriber) {
	    _inherits(CombineLatestInnerSubscriber, _ZipInnerSubscriber);

	    function CombineLatestInnerSubscriber(destination, parent, values, index, total) {
	        _classCallCheck(this, CombineLatestInnerSubscriber);

	        _ZipInnerSubscriber.call(this, destination, parent, values, index, total);
	    }

	    CombineLatestInnerSubscriber.prototype._next = function _next(x) {
	        var index = this.index;
	        var total = this.total;
	        var parent = this.parent;
	        var values = this.values;
	        var valueBox = values[index];
	        var limit = undefined;
	        if (valueBox) {
	            valueBox[0] = x;
	            limit = parent.limit;
	        } else {
	            limit = parent.limit += 1;
	            values[index] = [x];
	        }
	        if (limit >= total) {
	            this._projectNext(values, parent.project);
	        }
	    };

	    return CombineLatestInnerSubscriber;
	})(_zipSupport.ZipInnerSubscriber);

	exports.CombineLatestInnerSubscriber = CombineLatestInnerSubscriber;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.mapValue = mapValue;
	exports.hasValue = hasValue;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        _classCallCheck(this, ZipOperator);

	        this.project = project;
	    }

	    ZipOperator.prototype.call = function call(subscriber) {
	        return new ZipSubscriber(subscriber, this.project);
	    };

	    return ZipOperator;
	})();

	exports.ZipOperator = ZipOperator;

	var ZipSubscriber = (function (_Subscriber) {
	    _inherits(ZipSubscriber, _Subscriber);

	    function ZipSubscriber(destination, project) {
	        var values = arguments.length <= 2 || arguments[2] === undefined ? Object.create(null) : arguments[2];

	        _classCallCheck(this, ZipSubscriber);

	        _Subscriber.call(this, destination);
	        this.active = 0;
	        this.observables = [];
	        this.limit = Number.POSITIVE_INFINITY;
	        this.project = typeof project === "function" ? project : null;
	        this.values = values;
	    }

	    ZipSubscriber.prototype._next = function _next(observable) {
	        this.observables.push(observable);
	    };

	    ZipSubscriber.prototype._complete = function _complete() {
	        var values = this.values;
	        var observables = this.observables;
	        var index = -1;
	        var len = observables.length;
	        this.active = len;
	        while (++index < len) {
	            this.add(this._subscribeInner(observables[index], values, index, len));
	        }
	    };

	    ZipSubscriber.prototype._subscribeInner = function _subscribeInner(observable, values, index, total) {
	        return observable._subscribe(new ZipInnerSubscriber(this.destination, this, values, index, total));
	    };

	    ZipSubscriber.prototype._innerComplete = function _innerComplete(innerSubscriber) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        } else {
	            this.limit = innerSubscriber.events;
	        }
	    };

	    return ZipSubscriber;
	})(_Subscriber4['default']);

	exports.ZipSubscriber = ZipSubscriber;

	function arrayInitialize(length) {
	    var arr = Array(length);
	    for (var i = 0; i < length; i++) {
	        arr[i] = null;
	    }
	    return arr;
	}

	var ZipInnerSubscriber = (function (_Subscriber2) {
	    _inherits(ZipInnerSubscriber, _Subscriber2);

	    function ZipInnerSubscriber(destination, parent, values, index, total) {
	        _classCallCheck(this, ZipInnerSubscriber);

	        _Subscriber2.call(this, destination);
	        this.events = 0;
	        this.parent = parent;
	        this.values = values;
	        this.index = index;
	        this.total = total;
	    }

	    ZipInnerSubscriber.prototype._next = function _next(x) {
	        var parent = this.parent;
	        var events = this.events;
	        var total = this.total;
	        var limit = parent.limit;
	        if (events >= limit) {
	            this.destination.complete();
	            return;
	        }
	        var index = this.index;
	        var values = this.values;
	        var zipped = values[events] || (values[events] = arrayInitialize(total));
	        zipped[index] = [x];
	        if (zipped.every(hasValue)) {
	            this._projectNext(zipped, parent.project);
	            values[events] = undefined;
	        }
	        this.events = events + 1;
	    };

	    ZipInnerSubscriber.prototype._projectNext = function _projectNext(values, project) {
	        if (project && typeof project === "function") {
	            var result = _utilTryCatch2['default'](project).apply(null, values.map(mapValue));
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	                return;
	            } else {
	                this.destination.next(result);
	            }
	        } else {
	            this.destination.next(values.map(mapValue));
	        }
	    };

	    ZipInnerSubscriber.prototype._complete = function _complete() {
	        this.parent._innerComplete(this);
	    };

	    return ZipInnerSubscriber;
	})(_Subscriber4['default']);

	exports.ZipInnerSubscriber = ZipInnerSubscriber;

	function mapValue(xs) {
	    return xs[0];
	}

	function hasValue(xs) {
	    return xs && xs.length === 1;
	}

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = combineLatest;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(29);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _combineLatestSupport = __webpack_require__(83);

	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new _combineLatestSupport.CombineLatestOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = combineAll;

	var _combineLatestSupport = __webpack_require__(83);

	function combineAll(project) {
	    return this.lift(new _combineLatestSupport.CombineLatestOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = withLatestFrom;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function withLatestFrom() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }

	    var project = args.pop();
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}

	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        _classCallCheck(this, WithLatestFromOperator);

	        this.observables = observables;
	        this.project = project;
	    }

	    WithLatestFromOperator.prototype.call = function call(subscriber) {
	        return new WithLatestFromSubscriber(subscriber, this.observables, this.project);
	    };

	    return WithLatestFromOperator;
	})();

	var WithLatestFromSubscriber = (function (_Subscriber) {
	    _inherits(WithLatestFromSubscriber, _Subscriber);

	    function WithLatestFromSubscriber(destination, observables, project) {
	        _classCallCheck(this, WithLatestFromSubscriber);

	        _Subscriber.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        var len = observables.length;
	        this.values = new Array(len);
	        this.toSet = len;
	        for (var i = 0; i < len; i++) {
	            this.add(observables[i]._subscribe(new WithLatestInnerSubscriber(this, i)));
	        }
	    }

	    WithLatestFromSubscriber.prototype.notifyValue = function notifyValue(index, value) {
	        this.values[index] = value;
	        this.toSet--;
	    };

	    WithLatestFromSubscriber.prototype._next = function _next(value) {
	        if (this.toSet === 0) {
	            var values = this.values;
	            var result = _utilTryCatch2['default'](this.project)([value].concat(values));
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(result.e);
	            } else {
	                this.destination.next(result);
	            }
	        }
	    };

	    return WithLatestFromSubscriber;
	})(_Subscriber4['default']);

	var WithLatestInnerSubscriber = (function (_Subscriber2) {
	    _inherits(WithLatestInnerSubscriber, _Subscriber2);

	    function WithLatestInnerSubscriber(parent, valueIndex) {
	        _classCallCheck(this, WithLatestInnerSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.valueIndex = valueIndex;
	    }

	    WithLatestInnerSubscriber.prototype._next = function _next(value) {
	        this.parent.notifyValue(this.valueIndex, value);
	    };

	    WithLatestInnerSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WithLatestInnerSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WithLatestInnerSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = zipProto;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _zipStatic = __webpack_require__(89);

	var _zipStatic2 = _interopRequireDefault(_zipStatic);

	function zipProto() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    observables.unshift(this);
	    return _zipStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = zip;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(29);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _zipSupport = __webpack_require__(84);

	function zip() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new _zipSupport.ZipOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = zipAll;

	var _zipSupport = __webpack_require__(84);

	function zipAll(project) {
	    return this.lift(new _zipSupport.ZipOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = publish;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _multicast = __webpack_require__(92);

	var _multicast2 = _interopRequireDefault(_multicast);

	function subjectFactory() {
	    return new _Subject2['default']();
	}

	function publish() {
	    return _multicast2['default'].call(this, subjectFactory);
	}

	module.exports = exports['default'];

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = multicast;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesConnectableObservable = __webpack_require__(28);

	var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);

	function multicast(subjectFactory) {
	    return new _observablesConnectableObservable2['default'](this, subjectFactory);
	}

	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = publishBehavior;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _subjectsBehaviorSubject = __webpack_require__(27);

	var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);

	var _multicast = __webpack_require__(92);

	var _multicast2 = _interopRequireDefault(_multicast);

	function publishBehavior(value) {
	    return _multicast2['default'].call(this, function () {
	        return new _subjectsBehaviorSubject2['default'](value);
	    });
	}

	module.exports = exports['default'];

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = publishReplay;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _subjectsReplaySubject = __webpack_require__(26);

	var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);

	var _multicast = __webpack_require__(92);

	var _multicast2 = _interopRequireDefault(_multicast);

	function publishReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	    if (windowTime === undefined) windowTime = Number.POSITIVE_INFINITY;

	    return _multicast2['default'].call(this, function () {
	        return new _subjectsReplaySubject2['default'](bufferSize, windowTime, scheduler);
	    });
	}

	module.exports = exports['default'];

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = observeOn;

	var _observeOnSupport = __webpack_require__(48);

	function observeOn(scheduler) {
	    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    return this.lift(new _observeOnSupport.ObserveOnOperator(scheduler, delay));
	}

	module.exports = exports['default'];

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = subscribeOn;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesSubscribeOnObservable = __webpack_require__(97);

	var _observablesSubscribeOnObservable2 = _interopRequireDefault(_observablesSubscribeOnObservable);

	function subscribeOn(scheduler) {
	    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    return new _observablesSubscribeOnObservable2['default'](this, delay, scheduler);
	}

	module.exports = exports['default'];

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(3);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var SubscribeOnObservable = (function (_Observable) {
	    _inherits(SubscribeOnObservable, _Observable);

	    function SubscribeOnObservable(source) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	        _classCallCheck(this, SubscribeOnObservable);

	        _Observable.call(this);
	        this.source = source;
	        this.delayTime = delay;
	        this.scheduler = scheduler;
	    }

	    SubscribeOnObservable.create = function create(source) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	        return new SubscribeOnObservable(source, delay, scheduler);
	    };

	    SubscribeOnObservable.dispatch = function dispatch(_ref) {
	        var source = _ref.source;
	        var subscriber = _ref.subscriber;

	        return source.subscribe(subscriber);
	    };

	    SubscribeOnObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        }));
	    };

	    return SubscribeOnObservable;
	})(_Observable3['default']);

	exports['default'] = SubscribeOnObservable;
	module.exports = exports['default'];

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = partition;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utilNot = __webpack_require__(99);

	var _utilNot2 = _interopRequireDefault(_utilNot);

	var _filter = __webpack_require__(79);

	var _filter2 = _interopRequireDefault(_filter);

	function partition(predicate, thisArg) {
	    return [_filter2['default'].call(this, predicate), _filter2['default'].call(this, _utilNot2['default'](predicate, thisArg))];
	}

	module.exports = exports['default'];

/***/ },
/* 99 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = not;

	function not(pred, thisArg) {
	    function notPred() {
	        return !notPred.pred.apply(notPred.thisArg, arguments);
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}

	module.exports = exports["default"];

/***/ },
/* 100 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = toPromise;

	function toPromise() {
	    var _this = this;

	    var PromiseCtor = arguments.length <= 0 || arguments[0] === undefined ? Promise : arguments[0];

	    return new PromiseCtor(function (resolve, reject) {
	        var value = undefined;
	        _this.subscribe(function (x) {
	            return value = x;
	        }, function (err) {
	            return reject(err);
	        }, function () {
	            return resolve(value);
	        });
	    });
	}

	module.exports = exports["default"];

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = defaultIfEmpty;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function defaultIfEmpty() {
	    var defaultValue = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}

	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        _classCallCheck(this, DefaultIfEmptyOperator);

	        this.defaultValue = defaultValue;
	    }

	    DefaultIfEmptyOperator.prototype.call = function call(subscriber) {
	        return new DefaultIfEmptySubscriber(subscriber, this.defaultValue);
	    };

	    return DefaultIfEmptyOperator;
	})();

	var DefaultIfEmptySubscriber = (function (_Subscriber) {
	    _inherits(DefaultIfEmptySubscriber, _Subscriber);

	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _classCallCheck(this, DefaultIfEmptySubscriber);

	        _Subscriber.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }

	    DefaultIfEmptySubscriber.prototype._next = function _next(x) {
	        this.isEmpty = false;
	        this.destination.next(x);
	    };

	    DefaultIfEmptySubscriber.prototype._complete = function _complete() {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };

	    return DefaultIfEmptySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = materialize;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Notification = __webpack_require__(15);

	var _Notification2 = _interopRequireDefault(_Notification);

	function materialize() {
	    return this.lift(new MaterializeOperator());
	}

	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	        _classCallCheck(this, MaterializeOperator);
	    }

	    MaterializeOperator.prototype.call = function call(subscriber) {
	        return new MaterializeSubscriber(subscriber);
	    };

	    return MaterializeOperator;
	})();

	var MaterializeSubscriber = (function (_Subscriber) {
	    _inherits(MaterializeSubscriber, _Subscriber);

	    function MaterializeSubscriber(destination) {
	        _classCallCheck(this, MaterializeSubscriber);

	        _Subscriber.call(this, destination);
	    }

	    MaterializeSubscriber.prototype._next = function _next(value) {
	        this.destination.next(_Notification2['default'].createNext(value));
	    };

	    MaterializeSubscriber.prototype._error = function _error(err) {
	        var destination = this.destination;
	        destination.next(_Notification2['default'].createError(err));
	        destination.complete();
	    };

	    MaterializeSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        destination.next(_Notification2['default'].createComplete());
	        destination.complete();
	    };

	    return MaterializeSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = _catch;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function _catch(selector) {
	    var catchOperator = new CatchOperator(selector);
	    var caught = this.lift(catchOperator);
	    catchOperator.caught = caught;
	    return caught;
	}

	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        _classCallCheck(this, CatchOperator);

	        this.selector = selector;
	    }

	    CatchOperator.prototype.call = function call(subscriber) {
	        return new CatchSubscriber(subscriber, this.selector, this.caught);
	    };

	    return CatchOperator;
	})();

	var CatchSubscriber = (function (_Subscriber) {
	    _inherits(CatchSubscriber, _Subscriber);

	    function CatchSubscriber(destination, selector, caught) {
	        _classCallCheck(this, CatchSubscriber);

	        _Subscriber.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }

	    CatchSubscriber.prototype._error = function _error(err) {
	        var result = _utilTryCatch2['default'](this.selector)(err, this.caught);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.add(result.subscribe(this.destination));
	        }
	    };

	    return CatchSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = retry;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function retry() {
	    var count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	    return this.lift(new RetryOperator(count, this));
	}

	var RetryOperator = (function () {
	    function RetryOperator(count, original) {
	        _classCallCheck(this, RetryOperator);

	        this.count = count;
	        this.original = original;
	    }

	    RetryOperator.prototype.call = function call(subscriber) {
	        return new RetrySubscriber(subscriber, this.count, this.original);
	    };

	    return RetryOperator;
	})();

	var RetrySubscriber = (function (_Subscriber) {
	    _inherits(RetrySubscriber, _Subscriber);

	    function RetrySubscriber(destination, count, original) {
	        _classCallCheck(this, RetrySubscriber);

	        _Subscriber.call(this, destination);
	        this.count = count;
	        this.original = original;
	        this.retries = 0;
	    }

	    RetrySubscriber.prototype._error = function _error(err) {
	        var count = this.count;
	        if (count && count === (this.retries += 1)) {
	            this.destination.error(err);
	        } else {
	            this.resubscribe();
	        }
	    };

	    RetrySubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };

	    return RetrySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = retryWhen;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function retryWhen(notifier) {
	    return this.lift(new RetryWhenOperator(notifier, this));
	}

	var RetryWhenOperator = (function () {
	    function RetryWhenOperator(notifier, original) {
	        _classCallCheck(this, RetryWhenOperator);

	        this.notifier = notifier;
	        this.original = original;
	    }

	    RetryWhenOperator.prototype.call = function call(subscriber) {
	        return new RetryWhenSubscriber(subscriber, this.notifier, this.original);
	    };

	    return RetryWhenOperator;
	})();

	var RetryWhenSubscriber = (function (_Subscriber) {
	    _inherits(RetryWhenSubscriber, _Subscriber);

	    function RetryWhenSubscriber(destination, notifier, original) {
	        _classCallCheck(this, RetryWhenSubscriber);

	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.original = original;
	    }

	    RetryWhenSubscriber.prototype._error = function _error(err) {
	        if (!this.retryNotifications) {
	            this.errors = new _Subject2['default']();
	            var notifications = _utilTryCatch2['default'](this.notifier).call(this, this.errors);
	            if (notifications === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.retryNotifications = notifications;
	                this.add(notifications._subscribe(new RetryNotificationSubscriber(this)));
	            }
	        }
	        this.errors.next(err);
	    };

	    RetryWhenSubscriber.prototype.finalError = function finalError(err) {
	        this.destination.error(err);
	    };

	    RetryWhenSubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };

	    return RetryWhenSubscriber;
	})(_Subscriber4['default']);

	var RetryNotificationSubscriber = (function (_Subscriber2) {
	    _inherits(RetryNotificationSubscriber, _Subscriber2);

	    function RetryNotificationSubscriber(parent) {
	        _classCallCheck(this, RetryNotificationSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    RetryNotificationSubscriber.prototype._next = function _next(value) {
	        this.parent.resubscribe();
	    };

	    RetryNotificationSubscriber.prototype._error = function _error(err) {
	        this.parent.finalError(err);
	    };

	    RetryNotificationSubscriber.prototype._complete = function _complete() {
	        this.parent.complete();
	    };

	    return RetryNotificationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = repeat;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function repeat(count) {
	    return this.lift(new RepeatOperator(count, this));
	}

	var RepeatOperator = (function () {
	    function RepeatOperator(count, original) {
	        _classCallCheck(this, RepeatOperator);

	        this.count = count;
	        this.original = original;
	    }

	    RepeatOperator.prototype.call = function call(subscriber) {
	        return new RepeatSubscriber(subscriber, this.count, this.original);
	    };

	    return RepeatOperator;
	})();

	var RepeatSubscriber = (function (_Subscriber) {
	    _inherits(RepeatSubscriber, _Subscriber);

	    function RepeatSubscriber(destination, count, original) {
	        _classCallCheck(this, RepeatSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = count;
	        this.original = original;
	        this.repeated = 0;
	    }

	    RepeatSubscriber.prototype._complete = function _complete() {
	        if (this.count === (this.repeated += 1)) {
	            this.destination.complete();
	        } else {
	            this.resubscribe();
	        }
	    };

	    RepeatSubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };

	    return RepeatSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = _finally;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilBindCallback = __webpack_require__(68);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	function _finally(finallySelector, thisArg) {
	    return this.lift(new FinallyOperator(thisArg ? _utilBindCallback2['default'](finallySelector, thisArg, 2) : finallySelector));
	}

	var FinallyOperator = (function () {
	    function FinallyOperator(finallySelector) {
	        _classCallCheck(this, FinallyOperator);

	        this.finallySelector = finallySelector;
	    }

	    FinallyOperator.prototype.call = function call(subscriber) {
	        return new FinallySubscriber(subscriber, this.finallySelector);
	    };

	    return FinallyOperator;
	})();

	var FinallySubscriber = (function (_Subscriber) {
	    _inherits(FinallySubscriber, _Subscriber);

	    function FinallySubscriber(destination, finallySelector) {
	        _classCallCheck(this, FinallySubscriber);

	        _Subscriber.call(this, destination);
	        this.add(new _Subscription2['default'](finallySelector));
	    }

	    return FinallySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = timeout;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var _utilIsDate = __webpack_require__(109);

	var _utilIsDate2 = _interopRequireDefault(_utilIsDate);

	function timeout(due) {
	    var errorToSend = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];

	    var waitFor = _utilIsDate2['default'](due) ? +due - Date.now() : due;
	    return this.lift(new TimeoutOperator(waitFor, errorToSend, scheduler));
	}

	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, errorToSend, scheduler) {
	        _classCallCheck(this, TimeoutOperator);

	        this.waitFor = waitFor;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	    }

	    TimeoutOperator.prototype.call = function call(subscriber) {
	        return new TimeoutSubscriber(subscriber, this.waitFor, this.errorToSend, this.scheduler);
	    };

	    return TimeoutOperator;
	})();

	var TimeoutSubscriber = (function (_Subscriber) {
	    _inherits(TimeoutSubscriber, _Subscriber);

	    function TimeoutSubscriber(destination, waitFor, errorToSend, scheduler) {
	        _classCallCheck(this, TimeoutSubscriber);

	        _Subscriber.call(this, destination);
	        this.waitFor = waitFor;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	        var delay = waitFor;
	        scheduler.schedule(dispatchTimeout, delay, { subscriber: this });
	    }

	    TimeoutSubscriber.prototype.sendTimeoutError = function sendTimeoutError() {
	        this.error(this.errorToSend || new Error('timeout'));
	    };

	    return TimeoutSubscriber;
	})(_Subscriber3['default']);

	function dispatchTimeout(state) {
	    var subscriber = state.subscriber;
	    subscriber.sendTimeoutError();
	}
	module.exports = exports['default'];

/***/ },
/* 109 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = isDate;

	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}

	module.exports = exports["default"];

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = timeoutWith;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var _utilIsDate = __webpack_require__(109);

	var _utilIsDate2 = _interopRequireDefault(_utilIsDate);

	function timeoutWith(due, withObservable) {
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];

	    var waitFor = _utilIsDate2['default'](due) ? +due - Date.now() : due;
	    return this.lift(new TimeoutWithOperator(waitFor, withObservable, scheduler));
	}

	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, withObservable, scheduler) {
	        _classCallCheck(this, TimeoutWithOperator);

	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }

	    TimeoutWithOperator.prototype.call = function call(subscriber) {
	        return new TimeoutWithSubscriber(subscriber, this.waitFor, this.withObservable, this.scheduler);
	    };

	    return TimeoutWithOperator;
	})();

	var TimeoutWithSubscriber = (function (_Subscriber) {
	    _inherits(TimeoutWithSubscriber, _Subscriber);

	    function TimeoutWithSubscriber(destination, waitFor, withObservable, scheduler) {
	        _classCallCheck(this, TimeoutWithSubscriber);

	        _Subscriber.call(this, destination);
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        var delay = waitFor;
	        scheduler.schedule(dispatchTimeout, delay, { subscriber: this });
	    }

	    TimeoutWithSubscriber.prototype.handleTimeout = function handleTimeout() {
	        var withObservable = this.withObservable;
	        this.add(withObservable.subscribe(this));
	    };

	    return TimeoutWithSubscriber;
	})(_Subscriber3['default']);

	function dispatchTimeout(state) {
	    var subscriber = state.subscriber;
	    subscriber.handleTimeout();
	}
	module.exports = exports['default'];

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = groupBy;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilMap = __webpack_require__(112);

	var _utilMap2 = _interopRequireDefault(_utilMap);

	var _utilFastMap = __webpack_require__(113);

	var _utilFastMap2 = _interopRequireDefault(_utilFastMap);

	var _subjectsGroupSubject = __webpack_require__(114);

	var _subjectsGroupSubject2 = _interopRequireDefault(_subjectsGroupSubject);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function groupBy(keySelector, elementSelector, durationSelector) {
	    return this.lift(new GroupByOperator(keySelector, durationSelector, elementSelector));
	}

	var GroupByOperator = (function () {
	    function GroupByOperator(keySelector, durationSelector, elementSelector) {
	        _classCallCheck(this, GroupByOperator);

	        this.keySelector = keySelector;
	        this.durationSelector = durationSelector;
	        this.elementSelector = elementSelector;
	    }

	    GroupByOperator.prototype.call = function call(subscriber) {
	        return new GroupBySubscriber(subscriber, this.keySelector, this.durationSelector, this.elementSelector);
	    };

	    return GroupByOperator;
	})();

	var GroupBySubscriber = (function (_Subscriber) {
	    _inherits(GroupBySubscriber, _Subscriber);

	    function GroupBySubscriber(destination, keySelector, durationSelector, elementSelector) {
	        _classCallCheck(this, GroupBySubscriber);

	        _Subscriber.call(this, destination);
	        this.keySelector = keySelector;
	        this.durationSelector = durationSelector;
	        this.elementSelector = elementSelector;
	        this.groups = null;
	    }

	    GroupBySubscriber.prototype._next = function _next(x) {
	        var key = _utilTryCatch2['default'](this.keySelector)(x);
	        if (key === _utilErrorObject.errorObject) {
	            this.error(key.e);
	        } else {
	            var groups = this.groups;
	            var elementSelector = this.elementSelector;
	            var durationSelector = this.durationSelector;
	            if (!groups) {
	                groups = this.groups = typeof key === 'string' ? new _utilFastMap2['default']() : new _utilMap2['default']();
	            }
	            var group = groups.get(key);
	            if (!group) {
	                groups.set(key, group = new _subjectsGroupSubject2['default'](key));
	                if (durationSelector) {
	                    var duration = _utilTryCatch2['default'](durationSelector)(group);
	                    if (duration === _utilErrorObject.errorObject) {
	                        this.error(duration.e);
	                    } else {
	                        this.add(duration._subscribe(new GroupDurationSubscriber(group, this)));
	                    }
	                }
	                this.destination.next(group);
	            }
	            if (elementSelector) {
	                var value = _utilTryCatch2['default'](elementSelector)(x);
	                if (value === _utilErrorObject.errorObject) {
	                    group.error(value.e);
	                } else {
	                    group.next(value);
	                }
	            } else {
	                group.next(x);
	            }
	        }
	    };

	    GroupBySubscriber.prototype._error = function _error(err) {
	        var _this = this;

	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	                _this.removeGroup(key);
	            });
	        }
	        this.destination.error(err);
	    };

	    GroupBySubscriber.prototype._complete = function _complete() {
	        var _this2 = this;

	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	                _this2.removeGroup(group);
	            });
	        }
	        this.destination.complete();
	    };

	    GroupBySubscriber.prototype.removeGroup = function removeGroup(key) {
	        this.groups[key] = null;
	    };

	    return GroupBySubscriber;
	})(_Subscriber4['default']);

	var GroupDurationSubscriber = (function (_Subscriber2) {
	    _inherits(GroupDurationSubscriber, _Subscriber2);

	    function GroupDurationSubscriber(group, parent) {
	        _classCallCheck(this, GroupDurationSubscriber);

	        _Subscriber2.call(this, null);
	        this.group = group;
	        this.parent = parent;
	    }

	    GroupDurationSubscriber.prototype._next = function _next(value) {
	        var group = this.group;
	        group.complete();
	        this.parent.removeGroup(group.key);
	    };

	    GroupDurationSubscriber.prototype._error = function _error(err) {
	        var group = this.group;
	        group.error(err);
	        this.parent.removeGroup(group.key);
	    };

	    GroupDurationSubscriber.prototype._complete = function _complete() {
	        var group = this.group;
	        group.complete();
	        this.parent.removeGroup(group.key);
	    };

	    return GroupDurationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _root = __webpack_require__(10);

	exports['default'] = _root.root.Map || (function () {
	    function Map() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    Map.prototype['delete'] = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    Map.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    Map.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        } else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    Map.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return Map;
	})();

	module.exports = exports['default'];

/***/ },
/* 113 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FastMap = (function () {
	    function FastMap() {
	        _classCallCheck(this, FastMap);

	        this.size = 0;
	        this._values = {};
	    }

	    FastMap.prototype["delete"] = function _delete(key) {
	        this._values[key] = null;
	        return true;
	    };

	    FastMap.prototype.set = function set(key, value) {
	        this._values[key] = value;
	        return this;
	    };

	    FastMap.prototype.get = function get(key) {
	        return this._values[key];
	    };

	    FastMap.prototype.forEach = function forEach(cb, thisArg) {
	        var values = this._values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key)) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };

	    FastMap.prototype.clear = function clear() {
	        this._values = {};
	    };

	    return FastMap;
	})();

	exports["default"] = FastMap;
	module.exports = exports["default"];

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subject2 = __webpack_require__(2);

	var _Subject3 = _interopRequireDefault(_Subject2);

	var GroupSubject = (function (_Subject) {
	    _inherits(GroupSubject, _Subject);

	    function GroupSubject(key) {
	        _classCallCheck(this, GroupSubject);

	        _Subject.call(this);
	        this.key = key;
	    }

	    return GroupSubject;
	})(_Subject3['default']);

	exports['default'] = GroupSubject;
	module.exports = exports['default'];

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = window;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	function window(closingNotifier) {
	    return this.lift(new WindowOperator(closingNotifier));
	}

	var WindowOperator = (function () {
	    function WindowOperator(closingNotifier) {
	        _classCallCheck(this, WindowOperator);

	        this.closingNotifier = closingNotifier;
	    }

	    WindowOperator.prototype.call = function call(subscriber) {
	        return new WindowSubscriber(subscriber, this.closingNotifier);
	    };

	    return WindowOperator;
	})();

	var WindowSubscriber = (function (_Subscriber) {
	    _inherits(WindowSubscriber, _Subscriber);

	    function WindowSubscriber(destination, closingNotifier) {
	        _classCallCheck(this, WindowSubscriber);

	        _Subscriber.call(this, destination);
	        this.closingNotifier = closingNotifier;
	        this.window = new _Subject2['default']();
	        this.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this)));
	        this.openWindow();
	    }

	    WindowSubscriber.prototype._next = function _next(value) {
	        this.window.next(value);
	    };

	    WindowSubscriber.prototype._error = function _error(err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };

	    WindowSubscriber.prototype._complete = function _complete() {
	        this.window.complete();
	        this.destination.complete();
	    };

	    WindowSubscriber.prototype.openWindow = function openWindow() {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        this.destination.next(this.window = new _Subject2['default']());
	    };

	    return WindowSubscriber;
	})(_Subscriber4['default']);

	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

	    function WindowClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openWindow();
	    };

	    return WindowClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = window;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function window(closingSelector) {
	    return this.lift(new WindowOperator(closingSelector));
	}

	var WindowOperator = (function () {
	    function WindowOperator(closingSelector) {
	        _classCallCheck(this, WindowOperator);

	        this.closingSelector = closingSelector;
	    }

	    WindowOperator.prototype.call = function call(subscriber) {
	        return new WindowSubscriber(subscriber, this.closingSelector);
	    };

	    return WindowOperator;
	})();

	var WindowSubscriber = (function (_Subscriber) {
	    _inherits(WindowSubscriber, _Subscriber);

	    function WindowSubscriber(destination, closingSelector) {
	        _classCallCheck(this, WindowSubscriber);

	        _Subscriber.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.window = new _Subject2['default']();
	        this.openWindow();
	    }

	    WindowSubscriber.prototype._next = function _next(value) {
	        this.window.next(value);
	    };

	    WindowSubscriber.prototype._error = function _error(err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };

	    WindowSubscriber.prototype._complete = function _complete() {
	        this.window.complete();
	        this.destination.complete();
	    };

	    WindowSubscriber.prototype.openWindow = function openWindow() {
	        var prevClosingNotification = this.closingNotification;
	        if (prevClosingNotification) {
	            this.remove(prevClosingNotification);
	            prevClosingNotification.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        this.destination.next(this.window = new _Subject2['default']());
	        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.destination.error(err);
	            this.window.error(err);
	        } else {
	            var closingNotification = this.closingNotification = new _Subscription2['default']();
	            this.add(closingNotification.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this))));
	        }
	    };

	    return WindowSubscriber;
	})(_Subscriber4['default']);

	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

	    function WindowClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openWindow();
	    };

	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WindowClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = windowToggle;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber4 = __webpack_require__(4);

	var _Subscriber5 = _interopRequireDefault(_Subscriber4);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function windowToggle(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}

	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        _classCallCheck(this, WindowToggleOperator);

	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }

	    WindowToggleOperator.prototype.call = function call(subscriber) {
	        return new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector);
	    };

	    return WindowToggleOperator;
	})();

	var WindowToggleSubscriber = (function (_Subscriber) {
	    _inherits(WindowToggleSubscriber, _Subscriber);

	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _classCallCheck(this, WindowToggleSubscriber);

	        _Subscriber.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.windows = [];
	        this.add(this.openings._subscribe(new WindowToggleOpeningsSubscriber(this)));
	    }

	    WindowToggleSubscriber.prototype._next = function _next(value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	    };

	    WindowToggleSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };

	    WindowToggleSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };

	    WindowToggleSubscriber.prototype.openWindow = function openWindow(value) {
	        var window = new _Subject2['default']();
	        this.windows.push(window);
	        this.destination.next(window);
	        var windowContext = {
	            window: window,
	            subscription: new _Subscription2['default']()
	        };
	        var closingSelector = this.closingSelector;
	        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            this.error(closingNotifier.e);
	        } else {
	            this.add(windowContext.subscription.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this, windowContext))));
	        }
	    };

	    WindowToggleSubscriber.prototype.closeWindow = function closeWindow(windowContext) {
	        var window = windowContext.window;
	        var subscription = windowContext.subscription;

	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	        window.complete();
	        this.remove(subscription);
	    };

	    return WindowToggleSubscriber;
	})(_Subscriber5['default']);

	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

	    function WindowClosingNotifierSubscriber(parent, windowContext) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.windowContext = windowContext;
	    }

	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.closeWindow(this.windowContext);
	    };

	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WindowClosingNotifierSubscriber;
	})(_Subscriber5['default']);

	var WindowToggleOpeningsSubscriber = (function (_Subscriber3) {
	    _inherits(WindowToggleOpeningsSubscriber, _Subscriber3);

	    function WindowToggleOpeningsSubscriber(parent) {
	        _classCallCheck(this, WindowToggleOpeningsSubscriber);

	        _Subscriber3.call(this);
	        this.parent = parent;
	    }

	    WindowToggleOpeningsSubscriber.prototype._next = function _next(value) {
	        this.parent.openWindow(value);
	    };

	    WindowToggleOpeningsSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WindowToggleOpeningsSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WindowToggleOpeningsSubscriber;
	})(_Subscriber5['default']);

	module.exports = exports['default'];

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = windowTime;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function windowTime(windowTimeSpan) {
	    var windowCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
	}

	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
	        _classCallCheck(this, WindowTimeOperator);

	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	    }

	    WindowTimeOperator.prototype.call = function call(subscriber) {
	        return new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler);
	    };

	    return WindowTimeOperator;
	})();

	var WindowTimeSubscriber = (function (_Subscriber) {
	    _inherits(WindowTimeSubscriber, _Subscriber);

	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
	        _classCallCheck(this, WindowTimeSubscriber);

	        _Subscriber.call(this, destination);
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	        this.windows = [];
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var _window = this.openWindow();
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, { subscriber: this, window: _window, context: null }));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler }));
	        } else {
	            var _window2 = this.openWindow();
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, { subscriber: this, window: _window2, windowTimeSpan: windowTimeSpan }));
	        }
	    }

	    WindowTimeSubscriber.prototype._next = function _next(value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	    };

	    WindowTimeSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };

	    WindowTimeSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };

	    WindowTimeSubscriber.prototype.openWindow = function openWindow() {
	        var window = new _Subject2['default']();
	        this.windows.push(window);
	        this.destination.next(window);
	        return window;
	    };

	    WindowTimeSubscriber.prototype.closeWindow = function closeWindow(window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };

	    return WindowTimeSubscriber;
	})(_Subscriber3['default']);

	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var windowTimeSpan = state.windowTimeSpan;
	    var window = state.window;

	    if (window) {
	        window.complete();
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan;
	    var subscriber = state.subscriber;
	    var scheduler = state.scheduler;
	    var windowCreationInterval = state.windowCreationInterval;

	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    action.add(context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, { subscriber: subscriber, window: window, context: context }));
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(_ref) {
	    var subscriber = _ref.subscriber;
	    var window = _ref.window;
	    var context = _ref.context;

	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}
	module.exports = exports['default'];

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = windowCount;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Subject = __webpack_require__(2);

	var _Subject2 = _interopRequireDefault(_Subject);

	function windowCount(windowSize) {
	    var startWindowEvery = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}

	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        _classCallCheck(this, WindowCountOperator);

	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }

	    WindowCountOperator.prototype.call = function call(subscriber) {
	        return new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery);
	    };

	    return WindowCountOperator;
	})();

	var WindowCountSubscriber = (function (_Subscriber) {
	    _inherits(WindowCountSubscriber, _Subscriber);

	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _classCallCheck(this, WindowCountSubscriber);

	        _Subscriber.call(this, destination);
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [{ count: 0, notified: false, window: new _Subject2['default']() }];
	        this.count = 0;
	    }

	    WindowCountSubscriber.prototype._next = function _next(value) {
	        var count = this.count += 1;
	        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        if (count % startWindowEvery === 0) {
	            var _window = new _Subject2['default']();
	            windows.push({ count: 0, notified: false, window: _window });
	        }
	        for (var i = 0; i < len; i++) {
	            var w = windows[i];
	            var _window2 = w.window;
	            if (!w.notified) {
	                w.notified = true;
	                this.destination.next(_window2);
	            }
	            _window2.next(value);
	            if (windowSize === (w.count += 1)) {
	                _window2.complete();
	            }
	        }
	    };

	    WindowCountSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().window.error(err);
	        }
	        this.destination.error(err);
	    };

	    WindowCountSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().window.complete();
	        }
	        this.destination.complete();
	    };

	    return WindowCountSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = delay;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Notification = __webpack_require__(15);

	var _Notification2 = _interopRequireDefault(_Notification);

	var _schedulersImmediate = __webpack_require__(16);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	function delay(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

	    return this.lift(new DelayOperator(delay, scheduler));
	}

	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        _classCallCheck(this, DelayOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    DelayOperator.prototype.call = function call(subscriber) {
	        return new DelaySubscriber(subscriber, this.delay, this.scheduler);
	    };

	    return DelayOperator;
	})();

	var DelaySubscriber = (function (_Subscriber) {
	    _inherits(DelaySubscriber, _Subscriber);

	    function DelaySubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, DelaySubscriber);

	        _Subscriber.call(this, destination);
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    DelaySubscriber.dispatch = function dispatch(state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var _delay = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, _delay);
	        } else {
	            source.active = false;
	        }
	    };

	    DelaySubscriber.prototype._next = function _next(x) {
	        if (this.errored) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createNext(x)));
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };

	    DelaySubscriber.prototype._error = function _error(e) {
	        var scheduler = this.scheduler;
	        this.errored = true;
	        this.queue = [new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createError(e))];
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };

	    DelaySubscriber.prototype._complete = function _complete() {
	        if (this.errored) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createComplete()));
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };

	    DelaySubscriber.prototype._schedule = function _schedule(scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };

	    return DelaySubscriber;
	})(_Subscriber3['default']);

	var DelayMessage = function DelayMessage(time, notification) {
	    _classCallCheck(this, DelayMessage);

	    this.time = time;
	    this.notification = notification;
	};

	module.exports = exports['default'];

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = throttle;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function throttle(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	    return this.lift(new ThrottleOperator(delay, scheduler));
	}

	var ThrottleOperator = (function () {
	    function ThrottleOperator(delay, scheduler) {
	        _classCallCheck(this, ThrottleOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ThrottleOperator.prototype.call = function call(subscriber) {
	        return new ThrottleSubscriber(subscriber, this.delay, this.scheduler);
	    };

	    return ThrottleOperator;
	})();

	var ThrottleSubscriber = (function (_Subscriber) {
	    _inherits(ThrottleSubscriber, _Subscriber);

	    function ThrottleSubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, ThrottleSubscriber);

	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ThrottleSubscriber.prototype._next = function _next(x) {
	        this.clearThrottle();
	        this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.delay, { value: x, subscriber: this }));
	    };

	    ThrottleSubscriber.prototype.throttledNext = function throttledNext(x) {
	        this.clearThrottle();
	        this.destination.next(x);
	    };

	    ThrottleSubscriber.prototype.clearThrottle = function clearThrottle() {
	        var throttled = this.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            throttled.unsubscribe();
	            this.throttled = null;
	        }
	    };

	    return ThrottleSubscriber;
	})(_Subscriber3['default']);

	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;

	    subscriber.throttledNext(value);
	}
	module.exports = exports['default'];

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = debounce;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function debounce(dueTime) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	    return this.lift(new DebounceOperator(dueTime, scheduler));
	}

	var DebounceOperator = (function () {
	    function DebounceOperator(dueTime, scheduler) {
	        _classCallCheck(this, DebounceOperator);

	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }

	    DebounceOperator.prototype.call = function call(subscriber) {
	        return new DebounceSubscriber(subscriber, this.dueTime, this.scheduler);
	    };

	    return DebounceOperator;
	})();

	var DebounceSubscriber = (function (_Subscriber) {
	    _inherits(DebounceSubscriber, _Subscriber);

	    function DebounceSubscriber(destination, dueTime, scheduler) {
	        _classCallCheck(this, DebounceSubscriber);

	        _Subscriber.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }

	    DebounceSubscriber.prototype._next = function _next(value) {
	        if (!this.debounced) {
	            this.add(this.debounced = this.scheduler.schedule(dispatchNext, this.dueTime, { value: value, subscriber: this }));
	        }
	    };

	    DebounceSubscriber.prototype.clearDebounce = function clearDebounce() {
	        var debounced = this.debounced;
	        if (debounced) {
	            debounced.unsubscribe();
	            this.remove(debounced);
	        }
	    };

	    DebounceSubscriber.prototype.debouncedNext = function debouncedNext(value) {
	        this.clearDebounce();
	        this.destination.next(value);
	    };

	    return DebounceSubscriber;
	})(_Subscriber3['default']);

	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;

	    subscriber.debouncedNext(value);
	}
	module.exports = exports['default'];

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = buffer;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	/**
	 * buffers the incoming observable values until the passed `closingNotifier` emits a value, at which point
	 * it emits the buffer on the returned observable and starts a new buffer internally, awaiting the
	 * next time `closingNotifier` emits
	 *
	 * @param {Observable<any>} closingNotifier an observable, that signals the buffer to be emitted from the returned observable
	 * @returns {Observable<T[]>} an observable of buffers, which are arrays of values
	 */

	function buffer(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}

	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        _classCallCheck(this, BufferOperator);

	        this.closingNotifier = closingNotifier;
	    }

	    BufferOperator.prototype.call = function call(subscriber) {
	        return new BufferSubscriber(subscriber, this.closingNotifier);
	    };

	    return BufferOperator;
	})();

	var BufferSubscriber = (function (_Subscriber) {
	    _inherits(BufferSubscriber, _Subscriber);

	    function BufferSubscriber(destination, closingNotifier) {
	        _classCallCheck(this, BufferSubscriber);

	        _Subscriber.call(this, destination);
	        this.buffer = [];
	        this.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
	    }

	    BufferSubscriber.prototype._next = function _next(value) {
	        this.buffer.push(value);
	    };

	    BufferSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };

	    BufferSubscriber.prototype._complete = function _complete() {
	        this.flushBuffer();
	        this.destination.complete();
	    };

	    BufferSubscriber.prototype.flushBuffer = function flushBuffer() {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };

	    return BufferSubscriber;
	})(_Subscriber4['default']);

	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

	    function BufferClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    BufferClosingNotifierSubscriber.prototype._next = function _next(value) {
	        this.parent.flushBuffer();
	    };

	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferCount;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function bufferCount(bufferSize) {
	    var startBufferEvery = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}

	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        _classCallCheck(this, BufferCountOperator);

	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	    }

	    BufferCountOperator.prototype.call = function call(subscriber) {
	        return new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery);
	    };

	    return BufferCountOperator;
	})();

	var BufferCountSubscriber = (function (_Subscriber) {
	    _inherits(BufferCountSubscriber, _Subscriber);

	    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _classCallCheck(this, BufferCountSubscriber);

	        _Subscriber.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [[]];
	        this.count = 0;
	    }

	    BufferCountSubscriber.prototype._next = function _next(value) {
	        var count = this.count += 1;
	        var destination = this.destination;
	        var bufferSize = this.bufferSize;
	        var startBufferEvery = this.startBufferEvery == null ? bufferSize : this.startBufferEvery;
	        var buffers = this.buffers;
	        var len = buffers.length;
	        var remove = -1;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = 0; i < len; i++) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                remove = i;
	                this.destination.next(buffer);
	            }
	        }
	        if (remove !== -1) {
	            buffers.splice(remove, 1);
	        }
	    };

	    BufferCountSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };

	    BufferCountSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        destination.complete();
	    };

	    return BufferCountSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferTime;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function bufferTime(bufferTimeSpan) {
	    var bufferCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler));
	}

	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _classCallCheck(this, BufferTimeOperator);

	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	    }

	    BufferTimeOperator.prototype.call = function call(subscriber) {
	        return new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.scheduler);
	    };

	    return BufferTimeOperator;
	})();

	var BufferTimeSubscriber = (function (_Subscriber) {
	    _inherits(BufferTimeSubscriber, _Subscriber);

	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _classCallCheck(this, BufferTimeSubscriber);

	        _Subscriber.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	        this.buffers = [];
	        var buffer = this.openBuffer();
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            this.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: this, buffer: buffer }));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler }));
	        } else {
	            this.add(scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, { subscriber: this, buffer: buffer, bufferTimeSpan: bufferTimeSpan }));
	        }
	    }

	    BufferTimeSubscriber.prototype._next = function _next(value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };

	    BufferTimeSubscriber.prototype._error = function _error(err) {
	        this.buffers.length = 0;
	        this.destination.error(err);
	    };

	    BufferTimeSubscriber.prototype._complete = function _complete() {
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            this.destination.next(buffers.shift());
	        }
	        this.destination.complete();
	    };

	    BufferTimeSubscriber.prototype.openBuffer = function openBuffer() {
	        var buffer = [];
	        this.buffers.push(buffer);
	        return buffer;
	    };

	    BufferTimeSubscriber.prototype.closeBuffer = function closeBuffer(buffer) {
	        this.destination.next(buffer);
	        var buffers = this.buffers;
	        buffers.splice(buffers.indexOf(buffer), 1);
	    };

	    return BufferTimeSubscriber;
	})(_Subscriber3['default']);

	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevBuffer = state.buffer;
	    if (prevBuffer) {
	        subscriber.closeBuffer(prevBuffer);
	    }
	    state.buffer = subscriber.openBuffer();
	    this.schedule(state, state.bufferTimeSpan);
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval;
	    var bufferTimeSpan = state.bufferTimeSpan;
	    var subscriber = state.subscriber;
	    var scheduler = state.scheduler;

	    var buffer = subscriber.openBuffer();
	    var action = this;
	    action.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, buffer: buffer }));
	    action.schedule(state, bufferCreationInterval);
	}
	function dispatchBufferClose(_ref) {
	    var subscriber = _ref.subscriber;
	    var buffer = _ref.buffer;

	    subscriber.closeBuffer(buffer);
	}
	module.exports = exports['default'];

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferToggle;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber4 = __webpack_require__(4);

	var _Subscriber5 = _interopRequireDefault(_Subscriber4);

	var _Subscription = __webpack_require__(8);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function bufferToggle(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}

	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        _classCallCheck(this, BufferToggleOperator);

	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }

	    BufferToggleOperator.prototype.call = function call(subscriber) {
	        return new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector);
	    };

	    return BufferToggleOperator;
	})();

	var BufferToggleSubscriber = (function (_Subscriber) {
	    _inherits(BufferToggleSubscriber, _Subscriber);

	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _classCallCheck(this, BufferToggleSubscriber);

	        _Subscriber.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.buffers = [];
	        this.add(this.openings._subscribe(new BufferToggleOpeningsSubscriber(this)));
	    }

	    BufferToggleSubscriber.prototype._next = function _next(value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };

	    BufferToggleSubscriber.prototype._error = function _error(err) {
	        this.buffers = null;
	        this.destination.error(err);
	    };

	    BufferToggleSubscriber.prototype._complete = function _complete() {
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            this.destination.next(buffers.shift());
	        }
	        this.destination.complete();
	    };

	    BufferToggleSubscriber.prototype.openBuffer = function openBuffer(value) {
	        var closingSelector = this.closingSelector;
	        var buffers = this.buffers;
	        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.buffers = null;
	            this.destination.error(err);
	        } else {
	            var buffer = [];
	            var context = {
	                buffer: buffer,
	                subscription: new _Subscription2['default']()
	            };
	            buffers.push(buffer);
	            this.add(context.subscription.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this, context))));
	        }
	    };

	    BufferToggleSubscriber.prototype.closeBuffer = function closeBuffer(context) {
	        var buffer = context.buffer;
	        var subscription = context.subscription;

	        var buffers = this.buffers;
	        this.destination.next(buffer);
	        buffers.splice(buffers.indexOf(buffer), 1);
	        this.remove(subscription);
	        subscription.unsubscribe();
	    };

	    return BufferToggleSubscriber;
	})(_Subscriber5['default']);

	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

	    function BufferClosingNotifierSubscriber(parent, context) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.context = context;
	    }

	    BufferClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.closeBuffer(this.context);
	    };

	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferClosingNotifierSubscriber;
	})(_Subscriber5['default']);

	var BufferToggleOpeningsSubscriber = (function (_Subscriber3) {
	    _inherits(BufferToggleOpeningsSubscriber, _Subscriber3);

	    function BufferToggleOpeningsSubscriber(parent) {
	        _classCallCheck(this, BufferToggleOpeningsSubscriber);

	        _Subscriber3.call(this, null);
	        this.parent = parent;
	    }

	    BufferToggleOpeningsSubscriber.prototype._next = function _next(value) {
	        this.parent.openBuffer(value);
	    };

	    BufferToggleOpeningsSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferToggleOpeningsSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferToggleOpeningsSubscriber;
	})(_Subscriber5['default']);

	module.exports = exports['default'];

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferWhen;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilTryCatch = __webpack_require__(33);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(34);

	function bufferWhen(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}

	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        _classCallCheck(this, BufferWhenOperator);

	        this.closingSelector = closingSelector;
	    }

	    BufferWhenOperator.prototype.call = function call(subscriber) {
	        return new BufferWhenSubscriber(subscriber, this.closingSelector);
	    };

	    return BufferWhenOperator;
	})();

	var BufferWhenSubscriber = (function (_Subscriber) {
	    _inherits(BufferWhenSubscriber, _Subscriber);

	    function BufferWhenSubscriber(destination, closingSelector) {
	        _classCallCheck(this, BufferWhenSubscriber);

	        _Subscriber.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.openBuffer();
	    }

	    BufferWhenSubscriber.prototype._next = function _next(value) {
	        this.buffer.push(value);
	    };

	    BufferWhenSubscriber.prototype._error = function _error(err) {
	        this.buffer = null;
	        this.destination.error(err);
	    };

	    BufferWhenSubscriber.prototype._complete = function _complete() {
	        var buffer = this.buffer;
	        this.destination.next(buffer);
	        this.buffer = null;
	        this.destination.complete();
	    };

	    BufferWhenSubscriber.prototype.openBuffer = function openBuffer() {
	        var prevClosingNotification = this.closingNotification;
	        if (prevClosingNotification) {
	            this.remove(prevClosingNotification);
	            prevClosingNotification.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.buffer = null;
	            this.destination.error(err);
	        } else {
	            this.add(this.closingNotification = closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
	        }
	    };

	    return BufferWhenSubscriber;
	})(_Subscriber4['default']);

	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

	    function BufferClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    BufferClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openBuffer();
	    };

	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = sample;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(4);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	function sample(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}

	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        _classCallCheck(this, SampleOperator);

	        this.notifier = notifier;
	    }

	    SampleOperator.prototype.call = function call(subscriber) {
	        return new SampleSubscriber(subscriber, this.notifier);
	    };

	    return SampleOperator;
	})();

	var SampleSubscriber = (function (_Subscriber) {
	    _inherits(SampleSubscriber, _Subscriber);

	    function SampleSubscriber(destination, notifier) {
	        _classCallCheck(this, SampleSubscriber);

	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.hasValue = false;
	        this.add(notifier._subscribe(new SampleNoficationSubscriber(this)));
	    }

	    SampleSubscriber.prototype._next = function _next(value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };

	    SampleSubscriber.prototype.notifyNext = function notifyNext() {
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	        }
	    };

	    return SampleSubscriber;
	})(_Subscriber4['default']);

	var SampleNoficationSubscriber = (function (_Subscriber2) {
	    _inherits(SampleNoficationSubscriber, _Subscriber2);

	    function SampleNoficationSubscriber(parent) {
	        _classCallCheck(this, SampleNoficationSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    SampleNoficationSubscriber.prototype._next = function _next() {
	        this.parent.notifyNext();
	    };

	    SampleNoficationSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    SampleNoficationSubscriber.prototype._complete = function _complete() {
	        //noop
	    };

	    return SampleNoficationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = sampleTime;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(4);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(20);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function sampleTime(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	    return this.lift(new SampleTimeOperator(delay, scheduler));
	}

	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(delay, scheduler) {
	        _classCallCheck(this, SampleTimeOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    SampleTimeOperator.prototype.call = function call(subscriber) {
	        return new SampleTimeSubscriber(subscriber, this.delay, this.scheduler);
	    };

	    return SampleTimeOperator;
	})();

	var SampleTimeSubscriber = (function (_Subscriber) {
	    _inherits(SampleTimeSubscriber, _Subscriber);

	    function SampleTimeSubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, SampleTimeSubscriber);

	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, delay, { subscriber: this, delay: delay }));
	    }

	    SampleTimeSubscriber.prototype._next = function _next(value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };

	    SampleTimeSubscriber.prototype.notifyNext = function notifyNext() {
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	        }
	    };

	    return SampleTimeSubscriber;
	})(_Subscriber3['default']);

	function dispatchNotification(state) {
	    var subscriber = state.subscriber;
	    var delay = state.delay;

	    subscriber.notifyNext();
	    this.schedule(state, delay);
	}
	module.exports = exports['default'];

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;var require;var require;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
	(function (global){
	'use strict';

	var core = require('../core');
	var microtask = require('../microtask');
	var browserPatch = require('../patch/browser');
	var es6Promise = require('es6-promise');

	if (global.Zone) {
	  console.warn('Zone already exported on window the object!');
	}

	global.Zone = microtask.addMicrotaskSupport(core.Zone);
	global.zone = new global.Zone();

	// Monkey path he Promise implementation to add support for microtasks
	global.Promise = es6Promise.Promise;

	browserPatch.apply();

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../core":2,"../microtask":3,"../patch/browser":4,"es6-promise":15}],2:[function(require,module,exports){
	(function (global){
	'use strict';

	function Zone(parentZone, data) {
	  var zone = (arguments.length) ? Object.create(parentZone) : this;

	  zone.parent = parentZone || null;

	  Object.keys(data || {}).forEach(function(property) {

	    var _property = property.substr(1);

	    // augment the new zone with a hook decorates the parent's hook
	    if (property[0] === '$') {
	      zone[_property] = data[property](parentZone[_property] || function () {});

	    // augment the new zone with a hook that runs after the parent's hook
	    } else if (property[0] === '+') {
	      if (parentZone[_property]) {
	        zone[_property] = function () {
	          var result = parentZone[_property].apply(this, arguments);
	          data[property].apply(this, arguments);
	          return result;
	        };
	      } else {
	        zone[_property] = data[property];
	      }

	    // augment the new zone with a hook that runs before the parent's hook
	    } else if (property[0] === '-') {
	      if (parentZone[_property]) {
	        zone[_property] = function () {
	          data[property].apply(this, arguments);
	          return parentZone[_property].apply(this, arguments);
	        };
	      } else {
	        zone[_property] = data[property];
	      }

	    // set the new zone's hook (replacing the parent zone's)
	    } else {
	      zone[property] = (typeof data[property] === 'object') ?
	                        JSON.parse(JSON.stringify(data[property])) :
	                        data[property];
	    }
	  });

	  zone.$id = Zone.nextId++;

	  return zone;
	}

	Zone.prototype = {
	  constructor: Zone,

	  fork: function (locals) {
	    this.onZoneCreated();
	    return new Zone(this, locals);
	  },

	  bind: function (fn, skipEnqueue) {
	    if (typeof fn !== 'function') {
	      throw new Error('Expecting function got: ' + fn);
	    }
	    skipEnqueue || this.enqueueTask(fn);
	    var zone = this.isRootZone() ? this : this.fork();
	    return function zoneBoundFn() {
	      return zone.run(fn, this, arguments);
	    };
	  },

	  bindOnce: function (fn) {
	    var boundZone = this;
	    return this.bind(function () {
	      var result = fn.apply(this, arguments);
	      boundZone.dequeueTask(fn);
	      return result;
	    });
	  },

	  isRootZone: function() {
	    return this.parent === null;
	  },

	  run: function run (fn, applyTo, applyWith) {
	    applyWith = applyWith || [];

	    var oldZone = global.zone;

	    // MAKE THIS ZONE THE CURRENT ZONE
	    global.zone = this;

	    try {
	      this.beforeTask();
	      return fn.apply(applyTo, applyWith);
	    } catch (e) {
	      if (this.onError) {
	        this.onError(e);
	      } else {
	        throw e;
	      }
	    } finally {
	      this.afterTask();
	      // REVERT THE CURRENT ZONE BACK TO THE ORIGINAL ZONE
	      global.zone = oldZone;
	    }
	  },

	  // onError is used to override error handling.
	  // When a custom error handler is provided, it should most probably rethrow the exception
	  // not to break the expected control flow:
	  //
	  // `promise.then(fnThatThrows).catch(fn);`
	  //
	  // When this code is executed in a zone with a custom onError handler that doesn't rethrow, the
	  // `.catch()` branch will not be taken as the `fnThatThrows` exception will be swallowed by the
	  // handler.
	  onError: null,
	  beforeTask: function () {},
	  onZoneCreated: function () {},
	  afterTask: function () {},
	  enqueueTask: function () {},
	  dequeueTask: function () {}
	};

	// Root zone ID === 1
	Zone.nextId = 1;

	Zone.bindPromiseFn = require('./patch/promise').bindPromiseFn;

	module.exports = {
	  Zone: Zone
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./patch/promise":10}],3:[function(require,module,exports){
	(function (global){
	'use strict';

	var es6Promise = require('es6-promise').Promise;

	// es6-promise asap should schedule microtasks via zone.scheduleMicrotask so that any
	// user defined hooks are triggered
	es6Promise._setAsap(function(fn, arg) {
	  global.zone.scheduleMicrotask(function() {
	    fn(arg);
	  });
	});

	// The default implementation of scheduleMicrotask use the original es6-promise implementation
	// to schedule a microtask
	function scheduleMicrotask(fn) {
	  es6Promise._asap(this.bind(fn));
	}

	function addMicrotaskSupport(zoneClass) {
	  zoneClass.prototype.scheduleMicrotask = scheduleMicrotask;
	  return zoneClass;
	}

	module.exports = {
	  addMicrotaskSupport: addMicrotaskSupport
	};

	// TODO(vicb): Create a benchmark for the different methods & the usage of the queue
	// see https://github.com/angular/zone.js/issues/97

	var hasNativePromise = typeof Promise !== "undefined" &&
	                       Promise.toString().indexOf("[native code]") !== -1;

	var isFirefox = global.navigator &&
	                global.navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

	// TODO(vicb): remove '!isFirefox' when the bug gets fixed:
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1162013
	if (hasNativePromise && !isFirefox) {
	  // When available use a native Promise to schedule microtasks.
	  // When not available, es6-promise fallback will be used
	  var resolvedPromise = Promise.resolve();
	  es6Promise._setScheduler(function(fn) {
	    resolvedPromise.then(fn);
	  });
	}


	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"es6-promise":15}],4:[function(require,module,exports){
	(function (global){
	'use strict';

	var fnPatch = require('./functions');
	var promisePatch = require('./promise');
	var mutationObserverPatch = require('./mutation-observer');
	var definePropertyPatch = require('./define-property');
	var registerElementPatch = require('./register-element');
	var webSocketPatch = require('./websocket');
	var eventTargetPatch = require('./event-target');
	var propertyDescriptorPatch = require('./property-descriptor');
	var geolocationPatch = require('./geolocation');

	function apply() {
	  fnPatch.patchSetClearFunction(global, [
	    'timeout',
	    'interval',
	    'immediate'
	  ]);

	  fnPatch.patchRequestAnimationFrame(global, [
	    'requestAnimationFrame',
	    'mozRequestAnimationFrame',
	    'webkitRequestAnimationFrame'
	  ]);

	  fnPatch.patchFunction(global, [
	    'alert',
	    'prompt'
	  ]);

	  eventTargetPatch.apply();

	  propertyDescriptorPatch.apply();

	  promisePatch.apply();

	  mutationObserverPatch.patchClass('MutationObserver');
	  mutationObserverPatch.patchClass('WebKitMutationObserver');

	  definePropertyPatch.apply();

	  registerElementPatch.apply();

	  geolocationPatch.apply();
	}

	module.exports = {
	  apply: apply
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"./define-property":5,"./event-target":6,"./functions":7,"./geolocation":8,"./mutation-observer":9,"./promise":10,"./property-descriptor":11,"./register-element":12,"./websocket":13}],5:[function(require,module,exports){
	'use strict';

	// might need similar for object.freeze
	// i regret nothing

	var _defineProperty = Object.defineProperty;
	var _getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var _create = Object.create;

	function apply() {
	  Object.defineProperty = function (obj, prop, desc) {
	    if (isUnconfigurable(obj, prop)) {
	      throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
	    }
	    if (prop !== 'prototype') {
	      desc = rewriteDescriptor(obj, prop, desc);
	    }
	    return _defineProperty(obj, prop, desc);
	  };

	  Object.defineProperties = function (obj, props) {
	    Object.keys(props).forEach(function (prop) {
	      Object.defineProperty(obj, prop, props[prop]);
	    });
	    return obj;
	  };

	  Object.create = function (obj, proto) {
	    if (typeof proto === 'object') {
	      Object.keys(proto).forEach(function (prop) {
	        proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
	      });
	    }
	    return _create(obj, proto);
	  };

	  Object.getOwnPropertyDescriptor = function (obj, prop) {
	    var desc = _getOwnPropertyDescriptor(obj, prop);
	    if (isUnconfigurable(obj, prop)) {
	      desc.configurable = false;
	    }
	    return desc;
	  };
	};

	function _redefineProperty(obj, prop, desc) {
	  desc = rewriteDescriptor(obj, prop, desc);
	  return _defineProperty(obj, prop, desc);
	};

	function isUnconfigurable (obj, prop) {
	  return obj && obj.__unconfigurables && obj.__unconfigurables[prop];
	}

	function rewriteDescriptor (obj, prop, desc) {
	  desc.configurable = true;
	  if (!desc.configurable) {
	    if (!obj.__unconfigurables) {
	      _defineProperty(obj, '__unconfigurables', { writable: true, value: {} });
	    }
	    obj.__unconfigurables[prop] = true;
	  }
	  return desc;
	}

	module.exports = {
	  apply: apply,
	  _redefineProperty: _redefineProperty
	};



	},{}],6:[function(require,module,exports){
	(function (global){
	'use strict';

	var utils = require('../utils');

	function apply() {
	  // patched properties depend on addEventListener, so this needs to come first
	  if (global.EventTarget) {
	    utils.patchEventTargetMethods(global.EventTarget.prototype);

	  // Note: EventTarget is not available in all browsers,
	  // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
	  } else {
	    var apis = [ 'ApplicationCache',
	      'EventSource',
	      'FileReader',
	      'InputMethodContext',
	      'MediaController',
	      'MessagePort',
	      'Node',
	      'Performance',
	      'SVGElementInstance',
	      'SharedWorker',
	      'TextTrack',
	      'TextTrackCue',
	      'TextTrackList',
	      'WebKitNamedFlow',
	      'Window',
	      'Worker',
	      'WorkerGlobalScope',
	      'XMLHttpRequest',
	      'XMLHttpRequestEventTarget',
	      'XMLHttpRequestUpload'
	    ];

	    apis.forEach(function(thing) {
	      global[thing] && utils.patchEventTargetMethods(global[thing].prototype);
	    });
	  }
	}

	module.exports = {
	  apply: apply
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14}],7:[function(require,module,exports){
	(function (global){
	'use strict';

	var utils = require('../utils');

	function patchSetClearFunction(obj, fnNames) {
	  fnNames.map(function (name) {
	    return name[0].toUpperCase() + name.substr(1);
	  }).forEach(function (name) {
	    var setName = 'set' + name;
	    var delegate = obj[setName];

	    if (delegate) {
	      var clearName = 'clear' + name;
	      var ids = {};

	      var bindArgs = setName === 'setInterval' ? utils.bindArguments : utils.bindArgumentsOnce;

	      global.zone[setName] = function (fn) {
	        var id, fnRef = fn;
	        arguments[0] = function () {
	          delete ids[id];
	          return fnRef.apply(this, arguments);
	        };
	        var args = bindArgs(arguments);
	        id = delegate.apply(obj, args);
	        ids[id] = true;
	        return id;
	      };

	      obj[setName] = function () {
	        return global.zone[setName].apply(this, arguments);
	      };

	      var clearDelegate = obj[clearName];

	      global.zone[clearName] = function (id) {
	        if (ids[id]) {
	          delete ids[id];
	          global.zone.dequeueTask();
	        }
	        return clearDelegate.apply(this, arguments);
	      };

	      obj[clearName] = function () {
	        return global.zone[clearName].apply(this, arguments);
	      };
	    }
	  });
	};


	/**
	 * requestAnimationFrame is typically recursively called from within the callback function
	 * that it executes.  To handle this case, only fork a zone if this is executed
	 * within the root zone.
	 */
	function patchRequestAnimationFrame(obj, fnNames) {
	  fnNames.forEach(function (name) {
	    var delegate = obj[name];
	    if (delegate) {
	      global.zone[name] = function (fn) {
	        var callZone = global.zone.isRootZone() ? global.zone.fork() : global.zone;
	        if (fn) {
	          arguments[0] = function () {
	            return callZone.run(fn, arguments);
	          };
	        }
	        return delegate.apply(obj, arguments);
	      };

	      obj[name] = function () {
	        return global.zone[name].apply(this, arguments);
	      };
	    }
	  });
	};

	function patchSetFunction(obj, fnNames) {
	  fnNames.forEach(function (name) {
	    var delegate = obj[name];

	    if (delegate) {
	      global.zone[name] = function (fn) {
	        var fnRef = fn;
	        arguments[0] = function () {
	          return fnRef.apply(this, arguments);
	        };
	        var args = utils.bindArgumentsOnce(arguments);
	        return delegate.apply(obj, args);
	      };

	      obj[name] = function () {
	        return zone[name].apply(this, arguments);
	      };
	    }
	  });
	};

	function patchFunction(obj, fnNames) {
	  fnNames.forEach(function (name) {
	    var delegate = obj[name];
	    global.zone[name] = function () {
	      return delegate.apply(obj, arguments);
	    };

	    obj[name] = function () {
	      return global.zone[name].apply(this, arguments);
	    };
	  });
	};


	module.exports = {
	  patchSetClearFunction: patchSetClearFunction,
	  patchSetFunction: patchSetFunction,
	  patchRequestAnimationFrame: patchRequestAnimationFrame,
	  patchFunction: patchFunction
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14}],8:[function(require,module,exports){
	(function (global){
	'use strict';

	var utils = require('../utils');

	function apply() {
	  if (global.navigator && global.navigator.geolocation) {
	    utils.patchPrototype(global.navigator.geolocation, [
	      'getCurrentPosition',
	      'watchPosition'
	    ]);
	  }
	}

	module.exports = {
	  apply: apply
	}

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14}],9:[function(require,module,exports){
	(function (global){
	'use strict';

	// wrap some native API on `window`
	function patchClass(className) {
	  var OriginalClass = global[className];
	  if (!OriginalClass) return;

	  global[className] = function (fn) {
	    this._o = new OriginalClass(global.zone.bind(fn, true));
	    // Remember where the class was instantiate to execute the enqueueTask and dequeueTask hooks
	    this._creationZone = global.zone;
	  };

	  var instance = new OriginalClass(function () {});

	  global[className].prototype.disconnect = function () {
	    var result = this._o.disconnect.apply(this._o, arguments);
	    if (this._active) {
	      this._creationZone.dequeueTask();
	      this._active = false;
	    }
	    return result;
	  };

	  global[className].prototype.observe = function () {
	    if (!this._active) {
	      this._creationZone.enqueueTask();
	      this._active = true;
	    }
	    return this._o.observe.apply(this._o, arguments);
	  };

	  var prop;
	  for (prop in instance) {
	    (function (prop) {
	      if (typeof global[className].prototype !== undefined) {
	        return;
	      }
	      if (typeof instance[prop] === 'function') {
	        global[className].prototype[prop] = function () {
	          return this._o[prop].apply(this._o, arguments);
	        };
	      } else {
	        Object.defineProperty(global[className].prototype, prop, {
	          set: function (fn) {
	            if (typeof fn === 'function') {
	              this._o[prop] = global.zone.bind(fn);
	            } else {
	              this._o[prop] = fn;
	            }
	          },
	          get: function () {
	            return this._o[prop];
	          }
	        });
	      }
	    }(prop));
	  }
	};

	module.exports = {
	  patchClass: patchClass
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],10:[function(require,module,exports){
	(function (global){
	'use strict';

	var utils = require('../utils');

	/*
	 * Patches a function that returns a Promise-like instance.
	 *
	 * This function must be used when either:
	 * - Native Promises are not available,
	 * - The function returns a Promise-like object.
	 *
	 * This is required because zones rely on a Promise monkey patch that could not be applied when
	 * Promise is not natively available or when the returned object is not an instance of Promise.
	 *
	 * Note that calling `bindPromiseFn` on a function that returns a native Promise will also work
	 * with minimal overhead.
	 *
	 * ```
	 * var boundFunction = bindPromiseFn(FunctionReturningAPromise);
	 *
	 * boundFunction.then(successHandler, errorHandler);
	 * ```
	 */
	var bindPromiseFn;

	if (global.Promise) {
	  bindPromiseFn = function (delegate) {
	    return function() {
	      var delegatePromise = delegate.apply(this, arguments);

	      // if the delegate returned an instance of Promise, forward it.
	      if (delegatePromise instanceof Promise) {
	        return delegatePromise;
	      }

	      // Otherwise wrap the Promise-like in a global Promise
	      return new Promise(function(resolve, reject) {
	        delegatePromise.then(resolve, reject);
	      });
	    };
	  };
	} else {
	  bindPromiseFn = function (delegate) {
	    return function () {
	      return _patchThenable(delegate.apply(this, arguments));
	    };
	  };
	}


	function _patchPromiseFnsOnObject(objectPath, fnNames) {
	  var obj = global;

	  var exists = objectPath.every(function (segment) {
	    obj = obj[segment];
	    return obj;
	  });

	  if (!exists) {
	    return;
	  }

	  fnNames.forEach(function (name) {
	    var fn = obj[name];
	    if (fn) {
	      obj[name] = bindPromiseFn(fn);
	    }
	  });
	}

	function _patchThenable(thenable) {
	  var then = thenable.then;
	  thenable.then = function () {
	    var args = utils.bindArguments(arguments);
	    var nextThenable = then.apply(thenable, args);
	    return _patchThenable(nextThenable);
	  };

	  var ocatch = thenable.catch;
	  thenable.catch = function () {
	    var args = utils.bindArguments(arguments);
	    var nextThenable = ocatch.apply(thenable, args);
	    return _patchThenable(nextThenable);
	  };

	  return thenable;
	}


	function apply() {
	  // Patch .then() and .catch() on native Promises to execute callbacks in the zone where
	  // those functions are called.
	  if (global.Promise) {
	    utils.patchPrototype(Promise.prototype, [
	      'then',
	      'catch'
	    ]);

	    // Patch browser APIs that return a Promise
	    var patchFns = [
	      // fetch
	      [[], ['fetch']],
	      [['Response', 'prototype'], ['arrayBuffer', 'blob', 'json', 'text']]
	    ];

	    patchFns.forEach(function(objPathAndFns) {
	      _patchPromiseFnsOnObject(objPathAndFns[0], objPathAndFns[1]);
	    });
	  }
	}

	module.exports = {
	  apply: apply,
	  bindPromiseFn: bindPromiseFn
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14}],11:[function(require,module,exports){
	(function (global){
	'use strict';

	var webSocketPatch = require('./websocket');
	var utils = require('../utils');

	var eventNames = 'copy cut paste abort blur focus canplay canplaythrough change click contextmenu dblclick drag dragend dragenter dragleave dragover dragstart drop durationchange emptied ended input invalid keydown keypress keyup load loadeddata loadedmetadata loadstart message mousedown mouseenter mouseleave mousemove mouseout mouseover mouseup pause play playing progress ratechange reset scroll seeked seeking select show stalled submit suspend timeupdate volumechange waiting mozfullscreenchange mozfullscreenerror mozpointerlockchange mozpointerlockerror error webglcontextrestored webglcontextlost webglcontextcreationerror'.split(' ');

	function apply() {
	  if (utils.isWebWorker()){
	    // on WebWorker so don't apply patch
	    return;
	  }

	  var supportsWebSocket = typeof WebSocket !== 'undefined';
	  if (canPatchViaPropertyDescriptor()) {
	    // for browsers that we can patch the descriptor:  Chrome & Firefox
	    var onEventNames = eventNames.map(function (property) {
	      return 'on' + property;
	    });
	    utils.patchProperties(HTMLElement.prototype, onEventNames);
	    utils.patchProperties(XMLHttpRequest.prototype);
	    if (supportsWebSocket) {
	      utils.patchProperties(WebSocket.prototype);
	    }
	  } else {
	    // Safari, Android browsers (Jelly Bean)
	    patchViaCapturingAllTheEvents();
	    utils.patchClass('XMLHttpRequest');
	    if (supportsWebSocket) {
	      webSocketPatch.apply();
	    }
	  }
	}

	function canPatchViaPropertyDescriptor() {
	  if (!Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {
	    // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
	    // IDL interface attributes are not configurable
	    var desc = Object.getOwnPropertyDescriptor(Element.prototype, 'onclick');
	    if (desc && !desc.configurable) return false;
	  }

	  Object.defineProperty(HTMLElement.prototype, 'onclick', {
	    get: function () {
	      return true;
	    }
	  });
	  var elt = document.createElement('div');
	  var result = !!elt.onclick;
	  Object.defineProperty(HTMLElement.prototype, 'onclick', {});
	  return result;
	};

	// Whenever any event fires, we check the event target and all parents
	// for `onwhatever` properties and replace them with zone-bound functions
	// - Chrome (for now)
	function patchViaCapturingAllTheEvents() {
	  eventNames.forEach(function (property) {
	    var onproperty = 'on' + property;
	    document.addEventListener(property, function (event) {
	      var elt = event.target, bound;
	      while (elt) {
	        if (elt[onproperty] && !elt[onproperty]._unbound) {
	          bound = global.zone.bind(elt[onproperty]);
	          bound._unbound = elt[onproperty];
	          elt[onproperty] = bound;
	        }
	        elt = elt.parentElement;
	      }
	    }, true);
	  });
	};

	module.exports = {
	  apply: apply
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14,"./websocket":13}],12:[function(require,module,exports){
	(function (global){
	'use strict';

	var _redefineProperty = require('./define-property')._redefineProperty;
	var utils = require("../utils");

	function apply() {
	  if (utils.isWebWorker() || !('registerElement' in global.document)) {
	    return;
	  }

	  var _registerElement = document.registerElement;
	  var callbacks = [
	    'createdCallback',
	    'attachedCallback',
	    'detachedCallback',
	    'attributeChangedCallback'
	  ];

	  document.registerElement = function (name, opts) {
	    if (opts && opts.prototype) {
	      callbacks.forEach(function (callback) {
	        if (opts.prototype.hasOwnProperty(callback)) {
	          var descriptor = Object.getOwnPropertyDescriptor(opts.prototype, callback);
	          if (descriptor && descriptor.value) {
	            descriptor.value = global.zone.bind(descriptor.value);
	            _redefineProperty(opts.prototype, callback, descriptor);
	          } else {
	            opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);
	          }
	        } else if (opts.prototype[callback]) {
	          opts.prototype[callback] = global.zone.bind(opts.prototype[callback]);
	        }
	      });
	    }

	    return _registerElement.apply(document, [name, opts]);
	  };
	}

	module.exports = {
	  apply: apply
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14,"./define-property":5}],13:[function(require,module,exports){
	(function (global){
	'use strict';

	var utils = require('../utils');

	// we have to patch the instance since the proto is non-configurable
	function apply() {
	  var WS = global.WebSocket;
	  utils.patchEventTargetMethods(WS.prototype);
	  global.WebSocket = function(a, b) {
	    var socket = arguments.length > 1 ? new WS(a, b) : new WS(a);
	    var proxySocket;

	    // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance
	    var onmessageDesc = Object.getOwnPropertyDescriptor(socket, 'onmessage');
	    if (onmessageDesc && onmessageDesc.configurable === false) {
	      proxySocket = Object.create(socket);
	      ['addEventListener', 'removeEventListener', 'send', 'close'].forEach(function(propName) {
	        proxySocket[propName] = function() {
	          return socket[propName].apply(socket, arguments);
	        };
	      });
	    } else {
	      // we can patch the real socket
	      proxySocket = socket;
	    }

	    utils.patchProperties(proxySocket, ['onclose', 'onerror', 'onmessage', 'onopen']);

	    return proxySocket;
	  };
	}

	module.exports = {
	  apply: apply
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{"../utils":14}],14:[function(require,module,exports){
	(function (global){
	'use strict';

	function bindArguments(args) {
	  for (var i = args.length - 1; i >= 0; i--) {
	    if (typeof args[i] === 'function') {
	      args[i] = global.zone.bind(args[i]);
	    }
	  }
	  return args;
	};

	function bindArgumentsOnce(args) {
	  for (var i = args.length - 1; i >= 0; i--) {
	    if (typeof args[i] === 'function') {
	      args[i] = global.zone.bindOnce(args[i]);
	    }
	  }
	  return args;
	};

	function patchPrototype(obj, fnNames) {
	  fnNames.forEach(function (name) {
	    var delegate = obj[name];
	    if (delegate) {
	      obj[name] = function () {
	        return delegate.apply(this, bindArguments(arguments));
	      };
	    }
	  });
	};

	function isWebWorker() {
	  return (typeof document === "undefined");
	}

	function patchProperty(obj, prop) {
	  var desc = Object.getOwnPropertyDescriptor(obj, prop) || {
	    enumerable: true,
	    configurable: true
	  };

	  // A property descriptor cannot have getter/setter and be writable
	  // deleting the writable and value properties avoids this error:
	  //
	  // TypeError: property descriptors must not specify a value or be writable when a
	  // getter or setter has been specified
	  delete desc.writable;
	  delete desc.value;

	  // substr(2) cuz 'onclick' -> 'click', etc
	  var eventName = prop.substr(2);
	  var _prop = '_' + prop;

	  desc.set = function (fn) {
	    if (this[_prop]) {
	      this.removeEventListener(eventName, this[_prop]);
	    }

	    if (typeof fn === 'function') {
	      this[_prop] = fn;
	      this.addEventListener(eventName, fn, false);
	    } else {
	      this[_prop] = null;
	    }
	  };

	  desc.get = function () {
	    return this[_prop];
	  };

	  Object.defineProperty(obj, prop, desc);
	};

	function patchProperties(obj, properties) {

	  (properties || (function () {
	      var props = [];
	      for (var prop in obj) {
	        props.push(prop);
	      }
	      return props;
	    }()).
	    filter(function (propertyName) {
	      return propertyName.substr(0,2) === 'on';
	    })).
	    forEach(function (eventName) {
	      patchProperty(obj, eventName);
	    });
	};

	function patchEventTargetMethods(obj) {
	  var addDelegate = obj.addEventListener;
	  obj.addEventListener = function (eventName, handler) {
	    var fn;
	    //Ignore special listeners of IE11 & Edge dev tools, see https://github.com/angular/zone.js/issues/150
	    if (handler.toString() !== "[object FunctionWrapper]") {
	      if (handler.handleEvent) {
	        // Have to pass in 'handler' reference as an argument here, otherwise it gets clobbered in
	        // IE9 by the arguments[1] assignment at end of this function.
	        fn = (function(handler) {
	          return function() {
	            handler.handleEvent.apply(handler, arguments);
	          };
	        })(handler);
	      } else {
	        fn = handler;
	      }

	      handler._fn = fn;
	      handler._bound = handler._bound || {};
	      arguments[1] = handler._bound[eventName] = zone.bind(fn);
	    }
	    return addDelegate.apply(this, arguments);
	  };

	  var removeDelegate = obj.removeEventListener;
	  obj.removeEventListener = function (eventName, handler) {
	    if(handler._bound && handler._bound[eventName]) {
	      var _bound = handler._bound;
	      
	      arguments[1] = _bound[eventName];
	      delete _bound[eventName];
	    }
	    var result = removeDelegate.apply(this, arguments);
	    global.zone.dequeueTask(handler._fn);
	    return result;
	  };
	};

	// wrap some native API on `window`
	function patchClass(className) {
	  var OriginalClass = global[className];
	  if (!OriginalClass) return;

	  global[className] = function () {
	    var a = bindArguments(arguments);
	    switch (a.length) {
	      case 0: this._o = new OriginalClass(); break;
	      case 1: this._o = new OriginalClass(a[0]); break;
	      case 2: this._o = new OriginalClass(a[0], a[1]); break;
	      case 3: this._o = new OriginalClass(a[0], a[1], a[2]); break;
	      case 4: this._o = new OriginalClass(a[0], a[1], a[2], a[3]); break;
	      default: throw new Error('what are you even doing?');
	    }
	  };

	  var instance = new OriginalClass();

	  var prop;
	  for (prop in instance) {
	    (function (prop) {
	      if (typeof instance[prop] === 'function') {
	        global[className].prototype[prop] = function () {
	          return this._o[prop].apply(this._o, arguments);
	        };
	      } else {
	        Object.defineProperty(global[className].prototype, prop, {
	          set: function (fn) {
	            if (typeof fn === 'function') {
	              this._o[prop] = global.zone.bind(fn);
	            } else {
	              this._o[prop] = fn;
	            }
	          },
	          get: function () {
	            return this._o[prop];
	          }
	        });
	      }
	    }(prop));
	  }

	  for (prop in OriginalClass) {
	    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
	      global[className][prop] = OriginalClass[prop];
	    }
	  }
	};

	module.exports = {
	  bindArguments: bindArguments,
	  bindArgumentsOnce: bindArgumentsOnce,
	  patchPrototype: patchPrototype,
	  patchProperty: patchProperty,
	  patchProperties: patchProperties,
	  patchEventTargetMethods: patchEventTargetMethods,
	  patchClass: patchClass,
	  isWebWorker: isWebWorker
	};

	}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}],15:[function(require,module,exports){
	(function (process,global){
	/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
	 * @version   2.3.0
	 */

	(function() {
	    "use strict";
	    function lib$es6$promise$utils$$objectOrFunction(x) {
	      return typeof x === 'function' || (typeof x === 'object' && x !== null);
	    }

	    function lib$es6$promise$utils$$isFunction(x) {
	      return typeof x === 'function';
	    }

	    function lib$es6$promise$utils$$isMaybeThenable(x) {
	      return typeof x === 'object' && x !== null;
	    }

	    var lib$es6$promise$utils$$_isArray;
	    if (!Array.isArray) {
	      lib$es6$promise$utils$$_isArray = function (x) {
	        return Object.prototype.toString.call(x) === '[object Array]';
	      };
	    } else {
	      lib$es6$promise$utils$$_isArray = Array.isArray;
	    }

	    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
	    var lib$es6$promise$asap$$len = 0;
	    var lib$es6$promise$asap$$toString = {}.toString;
	    var lib$es6$promise$asap$$vertxNext;
	    var lib$es6$promise$asap$$customSchedulerFn;

	    var lib$es6$promise$asap$$asap = function asap(callback, arg) {
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
	      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
	      lib$es6$promise$asap$$len += 2;
	      if (lib$es6$promise$asap$$len === 2) {
	        // If len is 2, that means that we need to schedule an async flush.
	        // If additional callbacks are queued before the queue is flushed, they
	        // will be processed by this flush that we are scheduling.
	        if (lib$es6$promise$asap$$customSchedulerFn) {
	          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
	        } else {
	          lib$es6$promise$asap$$scheduleFlush();
	        }
	      }
	    }

	    function lib$es6$promise$asap$$setScheduler(scheduleFn) {
	      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
	    }

	    function lib$es6$promise$asap$$setAsap(asapFn) {
	      lib$es6$promise$asap$$asap = asapFn;
	    }

	    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;
	    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
	    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
	    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

	    // test for web worker but not in IE10
	    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
	      typeof importScripts !== 'undefined' &&
	      typeof MessageChannel !== 'undefined';

	    // node
	    function lib$es6$promise$asap$$useNextTick() {
	      var nextTick = process.nextTick;
	      // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	      // setImmediate should be used instead instead
	      var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
	      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
	        nextTick = setImmediate;
	      }
	      return function() {
	        nextTick(lib$es6$promise$asap$$flush);
	      };
	    }

	    // vertx
	    function lib$es6$promise$asap$$useVertxTimer() {
	      return function() {
	        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
	      };
	    }

	    function lib$es6$promise$asap$$useMutationObserver() {
	      var iterations = 0;
	      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
	      var node = document.createTextNode('');
	      observer.observe(node, { characterData: true });

	      return function() {
	        node.data = (iterations = ++iterations % 2);
	      };
	    }

	    // web worker
	    function lib$es6$promise$asap$$useMessageChannel() {
	      var channel = new MessageChannel();
	      channel.port1.onmessage = lib$es6$promise$asap$$flush;
	      return function () {
	        channel.port2.postMessage(0);
	      };
	    }

	    function lib$es6$promise$asap$$useSetTimeout() {
	      return function() {
	        setTimeout(lib$es6$promise$asap$$flush, 1);
	      };
	    }

	    var lib$es6$promise$asap$$queue = new Array(1000);
	    function lib$es6$promise$asap$$flush() {
	      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {
	        var callback = lib$es6$promise$asap$$queue[i];
	        var arg = lib$es6$promise$asap$$queue[i+1];

	        callback(arg);

	        lib$es6$promise$asap$$queue[i] = undefined;
	        lib$es6$promise$asap$$queue[i+1] = undefined;
	      }

	      lib$es6$promise$asap$$len = 0;
	    }

	    function lib$es6$promise$asap$$attemptVertex() {
	      try {
	        var r = require;
	        var vertx = r('vertx');
	        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
	        return lib$es6$promise$asap$$useVertxTimer();
	      } catch(e) {
	        return lib$es6$promise$asap$$useSetTimeout();
	      }
	    }

	    var lib$es6$promise$asap$$scheduleFlush;
	    // Decide what async method to use to triggering processing of queued callbacks:
	    if (lib$es6$promise$asap$$isNode) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
	    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
	    } else if (lib$es6$promise$asap$$isWorker) {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
	    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertex();
	    } else {
	      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
	    }

	    function lib$es6$promise$$internal$$noop() {}

	    var lib$es6$promise$$internal$$PENDING   = void 0;
	    var lib$es6$promise$$internal$$FULFILLED = 1;
	    var lib$es6$promise$$internal$$REJECTED  = 2;

	    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	    function lib$es6$promise$$internal$$selfFullfillment() {
	      return new TypeError("You cannot resolve a promise with itself");
	    }

	    function lib$es6$promise$$internal$$cannotReturnOwn() {
	      return new TypeError('A promises callback cannot return that same promise.');
	    }

	    function lib$es6$promise$$internal$$getThen(promise) {
	      try {
	        return promise.then;
	      } catch(error) {
	        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
	        return lib$es6$promise$$internal$$GET_THEN_ERROR;
	      }
	    }

	    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	      try {
	        then.call(value, fulfillmentHandler, rejectionHandler);
	      } catch(e) {
	        return e;
	      }
	    }

	    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
	       lib$es6$promise$asap$$asap(function(promise) {
	        var sealed = false;
	        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {
	          if (sealed) { return; }
	          sealed = true;
	          if (thenable !== value) {
	            lib$es6$promise$$internal$$resolve(promise, value);
	          } else {
	            lib$es6$promise$$internal$$fulfill(promise, value);
	          }
	        }, function(reason) {
	          if (sealed) { return; }
	          sealed = true;

	          lib$es6$promise$$internal$$reject(promise, reason);
	        }, 'Settle: ' + (promise._label || ' unknown promise'));

	        if (!sealed && error) {
	          sealed = true;
	          lib$es6$promise$$internal$$reject(promise, error);
	        }
	      }, promise);
	    }

	    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
	      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, thenable._result);
	      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, thenable._result);
	      } else {
	        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      }
	    }

	    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
	      if (maybeThenable.constructor === promise.constructor) {
	        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
	      } else {
	        var then = lib$es6$promise$$internal$$getThen(maybeThenable);

	        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
	        } else if (then === undefined) {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        } else if (lib$es6$promise$utils$$isFunction(then)) {
	          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
	        } else {
	          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
	        }
	      }
	    }

	    function lib$es6$promise$$internal$$resolve(promise, value) {
	      if (promise === value) {
	        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFullfillment());
	      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
	        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
	      } else {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      }
	    }

	    function lib$es6$promise$$internal$$publishRejection(promise) {
	      if (promise._onerror) {
	        promise._onerror(promise._result);
	      }

	      lib$es6$promise$$internal$$publish(promise);
	    }

	    function lib$es6$promise$$internal$$fulfill(promise, value) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }

	      promise._result = value;
	      promise._state = lib$es6$promise$$internal$$FULFILLED;

	      if (promise._subscribers.length !== 0) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
	      }
	    }

	    function lib$es6$promise$$internal$$reject(promise, reason) {
	      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }
	      promise._state = lib$es6$promise$$internal$$REJECTED;
	      promise._result = reason;

	      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
	    }

	    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
	      var subscribers = parent._subscribers;
	      var length = subscribers.length;

	      parent._onerror = null;

	      subscribers[length] = child;
	      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
	      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;

	      if (length === 0 && parent._state) {
	        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
	      }
	    }

	    function lib$es6$promise$$internal$$publish(promise) {
	      var subscribers = promise._subscribers;
	      var settled = promise._state;

	      if (subscribers.length === 0) { return; }

	      var child, callback, detail = promise._result;

	      for (var i = 0; i < subscribers.length; i += 3) {
	        child = subscribers[i];
	        callback = subscribers[i + settled];

	        if (child) {
	          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
	        } else {
	          callback(detail);
	        }
	      }

	      promise._subscribers.length = 0;
	    }

	    function lib$es6$promise$$internal$$ErrorObject() {
	      this.error = null;
	    }

	    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

	    function lib$es6$promise$$internal$$tryCatch(callback, detail) {
	      try {
	        return callback(detail);
	      } catch(e) {
	        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
	        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
	      }
	    }

	    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
	      var hasCallback = lib$es6$promise$utils$$isFunction(callback),
	          value, error, succeeded, failed;

	      if (hasCallback) {
	        value = lib$es6$promise$$internal$$tryCatch(callback, detail);

	        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
	          failed = true;
	          error = value.error;
	          value = null;
	        } else {
	          succeeded = true;
	        }

	        if (promise === value) {
	          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
	          return;
	        }

	      } else {
	        value = detail;
	        succeeded = true;
	      }

	      if (promise._state !== lib$es6$promise$$internal$$PENDING) {
	        // noop
	      } else if (hasCallback && succeeded) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      } else if (failed) {
	        lib$es6$promise$$internal$$reject(promise, error);
	      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
	        lib$es6$promise$$internal$$fulfill(promise, value);
	      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
	        lib$es6$promise$$internal$$reject(promise, value);
	      }
	    }

	    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
	      try {
	        resolver(function resolvePromise(value){
	          lib$es6$promise$$internal$$resolve(promise, value);
	        }, function rejectPromise(reason) {
	          lib$es6$promise$$internal$$reject(promise, reason);
	        });
	      } catch(e) {
	        lib$es6$promise$$internal$$reject(promise, e);
	      }
	    }

	    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
	      var enumerator = this;

	      enumerator._instanceConstructor = Constructor;
	      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

	      if (enumerator._validateInput(input)) {
	        enumerator._input     = input;
	        enumerator.length     = input.length;
	        enumerator._remaining = input.length;

	        enumerator._init();

	        if (enumerator.length === 0) {
	          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	        } else {
	          enumerator.length = enumerator.length || 0;
	          enumerator._enumerate();
	          if (enumerator._remaining === 0) {
	            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
	          }
	        }
	      } else {
	        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
	      }
	    }

	    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {
	      return lib$es6$promise$utils$$isArray(input);
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {
	      return new Error('Array Methods must be provided an Array');
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {
	      this._result = new Array(this.length);
	    };

	    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

	    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {
	      var enumerator = this;

	      var length  = enumerator.length;
	      var promise = enumerator.promise;
	      var input   = enumerator._input;

	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        enumerator._eachEntry(input[i], i);
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
	      var enumerator = this;
	      var c = enumerator._instanceConstructor;

	      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
	        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
	          entry._onerror = null;
	          enumerator._settledAt(entry._state, i, entry._result);
	        } else {
	          enumerator._willSettleAt(c.resolve(entry), i);
	        }
	      } else {
	        enumerator._remaining--;
	        enumerator._result[i] = entry;
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
	      var enumerator = this;
	      var promise = enumerator.promise;

	      if (promise._state === lib$es6$promise$$internal$$PENDING) {
	        enumerator._remaining--;

	        if (state === lib$es6$promise$$internal$$REJECTED) {
	          lib$es6$promise$$internal$$reject(promise, value);
	        } else {
	          enumerator._result[i] = value;
	        }
	      }

	      if (enumerator._remaining === 0) {
	        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
	      }
	    };

	    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
	      var enumerator = this;

	      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {
	        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
	      }, function(reason) {
	        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
	      });
	    };
	    function lib$es6$promise$promise$all$$all(entries) {
	      return new lib$es6$promise$enumerator$$default(this, entries).promise;
	    }
	    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
	    function lib$es6$promise$promise$race$$race(entries) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      var promise = new Constructor(lib$es6$promise$$internal$$noop);

	      if (!lib$es6$promise$utils$$isArray(entries)) {
	        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
	        return promise;
	      }

	      var length = entries.length;

	      function onFulfillment(value) {
	        lib$es6$promise$$internal$$resolve(promise, value);
	      }

	      function onRejection(reason) {
	        lib$es6$promise$$internal$$reject(promise, reason);
	      }

	      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
	        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
	      }

	      return promise;
	    }
	    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
	    function lib$es6$promise$promise$resolve$$resolve(object) {
	      /*jshint validthis:true */
	      var Constructor = this;

	      if (object && typeof object === 'object' && object.constructor === Constructor) {
	        return object;
	      }

	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$resolve(promise, object);
	      return promise;
	    }
	    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
	    function lib$es6$promise$promise$reject$$reject(reason) {
	      /*jshint validthis:true */
	      var Constructor = this;
	      var promise = new Constructor(lib$es6$promise$$internal$$noop);
	      lib$es6$promise$$internal$$reject(promise, reason);
	      return promise;
	    }
	    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

	    var lib$es6$promise$promise$$counter = 0;

	    function lib$es6$promise$promise$$needsResolver() {
	      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	    }

	    function lib$es6$promise$promise$$needsNew() {
	      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	    }

	    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
	    /**
	      Promise objects represent the eventual result of an asynchronous operation. The
	      primary way of interacting with a promise is through its `then` method, which
	      registers callbacks to receive either a promise's eventual value or the reason
	      why the promise cannot be fulfilled.

	      Terminology
	      -----------

	      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	      - `thenable` is an object or function that defines a `then` method.
	      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	      - `exception` is a value that is thrown using the throw statement.
	      - `reason` is a value that indicates why a promise was rejected.
	      - `settled` the final resting state of a promise, fulfilled or rejected.

	      A promise can be in one of three states: pending, fulfilled, or rejected.

	      Promises that are fulfilled have a fulfillment value and are in the fulfilled
	      state.  Promises that are rejected have a rejection reason and are in the
	      rejected state.  A fulfillment value is never a thenable.

	      Promises can also be said to *resolve* a value.  If this value is also a
	      promise, then the original promise's settled state will match the value's
	      settled state.  So a promise that *resolves* a promise that rejects will
	      itself reject, and a promise that *resolves* a promise that fulfills will
	      itself fulfill.


	      Basic Usage:
	      ------------

	      ```js
	      var promise = new Promise(function(resolve, reject) {
	        // on success
	        resolve(value);

	        // on failure
	        reject(reason);
	      });

	      promise.then(function(value) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```

	      Advanced Usage:
	      ---------------

	      Promises shine when abstracting away asynchronous interactions such as
	      `XMLHttpRequest`s.

	      ```js
	      function getJSON(url) {
	        return new Promise(function(resolve, reject){
	          var xhr = new XMLHttpRequest();

	          xhr.open('GET', url);
	          xhr.onreadystatechange = handler;
	          xhr.responseType = 'json';
	          xhr.setRequestHeader('Accept', 'application/json');
	          xhr.send();

	          function handler() {
	            if (this.readyState === this.DONE) {
	              if (this.status === 200) {
	                resolve(this.response);
	              } else {
	                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	              }
	            }
	          };
	        });
	      }

	      getJSON('/posts.json').then(function(json) {
	        // on fulfillment
	      }, function(reason) {
	        // on rejection
	      });
	      ```

	      Unlike callbacks, promises are great composable primitives.

	      ```js
	      Promise.all([
	        getJSON('/posts'),
	        getJSON('/comments')
	      ]).then(function(values){
	        values[0] // => postsJSON
	        values[1] // => commentsJSON

	        return values;
	      });
	      ```

	      @class Promise
	      @param {function} resolver
	      Useful for tooling.
	      @constructor
	    */
	    function lib$es6$promise$promise$$Promise(resolver) {
	      this._id = lib$es6$promise$promise$$counter++;
	      this._state = undefined;
	      this._result = undefined;
	      this._subscribers = [];

	      if (lib$es6$promise$$internal$$noop !== resolver) {
	        if (!lib$es6$promise$utils$$isFunction(resolver)) {
	          lib$es6$promise$promise$$needsResolver();
	        }

	        if (!(this instanceof lib$es6$promise$promise$$Promise)) {
	          lib$es6$promise$promise$$needsNew();
	        }

	        lib$es6$promise$$internal$$initializePromise(this, resolver);
	      }
	    }

	    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
	    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
	    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
	    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
	    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
	    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
	    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

	    lib$es6$promise$promise$$Promise.prototype = {
	      constructor: lib$es6$promise$promise$$Promise,

	    /**
	      The primary way of interacting with a promise is through its `then` method,
	      which registers callbacks to receive either a promise's eventual value or the
	      reason why the promise cannot be fulfilled.

	      ```js
	      findUser().then(function(user){
	        // user is available
	      }, function(reason){
	        // user is unavailable, and you are given the reason why
	      });
	      ```

	      Chaining
	      --------

	      The return value of `then` is itself a promise.  This second, 'downstream'
	      promise is resolved with the return value of the first promise's fulfillment
	      or rejection handler, or rejected if the handler throws an exception.

	      ```js
	      findUser().then(function (user) {
	        return user.name;
	      }, function (reason) {
	        return 'default name';
	      }).then(function (userName) {
	        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	        // will be `'default name'`
	      });

	      findUser().then(function (user) {
	        throw new Error('Found user, but still unhappy');
	      }, function (reason) {
	        throw new Error('`findUser` rejected and we're unhappy');
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	      });
	      ```
	      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

	      ```js
	      findUser().then(function (user) {
	        throw new PedagogicalException('Upstream error');
	      }).then(function (value) {
	        // never reached
	      }).then(function (value) {
	        // never reached
	      }, function (reason) {
	        // The `PedgagocialException` is propagated all the way down to here
	      });
	      ```

	      Assimilation
	      ------------

	      Sometimes the value you want to propagate to a downstream promise can only be
	      retrieved asynchronously. This can be achieved by returning a promise in the
	      fulfillment or rejection handler. The downstream promise will then be pending
	      until the returned promise is settled. This is called *assimilation*.

	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // The user's comments are now available
	      });
	      ```

	      If the assimliated promise rejects, then the downstream promise will also reject.

	      ```js
	      findUser().then(function (user) {
	        return findCommentsByAuthor(user);
	      }).then(function (comments) {
	        // If `findCommentsByAuthor` fulfills, we'll have the value here
	      }, function (reason) {
	        // If `findCommentsByAuthor` rejects, we'll have the reason here
	      });
	      ```

	      Simple Example
	      --------------

	      Synchronous Example

	      ```javascript
	      var result;

	      try {
	        result = findResult();
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```

	      Errback Example

	      ```js
	      findResult(function(result, err){
	        if (err) {
	          // failure
	        } else {
	          // success
	        }
	      });
	      ```

	      Promise Example;

	      ```javascript
	      findResult().then(function(result){
	        // success
	      }, function(reason){
	        // failure
	      });
	      ```

	      Advanced Example
	      --------------

	      Synchronous Example

	      ```javascript
	      var author, books;

	      try {
	        author = findAuthor();
	        books  = findBooksByAuthor(author);
	        // success
	      } catch(reason) {
	        // failure
	      }
	      ```

	      Errback Example

	      ```js

	      function foundBooks(books) {

	      }

	      function failure(reason) {

	      }

	      findAuthor(function(author, err){
	        if (err) {
	          failure(err);
	          // failure
	        } else {
	          try {
	            findBoooksByAuthor(author, function(books, err) {
	              if (err) {
	                failure(err);
	              } else {
	                try {
	                  foundBooks(books);
	                } catch(reason) {
	                  failure(reason);
	                }
	              }
	            });
	          } catch(error) {
	            failure(err);
	          }
	          // success
	        }
	      });
	      ```

	      Promise Example;

	      ```javascript
	      findAuthor().
	        then(findBooksByAuthor).
	        then(function(books){
	          // found books
	      }).catch(function(reason){
	        // something went wrong
	      });
	      ```

	      @method then
	      @param {Function} onFulfilled
	      @param {Function} onRejected
	      Useful for tooling.
	      @return {Promise}
	    */
	      then: function(onFulfillment, onRejection) {
	        var parent = this;
	        var state = parent._state;

	        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
	          return this;
	        }

	        var child = new this.constructor(lib$es6$promise$$internal$$noop);
	        var result = parent._result;

	        if (state) {
	          var callback = arguments[state - 1];
	          lib$es6$promise$asap$$asap(function(){
	            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
	          });
	        } else {
	          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
	        }

	        return child;
	      },

	    /**
	      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	      as the catch block of a try/catch statement.

	      ```js
	      function findAuthor(){
	        throw new Error('couldn't find that author');
	      }

	      // synchronous
	      try {
	        findAuthor();
	      } catch(reason) {
	        // something went wrong
	      }

	      // async with promises
	      findAuthor().catch(function(reason){
	        // something went wrong
	      });
	      ```

	      @method catch
	      @param {Function} onRejection
	      Useful for tooling.
	      @return {Promise}
	    */
	      'catch': function(onRejection) {
	        return this.then(null, onRejection);
	      }
	    };
	    function lib$es6$promise$polyfill$$polyfill() {
	      var local;

	      if (typeof global !== 'undefined') {
	          local = global;
	      } else if (typeof self !== 'undefined') {
	          local = self;
	      } else {
	          try {
	              local = Function('return this')();
	          } catch (e) {
	              throw new Error('polyfill failed because global object is unavailable in this environment');
	          }
	      }

	      var P = local.Promise;

	      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
	        return;
	      }

	      local.Promise = lib$es6$promise$promise$$default;
	    }
	    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

	    var lib$es6$promise$umd$$ES6Promise = {
	      'Promise': lib$es6$promise$promise$$default,
	      'polyfill': lib$es6$promise$polyfill$$default
	    };

	    /* global define:true module:true window: true */
	    if ("function" === 'function' && __webpack_require__(131)['amd']) {
	      !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return lib$es6$promise$umd$$ES6Promise; }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined' && module['exports']) {
	      module['exports'] = lib$es6$promise$umd$$ES6Promise;
	    } else if (typeof this !== 'undefined') {
	      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
	    }

	    lib$es6$promise$polyfill$$default();
	}).call(this);


	}).call(this,{},typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	},{}]},{},[1]);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(24).setImmediate))

/***/ },
/* 131 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************
	Copyright (C) Microsoft. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0

	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.

	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	"use strict";
	var Reflect;
	(function (Reflect) {
	    // Load global or shim versions of Map, Set, and WeakMap
	    var functionPrototype = Object.getPrototypeOf(Function);
	    var _Map = typeof Map === "function" ? Map : CreateMapPolyfill();
	    var _Set = typeof Set === "function" ? Set : CreateSetPolyfill();
	    var _WeakMap = typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
	    // [[Metadata]] internal slot
	    var __Metadata__ = new _WeakMap();
	    /**
	      * Applies a set of decorators to a property of a target object.
	      * @param decorators An array of decorators.
	      * @param target The target object.
	      * @param targetKey (Optional) The property key to decorate.
	      * @param targetDescriptor (Optional) The property descriptor for the target key
	      * @remarks Decorators are applied in reverse order.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     C = Reflect.decorate(decoratorsArray, C);
	      *
	      *     // property (on constructor)
	      *     Reflect.decorate(decoratorsArray, C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     Reflect.decorate(decoratorsArray, C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     Object.defineProperty(C, "staticMethod",
	      *         Reflect.decorate(decoratorsArray, C, "staticMethod",
	      *             Object.getOwnPropertyDescriptor(C, "staticMethod")));
	      *
	      *     // method (on prototype)
	      *     Object.defineProperty(C.prototype, "method",
	      *         Reflect.decorate(decoratorsArray, C.prototype, "method",
	      *             Object.getOwnPropertyDescriptor(C.prototype, "method")));
	      *
	      */
	    function decorate(decorators, target, targetKey, targetDescriptor) {
	        if (!IsUndefined(targetDescriptor)) {
	            if (!IsArray(decorators)) {
	                throw new TypeError();
	            }
	            else if (!IsObject(target)) {
	                throw new TypeError();
	            }
	            else if (IsUndefined(targetKey)) {
	                throw new TypeError();
	            }
	            else if (!IsObject(targetDescriptor)) {
	                throw new TypeError();
	            }
	            targetKey = ToPropertyKey(targetKey);
	            return DecoratePropertyWithDescriptor(decorators, target, targetKey, targetDescriptor);
	        }
	        else if (!IsUndefined(targetKey)) {
	            if (!IsArray(decorators)) {
	                throw new TypeError();
	            }
	            else if (!IsObject(target)) {
	                throw new TypeError();
	            }
	            targetKey = ToPropertyKey(targetKey);
	            return DecoratePropertyWithoutDescriptor(decorators, target, targetKey);
	        }
	        else {
	            if (!IsArray(decorators)) {
	                throw new TypeError();
	            }
	            else if (!IsConstructor(target)) {
	                throw new TypeError();
	            }
	            return DecorateConstructor(decorators, target);
	        }
	    }
	    Reflect.decorate = decorate;
	    /**
	      * A default metadata decorator factory that can be used on a class, class member, or parameter.
	      * @param metadataKey The key for the metadata entry.
	      * @param metadataValue The value for the metadata entry.
	      * @returns A decorator function.
	      * @remarks
	      * If `metadataKey` is already defined for the target and target key, the
	      * metadataValue for that key will be overwritten.
	      * @example
	      *
	      *     // constructor
	      *     @Reflect.metadata(key, value)
	      *     class C {
	      *     }
	      *
	      *     // property (on constructor, TypeScript only)
	      *     class C {
	      *         @Reflect.metadata(key, value)
	      *         static staticProperty;
	      *     }
	      *
	      *     // property (on prototype, TypeScript only)
	      *     class C {
	      *         @Reflect.metadata(key, value)
	      *         property;
	      *     }
	      *
	      *     // method (on constructor)
	      *     class C {
	      *         @Reflect.metadata(key, value)
	      *         static staticMethod() { }
	      *     }
	      *
	      *     // method (on prototype)
	      *     class C {
	      *         @Reflect.metadata(key, value)
	      *         method() { }
	      *     }
	      *
	      */
	    function metadata(metadataKey, metadataValue) {
	        function decorator(target, targetKey) {
	            if (!IsUndefined(targetKey)) {
	                if (!IsObject(target)) {
	                    throw new TypeError();
	                }
	                targetKey = ToPropertyKey(targetKey);
	                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
	            }
	            else {
	                if (!IsConstructor(target)) {
	                    throw new TypeError();
	                }
	                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, undefined);
	            }
	        }
	        return decorator;
	    }
	    Reflect.metadata = metadata;
	    /**
	      * Define a unique metadata entry on the target.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param metadataValue A value that contains attached metadata.
	      * @param target The target object on which to define metadata.
	      * @param targetKey (Optional) The property key for the target.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     Reflect.defineMetadata("custom:annotation", options, C);
	      *
	      *     // property (on constructor)
	      *     Reflect.defineMetadata("custom:annotation", options, C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     Reflect.defineMetadata("custom:annotation", options, C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     Reflect.defineMetadata("custom:annotation", options, C.prototype, "method");
	      *
	      *     // decorator factory as metadata-producing annotation.
	      *     function MyAnnotation(options): Decorator {
	      *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
	      *     }
	      *
	      */
	    function defineMetadata(metadataKey, metadataValue, target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, targetKey);
	    }
	    Reflect.defineMetadata = defineMetadata;
	    /**
	      * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.hasMetadata("custom:annotation", C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.hasMetadata("custom:annotation", C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.hasMetadata("custom:annotation", C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.hasMetadata("custom:annotation", C.prototype, "method");
	      *
	      */
	    function hasMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryHasMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.hasMetadata = hasMetadata;
	    /**
	      * Gets a value indicating whether the target object has the provided metadata key defined.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.hasOwnMetadata("custom:annotation", C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.hasOwnMetadata("custom:annotation", C.prototype, "method");
	      *
	      */
	    function hasOwnMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryHasOwnMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.hasOwnMetadata = hasOwnMetadata;
	    /**
	      * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getMetadata("custom:annotation", C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getMetadata("custom:annotation", C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getMetadata("custom:annotation", C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getMetadata("custom:annotation", C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getMetadata("custom:annotation", C.prototype, "method");
	      *
	      */
	    function getMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryGetMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.getMetadata = getMetadata;
	    /**
	      * Gets the metadata value for the provided metadata key on the target object.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getOwnMetadata("custom:annotation", C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getOwnMetadata("custom:annotation", C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getOwnMetadata("custom:annotation", C.prototype, "method");
	      *
	      */
	    function getOwnMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryGetOwnMetadata(metadataKey, target, targetKey);
	    }
	    Reflect.getOwnMetadata = getOwnMetadata;
	    /**
	      * Gets the metadata keys defined on the target object or its prototype chain.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns An array of unique metadata keys.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getMetadataKeys(C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getMetadataKeys(C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getMetadataKeys(C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getMetadataKeys(C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getMetadataKeys(C.prototype, "method");
	      *
	      */
	    function getMetadataKeys(target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryMetadataKeys(target, targetKey);
	    }
	    Reflect.getMetadataKeys = getMetadataKeys;
	    /**
	      * Gets the unique metadata keys defined on the target object.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns An array of unique metadata keys.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.getOwnMetadataKeys(C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.getOwnMetadataKeys(C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.getOwnMetadataKeys(C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.getOwnMetadataKeys(C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.getOwnMetadataKeys(C.prototype, "method");
	      *
	      */
	    function getOwnMetadataKeys(target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        return OrdinaryOwnMetadataKeys(target, targetKey);
	    }
	    Reflect.getOwnMetadataKeys = getOwnMetadataKeys;
	    /**
	      * Deletes the metadata entry from the target object with the provided key.
	      * @param metadataKey A key used to store and retrieve metadata.
	      * @param target The target object on which the metadata is defined.
	      * @param targetKey (Optional) The property key for the target.
	      * @returns `true` if the metadata entry was found and deleted; otherwise, false.
	      * @example
	      *
	      *     class C {
	      *         // property declarations are not part of ES6, though they are valid in TypeScript:
	      *         // static staticProperty;
	      *         // property;
	      *
	      *         constructor(p) { }
	      *         static staticMethod(p) { }
	      *         method(p) { }
	      *     }
	      *
	      *     // constructor
	      *     result = Reflect.deleteMetadata("custom:annotation", C);
	      *
	      *     // property (on constructor)
	      *     result = Reflect.deleteMetadata("custom:annotation", C, "staticProperty");
	      *
	      *     // property (on prototype)
	      *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "property");
	      *
	      *     // method (on constructor)
	      *     result = Reflect.deleteMetadata("custom:annotation", C, "staticMethod");
	      *
	      *     // method (on prototype)
	      *     result = Reflect.deleteMetadata("custom:annotation", C.prototype, "method");
	      *
	      */
	    function deleteMetadata(metadataKey, target, targetKey) {
	        if (!IsObject(target)) {
	            throw new TypeError();
	        }
	        else if (!IsUndefined(targetKey)) {
	            targetKey = ToPropertyKey(targetKey);
	        }
	        // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#deletemetadata-metadatakey-p-
	        var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
	        if (IsUndefined(metadataMap)) {
	            return false;
	        }
	        if (!metadataMap.delete(metadataKey)) {
	            return false;
	        }
	        if (metadataMap.size > 0) {
	            return true;
	        }
	        var targetMetadata = __Metadata__.get(target);
	        targetMetadata.delete(targetKey);
	        if (targetMetadata.size > 0) {
	            return true;
	        }
	        __Metadata__.delete(target);
	        return true;
	    }
	    Reflect.deleteMetadata = deleteMetadata;
	    function DecorateConstructor(decorators, target) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            var decorated = decorator(target);
	            if (!IsUndefined(decorated)) {
	                if (!IsConstructor(decorated)) {
	                    throw new TypeError();
	                }
	                target = decorated;
	            }
	        }
	        return target;
	    }
	    function DecoratePropertyWithDescriptor(decorators, target, propertyKey, descriptor) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            var decorated = decorator(target, propertyKey, descriptor);
	            if (!IsUndefined(decorated)) {
	                if (!IsObject(decorated)) {
	                    throw new TypeError();
	                }
	                descriptor = decorated;
	            }
	        }
	        return descriptor;
	    }
	    function DecoratePropertyWithoutDescriptor(decorators, target, propertyKey) {
	        for (var i = decorators.length - 1; i >= 0; --i) {
	            var decorator = decorators[i];
	            decorator(target, propertyKey);
	        }
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#getorcreatemetadatamap--o-p-create-
	    function GetOrCreateMetadataMap(target, targetKey, create) {
	        var targetMetadata = __Metadata__.get(target);
	        if (!targetMetadata) {
	            if (!create) {
	                return undefined;
	            }
	            targetMetadata = new _Map();
	            __Metadata__.set(target, targetMetadata);
	        }
	        var keyMetadata = targetMetadata.get(targetKey);
	        if (!keyMetadata) {
	            if (!create) {
	                return undefined;
	            }
	            keyMetadata = new _Map();
	            targetMetadata.set(targetKey, keyMetadata);
	        }
	        return keyMetadata;
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasmetadata--metadatakey-o-p-
	    function OrdinaryHasMetadata(MetadataKey, O, P) {
	        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	        if (hasOwn) {
	            return true;
	        }
	        var parent = GetPrototypeOf(O);
	        if (parent !== null) {
	            return OrdinaryHasMetadata(MetadataKey, parent, P);
	        }
	        return false;
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryhasownmetadata--metadatakey-o-p-
	    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, false);
	        if (metadataMap === undefined) {
	            return false;
	        }
	        return Boolean(metadataMap.has(MetadataKey));
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetmetadata--metadatakey-o-p-
	    function OrdinaryGetMetadata(MetadataKey, O, P) {
	        var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
	        if (hasOwn) {
	            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
	        }
	        var parent = GetPrototypeOf(O);
	        if (parent !== null) {
	            return OrdinaryGetMetadata(MetadataKey, parent, P);
	        }
	        return undefined;
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarygetownmetadata--metadatakey-o-p-
	    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, false);
	        if (metadataMap === undefined) {
	            return undefined;
	        }
	        return metadataMap.get(MetadataKey);
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarydefineownmetadata--metadatakey-metadatavalue-o-p-
	    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
	        var metadataMap = GetOrCreateMetadataMap(O, P, true);
	        metadataMap.set(MetadataKey, MetadataValue);
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinarymetadatakeys--o-p-
	    function OrdinaryMetadataKeys(O, P) {
	        var ownKeys = OrdinaryOwnMetadataKeys(O, P);
	        var parent = GetPrototypeOf(O);
	        if (parent === null) {
	            return ownKeys;
	        }
	        var parentKeys = OrdinaryMetadataKeys(parent, P);
	        if (parentKeys.length <= 0) {
	            return ownKeys;
	        }
	        if (ownKeys.length <= 0) {
	            return parentKeys;
	        }
	        var set = new _Set();
	        var keys = [];
	        for (var _i = 0; _i < ownKeys.length; _i++) {
	            var key = ownKeys[_i];
	            var hasKey = set.has(key);
	            if (!hasKey) {
	                set.add(key);
	                keys.push(key);
	            }
	        }
	        for (var _a = 0; _a < parentKeys.length; _a++) {
	            var key = parentKeys[_a];
	            var hasKey = set.has(key);
	            if (!hasKey) {
	                set.add(key);
	                keys.push(key);
	            }
	        }
	        return keys;
	    }
	    // https://github.com/jonathandturner/decorators/blob/master/specs/metadata.md#ordinaryownmetadatakeys--o-p-
	    function OrdinaryOwnMetadataKeys(target, targetKey) {
	        var metadataMap = GetOrCreateMetadataMap(target, targetKey, false);
	        var keys = [];
	        if (metadataMap) {
	            metadataMap.forEach(function (_, key) { return keys.push(key); });
	        }
	        return keys;
	    }
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-undefined-type
	    function IsUndefined(x) {
	        return x === undefined;
	    }
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	    function IsArray(x) {
	        return Array.isArray(x);
	    }
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object-type
	    function IsObject(x) {
	        return typeof x === "object" ? x !== null : typeof x === "function";
	    }
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	    function IsConstructor(x) {
	        return typeof x === "function";
	    }
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ecmascript-language-types-symbol-type
	    function IsSymbol(x) {
	        return typeof x === "symbol";
	    }
	    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	    function ToPropertyKey(value) {
	        if (IsSymbol(value)) {
	            return value;
	        }
	        return String(value);
	    }
	    function GetPrototypeOf(O) {
	        var proto = Object.getPrototypeOf(O);
	        if (typeof O !== "function" || O === functionPrototype) {
	            return proto;
	        }
	        // TypeScript doesn't set __proto__ in ES5, as it's non-standard. 
	        // Try to determine the superclass constructor. Compatible implementations
	        // must either set __proto__ on a subclass constructor to the superclass constructor,
	        // or ensure each class has a valid `constructor` property on its prototype that
	        // points back to the constructor.
	        // If this is not the same as Function.[[Prototype]], then this is definately inherited.
	        // This is the case when in ES6 or when using __proto__ in a compatible browser.
	        if (proto !== functionPrototype) {
	            return proto;
	        }
	        // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
	        var prototype = O.prototype;
	        var prototypeProto = Object.getPrototypeOf(prototype);
	        if (prototypeProto == null || prototypeProto === Object.prototype) {
	            return proto;
	        }
	        // if the constructor was not a function, then we cannot determine the heritage.
	        var constructor = prototypeProto.constructor;
	        if (typeof constructor !== "function") {
	            return proto;
	        }
	        // if we have some kind of self-reference, then we cannot determine the heritage.
	        if (constructor === O) {
	            return proto;
	        }
	        // we have a pretty good guess at the heritage.
	        return constructor;
	    }
	    // naive Map shim
	    function CreateMapPolyfill() {
	        var cacheSentinel = {};
	        function Map() {
	            this._keys = [];
	            this._values = [];
	            this._cache = cacheSentinel;
	        }
	        Map.prototype = {
	            get size() {
	                return this._keys.length;
	            },
	            has: function (key) {
	                if (key === this._cache) {
	                    return true;
	                }
	                if (this._find(key) >= 0) {
	                    this._cache = key;
	                    return true;
	                }
	                return false;
	            },
	            get: function (key) {
	                var index = this._find(key);
	                if (index >= 0) {
	                    this._cache = key;
	                    return this._values[index];
	                }
	                return undefined;
	            },
	            set: function (key, value) {
	                this.delete(key);
	                this._keys.push(key);
	                this._values.push(value);
	                this._cache = key;
	                return this;
	            },
	            delete: function (key) {
	                var index = this._find(key);
	                if (index >= 0) {
	                    this._keys.splice(index, 1);
	                    this._values.splice(index, 1);
	                    this._cache = cacheSentinel;
	                    return true;
	                }
	                return false;
	            },
	            clear: function () {
	                this._keys.length = 0;
	                this._values.length = 0;
	                this._cache = cacheSentinel;
	            },
	            forEach: function (callback, thisArg) {
	                var size = this.size;
	                for (var i = 0; i < size; ++i) {
	                    var key = this._keys[i];
	                    var value = this._values[i];
	                    this._cache = key;
	                    callback.call(this, value, key, this);
	                }
	            },
	            _find: function (key) {
	                var keys = this._keys;
	                var size = keys.length;
	                for (var i = 0; i < size; ++i) {
	                    if (keys[i] === key) {
	                        return i;
	                    }
	                }
	                return -1;
	            }
	        };
	        return Map;
	    }
	    // naive Set shim
	    function CreateSetPolyfill() {
	        var cacheSentinel = {};
	        function Set() {
	            this._map = new _Map();
	        }
	        Set.prototype = {
	            get size() {
	                return this._map.length;
	            },
	            has: function (value) {
	                return this._map.has(value);
	            },
	            add: function (value) {
	                this._map.set(value, value);
	                return this;
	            },
	            delete: function (value) {
	                return this._map.delete(value);
	            },
	            clear: function () {
	                this._map.clear();
	            },
	            forEach: function (callback, thisArg) {
	                this._map.forEach(callback, thisArg);
	            }
	        };
	        return Set;
	    }
	    // naive WeakMap shim
	    function CreateWeakMapPolyfill() {
	        var UUID_SIZE = 16;
	        var isNode = typeof global !== "undefined" && Object.prototype.toString.call(global.process) === '[object process]';
	        var nodeCrypto = isNode && __webpack_require__(133);
	        var hasOwn = Object.prototype.hasOwnProperty;
	        var keys = {};
	        var rootKey = CreateUniqueKey();
	        function WeakMap() {
	            this._key = CreateUniqueKey();
	        }
	        WeakMap.prototype = {
	            has: function (target) {
	                var table = GetOrCreateWeakMapTable(target, false);
	                if (table) {
	                    return this._key in table;
	                }
	                return false;
	            },
	            get: function (target) {
	                var table = GetOrCreateWeakMapTable(target, false);
	                if (table) {
	                    return table[this._key];
	                }
	                return undefined;
	            },
	            set: function (target, value) {
	                var table = GetOrCreateWeakMapTable(target, true);
	                table[this._key] = value;
	                return this;
	            },
	            delete: function (target) {
	                var table = GetOrCreateWeakMapTable(target, false);
	                if (table && this._key in table) {
	                    return delete table[this._key];
	                }
	                return false;
	            },
	            clear: function () {
	                // NOTE: not a real clear, just makes the previous data unreachable
	                this._key = CreateUniqueKey();
	            }
	        };
	        function FillRandomBytes(buffer, size) {
	            for (var i = 0; i < size; ++i) {
	                buffer[i] = Math.random() * 255 | 0;
	            }
	        }
	        function GenRandomBytes(size) {
	            if (nodeCrypto) {
	                var data = nodeCrypto.randomBytes(size);
	                return data;
	            }
	            else if (typeof Uint8Array === "function") {
	                var data = new Uint8Array(size);
	                if (typeof crypto !== "undefined") {
	                    crypto.getRandomValues(data);
	                }
	                else if (typeof msCrypto !== "undefined") {
	                    msCrypto.getRandomValues(data);
	                }
	                else {
	                    FillRandomBytes(data, size);
	                }
	                return data;
	            }
	            else {
	                var data = new Array(size);
	                FillRandomBytes(data, size);
	                return data;
	            }
	        }
	        function CreateUUID() {
	            var data = GenRandomBytes(UUID_SIZE);
	            // mark as random - RFC 4122  4.4
	            data[6] = data[6] & 0x4f | 0x40;
	            data[8] = data[8] & 0xbf | 0x80;
	            var result = "";
	            for (var offset = 0; offset < UUID_SIZE; ++offset) {
	                var byte = data[offset];
	                if (offset === 4 || offset === 6 || offset === 8) {
	                    result += "-";
	                }
	                if (byte < 16) {
	                    result += "0";
	                }
	                result += byte.toString(16).toLowerCase();
	            }
	            return result;
	        }
	        function CreateUniqueKey() {
	            var key;
	            do {
	                key = "@@WeakMap@@" + CreateUUID();
	            } while (hasOwn.call(keys, key));
	            keys[key] = true;
	            return key;
	        }
	        function GetOrCreateWeakMapTable(target, create) {
	            if (!hasOwn.call(target, rootKey)) {
	                if (!create) {
	                    return undefined;
	                }
	                Object.defineProperty(target, rootKey, { value: Object.create(null) });
	            }
	            return target[rootKey];
	        }
	        return WeakMap;
	    }
	    // hook global Reflect
	    (function (__global) {
	        if (typeof __global.Reflect !== "undefined") {
	            if (__global.Reflect !== Reflect) {
	                for (var p in Reflect) {
	                    __global.Reflect[p] = Reflect[p];
	                }
	            }
	        }
	        else {
	            __global.Reflect = Reflect;
	        }
	    })(typeof window !== "undefined" ? window :
	        typeof WorkerGlobalScope !== "undefined" ? self :
	            typeof global !== "undefined" ? global :
	                Function("return this;")());
	})(Reflect || (Reflect = {}));
	//# sourceMappingURL=Reflect.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var rng = __webpack_require__(138)

	function error () {
	  var m = [].slice.call(arguments).join(' ')
	  throw new Error([
	    m,
	    'we accept pull requests',
	    'http://github.com/dominictarr/crypto-browserify'
	    ].join('\n'))
	}

	exports.createHash = __webpack_require__(140)

	exports.createHmac = __webpack_require__(152)

	exports.randomBytes = function(size, callback) {
	  if (callback && callback.call) {
	    try {
	      callback.call(this, undefined, new Buffer(rng(size)))
	    } catch (err) { callback(err) }
	  } else {
	    return new Buffer(rng(size))
	  }
	}

	function each(a, f) {
	  for(var i in a)
	    f(a[i], i)
	}

	exports.getHashes = function () {
	  return ['sha1', 'sha256', 'sha512', 'md5', 'rmd160']
	}

	var p = __webpack_require__(153)(exports)
	exports.pbkdf2 = p.pbkdf2
	exports.pbkdf2Sync = p.pbkdf2Sync


	// the least I can do is make error messages for the rest of the node.js/crypto api.
	each(['createCredentials'
	, 'createCipher'
	, 'createCipheriv'
	, 'createDecipher'
	, 'createDecipheriv'
	, 'createSign'
	, 'createVerify'
	, 'createDiffieHellman'
	], function (name) {
	  exports[name] = function () {
	    error('sorry,', name, 'is not implemented yet')
	  }
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */

	var base64 = __webpack_require__(135)
	var ieee754 = __webpack_require__(136)
	var isArray = __webpack_require__(137)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation

	var rootParent = {}

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = (function () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	})()

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }

	  this.length = 0
	  this.parent = undefined

	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }

	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }

	  // Unusual.
	  return fromObject(this, arg)
	}

	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)

	  that.write(string, encoding)
	  return that
	}

	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

	  if (isArray(object)) return fromArray(that, object)

	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }

	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }

	  if (object.length) return fromArrayLike(that, object)

	  return fromJsonObject(that, object)
	}

	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}

	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}

	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0

	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)

	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }

	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent

	  return that
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break

	    ++i
	  }

	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

	  if (list.length === 0) {
	    return new Buffer(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }

	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}

	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0

	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'binary':
	        return binarySlice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0

	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1

	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }

	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}

	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'binary':
	        return binaryWrite(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  if (newBuf.length) newBuf.parent = this.parent || this

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = value
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = value
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = value
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = value
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = value
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = value
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }

	  return len
	}

	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length

	  if (end < start) throw new RangeError('end < start')

	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return

	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }

	  return this
	}

	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}

	// HELPER FUNCTIONS
	// ================

	var BP = Buffer.prototype

	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true

	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set

	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set

	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer

	  return arr
	}

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	;(function (exports) {
		'use strict';

	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array

		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)

		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}

		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr

			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}

			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)

			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length

			var L = 0

			function push (v) {
				arr[L++] = v
			}

			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}

			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}

			return arr
		}

		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length

			function encode (num) {
				return lookup.charAt(num)
			}

			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}

			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}

			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}

			return output
		}

		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 136 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 137 */
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */

	var isArray = Array.isArray;

	/**
	 * toString
	 */

	var str = Object.prototype.toString;

	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */

	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, Buffer) {(function() {
	  var g = ('undefined' === typeof window ? global : window) || {}
	  _crypto = (
	    g.crypto || g.msCrypto || __webpack_require__(139)
	  )
	  module.exports = function(size) {
	    // Modern Browsers
	    if(_crypto.getRandomValues) {
	      var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
	      /* This will not work in older browsers.
	       * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	       */
	    
	      _crypto.getRandomValues(bytes);
	      return bytes;
	    }
	    else if (_crypto.randomBytes) {
	      return _crypto.randomBytes(size)
	    }
	    else
	      throw new Error(
	        'secure random number generation not supported by this browser\n'+
	        'use chrome, FireFox or Internet Explorer 11'
	      )
	  }
	}())

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(134).Buffer))

/***/ },
/* 139 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(141)

	var md5 = toConstructor(__webpack_require__(149))
	var rmd160 = toConstructor(__webpack_require__(151))

	function toConstructor (fn) {
	  return function () {
	    var buffers = []
	    var m= {
	      update: function (data, enc) {
	        if(!Buffer.isBuffer(data)) data = new Buffer(data, enc)
	        buffers.push(data)
	        return this
	      },
	      digest: function (enc) {
	        var buf = Buffer.concat(buffers)
	        var r = fn(buf)
	        buffers = null
	        return enc ? r.toString(enc) : r
	      }
	    }
	    return m
	  }
	}

	module.exports = function (alg) {
	  if('md5' === alg) return new md5()
	  if('rmd160' === alg) return new rmd160()
	  return createHash(alg)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	var exports = module.exports = function (alg) {
	  var Alg = exports[alg]
	  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
	  return new Alg()
	}

	var Buffer = __webpack_require__(134).Buffer
	var Hash   = __webpack_require__(142)(Buffer)

	exports.sha1 = __webpack_require__(143)(Buffer, Hash)
	exports.sha256 = __webpack_require__(147)(Buffer, Hash)
	exports.sha512 = __webpack_require__(148)(Buffer, Hash)


/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = function (Buffer) {

	  //prototype class for hash functions
	  function Hash (blockSize, finalSize) {
	    this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
	    this._finalSize = finalSize
	    this._blockSize = blockSize
	    this._len = 0
	    this._s = 0
	  }

	  Hash.prototype.init = function () {
	    this._s = 0
	    this._len = 0
	  }

	  Hash.prototype.update = function (data, enc) {
	    if ("string" === typeof data) {
	      enc = enc || "utf8"
	      data = new Buffer(data, enc)
	    }

	    var l = this._len += data.length
	    var s = this._s = (this._s || 0)
	    var f = 0
	    var buffer = this._block

	    while (s < l) {
	      var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
	      var ch = (t - f)

	      for (var i = 0; i < ch; i++) {
	        buffer[(s % this._blockSize) + i] = data[i + f]
	      }

	      s += ch
	      f += ch

	      if ((s % this._blockSize) === 0) {
	        this._update(buffer)
	      }
	    }
	    this._s = s

	    return this
	  }

	  Hash.prototype.digest = function (enc) {
	    // Suppose the length of the message M, in bits, is l
	    var l = this._len * 8

	    // Append the bit 1 to the end of the message
	    this._block[this._len % this._blockSize] = 0x80

	    // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
	    this._block.fill(0, this._len % this._blockSize + 1)

	    if (l % (this._blockSize * 8) >= this._finalSize * 8) {
	      this._update(this._block)
	      this._block.fill(0)
	    }

	    // to this append the block which is equal to the number l written in binary
	    // TODO: handle case where l is > Math.pow(2, 29)
	    this._block.writeInt32BE(l, this._blockSize - 4)

	    var hash = this._update(this._block) || this._hash()

	    return enc ? hash.toString(enc) : hash
	  }

	  Hash.prototype._update = function () {
	    throw new Error('_update must be implemented by subclass')
	  }

	  return Hash
	}


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 */

	var inherits = __webpack_require__(144).inherits

	module.exports = function (Buffer, Hash) {

	  var A = 0|0
	  var B = 4|0
	  var C = 8|0
	  var D = 12|0
	  var E = 16|0

	  var W = new (typeof Int32Array === 'undefined' ? Array : Int32Array)(80)

	  var POOL = []

	  function Sha1 () {
	    if(POOL.length)
	      return POOL.pop().init()

	    if(!(this instanceof Sha1)) return new Sha1()
	    this._w = W
	    Hash.call(this, 16*4, 14*4)

	    this._h = null
	    this.init()
	  }

	  inherits(Sha1, Hash)

	  Sha1.prototype.init = function () {
	    this._a = 0x67452301
	    this._b = 0xefcdab89
	    this._c = 0x98badcfe
	    this._d = 0x10325476
	    this._e = 0xc3d2e1f0

	    Hash.prototype.init.call(this)
	    return this
	  }

	  Sha1.prototype._POOL = POOL
	  Sha1.prototype._update = function (X) {

	    var a, b, c, d, e, _a, _b, _c, _d, _e

	    a = _a = this._a
	    b = _b = this._b
	    c = _c = this._c
	    d = _d = this._d
	    e = _e = this._e

	    var w = this._w

	    for(var j = 0; j < 80; j++) {
	      var W = w[j] = j < 16 ? X.readInt32BE(j*4)
	        : rol(w[j - 3] ^ w[j -  8] ^ w[j - 14] ^ w[j - 16], 1)

	      var t = add(
	        add(rol(a, 5), sha1_ft(j, b, c, d)),
	        add(add(e, W), sha1_kt(j))
	      )

	      e = d
	      d = c
	      c = rol(b, 30)
	      b = a
	      a = t
	    }

	    this._a = add(a, _a)
	    this._b = add(b, _b)
	    this._c = add(c, _c)
	    this._d = add(d, _d)
	    this._e = add(e, _e)
	  }

	  Sha1.prototype._hash = function () {
	    if(POOL.length < 100) POOL.push(this)
	    var H = new Buffer(20)
	    //console.log(this._a|0, this._b|0, this._c|0, this._d|0, this._e|0)
	    H.writeInt32BE(this._a|0, A)
	    H.writeInt32BE(this._b|0, B)
	    H.writeInt32BE(this._c|0, C)
	    H.writeInt32BE(this._d|0, D)
	    H.writeInt32BE(this._e|0, E)
	    return H
	  }

	  /*
	   * Perform the appropriate triplet combination function for the current
	   * iteration
	   */
	  function sha1_ft(t, b, c, d) {
	    if(t < 20) return (b & c) | ((~b) & d);
	    if(t < 40) return b ^ c ^ d;
	    if(t < 60) return (b & c) | (b & d) | (c & d);
	    return b ^ c ^ d;
	  }

	  /*
	   * Determine the appropriate additive constant for the current iteration
	   */
	  function sha1_kt(t) {
	    return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
	           (t < 60) ? -1894007588 : -899497514;
	  }

	  /*
	   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	   * to work around bugs in some JS interpreters.
	   * //dominictarr: this is 10 years old, so maybe this can be dropped?)
	   *
	   */
	  function add(x, y) {
	    return (x + y ) | 0
	  //lets see how this goes on testling.
	  //  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  //  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  //  return (msw << 16) | (lsw & 0xFFFF);
	  }

	  /*
	   * Bitwise rotate a 32-bit number to the left.
	   */
	  function rol(num, cnt) {
	    return (num << cnt) | (num >>> (32 - cnt));
	  }

	  return Sha1
	}


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(145);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(146);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(25)))

/***/ },
/* 145 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 146 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
	 * in FIPS 180-2
	 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 *
	 */

	var inherits = __webpack_require__(144).inherits

	module.exports = function (Buffer, Hash) {

	  var K = [
	      0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	      0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	      0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	      0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	      0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	      0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	      0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	      0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	      0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	      0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	      0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	      0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	      0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	      0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	      0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	      0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	    ]

	  var W = new Array(64)

	  function Sha256() {
	    this.init()

	    this._w = W //new Array(64)

	    Hash.call(this, 16*4, 14*4)
	  }

	  inherits(Sha256, Hash)

	  Sha256.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, n) {
	    return (X >>> n) | (X << (32 - n));
	  }

	  function R (X, n) {
	    return (X >>> n);
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  function Sigma0256 (x) {
	    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
	  }

	  function Sigma1256 (x) {
	    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
	  }

	  function Gamma0256 (x) {
	    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
	  }

	  function Gamma1256 (x) {
	    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
	  }

	  Sha256.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var T1, T2

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    for (var j = 0; j < 64; j++) {
	      var w = W[j] = j < 16
	        ? M.readInt32BE(j * 4)
	        : Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16]

	      T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w

	      T2 = Sigma0256(a) + Maj(a, b, c);
	      h = g; g = f; f = e; e = d + T1; d = c; c = b; b = a; a = T1 + T2;
	    }

	    this._a = (a + this._a) | 0
	    this._b = (b + this._b) | 0
	    this._c = (c + this._c) | 0
	    this._d = (d + this._d) | 0
	    this._e = (e + this._e) | 0
	    this._f = (f + this._f) | 0
	    this._g = (g + this._g) | 0
	    this._h = (h + this._h) | 0

	  };

	  Sha256.prototype._hash = function () {
	    var H = new Buffer(32)

	    H.writeInt32BE(this._a,  0)
	    H.writeInt32BE(this._b,  4)
	    H.writeInt32BE(this._c,  8)
	    H.writeInt32BE(this._d, 12)
	    H.writeInt32BE(this._e, 16)
	    H.writeInt32BE(this._f, 20)
	    H.writeInt32BE(this._g, 24)
	    H.writeInt32BE(this._h, 28)

	    return H
	  }

	  return Sha256

	}


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	var inherits = __webpack_require__(144).inherits

	module.exports = function (Buffer, Hash) {
	  var K = [
	    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	  ]

	  var W = new Array(160)

	  function Sha512() {
	    this.init()
	    this._w = W

	    Hash.call(this, 128, 112)
	  }

	  inherits(Sha512, Hash)

	  Sha512.prototype.init = function () {

	    this._a = 0x6a09e667|0
	    this._b = 0xbb67ae85|0
	    this._c = 0x3c6ef372|0
	    this._d = 0xa54ff53a|0
	    this._e = 0x510e527f|0
	    this._f = 0x9b05688c|0
	    this._g = 0x1f83d9ab|0
	    this._h = 0x5be0cd19|0

	    this._al = 0xf3bcc908|0
	    this._bl = 0x84caa73b|0
	    this._cl = 0xfe94f82b|0
	    this._dl = 0x5f1d36f1|0
	    this._el = 0xade682d1|0
	    this._fl = 0x2b3e6c1f|0
	    this._gl = 0xfb41bd6b|0
	    this._hl = 0x137e2179|0

	    this._len = this._s = 0

	    return this
	  }

	  function S (X, Xl, n) {
	    return (X >>> n) | (Xl << (32 - n))
	  }

	  function Ch (x, y, z) {
	    return ((x & y) ^ ((~x) & z));
	  }

	  function Maj (x, y, z) {
	    return ((x & y) ^ (x & z) ^ (y & z));
	  }

	  Sha512.prototype._update = function(M) {

	    var W = this._w
	    var a, b, c, d, e, f, g, h
	    var al, bl, cl, dl, el, fl, gl, hl

	    a = this._a | 0
	    b = this._b | 0
	    c = this._c | 0
	    d = this._d | 0
	    e = this._e | 0
	    f = this._f | 0
	    g = this._g | 0
	    h = this._h | 0

	    al = this._al | 0
	    bl = this._bl | 0
	    cl = this._cl | 0
	    dl = this._dl | 0
	    el = this._el | 0
	    fl = this._fl | 0
	    gl = this._gl | 0
	    hl = this._hl | 0

	    for (var i = 0; i < 80; i++) {
	      var j = i * 2

	      var Wi, Wil

	      if (i < 16) {
	        Wi = W[j] = M.readInt32BE(j * 4)
	        Wil = W[j + 1] = M.readInt32BE(j * 4 + 4)

	      } else {
	        var x  = W[j - 15*2]
	        var xl = W[j - 15*2 + 1]
	        var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
	        var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

	        x  = W[j - 2*2]
	        xl = W[j - 2*2 + 1]
	        var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
	        var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

	        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	        var Wi7  = W[j - 7*2]
	        var Wi7l = W[j - 7*2 + 1]

	        var Wi16  = W[j - 16*2]
	        var Wi16l = W[j - 16*2 + 1]

	        Wil = gamma0l + Wi7l
	        Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
	        Wil = Wil + gamma1l
	        Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
	        Wil = Wil + Wi16l
	        Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)

	        W[j] = Wi
	        W[j + 1] = Wil
	      }

	      var maj = Maj(a, b, c)
	      var majl = Maj(al, bl, cl)

	      var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
	      var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
	      var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
	      var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

	      // t1 = h + sigma1 + ch + K[i] + W[i]
	      var Ki = K[j]
	      var Kil = K[j + 1]

	      var ch = Ch(e, f, g)
	      var chl = Ch(el, fl, gl)

	      var t1l = hl + sigma1l
	      var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
	      t1l = t1l + chl
	      t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
	      t1l = t1l + Kil
	      t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
	      t1l = t1l + Wil
	      t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

	      // t2 = sigma0 + maj
	      var t2l = sigma0l + majl
	      var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

	      h  = g
	      hl = gl
	      g  = f
	      gl = fl
	      f  = e
	      fl = el
	      el = (dl + t1l) | 0
	      e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	      d  = c
	      dl = cl
	      c  = b
	      cl = bl
	      b  = a
	      bl = al
	      al = (t1l + t2l) | 0
	      a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0
	    }

	    this._al = (this._al + al) | 0
	    this._bl = (this._bl + bl) | 0
	    this._cl = (this._cl + cl) | 0
	    this._dl = (this._dl + dl) | 0
	    this._el = (this._el + el) | 0
	    this._fl = (this._fl + fl) | 0
	    this._gl = (this._gl + gl) | 0
	    this._hl = (this._hl + hl) | 0

	    this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
	    this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
	    this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
	    this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
	    this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
	    this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
	    this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
	    this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
	  }

	  Sha512.prototype._hash = function () {
	    var H = new Buffer(64)

	    function writeInt64BE(h, l, offset) {
	      H.writeInt32BE(h, offset)
	      H.writeInt32BE(l, offset + 4)
	    }

	    writeInt64BE(this._a, this._al, 0)
	    writeInt64BE(this._b, this._bl, 8)
	    writeInt64BE(this._c, this._cl, 16)
	    writeInt64BE(this._d, this._dl, 24)
	    writeInt64BE(this._e, this._el, 32)
	    writeInt64BE(this._f, this._fl, 40)
	    writeInt64BE(this._g, this._gl, 48)
	    writeInt64BE(this._h, this._hl, 56)

	    return H
	  }

	  return Sha512

	}


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
	 * Digest Algorithm, as defined in RFC 1321.
	 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for more info.
	 */

	var helpers = __webpack_require__(150);

	/*
	 * Calculate the MD5 of an array of little-endian words, and a bit length
	 */
	function core_md5(x, len)
	{
	  /* append padding */
	  x[len >> 5] |= 0x80 << ((len) % 32);
	  x[(((len + 64) >>> 9) << 4) + 14] = len;

	  var a =  1732584193;
	  var b = -271733879;
	  var c = -1732584194;
	  var d =  271733878;

	  for(var i = 0; i < x.length; i += 16)
	  {
	    var olda = a;
	    var oldb = b;
	    var oldc = c;
	    var oldd = d;

	    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
	    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
	    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
	    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
	    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
	    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
	    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
	    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
	    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
	    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
	    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
	    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
	    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
	    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
	    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
	    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

	    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
	    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
	    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
	    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
	    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
	    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
	    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
	    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
	    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
	    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
	    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
	    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
	    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
	    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
	    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
	    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

	    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
	    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
	    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
	    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
	    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
	    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
	    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
	    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
	    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
	    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
	    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
	    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
	    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
	    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
	    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
	    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

	    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
	    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
	    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
	    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
	    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
	    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
	    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
	    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
	    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
	    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
	    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
	    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
	    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
	    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
	    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
	    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

	    a = safe_add(a, olda);
	    b = safe_add(b, oldb);
	    c = safe_add(c, oldc);
	    d = safe_add(d, oldd);
	  }
	  return Array(a, b, c, d);

	}

	/*
	 * These functions implement the four basic operations the algorithm uses.
	 */
	function md5_cmn(q, a, b, x, s, t)
	{
	  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
	}
	function md5_ff(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
	}
	function md5_gg(a, b, c, d, x, s, t)
	{
	  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
	}
	function md5_hh(a, b, c, d, x, s, t)
	{
	  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
	}
	function md5_ii(a, b, c, d, x, s, t)
	{
	  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
	}

	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */
	function safe_add(x, y)
	{
	  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
	  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
	  return (msw << 16) | (lsw & 0xFFFF);
	}

	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */
	function bit_rol(num, cnt)
	{
	  return (num << cnt) | (num >>> (32 - cnt));
	}

	module.exports = function md5(buf) {
	  return helpers.hash(buf, core_md5, 16);
	};


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var intSize = 4;
	var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
	var chrsz = 8;

	function toArray(buf, bigEndian) {
	  if ((buf.length % intSize) !== 0) {
	    var len = buf.length + (intSize - (buf.length % intSize));
	    buf = Buffer.concat([buf, zeroBuffer], len);
	  }

	  var arr = [];
	  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
	  for (var i = 0; i < buf.length; i += intSize) {
	    arr.push(fn.call(buf, i));
	  }
	  return arr;
	}

	function toBuffer(arr, size, bigEndian) {
	  var buf = new Buffer(size);
	  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
	  for (var i = 0; i < arr.length; i++) {
	    fn.call(buf, arr[i], i * 4, true);
	  }
	  return buf;
	}

	function hash(buf, fn, hashSize, bigEndian) {
	  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
	  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
	  return toBuffer(arr, hashSize, bigEndian);
	}

	module.exports = { hash: hash };

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {
	module.exports = ripemd160



	/*
	CryptoJS v3.1.2
	code.google.com/p/crypto-js
	(c) 2009-2013 by Jeff Mott. All rights reserved.
	code.google.com/p/crypto-js/wiki/License
	*/
	/** @preserve
	(c) 2012 by Cdric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	// Constants table
	var zl = [
	    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13];
	var zr = [
	    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11];
	var sl = [
	     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ];
	var sr = [
	    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ];

	var hl =  [ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
	var hr =  [ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];

	var bytesToWords = function (bytes) {
	  var words = [];
	  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
	    words[b >>> 5] |= bytes[i] << (24 - b % 32);
	  }
	  return words;
	};

	var wordsToBytes = function (words) {
	  var bytes = [];
	  for (var b = 0; b < words.length * 32; b += 8) {
	    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
	  }
	  return bytes;
	};

	var processBlock = function (H, M, offset) {

	  // Swap endian
	  for (var i = 0; i < 16; i++) {
	    var offset_i = offset + i;
	    var M_offset_i = M[offset_i];

	    // Swap
	    M[offset_i] = (
	        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	    );
	  }

	  // Working variables
	  var al, bl, cl, dl, el;
	  var ar, br, cr, dr, er;

	  ar = al = H[0];
	  br = bl = H[1];
	  cr = cl = H[2];
	  dr = dl = H[3];
	  er = el = H[4];
	  // Computation
	  var t;
	  for (var i = 0; i < 80; i += 1) {
	    t = (al +  M[offset+zl[i]])|0;
	    if (i<16){
	        t +=  f1(bl,cl,dl) + hl[0];
	    } else if (i<32) {
	        t +=  f2(bl,cl,dl) + hl[1];
	    } else if (i<48) {
	        t +=  f3(bl,cl,dl) + hl[2];
	    } else if (i<64) {
	        t +=  f4(bl,cl,dl) + hl[3];
	    } else {// if (i<80) {
	        t +=  f5(bl,cl,dl) + hl[4];
	    }
	    t = t|0;
	    t =  rotl(t,sl[i]);
	    t = (t+el)|0;
	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = t;

	    t = (ar + M[offset+zr[i]])|0;
	    if (i<16){
	        t +=  f5(br,cr,dr) + hr[0];
	    } else if (i<32) {
	        t +=  f4(br,cr,dr) + hr[1];
	    } else if (i<48) {
	        t +=  f3(br,cr,dr) + hr[2];
	    } else if (i<64) {
	        t +=  f2(br,cr,dr) + hr[3];
	    } else {// if (i<80) {
	        t +=  f1(br,cr,dr) + hr[4];
	    }
	    t = t|0;
	    t =  rotl(t,sr[i]) ;
	    t = (t+er)|0;
	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = t;
	  }
	  // Intermediate hash value
	  t    = (H[1] + cl + dr)|0;
	  H[1] = (H[2] + dl + er)|0;
	  H[2] = (H[3] + el + ar)|0;
	  H[3] = (H[4] + al + br)|0;
	  H[4] = (H[0] + bl + cr)|0;
	  H[0] =  t;
	};

	function f1(x, y, z) {
	  return ((x) ^ (y) ^ (z));
	}

	function f2(x, y, z) {
	  return (((x)&(y)) | ((~x)&(z)));
	}

	function f3(x, y, z) {
	  return (((x) | (~(y))) ^ (z));
	}

	function f4(x, y, z) {
	  return (((x) & (z)) | ((y)&(~(z))));
	}

	function f5(x, y, z) {
	  return ((x) ^ ((y) |(~(z))));
	}

	function rotl(x,n) {
	  return (x<<n) | (x>>>(32-n));
	}

	function ripemd160(message) {
	  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];

	  if (typeof message == 'string')
	    message = new Buffer(message, 'utf8');

	  var m = bytesToWords(message);

	  var nBitsLeft = message.length * 8;
	  var nBitsTotal = message.length * 8;

	  // Add padding
	  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	  );

	  for (var i=0 ; i<m.length; i += 16) {
	    processBlock(H, m, i);
	  }

	  // Swap endian
	  for (var i = 0; i < 5; i++) {
	      // Shortcut
	    var H_i = H[i];

	    // Swap
	    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	  }

	  var digestbytes = wordsToBytes(H);
	  return new Buffer(digestbytes);
	}



	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var createHash = __webpack_require__(140)

	var zeroBuffer = new Buffer(128)
	zeroBuffer.fill(0)

	module.exports = Hmac

	function Hmac (alg, key) {
	  if(!(this instanceof Hmac)) return new Hmac(alg, key)
	  this._opad = opad
	  this._alg = alg

	  var blocksize = (alg === 'sha512') ? 128 : 64

	  key = this._key = !Buffer.isBuffer(key) ? new Buffer(key) : key

	  if(key.length > blocksize) {
	    key = createHash(alg).update(key).digest()
	  } else if(key.length < blocksize) {
	    key = Buffer.concat([key, zeroBuffer], blocksize)
	  }

	  var ipad = this._ipad = new Buffer(blocksize)
	  var opad = this._opad = new Buffer(blocksize)

	  for(var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36
	    opad[i] = key[i] ^ 0x5C
	  }

	  this._hash = createHash(alg).update(ipad)
	}

	Hmac.prototype.update = function (data, enc) {
	  this._hash.update(data, enc)
	  return this
	}

	Hmac.prototype.digest = function (enc) {
	  var h = this._hash.digest()
	  return createHash(this._alg).update(this._opad).update(h).digest(enc)
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	var pbkdf2Export = __webpack_require__(154)

	module.exports = function (crypto, exports) {
	  exports = exports || {}

	  var exported = pbkdf2Export(crypto)

	  exports.pbkdf2 = exported.pbkdf2
	  exports.pbkdf2Sync = exported.pbkdf2Sync

	  return exports
	}


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function(crypto) {
	  function pbkdf2(password, salt, iterations, keylen, digest, callback) {
	    if ('function' === typeof digest) {
	      callback = digest
	      digest = undefined
	    }

	    if ('function' !== typeof callback)
	      throw new Error('No callback provided to pbkdf2')

	    setTimeout(function() {
	      var result

	      try {
	        result = pbkdf2Sync(password, salt, iterations, keylen, digest)
	      } catch (e) {
	        return callback(e)
	      }

	      callback(undefined, result)
	    })
	  }

	  function pbkdf2Sync(password, salt, iterations, keylen, digest) {
	    if ('number' !== typeof iterations)
	      throw new TypeError('Iterations not a number')

	    if (iterations < 0)
	      throw new TypeError('Bad iterations')

	    if ('number' !== typeof keylen)
	      throw new TypeError('Key length not a number')

	    if (keylen < 0)
	      throw new TypeError('Bad key length')

	    digest = digest || 'sha1'

	    if (!Buffer.isBuffer(password)) password = new Buffer(password)
	    if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

	    var hLen, l = 1, r, T
	    var DK = new Buffer(keylen)
	    var block1 = new Buffer(salt.length + 4)
	    salt.copy(block1, 0, 0, salt.length)

	    for (var i = 1; i <= l; i++) {
	      block1.writeUInt32BE(i, salt.length)

	      var U = crypto.createHmac(digest, password).update(block1).digest()

	      if (!hLen) {
	        hLen = U.length
	        T = new Buffer(hLen)
	        l = Math.ceil(keylen / hLen)
	        r = keylen - (l - 1) * hLen

	        if (keylen > (Math.pow(2, 32) - 1) * hLen)
	          throw new TypeError('keylen exceeds maximum length')
	      }

	      U.copy(T, 0, 0, hLen)

	      for (var j = 1; j < iterations; j++) {
	        U = crypto.createHmac(digest, password).update(U).digest()

	        for (var k = 0; k < hLen; k++) {
	          T[k] ^= U[k]
	        }
	      }

	      var destPos = (i - 1) * hLen
	      var len = (i == l ? r : hLen)
	      T.copy(DK, destPos, 0, len)
	    }

	    return DK
	  }

	  return {
	    pbkdf2: pbkdf2,
	    pbkdf2Sync: pbkdf2Sync
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(134).Buffer))

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	console.log("loading angular");
	__export(__webpack_require__(156));
	__export(__webpack_require__(466));
	__export(__webpack_require__(467));
	__export(__webpack_require__(468));
	//# sourceMappingURL=angular2.js.map

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	/**
	 * @module
	 * @description
	 * Starting point to import all public core APIs.
	 */
	__export(__webpack_require__(157));
	__export(__webpack_require__(213));
	__export(__webpack_require__(160));
	__export(__webpack_require__(214));
	__export(__webpack_require__(357));
	__export(__webpack_require__(358));
	__export(__webpack_require__(361));
	__export(__webpack_require__(453));
	__export(__webpack_require__(377));
	__export(__webpack_require__(454));
	__export(__webpack_require__(455));
	__export(__webpack_require__(404));
	__export(__webpack_require__(456));
	__export(__webpack_require__(363));
	__export(__webpack_require__(463));
	__export(__webpack_require__(178));
	var reflection_1 = __webpack_require__(170);
	exports.Reflector = reflection_1.Reflector;
	exports.ReflectionInfo = reflection_1.ReflectionInfo;
	//# sourceMappingURL=core.js.map

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * This indirection is needed to free up Component, etc symbols in the public API
	 * to be used by the decorator versions of these annotations.
	 */
	var di_1 = __webpack_require__(158);
	exports.QueryMetadata = di_1.QueryMetadata;
	exports.ViewQueryMetadata = di_1.ViewQueryMetadata;
	exports.AttributeMetadata = di_1.AttributeMetadata;
	var directives_1 = __webpack_require__(177);
	exports.ComponentMetadata = directives_1.ComponentMetadata;
	exports.DirectiveMetadata = directives_1.DirectiveMetadata;
	exports.PipeMetadata = directives_1.PipeMetadata;
	exports.PropertyMetadata = directives_1.PropertyMetadata;
	exports.EventMetadata = directives_1.EventMetadata;
	exports.HostBindingMetadata = directives_1.HostBindingMetadata;
	exports.HostListenerMetadata = directives_1.HostListenerMetadata;
	var view_1 = __webpack_require__(211);
	exports.ViewMetadata = view_1.ViewMetadata;
	exports.ViewEncapsulation = view_1.ViewEncapsulation;
	var di_2 = __webpack_require__(158);
	var directives_2 = __webpack_require__(177);
	var view_2 = __webpack_require__(211);
	var decorators_1 = __webpack_require__(163);
	/**
	 * {@link ComponentMetadata} factory function.
	 */
	exports.Component = decorators_1.makeDecorator(directives_2.ComponentMetadata, function (fn) { return fn.View = exports.View; });
	/**
	 * {@link DirectiveMetadata} factory function.
	 */
	exports.Directive = decorators_1.makeDecorator(directives_2.DirectiveMetadata);
	/**
	 * {@link ViewMetadata} factory function.
	 */
	exports.View = decorators_1.makeDecorator(view_2.ViewMetadata, function (fn) { return fn.View = exports.View; });
	/**
	 * {@link AttributeMetadata} factory function.
	 */
	exports.Attribute = decorators_1.makeParamDecorator(di_2.AttributeMetadata);
	/**
	 * {@link QueryMetadata} factory function.
	 */
	exports.Query = decorators_1.makeParamDecorator(di_2.QueryMetadata);
	/**
	 * {@link di/ViewQueryMetadata} factory function.
	 */
	exports.ViewQuery = decorators_1.makeParamDecorator(di_2.ViewQueryMetadata);
	/**
	 * {@link PipeMetadata} factory function.
	 */
	exports.Pipe = decorators_1.makeDecorator(directives_2.PipeMetadata);
	/**
	 * {@link PropertyMetadata} factory function.
	 */
	exports.Property = decorators_1.makePropDecorator(directives_2.PropertyMetadata);
	/**
	 * {@link EventMetadata} factory function.
	 */
	exports.Event = decorators_1.makePropDecorator(directives_2.EventMetadata);
	/**
	 * {@link HostBindingMetadata} factory function.
	 */
	exports.HostBinding = decorators_1.makePropDecorator(directives_2.HostBindingMetadata);
	/**
	 * {@link HostListenerMetadata} factory function.
	 */
	exports.HostListener = decorators_1.makePropDecorator(directives_2.HostListenerMetadata);
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var di_1 = __webpack_require__(160);
	/**
	 * Specifies that a constant attribute value should be injected.
	 *
	 * The directive can inject constant string literals of host element attributes.
	 *
	 * ## Example
	 *
	 * Suppose we have an `<input>` element and want to know its `type`.
	 *
	 * ```html
	 * <input type="text">
	 * ```
	 *
	 * A decorator can inject string literal `text` like so:
	 *
	 * ```javascript
	 * @Directive({
	 *   selector: `input'
	 * })
	 * class InputDirective {
	 *   constructor(@Attribute('type') type) {
	 *     // type would be `text` in this example
	 *   }
	 * }
	 * ```
	 */
	var AttributeMetadata = (function (_super) {
	    __extends(AttributeMetadata, _super);
	    function AttributeMetadata(attributeName) {
	        _super.call(this);
	        this.attributeName = attributeName;
	    }
	    Object.defineProperty(AttributeMetadata.prototype, "token", {
	        get: function () {
	            // Normally one would default a token to a type of an injected value but here
	            // the type of a variable is "string" and we can't use primitive type as a return value
	            // so we use instance of Attribute instead. This doesn't matter much in practice as arguments
	            // with @Attribute annotation are injected by ElementInjector that doesn't take tokens into
	            // account.
	            return this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AttributeMetadata.prototype.toString = function () { return "@Attribute(" + lang_1.stringify(this.attributeName) + ")"; };
	    AttributeMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [String])
	    ], AttributeMetadata);
	    return AttributeMetadata;
	})(di_1.DependencyMetadata);
	exports.AttributeMetadata = AttributeMetadata;
	/**
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * See {@link QueryList} for usage and example.
	 */
	var QueryMetadata = (function (_super) {
	    __extends(QueryMetadata, _super);
	    function QueryMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).descendants, descendants = _b === void 0 ? false : _b;
	        _super.call(this);
	        this._selector = _selector;
	        this.descendants = descendants;
	    }
	    Object.defineProperty(QueryMetadata.prototype, "isViewQuery", {
	        get: function () { return false; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "selector", {
	        get: function () { return di_1.resolveForwardRef(this._selector); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "isVarBindingQuery", {
	        get: function () { return lang_1.isString(this.selector); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryMetadata.prototype, "varBindings", {
	        get: function () { return lang_1.StringWrapper.split(this.selector, new RegExp(",")); },
	        enumerable: true,
	        configurable: true
	    });
	    QueryMetadata.prototype.toString = function () { return "@Query(" + lang_1.stringify(this.selector) + ")"; };
	    QueryMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object, Object])
	    ], QueryMetadata);
	    return QueryMetadata;
	})(di_1.DependencyMetadata);
	exports.QueryMetadata = QueryMetadata;
	/**
	 * Specifies that a {@link QueryList} should be injected.
	 *
	 * See {@link QueryList} for usage and example.
	 */
	var ViewQueryMetadata = (function (_super) {
	    __extends(ViewQueryMetadata, _super);
	    function ViewQueryMetadata(_selector, _a) {
	        var _b = (_a === void 0 ? {} : _a).descendants, descendants = _b === void 0 ? false : _b;
	        _super.call(this, _selector, { descendants: descendants });
	    }
	    Object.defineProperty(ViewQueryMetadata.prototype, "isViewQuery", {
	        get: function () { return true; },
	        enumerable: true,
	        configurable: true
	    });
	    ViewQueryMetadata.prototype.toString = function () { return "@ViewQuery(" + lang_1.stringify(this.selector) + ")"; };
	    ViewQueryMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object, Object])
	    ], ViewQueryMetadata);
	    return ViewQueryMetadata;
	})(QueryMetadata);
	exports.ViewQueryMetadata = ViewQueryMetadata;
	//# sourceMappingURL=di.js.map

/***/ },
/* 159 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/// <reference path="../../../manual_typings/globals.d.ts" />
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var globalScope;
	if (typeof window === 'undefined') {
	    if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
	        // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
	        globalScope = self;
	    }
	    else {
	        globalScope = global;
	    }
	}
	else {
	    globalScope = window;
	}
	;
	// Need to declare a new variable for global here since TypeScript
	// exports the original value of the symbol.
	var _global = globalScope;
	exports.global = _global;
	exports.Type = Function;
	function getTypeNameForDebugging(type) {
	    return type['name'];
	}
	exports.getTypeNameForDebugging = getTypeNameForDebugging;
	exports.Math = _global.Math;
	exports.Date = _global.Date;
	var assertionsEnabled_ = typeof _global['assert'] !== 'undefined';
	function assertionsEnabled() {
	    return assertionsEnabled_;
	}
	exports.assertionsEnabled = assertionsEnabled;
	// TODO: remove calls to assert in production environment
	// Note: Can't just export this and import in in other files
	// as `assert` is a reserved keyword in Dart
	_global.assert = function assert(condition) {
	    if (assertionsEnabled_) {
	        _global['assert'].call(condition);
	    }
	};
	// This function is needed only to properly support Dart's const expressions
	// see https://github.com/angular/ts2dart/pull/151 for more info
	function CONST_EXPR(expr) {
	    return expr;
	}
	exports.CONST_EXPR = CONST_EXPR;
	function CONST() {
	    return function (target) { return target; };
	}
	exports.CONST = CONST;
	function ABSTRACT() {
	    return function (t) { return t; };
	}
	exports.ABSTRACT = ABSTRACT;
	function isPresent(obj) {
	    return obj !== undefined && obj !== null;
	}
	exports.isPresent = isPresent;
	function isBlank(obj) {
	    return obj === undefined || obj === null;
	}
	exports.isBlank = isBlank;
	function isString(obj) {
	    return typeof obj === "string";
	}
	exports.isString = isString;
	function isFunction(obj) {
	    return typeof obj === "function";
	}
	exports.isFunction = isFunction;
	function isType(obj) {
	    return isFunction(obj);
	}
	exports.isType = isType;
	function isStringMap(obj) {
	    return typeof obj === 'object' && obj !== null;
	}
	exports.isStringMap = isStringMap;
	function isPromise(obj) {
	    return obj instanceof _global.Promise;
	}
	exports.isPromise = isPromise;
	function isArray(obj) {
	    return Array.isArray(obj);
	}
	exports.isArray = isArray;
	function isNumber(obj) {
	    return typeof obj === 'number';
	}
	exports.isNumber = isNumber;
	function isDate(obj) {
	    return obj instanceof exports.Date && !isNaN(obj.valueOf());
	}
	exports.isDate = isDate;
	function stringify(token) {
	    if (typeof token === 'string') {
	        return token;
	    }
	    if (token === undefined || token === null) {
	        return '' + token;
	    }
	    if (token.name) {
	        return token.name;
	    }
	    var res = token.toString();
	    var newLineIndex = res.indexOf("\n");
	    return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
	}
	exports.stringify = stringify;
	// serialize / deserialize enum exist only for consistency with dart API
	// enums in typescript don't need to be serialized
	function serializeEnum(val) {
	    return val;
	}
	exports.serializeEnum = serializeEnum;
	function deserializeEnum(val, values) {
	    return val;
	}
	exports.deserializeEnum = deserializeEnum;
	var StringWrapper = (function () {
	    function StringWrapper() {
	    }
	    StringWrapper.fromCharCode = function (code) { return String.fromCharCode(code); };
	    StringWrapper.charCodeAt = function (s, index) { return s.charCodeAt(index); };
	    StringWrapper.split = function (s, regExp) { return s.split(regExp); };
	    StringWrapper.equals = function (s, s2) { return s === s2; };
	    StringWrapper.replace = function (s, from, replace) {
	        return s.replace(from, replace);
	    };
	    StringWrapper.replaceAll = function (s, from, replace) {
	        return s.replace(from, replace);
	    };
	    StringWrapper.toUpperCase = function (s) { return s.toUpperCase(); };
	    StringWrapper.toLowerCase = function (s) { return s.toLowerCase(); };
	    StringWrapper.startsWith = function (s, start) { return s.startsWith(start); };
	    StringWrapper.substring = function (s, start, end) {
	        if (end === void 0) { end = null; }
	        return s.substring(start, end === null ? undefined : end);
	    };
	    StringWrapper.replaceAllMapped = function (s, from, cb) {
	        return s.replace(from, function () {
	            var matches = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                matches[_i - 0] = arguments[_i];
	            }
	            // Remove offset & string from the result array
	            matches.splice(-2, 2);
	            // The callback receives match, p1, ..., pn
	            return cb(matches);
	        });
	    };
	    StringWrapper.contains = function (s, substr) { return s.indexOf(substr) != -1; };
	    StringWrapper.compare = function (a, b) {
	        if (a < b) {
	            return -1;
	        }
	        else if (a > b) {
	            return 1;
	        }
	        else {
	            return 0;
	        }
	    };
	    return StringWrapper;
	})();
	exports.StringWrapper = StringWrapper;
	var StringJoiner = (function () {
	    function StringJoiner(parts) {
	        if (parts === void 0) { parts = []; }
	        this.parts = parts;
	    }
	    StringJoiner.prototype.add = function (part) { this.parts.push(part); };
	    StringJoiner.prototype.toString = function () { return this.parts.join(""); };
	    return StringJoiner;
	})();
	exports.StringJoiner = StringJoiner;
	var NumberParseError = (function (_super) {
	    __extends(NumberParseError, _super);
	    function NumberParseError(message) {
	        _super.call(this, message);
	        this.message = message;
	    }
	    NumberParseError.prototype.toString = function () { return this.message; };
	    return NumberParseError;
	})(Error);
	exports.NumberParseError = NumberParseError;
	var NumberWrapper = (function () {
	    function NumberWrapper() {
	    }
	    NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
	    NumberWrapper.equal = function (a, b) { return a === b; };
	    NumberWrapper.parseIntAutoRadix = function (text) {
	        var result = parseInt(text);
	        if (isNaN(result)) {
	            throw new NumberParseError("Invalid integer literal when parsing " + text);
	        }
	        return result;
	    };
	    NumberWrapper.parseInt = function (text, radix) {
	        if (radix == 10) {
	            if (/^(\-|\+)?[0-9]+$/.test(text)) {
	                return parseInt(text, radix);
	            }
	        }
	        else if (radix == 16) {
	            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
	                return parseInt(text, radix);
	            }
	        }
	        else {
	            var result = parseInt(text, radix);
	            if (!isNaN(result)) {
	                return result;
	            }
	        }
	        throw new NumberParseError("Invalid integer literal when parsing " + text + " in base " +
	            radix);
	    };
	    // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
	    NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
	    Object.defineProperty(NumberWrapper, "NaN", {
	        get: function () { return NaN; },
	        enumerable: true,
	        configurable: true
	    });
	    NumberWrapper.isNaN = function (value) { return isNaN(value); };
	    NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
	    return NumberWrapper;
	})();
	exports.NumberWrapper = NumberWrapper;
	exports.RegExp = _global.RegExp;
	var RegExpWrapper = (function () {
	    function RegExpWrapper() {
	    }
	    RegExpWrapper.create = function (regExpStr, flags) {
	        if (flags === void 0) { flags = ''; }
	        flags = flags.replace(/g/g, '');
	        return new _global.RegExp(regExpStr, flags + 'g');
	    };
	    RegExpWrapper.firstMatch = function (regExp, input) {
	        // Reset multimatch regex state
	        regExp.lastIndex = 0;
	        return regExp.exec(input);
	    };
	    RegExpWrapper.test = function (regExp, input) {
	        regExp.lastIndex = 0;
	        return regExp.test(input);
	    };
	    RegExpWrapper.matcher = function (regExp, input) {
	        // Reset regex state for the case
	        // someone did not loop over all matches
	        // last time.
	        regExp.lastIndex = 0;
	        return { re: regExp, input: input };
	    };
	    return RegExpWrapper;
	})();
	exports.RegExpWrapper = RegExpWrapper;
	var RegExpMatcherWrapper = (function () {
	    function RegExpMatcherWrapper() {
	    }
	    RegExpMatcherWrapper.next = function (matcher) {
	        return matcher.re.exec(matcher.input);
	    };
	    return RegExpMatcherWrapper;
	})();
	exports.RegExpMatcherWrapper = RegExpMatcherWrapper;
	var FunctionWrapper = (function () {
	    function FunctionWrapper() {
	    }
	    FunctionWrapper.apply = function (fn, posArgs) { return fn.apply(null, posArgs); };
	    return FunctionWrapper;
	})();
	exports.FunctionWrapper = FunctionWrapper;
	// JS has NaN !== NaN
	function looseIdentical(a, b) {
	    return a === b || typeof a === "number" && typeof b === "number" && isNaN(a) && isNaN(b);
	}
	exports.looseIdentical = looseIdentical;
	// JS considers NaN is the same as NaN for map Key (while NaN !== NaN otherwise)
	// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
	function getMapKey(value) {
	    return value;
	}
	exports.getMapKey = getMapKey;
	function normalizeBlank(obj) {
	    return isBlank(obj) ? null : obj;
	}
	exports.normalizeBlank = normalizeBlank;
	function normalizeBool(obj) {
	    return isBlank(obj) ? false : obj;
	}
	exports.normalizeBool = normalizeBool;
	function isJsObject(o) {
	    return o !== null && (typeof o === "function" || typeof o === "object");
	}
	exports.isJsObject = isJsObject;
	function print(obj) {
	    console.log(obj);
	}
	exports.print = print;
	// Can't be all uppercase as our transpiler would think it is a special directive...
	var Json = (function () {
	    function Json() {
	    }
	    Json.parse = function (s) { return _global.JSON.parse(s); };
	    Json.stringify = function (data) {
	        // Dart doesn't take 3 arguments
	        return _global.JSON.stringify(data, null, 2);
	    };
	    return Json;
	})();
	exports.Json = Json;
	var DateWrapper = (function () {
	    function DateWrapper() {
	    }
	    DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
	        if (month === void 0) { month = 1; }
	        if (day === void 0) { day = 1; }
	        if (hour === void 0) { hour = 0; }
	        if (minutes === void 0) { minutes = 0; }
	        if (seconds === void 0) { seconds = 0; }
	        if (milliseconds === void 0) { milliseconds = 0; }
	        return new exports.Date(year, month - 1, day, hour, minutes, seconds, milliseconds);
	    };
	    DateWrapper.fromMillis = function (ms) { return new exports.Date(ms); };
	    DateWrapper.toMillis = function (date) { return date.getTime(); };
	    DateWrapper.now = function () { return new exports.Date(); };
	    DateWrapper.toJson = function (date) { return date.toJSON(); };
	    return DateWrapper;
	})();
	exports.DateWrapper = DateWrapper;
	function setValueOnPath(global, path, value) {
	    var parts = path.split('.');
	    var obj = global;
	    while (parts.length > 1) {
	        var name = parts.shift();
	        if (obj.hasOwnProperty(name) && obj[name]) {
	            obj = obj[name];
	        }
	        else {
	            obj = obj[name] = {};
	        }
	    }
	    obj[parts.shift()] = value;
	}
	exports.setValueOnPath = setValueOnPath;
	//# sourceMappingURL=lang.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * The `di` module provides dependency injection container services.
	 */
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var metadata_1 = __webpack_require__(161);
	exports.InjectMetadata = metadata_1.InjectMetadata;
	exports.OptionalMetadata = metadata_1.OptionalMetadata;
	exports.InjectableMetadata = metadata_1.InjectableMetadata;
	exports.SelfMetadata = metadata_1.SelfMetadata;
	exports.HostMetadata = metadata_1.HostMetadata;
	exports.SkipSelfMetadata = metadata_1.SkipSelfMetadata;
	exports.DependencyMetadata = metadata_1.DependencyMetadata;
	// we have to reexport * because Dart and TS export two different sets of types
	__export(__webpack_require__(162));
	var forward_ref_1 = __webpack_require__(164);
	exports.forwardRef = forward_ref_1.forwardRef;
	exports.resolveForwardRef = forward_ref_1.resolveForwardRef;
	var injector_1 = __webpack_require__(165);
	exports.Injector = injector_1.Injector;
	exports.ProtoInjector = injector_1.ProtoInjector;
	exports.BindingWithVisibility = injector_1.BindingWithVisibility;
	exports.Visibility = injector_1.Visibility;
	exports.UNDEFINED = injector_1.UNDEFINED;
	var binding_1 = __webpack_require__(167);
	exports.Binding = binding_1.Binding;
	exports.BindingBuilder = binding_1.BindingBuilder;
	exports.ResolvedBinding = binding_1.ResolvedBinding;
	exports.ResolvedFactory = binding_1.ResolvedFactory;
	exports.Dependency = binding_1.Dependency;
	exports.bind = binding_1.bind;
	var key_1 = __webpack_require__(173);
	exports.Key = key_1.Key;
	exports.KeyRegistry = key_1.KeyRegistry;
	exports.TypeLiteral = key_1.TypeLiteral;
	var exceptions_1 = __webpack_require__(175);
	exports.NoBindingError = exceptions_1.NoBindingError;
	exports.AbstractBindingError = exceptions_1.AbstractBindingError;
	exports.CyclicDependencyError = exceptions_1.CyclicDependencyError;
	exports.InstantiationError = exceptions_1.InstantiationError;
	exports.InvalidBindingError = exceptions_1.InvalidBindingError;
	exports.NoAnnotationError = exceptions_1.NoAnnotationError;
	exports.OutOfBoundsError = exceptions_1.OutOfBoundsError;
	var opaque_token_1 = __webpack_require__(176);
	exports.OpaqueToken = opaque_token_1.OpaqueToken;
	//# sourceMappingURL=di.js.map

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	/**
	 * A parameter metadata that specifies a dependency.
	 *
	 * ```
	 * class AComponent {
	 *   constructor(@Inject(MyService) aService:MyService) {}
	 * }
	 * ```
	 */
	var InjectMetadata = (function () {
	    function InjectMetadata(token) {
	        this.token = token;
	    }
	    InjectMetadata.prototype.toString = function () { return "@Inject(" + lang_1.stringify(this.token) + ")"; };
	    InjectMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object])
	    ], InjectMetadata);
	    return InjectMetadata;
	})();
	exports.InjectMetadata = InjectMetadata;
	/**
	 * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
	 * the dependency is not found.
	 *
	 * ```
	 * class AComponent {
	 *   constructor(@Optional() aService:MyService) {
	 *     this.aService = aService;
	 *   }
	 * }
	 * ```
	 */
	var OptionalMetadata = (function () {
	    function OptionalMetadata() {
	    }
	    OptionalMetadata.prototype.toString = function () { return "@Optional()"; };
	    OptionalMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], OptionalMetadata);
	    return OptionalMetadata;
	})();
	exports.OptionalMetadata = OptionalMetadata;
	/**
	 * `DependencyMetadata is used by the framework to extend DI.
	 *
	 * Only metadata implementing `DependencyMetadata` are added to the list of dependency
	 * properties.
	 *
	 * For example:
	 *
	 * ```
	 * class Exclude extends DependencyMetadata {}
	 * class NotDependencyProperty {}
	 *
	 * class AComponent {
	 *   constructor(@Exclude @NotDependencyProperty aService:AService) {}
	 * }
	 * ```
	 *
	 * will create the following dependency:
	 *
	 * ```
	 * new Dependency(Key.get(AService), [new Exclude()])
	 * ```
	 *
	 * The framework can use `new Exclude()` to handle the `aService` dependency
	 * in a specific way.
	 */
	var DependencyMetadata = (function () {
	    function DependencyMetadata() {
	    }
	    Object.defineProperty(DependencyMetadata.prototype, "token", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    DependencyMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], DependencyMetadata);
	    return DependencyMetadata;
	})();
	exports.DependencyMetadata = DependencyMetadata;
	/**
	 * A marker metadata that marks a class as available to `Injector` for creation. Used by tooling
	 * for generating constructor stubs.
	 *
	 * ```
	 * class NeedsService {
	 *   constructor(svc:UsefulService) {}
	 * }
	 *
	 * @Injectable
	 * class UsefulService {}
	 * ```
	 */
	var InjectableMetadata = (function () {
	    function InjectableMetadata() {
	    }
	    InjectableMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], InjectableMetadata);
	    return InjectableMetadata;
	})();
	exports.InjectableMetadata = InjectableMetadata;
	/**
	 * Specifies that an injector should retrieve a dependency from itself.
	 *
	 * ## Example
	 *
	 * ```
	 * class Dependency {
	 * }
	 *
	 * class NeedsDependency {
	 *   constructor(public @Self() dependency:Dependency) {}
	 * }
	 *
	 * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
	 * var nd = inj.get(NeedsDependency);
	 * expect(nd.dependency).toBeAnInstanceOf(Dependency);
	 * ```
	 */
	var SelfMetadata = (function () {
	    function SelfMetadata() {
	    }
	    SelfMetadata.prototype.toString = function () { return "@Self()"; };
	    SelfMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], SelfMetadata);
	    return SelfMetadata;
	})();
	exports.SelfMetadata = SelfMetadata;
	/**
	 * Specifies that the dependency resolution should start from the parent injector.
	 *
	 * ## Example
	 *
	 *
	 * ```
	 * class Service {}
	 *
	 * class ParentService implements Service {
	 * }
	 *
	 * class ChildService implements Service {
	 *   constructor(public @SkipSelf() parentService:Service) {}
	 * }
	 *
	 * var parent = Injector.resolveAndCreate([
	 *   bind(Service).toClass(ParentService)
	 * ]);
	 * var child = parent.resolveAndCreateChild([
	 *   bind(Service).toClass(ChildSerice)
	 * ]);
	 * var s = child.get(Service);
	 * expect(s).toBeAnInstanceOf(ChildService);
	 * expect(s.parentService).toBeAnInstanceOf(ParentService);
	 * ```
	 */
	var SkipSelfMetadata = (function () {
	    function SkipSelfMetadata() {
	    }
	    SkipSelfMetadata.prototype.toString = function () { return "@SkipSelf()"; };
	    SkipSelfMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], SkipSelfMetadata);
	    return SkipSelfMetadata;
	})();
	exports.SkipSelfMetadata = SkipSelfMetadata;
	/**
	 * Specifies that an injector should retrieve a dependency from any injector until reaching the
	 * closest host.
	 *
	 * ## Example
	 *
	 * ```
	 * class Dependency {
	 * }
	 *
	 * class NeedsDependency {
	 *   constructor(public @Host() dependency:Dependency) {}
	 * }
	 *
	 * var parent = Injector.resolveAndCreate([
	 *   bind(Dependency).toClass(HostDependency)
	 * ]);
	 * var child = parent.resolveAndCreateChild([]);
	 * var grandChild = child.resolveAndCreateChild([NeedsDependency, Depedency]);
	 * var nd = grandChild.get(NeedsDependency);
	 * expect(nd.dependency).toBeAnInstanceOf(HostDependency);
	 * ```
	 */
	var HostMetadata = (function () {
	    function HostMetadata() {
	    }
	    HostMetadata.prototype.toString = function () { return "@Host()"; };
	    HostMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], HostMetadata);
	    return HostMetadata;
	})();
	exports.HostMetadata = HostMetadata;
	//# sourceMappingURL=metadata.js.map

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var metadata_1 = __webpack_require__(161);
	var decorators_1 = __webpack_require__(163);
	/**
	 * Factory for creating {@link InjectMetadata}.
	 */
	exports.Inject = decorators_1.makeParamDecorator(metadata_1.InjectMetadata);
	/**
	 * Factory for creating {@link OptionalMetadata}.
	 */
	exports.Optional = decorators_1.makeParamDecorator(metadata_1.OptionalMetadata);
	/**
	 * Factory for creating {@link InjectableMetadata}.
	 */
	exports.Injectable = decorators_1.makeDecorator(metadata_1.InjectableMetadata);
	/**
	 * Factory for creating {@link SelfMetadata}.
	 */
	exports.Self = decorators_1.makeParamDecorator(metadata_1.SelfMetadata);
	/**
	 * Factory for creating {@link HostMetadata}.
	 */
	exports.Host = decorators_1.makeParamDecorator(metadata_1.HostMetadata);
	/**
	 * Factory for creating {@link SkipSelfMetadata}.
	 */
	exports.SkipSelf = decorators_1.makeParamDecorator(metadata_1.SkipSelfMetadata);
	//# sourceMappingURL=decorators.js.map

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	function extractAnnotation(annotation) {
	    if (lang_1.isFunction(annotation) && annotation.hasOwnProperty('annotation')) {
	        // it is a decorator, extract annotation
	        annotation = annotation.annotation;
	    }
	    return annotation;
	}
	function applyParams(fnOrArray, key) {
	    if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||
	        fnOrArray === Number || fnOrArray === Array) {
	        throw new Error("Can not use native " + lang_1.stringify(fnOrArray) + " as constructor");
	    }
	    if (lang_1.isFunction(fnOrArray)) {
	        return fnOrArray;
	    }
	    else if (fnOrArray instanceof Array) {
	        var annotations = fnOrArray;
	        var fn = fnOrArray[fnOrArray.length - 1];
	        if (!lang_1.isFunction(fn)) {
	            throw new Error("Last position of Class method array must be Function in key " + key + " was '" + lang_1.stringify(fn) + "'");
	        }
	        var annoLength = annotations.length - 1;
	        if (annoLength != fn.length) {
	            throw new Error("Number of annotations (" + annoLength + ") does not match number of arguments (" + fn.length + ") in the function: " + lang_1.stringify(fn));
	        }
	        var paramsAnnotations = [];
	        for (var i = 0, ii = annotations.length - 1; i < ii; i++) {
	            var paramAnnotations = [];
	            paramsAnnotations.push(paramAnnotations);
	            var annotation = annotations[i];
	            if (annotation instanceof Array) {
	                for (var j = 0; j < annotation.length; j++) {
	                    paramAnnotations.push(extractAnnotation(annotation[j]));
	                }
	            }
	            else if (lang_1.isFunction(annotation)) {
	                paramAnnotations.push(extractAnnotation(annotation));
	            }
	            else {
	                paramAnnotations.push(annotation);
	            }
	        }
	        Reflect.defineMetadata('parameters', paramsAnnotations, fn);
	        return fn;
	    }
	    else {
	        throw new Error("Only Function or Array is supported in Class definition for key '" + key + "' is '" + lang_1.stringify(fnOrArray) + "'");
	    }
	}
	/**
	 * Provides a way for expressing ES6 classes with parameter annotations in ES5.
	 *
	 * ## Basic Example
	 *
	 * ```
	 * var Greeter = ng.Class({
	 *   constructor: function(name) {
	 *     this.name = name;
	 *   },
	 *
	 *   greet: function() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class Greeter {
	 *   constructor(name) {
	 *     this.name = name;
	 *   }
	 *
	 *   greet() {
	 *     alert('Hello ' + this.name + '!');
	 *   }
	 * }
	 * ```
	 *
	 * or equivalent to ES5:
	 *
	 * ```
	 * var Greeter = function (name) {
	 *   this.name = name;
	 * }
	 *
	 * Greeter.prototype.greet = function () {
	 *   alert('Hello ' + this.name + '!');
	 * }
	 * ```
	 *
	 * ## Example with parameter annotations
	 *
	 * ```
	 * var MyService = ng.Class({
	 *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
	 *     ...
	 *   }]
	 * });
	 * ```
	 *
	 * is equivalent to ES6:
	 *
	 * ```
	 * class MyService {
	 *   constructor(name: string, @Query() queryList: QueryList) {
	 *     ...
	 *   }
	 * }
	 * ```
	 *
	 * ## Example with inheritance
	 *
	 * ```
	 * var Shape = ng.Class({
	 *   constructor: (color) {
	 *     this.color = color;
	 *   }
	 * });
	 *
	 * var Square = ng.Class({
	 *   extends: Shape,
	 *   constructor: function(color, size) {
	 *     Shape.call(this, color);
	 *     this.size = size;
	 *   }
	 * });
	 * ```
	 */
	function Class(clsDef) {
	    var constructor = applyParams(clsDef.hasOwnProperty('constructor') ? clsDef.constructor : undefined, 'constructor');
	    var proto = constructor.prototype;
	    if (clsDef.hasOwnProperty('extends')) {
	        if (lang_1.isFunction(clsDef.extends)) {
	            constructor.prototype = proto =
	                Object.create(clsDef.extends.prototype);
	        }
	        else {
	            throw new Error("Class definition 'extends' property must be a constructor function was: " + lang_1.stringify(clsDef.extends));
	        }
	    }
	    for (var key in clsDef) {
	        if (key != 'extends' && key != 'prototype' && clsDef.hasOwnProperty(key)) {
	            proto[key] = applyParams(clsDef[key], key);
	        }
	    }
	    if (this && this.annotations instanceof Array) {
	        Reflect.defineMetadata('annotations', this.annotations, constructor);
	    }
	    return constructor;
	}
	exports.Class = Class;
	var Reflect = lang_1.global.Reflect;
	if (!(Reflect && Reflect.getMetadata)) {
	    throw 'reflect-metadata shim is required when using class decorators';
	}
	function makeDecorator(annotationCls, chainFn) {
	    if (chainFn === void 0) { chainFn = null; }
	    function DecoratorFactory(objOrType) {
	        var annotationInstance = new annotationCls(objOrType);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        }
	        else {
	            var chainAnnotation = lang_1.isFunction(this) && this.annotations instanceof Array ? this.annotations : [];
	            chainAnnotation.push(annotationInstance);
	            var TypeDecorator = function TypeDecorator(cls) {
	                var annotations = Reflect.getOwnMetadata('annotations', cls);
	                annotations = annotations || [];
	                annotations.push(annotationInstance);
	                Reflect.defineMetadata('annotations', annotations, cls);
	                return cls;
	            };
	            TypeDecorator.annotations = chainAnnotation;
	            TypeDecorator.Class = Class;
	            if (chainFn)
	                chainFn(TypeDecorator);
	            return TypeDecorator;
	        }
	    }
	    DecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    return DecoratorFactory;
	}
	exports.makeDecorator = makeDecorator;
	function makeParamDecorator(annotationCls) {
	    function ParamDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var annotationInstance = Object.create(annotationCls.prototype);
	        annotationCls.apply(annotationInstance, args);
	        if (this instanceof annotationCls) {
	            return annotationInstance;
	        }
	        else {
	            ParamDecorator.annotation = annotationInstance;
	            return ParamDecorator;
	        }
	        function ParamDecorator(cls, unusedKey, index) {
	            var parameters = Reflect.getMetadata('parameters', cls);
	            parameters = parameters || [];
	            // there might be gaps if some in between parameters do not have annotations.
	            // we pad with nulls.
	            while (parameters.length <= index) {
	                parameters.push(null);
	            }
	            parameters[index] = parameters[index] || [];
	            var annotationsForParam = parameters[index];
	            annotationsForParam.push(annotationInstance);
	            Reflect.defineMetadata('parameters', parameters, cls);
	            return cls;
	        }
	    }
	    ParamDecoratorFactory.prototype = Object.create(annotationCls.prototype);
	    return ParamDecoratorFactory;
	}
	exports.makeParamDecorator = makeParamDecorator;
	function makePropDecorator(decoratorCls) {
	    function PropDecoratorFactory() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var decoratorInstance = Object.create(decoratorCls.prototype);
	        decoratorCls.apply(decoratorInstance, args);
	        if (this instanceof decoratorCls) {
	            return decoratorInstance;
	        }
	        else {
	            return function PropDecorator(target, name) {
	                var meta = Reflect.getOwnMetadata('propMetadata', target.constructor);
	                meta = meta || {};
	                meta[name] = meta[name] || [];
	                meta[name].unshift(decoratorInstance);
	                Reflect.defineMetadata('propMetadata', meta, target.constructor);
	            };
	        }
	    }
	    PropDecoratorFactory.prototype = Object.create(decoratorCls.prototype);
	    return PropDecoratorFactory;
	}
	exports.makePropDecorator = makePropDecorator;
	//# sourceMappingURL=decorators.js.map

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	/**
	 * Allows to refer to references which are not yet defined.
	 *
	 * This situation arises when the key which we need to refer to for the purposes of DI is declared,
	 * but not yet defined.
	 *
	 * ## Example:
	 *
	 * ```
	 * class Door {
	 *   // Incorrect way to refer to a reference which is defined later.
	 *   // This fails because `Lock` is undefined at this point.
	 *   constructor(lock:Lock) { }
	 *
	 *   // Correct way to refer to a reference which is defined later.
	 *   // The reference needs to be captured in a closure.
	 *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }
	 * }
	 *
	 * // Only at this point the lock is defined.
	 * class Lock {
	 * }
	 * ```
	 */
	function forwardRef(forwardRefFn) {
	    forwardRefFn.__forward_ref__ = forwardRef;
	    forwardRefFn.toString = function () { return lang_1.stringify(this()); };
	    return forwardRefFn;
	}
	exports.forwardRef = forwardRef;
	/**
	 * Lazily retrieve the reference value.
	 *
	 * See: {@link forwardRef}
	 */
	function resolveForwardRef(type) {
	    if (lang_1.isFunction(type) && type.hasOwnProperty('__forward_ref__') &&
	        type.__forward_ref__ === forwardRef) {
	        return type();
	    }
	    else {
	        return type;
	    }
	}
	exports.resolveForwardRef = resolveForwardRef;
	//# sourceMappingURL=forward_ref.js.map

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var binding_1 = __webpack_require__(167);
	var exceptions_1 = __webpack_require__(175);
	var lang_1 = __webpack_require__(159);
	var key_1 = __webpack_require__(173);
	var metadata_1 = __webpack_require__(161);
	// Threshold for the dynamic version
	var _MAX_CONSTRUCTION_COUNTER = 10;
	exports.UNDEFINED = lang_1.CONST_EXPR(new Object());
	/**
	 * Visibility of a {@link Binding}.
	 */
	(function (Visibility) {
	    /**
	     * A `Public` {@link Binding} is only visible to regular (as opposed to host) child injectors.
	     */
	    Visibility[Visibility["Public"] = 0] = "Public";
	    /**
	     * A `Private` {@link Binding} is only visible to host (as opposed to regular) child injectors.
	     */
	    Visibility[Visibility["Private"] = 1] = "Private";
	    /**
	     * A `PublicAndPrivate` {@link Binding} is visible to both host and regular child injectors.
	     */
	    Visibility[Visibility["PublicAndPrivate"] = 2] = "PublicAndPrivate";
	})(exports.Visibility || (exports.Visibility = {}));
	var Visibility = exports.Visibility;
	function canSee(src, dst) {
	    return (src === dst) ||
	        (dst === Visibility.PublicAndPrivate || src === Visibility.PublicAndPrivate);
	}
	var ProtoInjectorInlineStrategy = (function () {
	    function ProtoInjectorInlineStrategy(protoEI, bwv) {
	        this.binding0 = null;
	        this.binding1 = null;
	        this.binding2 = null;
	        this.binding3 = null;
	        this.binding4 = null;
	        this.binding5 = null;
	        this.binding6 = null;
	        this.binding7 = null;
	        this.binding8 = null;
	        this.binding9 = null;
	        this.keyId0 = null;
	        this.keyId1 = null;
	        this.keyId2 = null;
	        this.keyId3 = null;
	        this.keyId4 = null;
	        this.keyId5 = null;
	        this.keyId6 = null;
	        this.keyId7 = null;
	        this.keyId8 = null;
	        this.keyId9 = null;
	        this.visibility0 = null;
	        this.visibility1 = null;
	        this.visibility2 = null;
	        this.visibility3 = null;
	        this.visibility4 = null;
	        this.visibility5 = null;
	        this.visibility6 = null;
	        this.visibility7 = null;
	        this.visibility8 = null;
	        this.visibility9 = null;
	        var length = bwv.length;
	        if (length > 0) {
	            this.binding0 = bwv[0].binding;
	            this.keyId0 = bwv[0].getKeyId();
	            this.visibility0 = bwv[0].visibility;
	        }
	        if (length > 1) {
	            this.binding1 = bwv[1].binding;
	            this.keyId1 = bwv[1].getKeyId();
	            this.visibility1 = bwv[1].visibility;
	        }
	        if (length > 2) {
	            this.binding2 = bwv[2].binding;
	            this.keyId2 = bwv[2].getKeyId();
	            this.visibility2 = bwv[2].visibility;
	        }
	        if (length > 3) {
	            this.binding3 = bwv[3].binding;
	            this.keyId3 = bwv[3].getKeyId();
	            this.visibility3 = bwv[3].visibility;
	        }
	        if (length > 4) {
	            this.binding4 = bwv[4].binding;
	            this.keyId4 = bwv[4].getKeyId();
	            this.visibility4 = bwv[4].visibility;
	        }
	        if (length > 5) {
	            this.binding5 = bwv[5].binding;
	            this.keyId5 = bwv[5].getKeyId();
	            this.visibility5 = bwv[5].visibility;
	        }
	        if (length > 6) {
	            this.binding6 = bwv[6].binding;
	            this.keyId6 = bwv[6].getKeyId();
	            this.visibility6 = bwv[6].visibility;
	        }
	        if (length > 7) {
	            this.binding7 = bwv[7].binding;
	            this.keyId7 = bwv[7].getKeyId();
	            this.visibility7 = bwv[7].visibility;
	        }
	        if (length > 8) {
	            this.binding8 = bwv[8].binding;
	            this.keyId8 = bwv[8].getKeyId();
	            this.visibility8 = bwv[8].visibility;
	        }
	        if (length > 9) {
	            this.binding9 = bwv[9].binding;
	            this.keyId9 = bwv[9].getKeyId();
	            this.visibility9 = bwv[9].visibility;
	        }
	    }
	    ProtoInjectorInlineStrategy.prototype.getBindingAtIndex = function (index) {
	        if (index == 0)
	            return this.binding0;
	        if (index == 1)
	            return this.binding1;
	        if (index == 2)
	            return this.binding2;
	        if (index == 3)
	            return this.binding3;
	        if (index == 4)
	            return this.binding4;
	        if (index == 5)
	            return this.binding5;
	        if (index == 6)
	            return this.binding6;
	        if (index == 7)
	            return this.binding7;
	        if (index == 8)
	            return this.binding8;
	        if (index == 9)
	            return this.binding9;
	        throw new exceptions_1.OutOfBoundsError(index);
	    };
	    ProtoInjectorInlineStrategy.prototype.createInjectorStrategy = function (injector) {
	        return new InjectorInlineStrategy(injector, this);
	    };
	    return ProtoInjectorInlineStrategy;
	})();
	exports.ProtoInjectorInlineStrategy = ProtoInjectorInlineStrategy;
	var ProtoInjectorDynamicStrategy = (function () {
	    function ProtoInjectorDynamicStrategy(protoInj, bwv) {
	        var len = bwv.length;
	        this.bindings = collection_1.ListWrapper.createFixedSize(len);
	        this.keyIds = collection_1.ListWrapper.createFixedSize(len);
	        this.visibilities = collection_1.ListWrapper.createFixedSize(len);
	        for (var i = 0; i < len; i++) {
	            this.bindings[i] = bwv[i].binding;
	            this.keyIds[i] = bwv[i].getKeyId();
	            this.visibilities[i] = bwv[i].visibility;
	        }
	    }
	    ProtoInjectorDynamicStrategy.prototype.getBindingAtIndex = function (index) {
	        if (index < 0 || index >= this.bindings.length) {
	            throw new exceptions_1.OutOfBoundsError(index);
	        }
	        return this.bindings[index];
	    };
	    ProtoInjectorDynamicStrategy.prototype.createInjectorStrategy = function (ei) {
	        return new InjectorDynamicStrategy(this, ei);
	    };
	    return ProtoInjectorDynamicStrategy;
	})();
	exports.ProtoInjectorDynamicStrategy = ProtoInjectorDynamicStrategy;
	var ProtoInjector = (function () {
	    function ProtoInjector(bwv) {
	        this.numberOfBindings = bwv.length;
	        this._strategy = bwv.length > _MAX_CONSTRUCTION_COUNTER ?
	            new ProtoInjectorDynamicStrategy(this, bwv) :
	            new ProtoInjectorInlineStrategy(this, bwv);
	    }
	    ProtoInjector.prototype.getBindingAtIndex = function (index) { return this._strategy.getBindingAtIndex(index); };
	    return ProtoInjector;
	})();
	exports.ProtoInjector = ProtoInjector;
	var InjectorInlineStrategy = (function () {
	    function InjectorInlineStrategy(injector, protoStrategy) {
	        this.injector = injector;
	        this.protoStrategy = protoStrategy;
	        this.obj0 = exports.UNDEFINED;
	        this.obj1 = exports.UNDEFINED;
	        this.obj2 = exports.UNDEFINED;
	        this.obj3 = exports.UNDEFINED;
	        this.obj4 = exports.UNDEFINED;
	        this.obj5 = exports.UNDEFINED;
	        this.obj6 = exports.UNDEFINED;
	        this.obj7 = exports.UNDEFINED;
	        this.obj8 = exports.UNDEFINED;
	        this.obj9 = exports.UNDEFINED;
	    }
	    InjectorInlineStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	    InjectorInlineStrategy.prototype.instantiateBinding = function (binding, visibility) {
	        return this.injector._new(binding, visibility);
	    };
	    InjectorInlineStrategy.prototype.attach = function (parent, isHost) {
	        var inj = this.injector;
	        inj._parent = parent;
	        inj._isHost = isHost;
	    };
	    InjectorInlineStrategy.prototype.getObjByKeyId = function (keyId, visibility) {
	        var p = this.protoStrategy;
	        var inj = this.injector;
	        if (p.keyId0 === keyId && canSee(p.visibility0, visibility)) {
	            if (this.obj0 === exports.UNDEFINED) {
	                this.obj0 = inj._new(p.binding0, p.visibility0);
	            }
	            return this.obj0;
	        }
	        if (p.keyId1 === keyId && canSee(p.visibility1, visibility)) {
	            if (this.obj1 === exports.UNDEFINED) {
	                this.obj1 = inj._new(p.binding1, p.visibility1);
	            }
	            return this.obj1;
	        }
	        if (p.keyId2 === keyId && canSee(p.visibility2, visibility)) {
	            if (this.obj2 === exports.UNDEFINED) {
	                this.obj2 = inj._new(p.binding2, p.visibility2);
	            }
	            return this.obj2;
	        }
	        if (p.keyId3 === keyId && canSee(p.visibility3, visibility)) {
	            if (this.obj3 === exports.UNDEFINED) {
	                this.obj3 = inj._new(p.binding3, p.visibility3);
	            }
	            return this.obj3;
	        }
	        if (p.keyId4 === keyId && canSee(p.visibility4, visibility)) {
	            if (this.obj4 === exports.UNDEFINED) {
	                this.obj4 = inj._new(p.binding4, p.visibility4);
	            }
	            return this.obj4;
	        }
	        if (p.keyId5 === keyId && canSee(p.visibility5, visibility)) {
	            if (this.obj5 === exports.UNDEFINED) {
	                this.obj5 = inj._new(p.binding5, p.visibility5);
	            }
	            return this.obj5;
	        }
	        if (p.keyId6 === keyId && canSee(p.visibility6, visibility)) {
	            if (this.obj6 === exports.UNDEFINED) {
	                this.obj6 = inj._new(p.binding6, p.visibility6);
	            }
	            return this.obj6;
	        }
	        if (p.keyId7 === keyId && canSee(p.visibility7, visibility)) {
	            if (this.obj7 === exports.UNDEFINED) {
	                this.obj7 = inj._new(p.binding7, p.visibility7);
	            }
	            return this.obj7;
	        }
	        if (p.keyId8 === keyId && canSee(p.visibility8, visibility)) {
	            if (this.obj8 === exports.UNDEFINED) {
	                this.obj8 = inj._new(p.binding8, p.visibility8);
	            }
	            return this.obj8;
	        }
	        if (p.keyId9 === keyId && canSee(p.visibility9, visibility)) {
	            if (this.obj9 === exports.UNDEFINED) {
	                this.obj9 = inj._new(p.binding9, p.visibility9);
	            }
	            return this.obj9;
	        }
	        return exports.UNDEFINED;
	    };
	    InjectorInlineStrategy.prototype.getObjAtIndex = function (index) {
	        if (index == 0)
	            return this.obj0;
	        if (index == 1)
	            return this.obj1;
	        if (index == 2)
	            return this.obj2;
	        if (index == 3)
	            return this.obj3;
	        if (index == 4)
	            return this.obj4;
	        if (index == 5)
	            return this.obj5;
	        if (index == 6)
	            return this.obj6;
	        if (index == 7)
	            return this.obj7;
	        if (index == 8)
	            return this.obj8;
	        if (index == 9)
	            return this.obj9;
	        throw new exceptions_1.OutOfBoundsError(index);
	    };
	    InjectorInlineStrategy.prototype.getMaxNumberOfObjects = function () { return _MAX_CONSTRUCTION_COUNTER; };
	    return InjectorInlineStrategy;
	})();
	exports.InjectorInlineStrategy = InjectorInlineStrategy;
	var InjectorDynamicStrategy = (function () {
	    function InjectorDynamicStrategy(protoStrategy, injector) {
	        this.protoStrategy = protoStrategy;
	        this.injector = injector;
	        this.objs = collection_1.ListWrapper.createFixedSize(protoStrategy.bindings.length);
	        collection_1.ListWrapper.fill(this.objs, exports.UNDEFINED);
	    }
	    InjectorDynamicStrategy.prototype.resetConstructionCounter = function () { this.injector._constructionCounter = 0; };
	    InjectorDynamicStrategy.prototype.instantiateBinding = function (binding, visibility) {
	        return this.injector._new(binding, visibility);
	    };
	    InjectorDynamicStrategy.prototype.attach = function (parent, isHost) {
	        var inj = this.injector;
	        inj._parent = parent;
	        inj._isHost = isHost;
	    };
	    InjectorDynamicStrategy.prototype.getObjByKeyId = function (keyId, visibility) {
	        var p = this.protoStrategy;
	        for (var i = 0; i < p.keyIds.length; i++) {
	            if (p.keyIds[i] === keyId && canSee(p.visibilities[i], visibility)) {
	                if (this.objs[i] === exports.UNDEFINED) {
	                    this.objs[i] = this.injector._new(p.bindings[i], p.visibilities[i]);
	                }
	                return this.objs[i];
	            }
	        }
	        return exports.UNDEFINED;
	    };
	    InjectorDynamicStrategy.prototype.getObjAtIndex = function (index) {
	        if (index < 0 || index >= this.objs.length) {
	            throw new exceptions_1.OutOfBoundsError(index);
	        }
	        return this.objs[index];
	    };
	    InjectorDynamicStrategy.prototype.getMaxNumberOfObjects = function () { return this.objs.length; };
	    return InjectorDynamicStrategy;
	})();
	exports.InjectorDynamicStrategy = InjectorDynamicStrategy;
	var BindingWithVisibility = (function () {
	    function BindingWithVisibility(binding, visibility) {
	        this.binding = binding;
	        this.visibility = visibility;
	    }
	    ;
	    BindingWithVisibility.prototype.getKeyId = function () { return this.binding.key.id; };
	    return BindingWithVisibility;
	})();
	exports.BindingWithVisibility = BindingWithVisibility;
	/**
	 * A dependency injection container used for resolving dependencies.
	 *
	 * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
	 * constructor dependencies.
	 * In typical use, application code asks for the dependencies in the constructor and they are
	 * resolved by the `Injector`.
	 *
	 * ## Example:
	 *
	 * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:
	 *
	 * ```javascript
	 * class Engine {
	 * }
	 *
	 * class Car {
	 *   constructor(@Inject(Engine) engine) {
	 *   }
	 * }
	 *
	 * ```
	 *
	 * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the
	 * `root` object, `Car`, so that the `Injector` can recursively build all of that object's
	 *dependencies.
	 *
	 * ```javascript
	 * main() {
	 *   var injector = Injector.resolveAndCreate([Car, Engine]);
	 *
	 *   // Get a reference to the `root` object, which will recursively instantiate the tree.
	 *   var car = injector.get(Car);
	 * }
	 * ```
	 * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`
	 * resolve all of the object's dependencies automatically.
	 */
	var Injector = (function () {
	    function Injector(_proto, _parent, _depProvider, _debugContext) {
	        if (_parent === void 0) { _parent = null; }
	        if (_depProvider === void 0) { _depProvider = null; }
	        if (_debugContext === void 0) { _debugContext = null; }
	        this._proto = _proto;
	        this._parent = _parent;
	        this._depProvider = _depProvider;
	        this._debugContext = _debugContext;
	        this._isHost = false;
	        this._constructionCounter = 0;
	        this._strategy = _proto._strategy.createInjectorStrategy(this);
	    }
	    /**
	     * Turns a list of binding definitions into an internal resolved list of resolved bindings.
	     *
	     * A resolution is a process of flattening multiple nested lists and converting individual
	     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`
	     * for the {@link Injector} for performance-sensitive code.
	     *
	     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
	     * recursive list of more bindings.
	     *
	     * The returned list is sparse, indexed by `id` for the {@link Key}. It is generally not useful to
	     *application code
	     * other than for passing it to {@link Injector} functions that require resolved binding lists,
	     *such as
	     * `fromResolvedBindings` and `createChildFromResolved`.
	     */
	    Injector.resolve = function (bindings) {
	        return binding_1.resolveBindings(bindings);
	    };
	    /**
	     * Resolves bindings and creates an injector based on those bindings. This function is slower than
	     * the corresponding `fromResolvedBindings` because it needs to resolve bindings first. See
	     *`resolve`
	     * for the {@link Injector}.
	     *
	     * Prefer `fromResolvedBindings` in performance-critical code that creates lots of injectors.
	     *
	     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
	     *recursive list of more
	     * bindings.
	     * @param `depProvider`
	     */
	    Injector.resolveAndCreate = function (bindings, depProvider) {
	        if (depProvider === void 0) { depProvider = null; }
	        var resolvedBindings = Injector.resolve(bindings);
	        return Injector.fromResolvedBindings(resolvedBindings, depProvider);
	    };
	    /**
	     * Creates an injector from previously resolved bindings. This bypasses resolution and flattening.
	     * This API is the recommended way to construct injectors in performance-sensitive parts.
	     *
	     * @param `bindings` A sparse list of {@link ResolvedBinding}s. See `resolve` for the
	     * {@link Injector}.
	     * @param `depProvider`
	     */
	    Injector.fromResolvedBindings = function (bindings, depProvider) {
	        if (depProvider === void 0) { depProvider = null; }
	        var bd = bindings.map(function (b) { return new BindingWithVisibility(b, Visibility.Public); });
	        var proto = new ProtoInjector(bd);
	        var inj = new Injector(proto, null, depProvider);
	        return inj;
	    };
	    /**
	     * Returns debug information about the injector.
	     *
	     * This information is included into exceptions thrown by the injector.
	     */
	    Injector.prototype.debugContext = function () { return this._debugContext(); };
	    /**
	     * Retrieves an instance from the injector.
	     *
	     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a
	     *binding).
	     * @returns an instance represented by the token. Throws if not found.
	     */
	    Injector.prototype.get = function (token) {
	        return this._getByKey(key_1.Key.get(token), null, null, false, Visibility.PublicAndPrivate);
	    };
	    /**
	     * Retrieves an instance from the injector.
	     *
	     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).
	     * @returns an instance represented by the token. Returns `null` if not found.
	     */
	    Injector.prototype.getOptional = function (token) {
	        return this._getByKey(key_1.Key.get(token), null, null, true, Visibility.PublicAndPrivate);
	    };
	    /**
	     * Retrieves an instance from the injector.
	     *
	     * @param `index`: index of an instance.
	     * @returns an instance represented by the index. Throws if not found.
	     */
	    Injector.prototype.getAt = function (index) { return this._strategy.getObjAtIndex(index); };
	    Object.defineProperty(Injector.prototype, "parent", {
	        /**
	         * Direct parent of this injector.
	         */
	        get: function () { return this._parent; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Injector.prototype, "internalStrategy", {
	        /**
	         * Internal. Do not use.
	         *
	         * We return `any` not to export the InjectorStrategy type.
	         */
	        get: function () { return this._strategy; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	    * Creates a child injector and loads a new set of bindings into it.
	    *
	    * A resolution is a process of flattening multiple nested lists and converting individual
	    * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`
	    * for the {@link Injector} for performance-sensitive code.
	    *
	    * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
	    * recursive list of more bindings.
	    * @param `depProvider`
	    */
	    Injector.prototype.resolveAndCreateChild = function (bindings, depProvider) {
	        if (depProvider === void 0) { depProvider = null; }
	        var resolvedBindings = Injector.resolve(bindings);
	        return this.createChildFromResolved(resolvedBindings, depProvider);
	    };
	    /**
	     * Creates a child injector and loads a new set of {@link ResolvedBinding}s into it.
	     *
	     * @param `bindings`: A sparse list of {@link ResolvedBinding}s.
	     * See `resolve` for the {@link Injector}.
	     * @param `depProvider`
	     * @returns a new child {@link Injector}.
	     */
	    Injector.prototype.createChildFromResolved = function (bindings, depProvider) {
	        if (depProvider === void 0) { depProvider = null; }
	        var bd = bindings.map(function (b) { return new BindingWithVisibility(b, Visibility.Public); });
	        var proto = new ProtoInjector(bd);
	        var inj = new Injector(proto, null, depProvider);
	        inj._parent = this;
	        return inj;
	    };
	    /**
	     * Resolves a binding and instantiates an object in the context of the injector.
	     *
	     * @param `binding`: either a type or a binding.
	     * @returns an object created using binding.
	     */
	    Injector.prototype.resolveAndInstantiate = function (binding) {
	        return this.instantiateResolved(Injector.resolve([binding])[0]);
	    };
	    /**
	     * Instantiates an object using a resolved binding in the context of the injector.
	     *
	     * @param `binding`: a resolved binding
	     * @returns an object created using binding.
	     */
	    Injector.prototype.instantiateResolved = function (binding) {
	        return this._instantiateBinding(binding, Visibility.PublicAndPrivate);
	    };
	    Injector.prototype._new = function (binding, visibility) {
	        if (this._constructionCounter++ > this._strategy.getMaxNumberOfObjects()) {
	            throw new exceptions_1.CyclicDependencyError(this, binding.key);
	        }
	        return this._instantiateBinding(binding, visibility);
	    };
	    Injector.prototype._instantiateBinding = function (binding, visibility) {
	        if (binding.multiBinding) {
	            var res = collection_1.ListWrapper.createFixedSize(binding.resolvedFactories.length);
	            for (var i = 0; i < binding.resolvedFactories.length; ++i) {
	                res[i] = this._instantiate(binding, binding.resolvedFactories[i], visibility);
	            }
	            return res;
	        }
	        else {
	            return this._instantiate(binding, binding.resolvedFactories[0], visibility);
	        }
	    };
	    Injector.prototype._instantiate = function (binding, resolvedFactory, visibility) {
	        var factory = resolvedFactory.factory;
	        var deps = resolvedFactory.dependencies;
	        var length = deps.length;
	        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19;
	        try {
	            d0 = length > 0 ? this._getByDependency(binding, deps[0], visibility) : null;
	            d1 = length > 1 ? this._getByDependency(binding, deps[1], visibility) : null;
	            d2 = length > 2 ? this._getByDependency(binding, deps[2], visibility) : null;
	            d3 = length > 3 ? this._getByDependency(binding, deps[3], visibility) : null;
	            d4 = length > 4 ? this._getByDependency(binding, deps[4], visibility) : null;
	            d5 = length > 5 ? this._getByDependency(binding, deps[5], visibility) : null;
	            d6 = length > 6 ? this._getByDependency(binding, deps[6], visibility) : null;
	            d7 = length > 7 ? this._getByDependency(binding, deps[7], visibility) : null;
	            d8 = length > 8 ? this._getByDependency(binding, deps[8], visibility) : null;
	            d9 = length > 9 ? this._getByDependency(binding, deps[9], visibility) : null;
	            d10 = length > 10 ? this._getByDependency(binding, deps[10], visibility) : null;
	            d11 = length > 11 ? this._getByDependency(binding, deps[11], visibility) : null;
	            d12 = length > 12 ? this._getByDependency(binding, deps[12], visibility) : null;
	            d13 = length > 13 ? this._getByDependency(binding, deps[13], visibility) : null;
	            d14 = length > 14 ? this._getByDependency(binding, deps[14], visibility) : null;
	            d15 = length > 15 ? this._getByDependency(binding, deps[15], visibility) : null;
	            d16 = length > 16 ? this._getByDependency(binding, deps[16], visibility) : null;
	            d17 = length > 17 ? this._getByDependency(binding, deps[17], visibility) : null;
	            d18 = length > 18 ? this._getByDependency(binding, deps[18], visibility) : null;
	            d19 = length > 19 ? this._getByDependency(binding, deps[19], visibility) : null;
	        }
	        catch (e) {
	            if (e instanceof exceptions_1.AbstractBindingError || e instanceof exceptions_1.InstantiationError) {
	                e.addKey(this, binding.key);
	            }
	            throw e;
	        }
	        var obj;
	        try {
	            switch (length) {
	                case 0:
	                    obj = factory();
	                    break;
	                case 1:
	                    obj = factory(d0);
	                    break;
	                case 2:
	                    obj = factory(d0, d1);
	                    break;
	                case 3:
	                    obj = factory(d0, d1, d2);
	                    break;
	                case 4:
	                    obj = factory(d0, d1, d2, d3);
	                    break;
	                case 5:
	                    obj = factory(d0, d1, d2, d3, d4);
	                    break;
	                case 6:
	                    obj = factory(d0, d1, d2, d3, d4, d5);
	                    break;
	                case 7:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6);
	                    break;
	                case 8:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7);
	                    break;
	                case 9:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8);
	                    break;
	                case 10:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9);
	                    break;
	                case 11:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10);
	                    break;
	                case 12:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11);
	                    break;
	                case 13:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
	                    break;
	                case 14:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13);
	                    break;
	                case 15:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14);
	                    break;
	                case 16:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15);
	                    break;
	                case 17:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16);
	                    break;
	                case 18:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17);
	                    break;
	                case 19:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18);
	                    break;
	                case 20:
	                    obj = factory(d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d15, d16, d17, d18, d19);
	                    break;
	            }
	        }
	        catch (e) {
	            throw new exceptions_1.InstantiationError(this, e, e.stack, binding.key);
	        }
	        return obj;
	    };
	    Injector.prototype._getByDependency = function (binding, dep, bindingVisibility) {
	        var special = lang_1.isPresent(this._depProvider) ?
	            this._depProvider.getDependency(this, binding, dep) :
	            exports.UNDEFINED;
	        if (special !== exports.UNDEFINED) {
	            return special;
	        }
	        else {
	            return this._getByKey(dep.key, dep.lowerBoundVisibility, dep.upperBoundVisibility, dep.optional, bindingVisibility);
	        }
	    };
	    Injector.prototype._getByKey = function (key, lowerBoundVisibility, upperBoundVisibility, optional, bindingVisibility) {
	        if (key === INJECTOR_KEY) {
	            return this;
	        }
	        if (upperBoundVisibility instanceof metadata_1.SelfMetadata) {
	            return this._getByKeySelf(key, optional, bindingVisibility);
	        }
	        else if (upperBoundVisibility instanceof metadata_1.HostMetadata) {
	            return this._getByKeyHost(key, optional, bindingVisibility, lowerBoundVisibility);
	        }
	        else {
	            return this._getByKeyDefault(key, optional, bindingVisibility, lowerBoundVisibility);
	        }
	    };
	    Injector.prototype._throwOrNull = function (key, optional) {
	        if (optional) {
	            return null;
	        }
	        else {
	            throw new exceptions_1.NoBindingError(this, key);
	        }
	    };
	    Injector.prototype._getByKeySelf = function (key, optional, bindingVisibility) {
	        var obj = this._strategy.getObjByKeyId(key.id, bindingVisibility);
	        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);
	    };
	    Injector.prototype._getByKeyHost = function (key, optional, bindingVisibility, lowerBoundVisibility) {
	        var inj = this;
	        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
	            if (inj._isHost) {
	                return this._getPrivateDependency(key, optional, inj);
	            }
	            else {
	                inj = inj._parent;
	            }
	        }
	        while (inj != null) {
	            var obj = inj._strategy.getObjByKeyId(key.id, bindingVisibility);
	            if (obj !== exports.UNDEFINED)
	                return obj;
	            if (lang_1.isPresent(inj._parent) && inj._isHost) {
	                return this._getPrivateDependency(key, optional, inj);
	            }
	            else {
	                inj = inj._parent;
	            }
	        }
	        return this._throwOrNull(key, optional);
	    };
	    Injector.prototype._getPrivateDependency = function (key, optional, inj) {
	        var obj = inj._parent._strategy.getObjByKeyId(key.id, Visibility.Private);
	        return (obj !== exports.UNDEFINED) ? obj : this._throwOrNull(key, optional);
	    };
	    Injector.prototype._getByKeyDefault = function (key, optional, bindingVisibility, lowerBoundVisibility) {
	        var inj = this;
	        if (lowerBoundVisibility instanceof metadata_1.SkipSelfMetadata) {
	            bindingVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
	            inj = inj._parent;
	        }
	        while (inj != null) {
	            var obj = inj._strategy.getObjByKeyId(key.id, bindingVisibility);
	            if (obj !== exports.UNDEFINED)
	                return obj;
	            bindingVisibility = inj._isHost ? Visibility.PublicAndPrivate : Visibility.Public;
	            inj = inj._parent;
	        }
	        return this._throwOrNull(key, optional);
	    };
	    Object.defineProperty(Injector.prototype, "displayName", {
	        get: function () {
	            return "Injector(bindings: [" + _mapBindings(this, function (b) { return (" \"" + b.key.displayName + "\" "); }).join(", ") + "])";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Injector.prototype.toString = function () { return this.displayName; };
	    return Injector;
	})();
	exports.Injector = Injector;
	var INJECTOR_KEY = key_1.Key.get(Injector);
	function _mapBindings(injector, fn) {
	    var res = [];
	    for (var i = 0; i < injector._proto.numberOfBindings; ++i) {
	        res.push(fn(injector._proto.getBindingAtIndex(i)));
	    }
	    return res;
	}
	//# sourceMappingURL=injector.js.map

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	exports.Map = lang_1.global.Map;
	exports.Set = lang_1.global.Set;
	exports.StringMap = lang_1.global.Object;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Map constructor.  We work around that by manually adding the items.
	var createMapFromPairs = (function () {
	    try {
	        if (new exports.Map([[1, 2]]).size === 1) {
	            return function createMapFromPairs(pairs) { return new exports.Map(pairs); };
	        }
	    }
	    catch (e) {
	    }
	    return function createMapAndPopulateFromPairs(pairs) {
	        var map = new exports.Map();
	        for (var i = 0; i < pairs.length; i++) {
	            var pair = pairs[i];
	            map.set(pair[0], pair[1]);
	        }
	        return map;
	    };
	})();
	var createMapFromMap = (function () {
	    try {
	        if (new exports.Map(new exports.Map())) {
	            return function createMapFromMap(m) { return new exports.Map(m); };
	        }
	    }
	    catch (e) {
	    }
	    return function createMapAndPopulateFromMap(m) {
	        var map = new exports.Map();
	        m.forEach(function (v, k) { map.set(k, v); });
	        return map;
	    };
	})();
	var _clearValues = (function () {
	    if ((new exports.Map()).keys().next) {
	        return function _clearValues(m) {
	            var keyIterator = m.keys();
	            var k;
	            while (!((k = keyIterator.next()).done)) {
	                m.set(k.value, null);
	            }
	        };
	    }
	    else {
	        return function _clearValuesWithForeEach(m) {
	            m.forEach(function (v, k) { m.set(k, null); });
	        };
	    }
	})();
	// Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
	// TODO(mlaval): remove the work around once we have a working polyfill of Array.from
	var _arrayFromMap = (function () {
	    try {
	        if ((new exports.Map()).values().next) {
	            return function createArrayFromMap(m, getValues) { return getValues ? Array.from(m.values()) : Array.from(m.keys()); };
	        }
	    }
	    catch (e) {
	    }
	    return function createArrayFromMapWithForeach(m, getValues) {
	        var res = ListWrapper.createFixedSize(m.size), i = 0;
	        m.forEach(function (v, k) {
	            res[i] = getValues ? v : k;
	            i++;
	        });
	        return res;
	    };
	})();
	var MapWrapper = (function () {
	    function MapWrapper() {
	    }
	    MapWrapper.clone = function (m) { return createMapFromMap(m); };
	    MapWrapper.createFromStringMap = function (stringMap) {
	        var result = new exports.Map();
	        for (var prop in stringMap) {
	            result.set(prop, stringMap[prop]);
	        }
	        return result;
	    };
	    MapWrapper.toStringMap = function (m) {
	        var r = {};
	        m.forEach(function (v, k) { return r[k] = v; });
	        return r;
	    };
	    MapWrapper.createFromPairs = function (pairs) { return createMapFromPairs(pairs); };
	    MapWrapper.forEach = function (m, fn) { m.forEach(fn); };
	    MapWrapper.get = function (map, key) { return map.get(key); };
	    MapWrapper.size = function (m) { return m.size; };
	    MapWrapper.delete = function (m, k) { m.delete(k); };
	    MapWrapper.clearValues = function (m) { _clearValues(m); };
	    MapWrapper.iterable = function (m) { return m; };
	    MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };
	    MapWrapper.values = function (m) { return _arrayFromMap(m, true); };
	    return MapWrapper;
	})();
	exports.MapWrapper = MapWrapper;
	/**
	 * Wraps Javascript Objects
	 */
	var StringMapWrapper = (function () {
	    function StringMapWrapper() {
	    }
	    StringMapWrapper.create = function () {
	        // Note: We are not using Object.create(null) here due to
	        // performance!
	        // http://jsperf.com/ng2-object-create-null
	        return {};
	    };
	    StringMapWrapper.contains = function (map, key) {
	        return map.hasOwnProperty(key);
	    };
	    StringMapWrapper.get = function (map, key) {
	        return map.hasOwnProperty(key) ? map[key] : undefined;
	    };
	    StringMapWrapper.set = function (map, key, value) { map[key] = value; };
	    StringMapWrapper.keys = function (map) { return Object.keys(map); };
	    StringMapWrapper.isEmpty = function (map) {
	        for (var prop in map) {
	            return false;
	        }
	        return true;
	    };
	    StringMapWrapper.delete = function (map, key) { delete map[key]; };
	    StringMapWrapper.forEach = function (map, callback) {
	        for (var prop in map) {
	            if (map.hasOwnProperty(prop)) {
	                callback(map[prop], prop);
	            }
	        }
	    };
	    StringMapWrapper.merge = function (m1, m2) {
	        var m = {};
	        for (var attr in m1) {
	            if (m1.hasOwnProperty(attr)) {
	                m[attr] = m1[attr];
	            }
	        }
	        for (var attr in m2) {
	            if (m2.hasOwnProperty(attr)) {
	                m[attr] = m2[attr];
	            }
	        }
	        return m;
	    };
	    StringMapWrapper.equals = function (m1, m2) {
	        var k1 = Object.keys(m1);
	        var k2 = Object.keys(m2);
	        if (k1.length != k2.length) {
	            return false;
	        }
	        var key;
	        for (var i = 0; i < k1.length; i++) {
	            key = k1[i];
	            if (m1[key] !== m2[key]) {
	                return false;
	            }
	        }
	        return true;
	    };
	    return StringMapWrapper;
	})();
	exports.StringMapWrapper = StringMapWrapper;
	var ListWrapper = (function () {
	    function ListWrapper() {
	    }
	    // JS has no way to express a staticly fixed size list, but dart does so we
	    // keep both methods.
	    ListWrapper.createFixedSize = function (size) { return new Array(size); };
	    ListWrapper.createGrowableSize = function (size) { return new Array(size); };
	    ListWrapper.clone = function (array) { return array.slice(0); };
	    ListWrapper.map = function (array, fn) { return array.map(fn); };
	    ListWrapper.forEach = function (array, fn) {
	        for (var i = 0; i < array.length; i++) {
	            fn(array[i]);
	        }
	    };
	    ListWrapper.forEachWithIndex = function (array, fn) {
	        for (var i = 0; i < array.length; i++) {
	            fn(array[i], i);
	        }
	    };
	    ListWrapper.first = function (array) {
	        if (!array)
	            return null;
	        return array[0];
	    };
	    ListWrapper.last = function (array) {
	        if (!array || array.length == 0)
	            return null;
	        return array[array.length - 1];
	    };
	    ListWrapper.find = function (list, pred) {
	        for (var i = 0; i < list.length; ++i) {
	            if (pred(list[i]))
	                return list[i];
	        }
	        return null;
	    };
	    ListWrapper.indexOf = function (array, value, startIndex) {
	        if (startIndex === void 0) { startIndex = 0; }
	        return array.indexOf(value, startIndex);
	    };
	    ListWrapper.reduce = function (list, fn, init) {
	        return list.reduce(fn, init);
	    };
	    ListWrapper.filter = function (array, pred) { return array.filter(pred); };
	    ListWrapper.any = function (list, pred) {
	        for (var i = 0; i < list.length; ++i) {
	            if (pred(list[i]))
	                return true;
	        }
	        return false;
	    };
	    ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
	    ListWrapper.reversed = function (array) {
	        var a = ListWrapper.clone(array);
	        return a.reverse();
	    };
	    ListWrapper.concat = function (a, b) { return a.concat(b); };
	    ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
	    ListWrapper.removeAt = function (list, index) {
	        var res = list[index];
	        list.splice(index, 1);
	        return res;
	    };
	    ListWrapper.removeAll = function (list, items) {
	        for (var i = 0; i < items.length; ++i) {
	            var index = list.indexOf(items[i]);
	            list.splice(index, 1);
	        }
	    };
	    ListWrapper.removeLast = function (list) { return list.pop(); };
	    ListWrapper.remove = function (list, el) {
	        var index = list.indexOf(el);
	        if (index > -1) {
	            list.splice(index, 1);
	            return true;
	        }
	        return false;
	    };
	    ListWrapper.clear = function (list) { list.length = 0; };
	    ListWrapper.join = function (list, s) { return list.join(s); };
	    ListWrapper.isEmpty = function (list) { return list.length == 0; };
	    ListWrapper.fill = function (list, value, start, end) {
	        if (start === void 0) { start = 0; }
	        if (end === void 0) { end = null; }
	        list.fill(value, start, end === null ? list.length : end);
	    };
	    ListWrapper.equals = function (a, b) {
	        if (a.length != b.length)
	            return false;
	        for (var i = 0; i < a.length; ++i) {
	            if (a[i] !== b[i])
	                return false;
	        }
	        return true;
	    };
	    ListWrapper.slice = function (l, from, to) {
	        if (from === void 0) { from = 0; }
	        if (to === void 0) { to = null; }
	        return l.slice(from, to === null ? undefined : to);
	    };
	    ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
	    ListWrapper.sort = function (l, compareFn) {
	        if (lang_1.isPresent(compareFn)) {
	            l.sort(compareFn);
	        }
	        else {
	            l.sort();
	        }
	    };
	    ListWrapper.toString = function (l) { return l.toString(); };
	    ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
	    ListWrapper.maximum = function (list, predicate) {
	        if (list.length == 0) {
	            return null;
	        }
	        var solution = null;
	        var maxValue = -Infinity;
	        for (var index = 0; index < list.length; index++) {
	            var candidate = list[index];
	            if (lang_1.isBlank(candidate)) {
	                continue;
	            }
	            var candidateValue = predicate(candidate);
	            if (candidateValue > maxValue) {
	                solution = candidate;
	                maxValue = candidateValue;
	            }
	        }
	        return solution;
	    };
	    return ListWrapper;
	})();
	exports.ListWrapper = ListWrapper;
	function isListLikeIterable(obj) {
	    if (!lang_1.isJsObject(obj))
	        return false;
	    return lang_1.isArray(obj) ||
	        (!(obj instanceof exports.Map) &&
	            Symbol.iterator in obj); // JS Iterable have a Symbol.iterator prop
	}
	exports.isListLikeIterable = isListLikeIterable;
	function iterateListLike(obj, fn) {
	    if (lang_1.isArray(obj)) {
	        for (var i = 0; i < obj.length; i++) {
	            fn(obj[i]);
	        }
	    }
	    else {
	        var iterator = obj[Symbol.iterator]();
	        var item;
	        while (!((item = iterator.next()).done)) {
	            fn(item.value);
	        }
	    }
	}
	exports.iterateListLike = iterateListLike;
	// Safari and Internet Explorer do not support the iterable parameter to the
	// Set constructor.  We work around that by manually adding the items.
	var createSetFromList = (function () {
	    var test = new exports.Set([1, 2, 3]);
	    if (test.size === 3) {
	        return function createSetFromList(lst) { return new exports.Set(lst); };
	    }
	    else {
	        return function createSetAndPopulateFromList(lst) {
	            var res = new exports.Set(lst);
	            if (res.size !== lst.length) {
	                for (var i = 0; i < lst.length; i++) {
	                    res.add(lst[i]);
	                }
	            }
	            return res;
	        };
	    }
	})();
	var SetWrapper = (function () {
	    function SetWrapper() {
	    }
	    SetWrapper.createFromList = function (lst) { return createSetFromList(lst); };
	    SetWrapper.has = function (s, key) { return s.has(key); };
	    SetWrapper.delete = function (m, k) { m.delete(k); };
	    return SetWrapper;
	})();
	exports.SetWrapper = SetWrapper;
	//# sourceMappingURL=collection.js.map

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var reflection_1 = __webpack_require__(170);
	var key_1 = __webpack_require__(173);
	var metadata_1 = __webpack_require__(161);
	var exceptions_2 = __webpack_require__(175);
	var forward_ref_1 = __webpack_require__(164);
	/**
	 * @private
	 */
	var Dependency = (function () {
	    function Dependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties) {
	        this.key = key;
	        this.optional = optional;
	        this.lowerBoundVisibility = lowerBoundVisibility;
	        this.upperBoundVisibility = upperBoundVisibility;
	        this.properties = properties;
	    }
	    Dependency.fromKey = function (key) { return new Dependency(key, false, null, null, []); };
	    return Dependency;
	})();
	exports.Dependency = Dependency;
	var _EMPTY_LIST = lang_1.CONST_EXPR([]);
	/**
	 * Describes how_ the {@link Injector} should instantiate a given token.
	 *
	 * See {@link bind}.
	 *
	 * ## Example
	 *
	 * ```javascript
	 * var injector = Injector.resolveAndCreate([
	 *   new Binding(String, { toValue: 'Hello' })
	 * ]);
	 *
	 * expect(injector.get(String)).toEqual('Hello');
	 * ```
	 */
	var Binding = (function () {
	    function Binding(token, _a) {
	        var toClass = _a.toClass, toValue = _a.toValue, toAlias = _a.toAlias, toFactory = _a.toFactory, deps = _a.deps, multi = _a.multi;
	        this.token = token;
	        this.toClass = toClass;
	        this.toValue = toValue;
	        this.toAlias = toAlias;
	        this.toFactory = toFactory;
	        this.dependencies = deps;
	        this._multi = multi;
	    }
	    Object.defineProperty(Binding.prototype, "multi", {
	        /**
	         * Used to create multiple bindings matching the same token.
	         *
	         * ## Example
	         *
	         * ```javascript
	         * var injector = Injector.resolveAndCreate([
	         *   new Binding("Strings", { toValue: "String1", multi: true}),
	         *   new Binding("Strings", { toValue: "String2", multi: true})
	         * ]);
	         *
	         * expect(injector.get("Strings")).toEqual(["String1", "String2"]);
	         * ```
	         *
	         * Multi bindings and regular bindings cannot be mixed. The following
	         * will throw an exception:
	         *
	         * ```javascript
	         * var injector = Injector.resolveAndCreate([
	         *   new Binding("Strings", { toValue: "String1", multi: true}),
	         *   new Binding("Strings", { toValue: "String2"})
	         * ]);
	         * ```
	         */
	        get: function () { return lang_1.normalizeBool(this._multi); },
	        enumerable: true,
	        configurable: true
	    });
	    Binding = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object, Object])
	    ], Binding);
	    return Binding;
	})();
	exports.Binding = Binding;
	/**
	 * An internal resolved representation of a {@link Binding} used by the {@link Injector}.
	 *
	 * A {@link Binding} is resolved when it has a factory function. Binding to a class, alias, or
	 * value, are just convenience methods, as {@link Injector} only operates on calling factory
	 * functions.
	 */
	var ResolvedBinding = (function () {
	    function ResolvedBinding(
	        /**
	         * A key, usually a `Type`.
	         */
	        key, 
	        /**
	         * Factory function which can return an instance of an object represented by a key.
	         */
	        resolvedFactories, multiBinding) {
	        this.key = key;
	        this.resolvedFactories = resolvedFactories;
	        this.multiBinding = multiBinding;
	    }
	    Object.defineProperty(ResolvedBinding.prototype, "resolvedFactory", {
	        get: function () { return this.resolvedFactories[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    return ResolvedBinding;
	})();
	exports.ResolvedBinding = ResolvedBinding;
	var ResolvedFactory = (function () {
	    function ResolvedFactory(
	        /**
	         * Factory function which can return an instance of an object represented by a key.
	         */
	        factory, 
	        /**
	         * Arguments (dependencies) to the `factory` function.
	         */
	        dependencies) {
	        this.factory = factory;
	        this.dependencies = dependencies;
	    }
	    return ResolvedFactory;
	})();
	exports.ResolvedFactory = ResolvedFactory;
	/**
	 * Provides an API for imperatively constructing {@link Binding}s.
	 *
	 * To construct a {@link Binding}, bind a `token` to either a class, a value or a factory function.
	 * See {@link BindingBuilder} for more details.
	 *
	 * The `token` is most commonly an {@link angular2/di/OpaqueToken} or a class.
	 *
	 * `bind` is only relevant for JavaScript. For Dart use the {@link Binding} constructor.
	 *
	 * ## Example
	 *
	 * ```typescript
	 * // inj.get(MyClass) would instantiate MyClass
	 * bind(MyClass).toClass(MyClass);
	 *
	 * // inj.get(MyClass) === 'my class'
	 * bind(MyClass).toValue('my class');
	 *
	 * // inj.get(MyClass) would instantiate the depenency and call the factory function with the
	 * // instance
	 * bind(MyClass).toFactory(dep => new MyClass(dep), [DepClass]);
	 *
	 * // inj.get(MyOtherClass) === inj.get(MyClass)
	 * bind(MyOtherClass).toAlias(MyClass);
	 * ```
	 *
	 * ```dart
	 * var binding = new Binding(MyClass, toClass: MyClass);
	 * var binding = new Binding(MyClass, toValue: 'my class');
	 * var binding = new Binding(MyClass, toFactory: (dep) => new MyClass(dep),
	 *                           dependencies: [DepClass]);
	 *  var binding = new Binding(MyOtherClass, toAlias: MyClass);
	 * ```
	 *
	 */
	function bind(token) {
	    return new BindingBuilder(token);
	}
	exports.bind = bind;
	/**
	 * Helper class for the {@link bind} function.
	 */
	var BindingBuilder = (function () {
	    function BindingBuilder(token) {
	        this.token = token;
	    }
	    /**
	     * Binds an interface to an implementation / subclass.
	     *
	     * ## Example
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
	     * easy comparison.
	     *
	     * ```javascript
	     *
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   bind(Vehicle).toClass(Car)
	     * ]);
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   bind(Vehicle).toAlias(Car)
	     * ]);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */
	    BindingBuilder.prototype.toClass = function (type) { return new Binding(this.token, { toClass: type }); };
	    /**
	     * Binds a key to a value.
	     *
	     * ## Example
	     *
	     * ```javascript
	     * var injector = Injector.resolveAndCreate([
	     *   bind(String).toValue('Hello')
	     * ]);
	     *
	     * expect(injector.get(String)).toEqual('Hello');
	     * ```
	     */
	    BindingBuilder.prototype.toValue = function (value) { return new Binding(this.token, { toValue: value }); };
	    /**
	     * Binds a key to the alias for an existing key.
	     *
	     * An alias means that we will return the same instance as if the alias token was used. (This is
	     * in contrast to `toClass` where a separate instance of `toClass` will be returned.)
	     *
	     * ## Example
	     *
	     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
	     * easy
	     * comparison.
	     *
	     * ```javascript
	     *
	     * class Vehicle {}
	     *
	     * class Car extends Vehicle {}
	     *
	     * var injectorAlias = Injector.resolveAndCreate([
	     *   Car,
	     *   bind(Vehicle).toAlias(Car)
	     * ]);
	     * var injectorClass = Injector.resolveAndCreate([
	     *   Car,
	     *   bind(Vehicle).toClass(Car)
	     * ]);
	     *
	     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
	     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
	     *
	     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
	     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
	     * ```
	     */
	    BindingBuilder.prototype.toAlias = function (aliasToken) {
	        if (lang_1.isBlank(aliasToken)) {
	            throw new exceptions_1.BaseException("Can not alias " + lang_1.stringify(this.token) + " to a blank value!");
	        }
	        return new Binding(this.token, { toAlias: aliasToken });
	    };
	    /**
	     * Binds a key to a function which computes the value.
	     *
	     * ## Example
	     *
	     * ```javascript
	     * var injector = Injector.resolveAndCreate([
	     *   bind(Number).toFactory(() => { return 1+2; }),
	     *   bind(String).toFactory((v) => { return "Value: " + v; }, [Number])
	     * ]);
	     *
	     * expect(injector.get(Number)).toEqual(3);
	     * expect(injector.get(String)).toEqual('Value: 3');
	     * ```
	     */
	    BindingBuilder.prototype.toFactory = function (factoryFunction, dependencies) {
	        return new Binding(this.token, { toFactory: factoryFunction, deps: dependencies });
	    };
	    return BindingBuilder;
	})();
	exports.BindingBuilder = BindingBuilder;
	/**
	 * Resolve a single binding.
	 */
	function resolveFactory(binding) {
	    var factoryFn;
	    var resolvedDeps;
	    if (lang_1.isPresent(binding.toClass)) {
	        var toClass = forward_ref_1.resolveForwardRef(binding.toClass);
	        factoryFn = reflection_1.reflector.factory(toClass);
	        resolvedDeps = _dependenciesFor(toClass);
	    }
	    else if (lang_1.isPresent(binding.toAlias)) {
	        factoryFn = function (aliasInstance) { return aliasInstance; };
	        resolvedDeps = [Dependency.fromKey(key_1.Key.get(binding.toAlias))];
	    }
	    else if (lang_1.isPresent(binding.toFactory)) {
	        factoryFn = binding.toFactory;
	        resolvedDeps = _constructDependencies(binding.toFactory, binding.dependencies);
	    }
	    else {
	        factoryFn = function () { return binding.toValue; };
	        resolvedDeps = _EMPTY_LIST;
	    }
	    return new ResolvedFactory(factoryFn, resolvedDeps);
	}
	exports.resolveFactory = resolveFactory;
	/**
	 * Converts the {@link Binding} into {@link ResolvedBinding}.
	 *
	 * {@link Injector} internally only uses {@link ResolvedBinding}, {@link Binding} contains
	 * convenience binding syntax.
	 */
	function resolveBinding(binding) {
	    return new ResolvedBinding(key_1.Key.get(binding.token), [resolveFactory(binding)], false);
	}
	exports.resolveBinding = resolveBinding;
	/**
	 * Resolve a list of Bindings.
	 */
	function resolveBindings(bindings) {
	    var normalized = _createListOfBindings(_normalizeBindings(bindings, new Map()));
	    return normalized.map(function (b) {
	        if (b instanceof _NormalizedBinding) {
	            return new ResolvedBinding(b.key, [b.resolvedFactory], false);
	        }
	        else {
	            var arr = b;
	            return new ResolvedBinding(arr[0].key, arr.map(function (_) { return _.resolvedFactory; }), true);
	        }
	    });
	}
	exports.resolveBindings = resolveBindings;
	/**
	 * The algorithm works as follows:
	 *
	 * [Binding] -> [_NormalizedBinding|[_NormalizedBinding]] -> [ResolvedBinding]
	 *
	 * _NormalizedBinding is essentially a resolved binding before it was grouped by key.
	 */
	var _NormalizedBinding = (function () {
	    function _NormalizedBinding(key, resolvedFactory) {
	        this.key = key;
	        this.resolvedFactory = resolvedFactory;
	    }
	    return _NormalizedBinding;
	})();
	function _createListOfBindings(flattenedBindings) {
	    return collection_1.MapWrapper.values(flattenedBindings);
	}
	function _normalizeBindings(bindings, res) {
	    collection_1.ListWrapper.forEach(bindings, function (b) {
	        if (b instanceof lang_1.Type) {
	            _normalizeBinding(bind(b).toClass(b), res);
	        }
	        else if (b instanceof Binding) {
	            _normalizeBinding(b, res);
	        }
	        else if (b instanceof Array) {
	            _normalizeBindings(b, res);
	        }
	        else if (b instanceof BindingBuilder) {
	            throw new exceptions_2.InvalidBindingError(b.token);
	        }
	        else {
	            throw new exceptions_2.InvalidBindingError(b);
	        }
	    });
	    return res;
	}
	function _normalizeBinding(b, res) {
	    var key = key_1.Key.get(b.token);
	    var factory = resolveFactory(b);
	    var normalized = new _NormalizedBinding(key, factory);
	    if (b.multi) {
	        var existingBinding = res.get(key.id);
	        if (existingBinding instanceof Array) {
	            existingBinding.push(normalized);
	        }
	        else if (lang_1.isBlank(existingBinding)) {
	            res.set(key.id, [normalized]);
	        }
	        else {
	            throw new exceptions_2.MixingMultiBindingsWithRegularBindings(existingBinding, b);
	        }
	    }
	    else {
	        var existingBinding = res.get(key.id);
	        if (existingBinding instanceof Array) {
	            throw new exceptions_2.MixingMultiBindingsWithRegularBindings(existingBinding, b);
	        }
	        res.set(key.id, normalized);
	    }
	}
	function _constructDependencies(factoryFunction, dependencies) {
	    if (lang_1.isBlank(dependencies)) {
	        return _dependenciesFor(factoryFunction);
	    }
	    else {
	        var params = collection_1.ListWrapper.map(dependencies, function (t) { return [t]; });
	        return collection_1.ListWrapper.map(dependencies, function (t) { return _extractToken(factoryFunction, t, params); });
	    }
	}
	function _dependenciesFor(typeOrFunc) {
	    var params = reflection_1.reflector.parameters(typeOrFunc);
	    if (lang_1.isBlank(params))
	        return [];
	    if (collection_1.ListWrapper.any(params, function (p) { return lang_1.isBlank(p); })) {
	        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);
	    }
	    return collection_1.ListWrapper.map(params, function (p) { return _extractToken(typeOrFunc, p, params); });
	}
	function _extractToken(typeOrFunc, metadata /*any[] | any*/, params) {
	    var depProps = [];
	    var token = null;
	    var optional = false;
	    if (!lang_1.isArray(metadata)) {
	        return _createDependency(metadata, optional, null, null, depProps);
	    }
	    var lowerBoundVisibility = null;
	    var upperBoundVisibility = null;
	    for (var i = 0; i < metadata.length; ++i) {
	        var paramMetadata = metadata[i];
	        if (paramMetadata instanceof lang_1.Type) {
	            token = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.InjectMetadata) {
	            token = paramMetadata.token;
	        }
	        else if (paramMetadata instanceof metadata_1.OptionalMetadata) {
	            optional = true;
	        }
	        else if (paramMetadata instanceof metadata_1.SelfMetadata) {
	            upperBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.HostMetadata) {
	            upperBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.SkipSelfMetadata) {
	            lowerBoundVisibility = paramMetadata;
	        }
	        else if (paramMetadata instanceof metadata_1.DependencyMetadata) {
	            if (lang_1.isPresent(paramMetadata.token)) {
	                token = paramMetadata.token;
	            }
	            depProps.push(paramMetadata);
	        }
	    }
	    token = forward_ref_1.resolveForwardRef(token);
	    if (lang_1.isPresent(token)) {
	        return _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	    }
	    else {
	        throw new exceptions_2.NoAnnotationError(typeOrFunc, params);
	    }
	}
	function _createDependency(token, optional, lowerBoundVisibility, upperBoundVisibility, depProps) {
	    return new Dependency(key_1.Key.get(token), optional, lowerBoundVisibility, upperBoundVisibility, depProps);
	}
	//# sourceMappingURL=binding.js.map

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../manual_typings/globals.d.ts" />
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var exception_handler_1 = __webpack_require__(169);
	var exception_handler_2 = __webpack_require__(169);
	exports.ExceptionHandler = exception_handler_2.ExceptionHandler;
	var BaseException = (function (_super) {
	    __extends(BaseException, _super);
	    function BaseException(message) {
	        _super.call(this, message);
	        this.message = message;
	        this.stack = (new Error(message)).stack;
	    }
	    BaseException.prototype.toString = function () { return this.message; };
	    return BaseException;
	})(Error);
	exports.BaseException = BaseException;
	var WrappedException = (function (_super) {
	    __extends(WrappedException, _super);
	    function WrappedException(_wrapperMessage, _originalException, _originalStack, _context) {
	        _super.call(this, _wrapperMessage);
	        this._wrapperMessage = _wrapperMessage;
	        this._originalException = _originalException;
	        this._originalStack = _originalStack;
	        this._context = _context;
	        this._wrapperStack = (new Error(_wrapperMessage)).stack;
	    }
	    Object.defineProperty(WrappedException.prototype, "wrapperMessage", {
	        get: function () { return this._wrapperMessage; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "wrapperStack", {
	        get: function () { return this._wrapperStack; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "originalException", {
	        get: function () { return this._originalException; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "originalStack", {
	        get: function () { return this._originalStack; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "context", {
	        get: function () { return this._context; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WrappedException.prototype, "message", {
	        get: function () { return exception_handler_1.ExceptionHandler.exceptionToString(this); },
	        enumerable: true,
	        configurable: true
	    });
	    WrappedException.prototype.toString = function () { return this.message; };
	    return WrappedException;
	})(Error);
	exports.WrappedException = WrappedException;
	function makeTypeError(message) {
	    return new TypeError(message);
	}
	exports.makeTypeError = makeTypeError;
	//# sourceMappingURL=exceptions.js.map

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var _ArrayLogger = (function () {
	    function _ArrayLogger() {
	        this.res = [];
	    }
	    _ArrayLogger.prototype.log = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logError = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logGroup = function (s) { this.res.push(s); };
	    _ArrayLogger.prototype.logGroupEnd = function () { };
	    ;
	    return _ArrayLogger;
	})();
	/**
	 * Provides a hook for centralized exception handling.
	 *
	 * The default implementation of `ExceptionHandler` prints error messages to the `Console`. To
	 * intercept error handling,
	 * write a custom exception handler that replaces this default as appropriate for your app.
	 *
	 * # Example
	 *
	 * ```javascript
	 *
	 * class MyExceptionHandler implements ExceptionHandler {
	 *   call(error, stackTrace = null, reason = null) {
	 *     // do something with the exception
	 *   }
	 * }
	 *
	 * bootstrap(MyApp, [bind(ExceptionHandler).toClass(MyExceptionHandler)])
	 *
	 * ```
	 */
	var ExceptionHandler = (function () {
	    function ExceptionHandler(_logger, _rethrowException) {
	        if (_rethrowException === void 0) { _rethrowException = true; }
	        this._logger = _logger;
	        this._rethrowException = _rethrowException;
	    }
	    ExceptionHandler.exceptionToString = function (exception, stackTrace, reason) {
	        if (stackTrace === void 0) { stackTrace = null; }
	        if (reason === void 0) { reason = null; }
	        var l = new _ArrayLogger();
	        var e = new ExceptionHandler(l, false);
	        e.call(exception, stackTrace, reason);
	        return l.res.join("\n");
	    };
	    ExceptionHandler.prototype.call = function (exception, stackTrace, reason) {
	        if (stackTrace === void 0) { stackTrace = null; }
	        if (reason === void 0) { reason = null; }
	        var originalException = this._findOriginalException(exception);
	        var originalStack = this._findOriginalStack(exception);
	        var context = this._findContext(exception);
	        this._logger.logGroup("EXCEPTION: " + this._extractMessage(exception));
	        if (lang_1.isPresent(stackTrace) && lang_1.isBlank(originalStack)) {
	            this._logger.logError("STACKTRACE:");
	            this._logger.logError(this._longStackTrace(stackTrace));
	        }
	        if (lang_1.isPresent(reason)) {
	            this._logger.logError("REASON: " + reason);
	        }
	        if (lang_1.isPresent(originalException)) {
	            this._logger.logError("ORIGINAL EXCEPTION: " + this._extractMessage(originalException));
	        }
	        if (lang_1.isPresent(originalStack)) {
	            this._logger.logError("ORIGINAL STACKTRACE:");
	            this._logger.logError(this._longStackTrace(originalStack));
	        }
	        if (lang_1.isPresent(context)) {
	            this._logger.logError("ERROR CONTEXT:");
	            this._logger.logError(context);
	        }
	        this._logger.logGroupEnd();
	        // We rethrow exceptions, so operations like 'bootstrap' will result in an error
	        // when an exception happens. If we do not rethrow, bootstrap will always succeed.
	        if (this._rethrowException)
	            throw exception;
	    };
	    ExceptionHandler.prototype._extractMessage = function (exception) {
	        return exception instanceof exceptions_1.WrappedException ? exception.wrapperMessage : exception.toString();
	    };
	    ExceptionHandler.prototype._longStackTrace = function (stackTrace) {
	        return collection_1.isListLikeIterable(stackTrace) ? stackTrace.join("\n\n-----async gap-----\n") :
	            stackTrace.toString();
	    };
	    ExceptionHandler.prototype._findContext = function (exception) {
	        try {
	            if (!(exception instanceof exceptions_1.WrappedException))
	                return null;
	            return lang_1.isPresent(exception.context) ? exception.context :
	                this._findContext(exception.originalException);
	        }
	        catch (e) {
	            // exception.context can throw an exception. if it happens, we ignore the context.
	            return null;
	        }
	    };
	    ExceptionHandler.prototype._findOriginalException = function (exception) {
	        if (!(exception instanceof exceptions_1.WrappedException))
	            return null;
	        var e = exception.originalException;
	        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
	            e = e.originalException;
	        }
	        return e;
	    };
	    ExceptionHandler.prototype._findOriginalStack = function (exception) {
	        if (!(exception instanceof exceptions_1.WrappedException))
	            return null;
	        var e = exception;
	        var stack = exception.originalStack;
	        while (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
	            e = e.originalException;
	            if (e instanceof exceptions_1.WrappedException && lang_1.isPresent(e.originalException)) {
	                stack = e.originalStack;
	            }
	        }
	        return stack;
	    };
	    return ExceptionHandler;
	})();
	exports.ExceptionHandler = ExceptionHandler;
	//# sourceMappingURL=exception_handler.js.map

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	var reflector_1 = __webpack_require__(171);
	var reflector_2 = __webpack_require__(171);
	exports.Reflector = reflector_2.Reflector;
	exports.ReflectionInfo = reflector_2.ReflectionInfo;
	var reflection_capabilities_1 = __webpack_require__(172);
	exports.reflector = new reflector_1.Reflector(new reflection_capabilities_1.ReflectionCapabilities());
	//# sourceMappingURL=reflection.js.map

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var ReflectionInfo = (function () {
	    function ReflectionInfo(annotations, parameters, factory, interfaces, propMetadata) {
	        this.annotations = annotations;
	        this.parameters = parameters;
	        this.factory = factory;
	        this.interfaces = interfaces;
	        this.propMetadata = propMetadata;
	    }
	    return ReflectionInfo;
	})();
	exports.ReflectionInfo = ReflectionInfo;
	var Reflector = (function () {
	    function Reflector(reflectionCapabilities) {
	        this._injectableInfo = new collection_1.Map();
	        this._getters = new collection_1.Map();
	        this._setters = new collection_1.Map();
	        this._methods = new collection_1.Map();
	        this._usedKeys = null;
	        this.reflectionCapabilities = reflectionCapabilities;
	    }
	    Reflector.prototype.isReflectionEnabled = function () { return this.reflectionCapabilities.isReflectionEnabled(); };
	    /**
	     * Causes `this` reflector to track keys used to access
	     * {@link ReflectionInfo} objects.
	     */
	    Reflector.prototype.trackUsage = function () { this._usedKeys = new collection_1.Set(); };
	    /**
	     * Lists types for which reflection information was not requested since
	     * {@link #trackUsage} was called. This list could later be audited as
	     * potential dead code.
	     */
	    Reflector.prototype.listUnusedKeys = function () {
	        var _this = this;
	        if (this._usedKeys == null) {
	            throw new exceptions_1.BaseException('Usage tracking is disabled');
	        }
	        var allTypes = collection_1.MapWrapper.keys(this._injectableInfo);
	        return collection_1.ListWrapper.filter(allTypes, function (key) { return !collection_1.SetWrapper.has(_this._usedKeys, key); });
	    };
	    Reflector.prototype.registerFunction = function (func, funcInfo) {
	        this._injectableInfo.set(func, funcInfo);
	    };
	    Reflector.prototype.registerType = function (type, typeInfo) {
	        this._injectableInfo.set(type, typeInfo);
	    };
	    Reflector.prototype.registerGetters = function (getters) {
	        _mergeMaps(this._getters, getters);
	    };
	    Reflector.prototype.registerSetters = function (setters) {
	        _mergeMaps(this._setters, setters);
	    };
	    Reflector.prototype.registerMethods = function (methods) {
	        _mergeMaps(this._methods, methods);
	    };
	    Reflector.prototype.factory = function (type) {
	        if (this._containsReflectionInfo(type)) {
	            var res = this._getReflectionInfo(type).factory;
	            return lang_1.isPresent(res) ? res : null;
	        }
	        else {
	            return this.reflectionCapabilities.factory(type);
	        }
	    };
	    Reflector.prototype.parameters = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).parameters;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.parameters(typeOrFunc);
	        }
	    };
	    Reflector.prototype.annotations = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).annotations;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.annotations(typeOrFunc);
	        }
	    };
	    Reflector.prototype.propMetadata = function (typeOrFunc) {
	        if (this._injectableInfo.has(typeOrFunc)) {
	            var res = this._getReflectionInfo(typeOrFunc).propMetadata;
	            return lang_1.isPresent(res) ? res : {};
	        }
	        else {
	            return this.reflectionCapabilities.propMetadata(typeOrFunc);
	        }
	    };
	    Reflector.prototype.interfaces = function (type) {
	        if (this._injectableInfo.has(type)) {
	            var res = this._getReflectionInfo(type).interfaces;
	            return lang_1.isPresent(res) ? res : [];
	        }
	        else {
	            return this.reflectionCapabilities.interfaces(type);
	        }
	    };
	    Reflector.prototype.getter = function (name) {
	        if (this._getters.has(name)) {
	            return this._getters.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.getter(name);
	        }
	    };
	    Reflector.prototype.setter = function (name) {
	        if (this._setters.has(name)) {
	            return this._setters.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.setter(name);
	        }
	    };
	    Reflector.prototype.method = function (name) {
	        if (this._methods.has(name)) {
	            return this._methods.get(name);
	        }
	        else {
	            return this.reflectionCapabilities.method(name);
	        }
	    };
	    Reflector.prototype._getReflectionInfo = function (typeOrFunc) {
	        if (lang_1.isPresent(this._usedKeys)) {
	            this._usedKeys.add(typeOrFunc);
	        }
	        return this._injectableInfo.get(typeOrFunc);
	    };
	    Reflector.prototype._containsReflectionInfo = function (typeOrFunc) { return this._injectableInfo.has(typeOrFunc); };
	    Reflector.prototype.importUri = function (type) { return this.reflectionCapabilities.importUri(type); };
	    return Reflector;
	})();
	exports.Reflector = Reflector;
	function _mergeMaps(target, config) {
	    collection_1.StringMapWrapper.forEach(config, function (v, k) { return target.set(k, v); });
	}
	//# sourceMappingURL=reflector.js.map

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var ReflectionCapabilities = (function () {
	    function ReflectionCapabilities(reflect) {
	        this._reflect = lang_1.isPresent(reflect) ? reflect : lang_1.global.Reflect;
	    }
	    ReflectionCapabilities.prototype.isReflectionEnabled = function () { return true; };
	    ReflectionCapabilities.prototype.factory = function (t) {
	        switch (t.length) {
	            case 0:
	                return function () { return new t(); };
	            case 1:
	                return function (a1) { return new t(a1); };
	            case 2:
	                return function (a1, a2) { return new t(a1, a2); };
	            case 3:
	                return function (a1, a2, a3) { return new t(a1, a2, a3); };
	            case 4:
	                return function (a1, a2, a3, a4) { return new t(a1, a2, a3, a4); };
	            case 5:
	                return function (a1, a2, a3, a4, a5) { return new t(a1, a2, a3, a4, a5); };
	            case 6:
	                return function (a1, a2, a3, a4, a5, a6) { return new t(a1, a2, a3, a4, a5, a6); };
	            case 7:
	                return function (a1, a2, a3, a4, a5, a6, a7) { return new t(a1, a2, a3, a4, a5, a6, a7); };
	            case 8:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return new t(a1, a2, a3, a4, a5, a6, a7, a8); };
	            case 9:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9); };
	            case 10:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	                };
	            case 11:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	                };
	            case 12:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	                };
	            case 13:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	                };
	            case 14:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	                };
	            case 15:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	                };
	            case 16:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
	                };
	            case 17:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
	                };
	            case 18:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18);
	                };
	            case 19:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19);
	                };
	            case 20:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) {
	                    return new t(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
	                };
	        }
	        ;
	        throw new Error("Cannot create a factory for '" + lang_1.stringify(t) + "' because its constructor has more than 20 arguments");
	    };
	    ReflectionCapabilities.prototype._zipTypesAndAnnotaions = function (paramTypes, paramAnnotations) {
	        var result;
	        if (typeof paramTypes === 'undefined') {
	            result = collection_1.ListWrapper.createFixedSize(paramAnnotations.length);
	        }
	        else {
	            result = collection_1.ListWrapper.createFixedSize(paramTypes.length);
	        }
	        for (var i = 0; i < result.length; i++) {
	            // TS outputs Object for parameters without types, while Traceur omits
	            // the annotations. For now we preserve the Traceur behavior to aid
	            // migration, but this can be revisited.
	            if (typeof paramTypes === 'undefined') {
	                result[i] = [];
	            }
	            else if (paramTypes[i] != Object) {
	                result[i] = [paramTypes[i]];
	            }
	            else {
	                result[i] = [];
	            }
	            if (lang_1.isPresent(paramAnnotations) && lang_1.isPresent(paramAnnotations[i])) {
	                result[i] = result[i].concat(paramAnnotations[i]);
	            }
	        }
	        return result;
	    };
	    ReflectionCapabilities.prototype.parameters = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.parameters)) {
	            return typeOrFunc.parameters;
	        }
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var paramAnnotations = this._reflect.getMetadata('parameters', typeOrFunc);
	            var paramTypes = this._reflect.getMetadata('design:paramtypes', typeOrFunc);
	            if (lang_1.isPresent(paramTypes) || lang_1.isPresent(paramAnnotations)) {
	                return this._zipTypesAndAnnotaions(paramTypes, paramAnnotations);
	            }
	        }
	        return collection_1.ListWrapper.createFixedSize(typeOrFunc.length);
	    };
	    ReflectionCapabilities.prototype.annotations = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.annotations)) {
	            var annotations = typeOrFunc.annotations;
	            if (lang_1.isFunction(annotations) && annotations.annotations) {
	                annotations = annotations.annotations;
	            }
	            return annotations;
	        }
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var annotations = this._reflect.getMetadata('annotations', typeOrFunc);
	            if (lang_1.isPresent(annotations))
	                return annotations;
	        }
	        return [];
	    };
	    ReflectionCapabilities.prototype.propMetadata = function (typeOrFunc) {
	        // Prefer the direct API.
	        if (lang_1.isPresent(typeOrFunc.propMetadata)) {
	            var propMetadata = typeOrFunc.propMetadata;
	            if (lang_1.isFunction(propMetadata) && propMetadata.propMetadata) {
	                propMetadata = propMetadata.propMetadata;
	            }
	            return propMetadata;
	        }
	        if (lang_1.isPresent(this._reflect) && lang_1.isPresent(this._reflect.getMetadata)) {
	            var propMetadata = this._reflect.getMetadata('propMetadata', typeOrFunc);
	            if (lang_1.isPresent(propMetadata))
	                return propMetadata;
	        }
	        return {};
	    };
	    ReflectionCapabilities.prototype.interfaces = function (type) {
	        throw new exceptions_1.BaseException("JavaScript does not support interfaces");
	    };
	    ReflectionCapabilities.prototype.getter = function (name) { return new Function('o', 'return o.' + name + ';'); };
	    ReflectionCapabilities.prototype.setter = function (name) {
	        return new Function('o', 'v', 'return o.' + name + ' = v;');
	    };
	    ReflectionCapabilities.prototype.method = function (name) {
	        var functionBody = "if (!o." + name + ") throw new Error('\"" + name + "\" is undefined');\n        return o." + name + ".apply(o, args);";
	        return new Function('o', 'args', functionBody);
	    };
	    // There is not a concept of import uri in Js, but this is useful in developing Dart applications.
	    ReflectionCapabilities.prototype.importUri = function (type) { return './'; };
	    return ReflectionCapabilities;
	})();
	exports.ReflectionCapabilities = ReflectionCapabilities;
	//# sourceMappingURL=reflection_capabilities.js.map

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var type_literal_1 = __webpack_require__(174);
	var forward_ref_1 = __webpack_require__(164);
	var type_literal_2 = __webpack_require__(174);
	exports.TypeLiteral = type_literal_2.TypeLiteral;
	/**
	 * A unique object used for retrieving items from the {@link Injector}.
	 *
	 * Keys have:
	 * - a system-wide unique `id`.
	 * - a `token`, usually the `Type` of the instance.
	 *
	 * Keys are used internally by the {@link Injector} because their system-wide unique `id`s allow the
	 * injector to index in arrays rather than looking up items in maps.
	 */
	var Key = (function () {
	    function Key(token, id) {
	        this.token = token;
	        this.id = id;
	        if (lang_1.isBlank(token)) {
	            throw new exceptions_1.BaseException('Token must be defined!');
	        }
	    }
	    Object.defineProperty(Key.prototype, "displayName", {
	        get: function () { return lang_1.stringify(this.token); },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Retrieves a `Key` for a token.
	     */
	    Key.get = function (token) { return _globalKeyRegistry.get(forward_ref_1.resolveForwardRef(token)); };
	    Object.defineProperty(Key, "numberOfKeys", {
	        /**
	         * @returns the number of keys registered in the system.
	         */
	        get: function () { return _globalKeyRegistry.numberOfKeys; },
	        enumerable: true,
	        configurable: true
	    });
	    return Key;
	})();
	exports.Key = Key;
	/**
	 * @private
	 */
	var KeyRegistry = (function () {
	    function KeyRegistry() {
	        this._allKeys = new Map();
	    }
	    KeyRegistry.prototype.get = function (token) {
	        if (token instanceof Key)
	            return token;
	        // TODO: workaround for https://github.com/Microsoft/TypeScript/issues/3123
	        var theToken = token;
	        if (token instanceof type_literal_1.TypeLiteral) {
	            theToken = token.type;
	        }
	        token = theToken;
	        if (this._allKeys.has(token)) {
	            return this._allKeys.get(token);
	        }
	        var newKey = new Key(token, Key.numberOfKeys);
	        this._allKeys.set(token, newKey);
	        return newKey;
	    };
	    Object.defineProperty(KeyRegistry.prototype, "numberOfKeys", {
	        get: function () { return collection_1.MapWrapper.size(this._allKeys); },
	        enumerable: true,
	        configurable: true
	    });
	    return KeyRegistry;
	})();
	exports.KeyRegistry = KeyRegistry;
	var _globalKeyRegistry = new KeyRegistry();
	//# sourceMappingURL=key.js.map

/***/ },
/* 174 */
/***/ function(module, exports) {

	/**
	 * Type literals is a Dart-only feature. This is here only so we can x-compile
	 * to multiple languages.
	 */
	var TypeLiteral = (function () {
	    function TypeLiteral() {
	    }
	    Object.defineProperty(TypeLiteral.prototype, "type", {
	        get: function () { throw new Error("Type literals are only supported in Dart"); },
	        enumerable: true,
	        configurable: true
	    });
	    return TypeLiteral;
	})();
	exports.TypeLiteral = TypeLiteral;
	//# sourceMappingURL=type_literal.js.map

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	function findFirstClosedCycle(keys) {
	    var res = [];
	    for (var i = 0; i < keys.length; ++i) {
	        if (collection_1.ListWrapper.contains(res, keys[i])) {
	            res.push(keys[i]);
	            return res;
	        }
	        else {
	            res.push(keys[i]);
	        }
	    }
	    return res;
	}
	function constructResolvingPath(keys) {
	    if (keys.length > 1) {
	        var reversed = findFirstClosedCycle(collection_1.ListWrapper.reversed(keys));
	        var tokenStrs = collection_1.ListWrapper.map(reversed, function (k) { return lang_1.stringify(k.token); });
	        return " (" + tokenStrs.join(' -> ') + ")";
	    }
	    else {
	        return "";
	    }
	}
	/**
	 * Base class for all errors arising from misconfigured bindings.
	 */
	var AbstractBindingError = (function (_super) {
	    __extends(AbstractBindingError, _super);
	    function AbstractBindingError(injector, key, constructResolvingMessage) {
	        _super.call(this, "DI Exception");
	        this.keys = [key];
	        this.injectors = [injector];
	        this.constructResolvingMessage = constructResolvingMessage;
	        this.message = this.constructResolvingMessage(this.keys);
	    }
	    AbstractBindingError.prototype.addKey = function (injector, key) {
	        this.injectors.push(injector);
	        this.keys.push(key);
	        this.message = this.constructResolvingMessage(this.keys);
	    };
	    Object.defineProperty(AbstractBindingError.prototype, "context", {
	        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
	        enumerable: true,
	        configurable: true
	    });
	    return AbstractBindingError;
	})(exceptions_1.BaseException);
	exports.AbstractBindingError = AbstractBindingError;
	/**
	 * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
	 * {@link Injector} does not have a {@link Binding} for {@link Key}.
	 */
	var NoBindingError = (function (_super) {
	    __extends(NoBindingError, _super);
	    function NoBindingError(injector, key) {
	        _super.call(this, injector, key, function (keys) {
	            var first = lang_1.stringify(collection_1.ListWrapper.first(keys).token);
	            return "No provider for " + first + "!" + constructResolvingPath(keys);
	        });
	    }
	    return NoBindingError;
	})(AbstractBindingError);
	exports.NoBindingError = NoBindingError;
	/**
	 * Thrown when dependencies form a cycle.
	 *
	 * ## Example:
	 *
	 * ```javascript
	 * class A {
	 *   constructor(b:B) {}
	 * }
	 * class B {
	 *   constructor(a:A) {}
	 * }
	 * ```
	 *
	 * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
	 */
	var CyclicDependencyError = (function (_super) {
	    __extends(CyclicDependencyError, _super);
	    function CyclicDependencyError(injector, key) {
	        _super.call(this, injector, key, function (keys) {
	            return "Cannot instantiate cyclic dependency!" + constructResolvingPath(keys);
	        });
	    }
	    return CyclicDependencyError;
	})(AbstractBindingError);
	exports.CyclicDependencyError = CyclicDependencyError;
	/**
	 * Thrown when a constructing type returns with an Error.
	 *
	 * The `InstantiationError` class contains the original error plus the dependency graph which caused
	 * this object to be instantiated.
	 */
	var InstantiationError = (function (_super) {
	    __extends(InstantiationError, _super);
	    function InstantiationError(injector, originalException, originalStack, key) {
	        _super.call(this, "DI Exception", originalException, originalStack, null);
	        this.keys = [key];
	        this.injectors = [injector];
	    }
	    InstantiationError.prototype.addKey = function (injector, key) {
	        this.injectors.push(injector);
	        this.keys.push(key);
	    };
	    Object.defineProperty(InstantiationError.prototype, "wrapperMessage", {
	        get: function () {
	            var first = lang_1.stringify(collection_1.ListWrapper.first(this.keys).token);
	            return "Error during instantiation of " + first + "!" + constructResolvingPath(this.keys) + ".";
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InstantiationError.prototype, "causeKey", {
	        get: function () { return this.keys[0]; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(InstantiationError.prototype, "context", {
	        get: function () { return this.injectors[this.injectors.length - 1].debugContext(); },
	        enumerable: true,
	        configurable: true
	    });
	    return InstantiationError;
	})(exceptions_1.WrappedException);
	exports.InstantiationError = InstantiationError;
	/**
	 * Thrown when an object other then {@link Binding} (or `Type`) is passed to {@link Injector}
	 * creation.
	 */
	var InvalidBindingError = (function (_super) {
	    __extends(InvalidBindingError, _super);
	    function InvalidBindingError(binding) {
	        _super.call(this);
	        this.message = "Invalid binding - only instances of Binding and Type are allowed, got: " +
	            binding.toString();
	    }
	    InvalidBindingError.prototype.toString = function () { return this.message; };
	    return InvalidBindingError;
	})(exceptions_1.BaseException);
	exports.InvalidBindingError = InvalidBindingError;
	/**
	 * Thrown when the class has no annotation information.
	 *
	 * Lack of annotation information prevents the {@link Injector} from determining which dependencies
	 * need to be injected into the constructor.
	 */
	var NoAnnotationError = (function (_super) {
	    __extends(NoAnnotationError, _super);
	    function NoAnnotationError(typeOrFunc, params) {
	        _super.call(this);
	        var signature = [];
	        for (var i = 0, ii = params.length; i < ii; i++) {
	            var parameter = params[i];
	            if (lang_1.isBlank(parameter) || parameter.length == 0) {
	                signature.push('?');
	            }
	            else {
	                signature.push(collection_1.ListWrapper.map(parameter, lang_1.stringify).join(' '));
	            }
	        }
	        this.message = "Cannot resolve all parameters for " + lang_1.stringify(typeOrFunc) + "(" +
	            signature.join(', ') + "). " +
	            'Make sure they all have valid type or annotations.';
	    }
	    NoAnnotationError.prototype.toString = function () { return this.message; };
	    return NoAnnotationError;
	})(exceptions_1.BaseException);
	exports.NoAnnotationError = NoAnnotationError;
	/**
	 * Thrown when getting an object by index.
	 */
	var OutOfBoundsError = (function (_super) {
	    __extends(OutOfBoundsError, _super);
	    function OutOfBoundsError(index) {
	        _super.call(this);
	        this.message = "Index " + index + " is out-of-bounds.";
	    }
	    OutOfBoundsError.prototype.toString = function () { return this.message; };
	    return OutOfBoundsError;
	})(exceptions_1.BaseException);
	exports.OutOfBoundsError = OutOfBoundsError;
	/**
	 * Thrown when a multi binding and a regular binding are bound to the same token.
	 */
	var MixingMultiBindingsWithRegularBindings = (function (_super) {
	    __extends(MixingMultiBindingsWithRegularBindings, _super);
	    function MixingMultiBindingsWithRegularBindings(binding1, binding2) {
	        _super.call(this);
	        this.message = "Cannot mix multi bindings and regular bindings, got: " + binding1.toString() +
	            " " + binding2.toString();
	    }
	    MixingMultiBindingsWithRegularBindings.prototype.toString = function () { return this.message; };
	    return MixingMultiBindingsWithRegularBindings;
	})(exceptions_1.BaseException);
	exports.MixingMultiBindingsWithRegularBindings = MixingMultiBindingsWithRegularBindings;
	//# sourceMappingURL=exceptions.js.map

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	/**
	 * By binding to an `OpaqueToken` you can enable an application to return more meaningful error
	 * messages.
	 *
	 * ## Example
	 *
	 * ```
	 * // While the following would work, see below for the preferred way
	 * var binding = bind('value0').toValue(0);
	 * ...
	 * var value = injector.get('value0');
	 *
	 * // An OpaqueToken is the preferred way and lead to more helpful error messages
	 * export value0Token = new OpaqueToken('value0');
	 * var binding = bind(value0Token).toValue(0);
	 * ...
	 * var value = injector.get(value0Token);
	 * ```
	 */
	var OpaqueToken = (function () {
	    function OpaqueToken(_desc) {
	        this._desc = _desc;
	    }
	    OpaqueToken.prototype.toString = function () { return "Token " + this._desc; };
	    OpaqueToken = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [String])
	    ], OpaqueToken);
	    return OpaqueToken;
	})();
	exports.OpaqueToken = OpaqueToken;
	//# sourceMappingURL=opaque_token.js.map

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var metadata_1 = __webpack_require__(161);
	var change_detection_1 = __webpack_require__(178);
	/**
	 * Directives allow you to attach behavior to elements in the DOM.
	 *
	 * {@link DirectiveMetadata}s with an embedded view are called {@link ComponentMetadata}s.
	 *
	 * A directive consists of a single directive annotation and a controller class. When the
	 * directive's `selector` matches
	 * elements in the DOM, the following steps occur:
	 *
	 * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
	 * arguments.
	 * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
	 * depth-first order,
	 *    as declared in the HTML.
	 *
	 * ## Understanding How Injection Works
	 *
	 * There are three stages of injection resolution.
	 * - *Pre-existing Injectors*:
	 *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
	 * the dependency was
	 *     specified as `@Optional`, returns `null`.
	 *   - The platform injector resolves browser singleton resources, such as: cookies, title,
	 * location, and others.
	 * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
	 * the same parent-child hierarchy
	 *     as the component instances in the DOM.
	 * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
	 * element has an `ElementInjector`
	 *     which follow the same parent-child hierarchy as the DOM elements themselves.
	 *
	 * When a template is instantiated, it also must instantiate the corresponding directives in a
	 * depth-first order. The
	 * current `ElementInjector` resolves the constructor dependencies for each directive.
	 *
	 * Angular then resolves dependencies as follows, according to the order in which they appear in the
	 * {@link ViewMetadata}:
	 *
	 * 1. Dependencies on the current element
	 * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
	 * 3. Dependencies on component injectors and their parents until it encounters the root component
	 * 4. Dependencies on pre-existing injectors
	 *
	 *
	 * The `ElementInjector` can inject other directives, element-specific special objects, or it can
	 * delegate to the parent
	 * injector.
	 *
	 * To inject other directives, declare the constructor parameter as:
	 * - `directive:DirectiveType`: a directive on the current element only
	 * - `@Host() directive:DirectiveType`: any directive that matches the type between the current
	 * element and the
	 *    Shadow DOM root.
	 * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
	 * directives.
	 * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
	 * child directives.
	 *
	 * To inject element-specific special objects, declare the constructor parameter as:
	 * - `element: ElementRef` to obtain a reference to logical element in the view.
	 * - `viewContainer: ViewContainerRef` to control child template instantiation, for
	 * {@link DirectiveMetadata} directives only
	 * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
	 *
	 * ## Example
	 *
	 * The following example demonstrates how dependency injection resolves constructor arguments in
	 * practice.
	 *
	 *
	 * Assume this HTML template:
	 *
	 * ```
	 * <div dependency="1">
	 *   <div dependency="2">
	 *     <div dependency="3" my-directive>
	 *       <div dependency="4">
	 *         <div dependency="5"></div>
	 *       </div>
	 *       <div dependency="6"></div>
	 *     </div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * With the following `dependency` decorator and `SomeService` injectable class.
	 *
	 * ```
	 * @Injectable()
	 * class SomeService {
	 * }
	 *
	 * @Directive({
	 *   selector: '[dependency]',
	 *   properties: [
	 *     'id: dependency'
	 *   ]
	 * })
	 * class Dependency {
	 *   id:string;
	 * }
	 * ```
	 *
	 * Let's step through the different ways in which `MyDirective` could be declared...
	 *
	 *
	 * ### No injection
	 *
	 * Here the constructor is declared with no arguments, therefore nothing is injected into
	 * `MyDirective`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor() {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with no dependencies.
	 *
	 *
	 * ### Component-level injection
	 *
	 * Directives can inject any injectable instance from the closest component injector or any of its
	 * parents.
	 *
	 * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
	 * from the parent
	 * component's injector.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(someService: SomeService) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a dependency on `SomeService`.
	 *
	 *
	 * ### Injecting a directive from the current element
	 *
	 * Directives can inject other directives declared on the current element.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(dependency: Dependency) {
	 *     expect(dependency.id).toEqual(3);
	 *   }
	 * }
	 * ```
	 * This directive would be instantiated with `Dependency` declared at the same element, in this case
	 * `dependency="3"`.
	 *
	 * ### Injecting a directive from any ancestor elements
	 *
	 * Directives can inject other directives declared on any ancestor element (in the current Shadow
	 * DOM), i.e. on the current element, the
	 * parent element, or its parents.
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Host() dependency: Dependency) {
	 *     expect(dependency.id).toEqual(2);
	 *   }
	 * }
	 * ```
	 *
	 * `@Host` checks the current element, the parent, as well as its parents recursively. If
	 * `dependency="2"` didn't
	 * exist on the direct parent, this injection would
	 * have returned
	 * `dependency="1"`.
	 *
	 *
	 * ### Injecting a live collection of direct child directives
	 *
	 *
	 * A directive can also query for other child directives. Since parent directives are instantiated
	 * before child directives, a directive can't simply inject the list of child directives. Instead,
	 * the directive injects a {@link QueryList}, which updates its contents as children are added,
	 * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an
	 * `ng-if`, or an `ng-switch`.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
	 * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
	 *
	 * ### Injecting a live collection of descendant directives
	 *
	 * By passing the descendant flag to `@Query` above, we can include the children of the child
	 * elements.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
	 *
	 * ### Optional injection
	 *
	 * The normal behavior of directives is to return an error when a specified dependency cannot be
	 * resolved. If you
	 * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
	 * with `@Optional()`.
	 * This explicitly permits the author of a template to treat some of the surrounding directives as
	 * optional.
	 *
	 * ```
	 * @Directive({ selector: '[my-directive]' })
	 * class MyDirective {
	 *   constructor(@Optional() dependency:Dependency) {
	 *   }
	 * }
	 * ```
	 *
	 * This directive would be instantiated with a `Dependency` directive found on the current element.
	 * If none can be
	 * found, the injector supplies `null` instead of throwing an error.
	 *
	 * ## Example
	 *
	 * Here we use a decorator directive to simply define basic tool-tip behavior.
	 *
	 * ```
	 * @Directive({
	 *   selector: '[tooltip]',
	 *   properties: [
	 *     'text: tooltip'
	 *   ],
	 *   host: {
	 *     '(mouseenter)': 'onMouseEnter()',
	 *     '(mouseleave)': 'onMouseLeave()'
	 *   }
	 * })
	 * class Tooltip{
	 *   text:string;
	 *   overlay:Overlay; // NOT YET IMPLEMENTED
	 *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
	 *
	 *   constructor(overlayManager:OverlayManager) {
	 *     this.overlay = overlay;
	 *   }
	 *
	 *   onMouseEnter() {
	 *     // exact signature to be determined
	 *     this.overlay = this.overlayManager.open(text, ...);
	 *   }
	 *
	 *   onMouseLeave() {
	 *     this.overlay.close();
	 *     this.overlay = null;
	 *   }
	 * }
	 * ```
	 * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
	 * `tooltip` selector,
	 * like so:
	 *
	 * ```
	 * <div tooltip="some text here"></div>
	 * ```
	 *
	 * Directives can also control the instantiation, destruction, and positioning of inline template
	 * elements:
	 *
	 * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
	 * runtime.
	 * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
	 * location in the current view
	 * where these actions are performed.
	 *
	 * Views are always created as children of the current {@link ViewMetadata}, and as siblings of the
	 * `<template>` element. Thus a
	 * directive in a child view cannot inject the directive that created it.
	 *
	 * Since directives that create views via ViewContainers are common in Angular, and using the full
	 * `<template>` element syntax is wordy, Angular
	 * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
	 * equivalent.
	 *
	 * Thus,
	 *
	 * ```
	 * <ul>
	 *   <li *foo="bar" title="text"></li>
	 * </ul>
	 * ```
	 *
	 * Expands in use to:
	 *
	 * ```
	 * <ul>
	 *   <template [foo]="bar">
	 *     <li title="text"></li>
	 *   </template>
	 * </ul>
	 * ```
	 *
	 * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
	 * the directive
	 * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the directive class implements some {@link angular2/lifecycle_hooks} the callbacks are
	 * called by the change detection at defined points in time during the life of the directive.
	 *
	 * ## Example
	 *
	 * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
	 *
	 * Here is a simple directive that triggers on an `unless` selector:
	 *
	 * ```
	 * @Directive({
	 *   selector: '[unless]',
	 *   properties: ['unless']
	 * })
	 * export class Unless {
	 *   viewContainer: ViewContainerRef;
	 *   templateRef: TemplateRef;
	 *   prevCondition: boolean;
	 *
	 *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
	 *     this.viewContainer = viewContainer;
	 *     this.templateRef = templateRef;
	 *     this.prevCondition = null;
	 *   }
	 *
	 *   set unless(newCondition) {
	 *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
	 *       this.prevCondition = true;
	 *       this.viewContainer.clear();
	 *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
	 *       this.prevCondition = false;
	 *       this.viewContainer.create(this.templateRef);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * We can then use this `unless` selector in a template:
	 * ```
	 * <ul>
	 *   <li *unless="expr"></li>
	 * </ul>
	 * ```
	 *
	 * Once the directive instantiates the child view, the shorthand notation for the template expands
	 * and the result is:
	 *
	 * ```
	 * <ul>
	 *   <template [unless]="exp">
	 *     <li></li>
	 *   </template>
	 *   <li></li>
	 * </ul>
	 * ```
	 *
	 * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
	 * the instantiated
	 * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
	 */
	var DirectiveMetadata = (function (_super) {
	    __extends(DirectiveMetadata, _super);
	    function DirectiveMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, selector = _b.selector, properties = _b.properties, events = _b.events, host = _b.host, bindings = _b.bindings, exportAs = _b.exportAs, _c = _b.compileChildren, compileChildren = _c === void 0 ? true : _c;
	        _super.call(this);
	        this.selector = selector;
	        this.properties = properties;
	        this.events = events;
	        this.host = host;
	        this.exportAs = exportAs;
	        this.compileChildren = compileChildren;
	        this.bindings = bindings;
	    }
	    DirectiveMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object])
	    ], DirectiveMetadata);
	    return DirectiveMetadata;
	})(metadata_1.InjectableMetadata);
	exports.DirectiveMetadata = DirectiveMetadata;
	/**
	 * Declare reusable UI building blocks for an application.
	 *
	 * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@Component`
	 * annotation specifies when a component is instantiated, and which properties and hostListeners it
	 * binds to.
	 *
	 * When a component is instantiated, Angular
	 * - creates a shadow DOM for the component.
	 * - loads the selected template into the shadow DOM.
	 * - creates all the injectable objects configured with `bindings` and `viewBindings`.
	 *
	 * All template expressions and statements are then evaluated against the component instance.
	 *
	 * For details on the `@View` annotation, see {@link ViewMetadata}.
	 *
	 * ## Lifecycle hooks
	 *
	 * When the component class implements some {@link angular2/lifecycle_hooks} the callbacks are
	 * called by the change detection at defined points in time during the life of the component.
	 *
	 * ## Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet'
	 * })
	 * @View({
	 *   template: 'Hello {{name}}!'
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 *
	 */
	var ComponentMetadata = (function (_super) {
	    __extends(ComponentMetadata, _super);
	    function ComponentMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, selector = _b.selector, properties = _b.properties, events = _b.events, host = _b.host, exportAs = _b.exportAs, bindings = _b.bindings, viewBindings = _b.viewBindings, _c = _b.changeDetection, changeDetection = _c === void 0 ? change_detection_1.ChangeDetectionStrategy.Default : _c, _d = _b.compileChildren, compileChildren = _d === void 0 ? true : _d;
	        _super.call(this, {
	            selector: selector,
	            properties: properties,
	            events: events,
	            host: host,
	            exportAs: exportAs,
	            bindings: bindings,
	            compileChildren: compileChildren
	        });
	        this.changeDetection = changeDetection;
	        this.viewBindings = viewBindings;
	    }
	    ComponentMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object])
	    ], ComponentMetadata);
	    return ComponentMetadata;
	})(DirectiveMetadata);
	exports.ComponentMetadata = ComponentMetadata;
	/**
	 * Declare reusable pipe function.
	 *
	 * ## Example
	 *
	 * ```
	 * @Pipe({
	 *   name: 'lowercase'
	 * })
	 * class Lowercase {
	 *   transform(v, args) { return v.toLowerCase(); }
	 * }
	 * ```
	 */
	var PipeMetadata = (function (_super) {
	    __extends(PipeMetadata, _super);
	    function PipeMetadata(_a) {
	        var name = _a.name, pure = _a.pure;
	        _super.call(this);
	        this.name = name;
	        this._pure = pure;
	    }
	    Object.defineProperty(PipeMetadata.prototype, "pure", {
	        get: function () { return lang_1.isPresent(this._pure) ? this._pure : true; },
	        enumerable: true,
	        configurable: true
	    });
	    PipeMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object])
	    ], PipeMetadata);
	    return PipeMetadata;
	})(metadata_1.InjectableMetadata);
	exports.PipeMetadata = PipeMetadata;
	/**
	 * Declare a bound field.
	 *
	 * ## Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'sample-dir'
	 * })
	 * class SampleDir {
	 *   @Property() property; // Same as @Property('property') property;
	 *   @Property("el-property") dirProperty;
	 * }
	 * ```
	 */
	var PropertyMetadata = (function () {
	    function PropertyMetadata(bindingPropertyName) {
	        this.bindingPropertyName = bindingPropertyName;
	    }
	    PropertyMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [String])
	    ], PropertyMetadata);
	    return PropertyMetadata;
	})();
	exports.PropertyMetadata = PropertyMetadata;
	/**
	 * Declare a bound event.
	 *
	 * ## Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'sample-dir'
	 * })
	 * class SampleDir {
	 *   @Event() event = new EventEmitter(); // Same as @Event('event') event = new EventEmitter();
	 *   @Event("el-event") dirEvent = new EventEmitter();
	 * }
	 * ```
	 */
	var EventMetadata = (function () {
	    function EventMetadata(bindingPropertyName) {
	        this.bindingPropertyName = bindingPropertyName;
	    }
	    EventMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [String])
	    ], EventMetadata);
	    return EventMetadata;
	})();
	exports.EventMetadata = EventMetadata;
	/**
	 * Declare a host property binding.
	 *
	 * ## Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'sample-dir'
	 * })
	 * class SampleDir {
	 *   @HostBinding() prop1; // Same as @HostBinding('prop1') prop1;
	 *   @HostBinding("el-prop") prop2;
	 * }
	 * ```
	 *
	 * This is equivalent to
	 *
	 * ```
	 * @Directive({
	 *   selector: 'sample-dir',
	 *   host: {'[prop1]': 'prop1', '[el-prop]': 'prop2'}
	 * })
	 * class SampleDir {
	 *   prop1;
	 *   prop2;
	 * }
	 * ```
	 */
	var HostBindingMetadata = (function () {
	    function HostBindingMetadata(hostPropertyName) {
	        this.hostPropertyName = hostPropertyName;
	    }
	    HostBindingMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [String])
	    ], HostBindingMetadata);
	    return HostBindingMetadata;
	})();
	exports.HostBindingMetadata = HostBindingMetadata;
	/**
	 * Declare a host listener.
	 *
	 * ## Example
	 *
	 * ```
	 * @Directive({
	 *   selector: 'sample-dir'
	 * })
	 * class SampleDir {
	 *   @HostListener("change", ['$event.target.value']) onChange(value){}
	 * }
	 * ```
	 *
	 * This is equivalent to
	 *
	 * ```
	 * @Directive({
	 *   selector: 'sample-dir',
	 *   host: {'(change)': 'onChange($event.target.value)'}
	 * })
	 * class SampleDir {
	 *   onChange(value){}
	 * }
	 * ```
	 */
	var HostListenerMetadata = (function () {
	    function HostListenerMetadata(eventName, args) {
	        this.eventName = eventName;
	        this.args = args;
	    }
	    HostListenerMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [String, Array])
	    ], HostListenerMetadata);
	    return HostListenerMetadata;
	})();
	exports.HostListenerMetadata = HostListenerMetadata;
	//# sourceMappingURL=directives.js.map

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * Change detection enables data binding in Angular.
	 */
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var change_detection_1 = __webpack_require__(179);
	exports.ChangeDetectionStrategy = change_detection_1.ChangeDetectionStrategy;
	exports.ExpressionChangedAfterItHasBeenCheckedException = change_detection_1.ExpressionChangedAfterItHasBeenCheckedException;
	exports.ChangeDetectionError = change_detection_1.ChangeDetectionError;
	exports.Locals = change_detection_1.Locals;
	exports.ChangeDetectorRef = change_detection_1.ChangeDetectorRef;
	exports.WrappedValue = change_detection_1.WrappedValue;
	exports.IterableDiffers = change_detection_1.IterableDiffers;
	exports.KeyValueDiffers = change_detection_1.KeyValueDiffers;
	exports.Lexer = change_detection_1.Lexer;
	exports.Parser = change_detection_1.Parser;
	exports.BindingTarget = change_detection_1.BindingTarget;
	exports.DirectiveIndex = change_detection_1.DirectiveIndex;
	exports.DebugContext = change_detection_1.DebugContext;
	__export(__webpack_require__(198));
	//# sourceMappingURL=change_detection.js.map

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var jit_proto_change_detector_1 = __webpack_require__(180);
	var pregen_proto_change_detector_1 = __webpack_require__(202);
	var proto_change_detector_1 = __webpack_require__(197);
	var iterable_differs_1 = __webpack_require__(203);
	var default_iterable_differ_1 = __webpack_require__(204);
	var keyvalue_differs_1 = __webpack_require__(205);
	var default_keyvalue_differ_1 = __webpack_require__(206);
	var interfaces_1 = __webpack_require__(207);
	var di_1 = __webpack_require__(160);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	__export(__webpack_require__(198));
	var lexer_1 = __webpack_require__(208);
	exports.Lexer = lexer_1.Lexer;
	var parser_1 = __webpack_require__(209);
	exports.Parser = parser_1.Parser;
	var locals_1 = __webpack_require__(210);
	exports.Locals = locals_1.Locals;
	var exceptions_1 = __webpack_require__(189);
	exports.DehydratedException = exceptions_1.DehydratedException;
	exports.ExpressionChangedAfterItHasBeenCheckedException = exceptions_1.ExpressionChangedAfterItHasBeenCheckedException;
	exports.ChangeDetectionError = exceptions_1.ChangeDetectionError;
	var interfaces_2 = __webpack_require__(207);
	exports.ChangeDetection = interfaces_2.ChangeDetection;
	exports.ChangeDetectorDefinition = interfaces_2.ChangeDetectorDefinition;
	exports.DebugContext = interfaces_2.DebugContext;
	exports.ChangeDetectorGenConfig = interfaces_2.ChangeDetectorGenConfig;
	var constants_1 = __webpack_require__(184);
	exports.ChangeDetectionStrategy = constants_1.ChangeDetectionStrategy;
	var proto_change_detector_2 = __webpack_require__(197);
	exports.DynamicProtoChangeDetector = proto_change_detector_2.DynamicProtoChangeDetector;
	var binding_record_1 = __webpack_require__(186);
	exports.BindingRecord = binding_record_1.BindingRecord;
	exports.BindingTarget = binding_record_1.BindingTarget;
	var directive_record_1 = __webpack_require__(187);
	exports.DirectiveIndex = directive_record_1.DirectiveIndex;
	exports.DirectiveRecord = directive_record_1.DirectiveRecord;
	var dynamic_change_detector_1 = __webpack_require__(199);
	exports.DynamicChangeDetector = dynamic_change_detector_1.DynamicChangeDetector;
	var change_detector_ref_1 = __webpack_require__(188);
	exports.ChangeDetectorRef = change_detector_ref_1.ChangeDetectorRef;
	var iterable_differs_2 = __webpack_require__(203);
	exports.IterableDiffers = iterable_differs_2.IterableDiffers;
	var keyvalue_differs_2 = __webpack_require__(205);
	exports.KeyValueDiffers = keyvalue_differs_2.KeyValueDiffers;
	var change_detection_util_1 = __webpack_require__(183);
	exports.WrappedValue = change_detection_util_1.WrappedValue;
	/**
	 * Structural diffing for `Object`s and `Map`s.
	 */
	exports.keyValDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_keyvalue_differ_1.DefaultKeyValueDifferFactory())]);
	/**
	 * Structural diffing for `Iterable` types such as `Array`s.
	 */
	exports.iterableDiff = lang_1.CONST_EXPR([lang_1.CONST_EXPR(new default_iterable_differ_1.DefaultIterableDifferFactory())]);
	exports.defaultIterableDiffers = lang_1.CONST_EXPR(new iterable_differs_1.IterableDiffers(exports.iterableDiff));
	exports.defaultKeyValueDiffers = lang_1.CONST_EXPR(new keyvalue_differs_1.KeyValueDiffers(exports.keyValDiff));
	/**
	 * Map from {@link ChangeDetectorDefinition#id} to a factory method which takes a
	 * {@link Pipes} and a {@link ChangeDetectorDefinition} and generates a
	 * {@link ProtoChangeDetector} associated with the definition.
	 */
	// TODO(kegluneq): Use PregenProtoChangeDetectorFactory rather than Function once possible in
	// dart2js. See https://github.com/dart-lang/sdk/issues/23630 for details.
	exports.preGeneratedProtoDetectors = {};
	/**
	 * Implements change detection using a map of pregenerated proto detectors.
	 */
	var PreGeneratedChangeDetection = (function (_super) {
	    __extends(PreGeneratedChangeDetection, _super);
	    function PreGeneratedChangeDetection(config, protoChangeDetectorsForTest) {
	        _super.call(this);
	        this._dynamicChangeDetection = new DynamicChangeDetection();
	        this._protoChangeDetectorFactories = lang_1.isPresent(protoChangeDetectorsForTest) ?
	            protoChangeDetectorsForTest :
	            exports.preGeneratedProtoDetectors;
	        this._genConfig =
	            lang_1.isPresent(config) ? config : new interfaces_1.ChangeDetectorGenConfig(lang_1.assertionsEnabled(), lang_1.assertionsEnabled(), false, false);
	    }
	    PreGeneratedChangeDetection.isSupported = function () { return pregen_proto_change_detector_1.PregenProtoChangeDetector.isSupported(); };
	    PreGeneratedChangeDetection.prototype.getProtoChangeDetector = function (id, definition) {
	        if (collection_1.StringMapWrapper.contains(this._protoChangeDetectorFactories, id)) {
	            return collection_1.StringMapWrapper.get(this._protoChangeDetectorFactories, id)(definition);
	        }
	        return this._dynamicChangeDetection.getProtoChangeDetector(id, definition);
	    };
	    Object.defineProperty(PreGeneratedChangeDetection.prototype, "genConfig", {
	        get: function () { return this._genConfig; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PreGeneratedChangeDetection.prototype, "generateDetectors", {
	        get: function () { return true; },
	        enumerable: true,
	        configurable: true
	    });
	    PreGeneratedChangeDetection = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [interfaces_1.ChangeDetectorGenConfig, Object])
	    ], PreGeneratedChangeDetection);
	    return PreGeneratedChangeDetection;
	})(interfaces_1.ChangeDetection);
	exports.PreGeneratedChangeDetection = PreGeneratedChangeDetection;
	/**
	 * Implements change detection that does not require `eval()`.
	 *
	 * This is slower than {@link JitChangeDetection}.
	 */
	var DynamicChangeDetection = (function (_super) {
	    __extends(DynamicChangeDetection, _super);
	    function DynamicChangeDetection(config) {
	        _super.call(this);
	        this._genConfig =
	            lang_1.isPresent(config) ? config : new interfaces_1.ChangeDetectorGenConfig(lang_1.assertionsEnabled(), lang_1.assertionsEnabled(), false, false);
	    }
	    DynamicChangeDetection.prototype.getProtoChangeDetector = function (id, definition) {
	        return new proto_change_detector_1.DynamicProtoChangeDetector(definition);
	    };
	    Object.defineProperty(DynamicChangeDetection.prototype, "genConfig", {
	        get: function () { return this._genConfig; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DynamicChangeDetection.prototype, "generateDetectors", {
	        get: function () { return true; },
	        enumerable: true,
	        configurable: true
	    });
	    DynamicChangeDetection = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [interfaces_1.ChangeDetectorGenConfig])
	    ], DynamicChangeDetection);
	    return DynamicChangeDetection;
	})(interfaces_1.ChangeDetection);
	exports.DynamicChangeDetection = DynamicChangeDetection;
	/**
	 * Implements faster change detection by generating source code.
	 *
	 * This requires `eval()`. For change detection that does not require `eval()`, see
	 * {@link DynamicChangeDetection} and {@link PreGeneratedChangeDetection}.
	 */
	var JitChangeDetection = (function (_super) {
	    __extends(JitChangeDetection, _super);
	    function JitChangeDetection(config) {
	        _super.call(this);
	        this._genConfig =
	            lang_1.isPresent(config) ? config : new interfaces_1.ChangeDetectorGenConfig(lang_1.assertionsEnabled(), lang_1.assertionsEnabled(), false, true);
	    }
	    JitChangeDetection.isSupported = function () { return jit_proto_change_detector_1.JitProtoChangeDetector.isSupported(); };
	    JitChangeDetection.prototype.getProtoChangeDetector = function (id, definition) {
	        return new jit_proto_change_detector_1.JitProtoChangeDetector(definition);
	    };
	    Object.defineProperty(JitChangeDetection.prototype, "genConfig", {
	        get: function () { return this._genConfig; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(JitChangeDetection.prototype, "generateDetectors", {
	        get: function () { return true; },
	        enumerable: true,
	        configurable: true
	    });
	    JitChangeDetection = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [interfaces_1.ChangeDetectorGenConfig])
	    ], JitChangeDetection);
	    return JitChangeDetection;
	})(interfaces_1.ChangeDetection);
	exports.JitChangeDetection = JitChangeDetection;
	//# sourceMappingURL=change_detection.js.map

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	var change_detection_jit_generator_1 = __webpack_require__(181);
	var JitProtoChangeDetector = (function () {
	    function JitProtoChangeDetector(definition) {
	        this.definition = definition;
	        this._factory = this._createFactory(definition);
	    }
	    JitProtoChangeDetector.isSupported = function () { return true; };
	    JitProtoChangeDetector.prototype.instantiate = function (dispatcher) { return this._factory(dispatcher); };
	    JitProtoChangeDetector.prototype._createFactory = function (definition) {
	        return new change_detection_jit_generator_1.ChangeDetectorJITGenerator(definition, 'util', 'AbstractChangeDetector').generate();
	    };
	    return JitProtoChangeDetector;
	})();
	exports.JitProtoChangeDetector = JitProtoChangeDetector;
	//# sourceMappingURL=jit_proto_change_detector.js.map

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var abstract_change_detector_1 = __webpack_require__(182);
	var change_detection_util_1 = __webpack_require__(183);
	var codegen_name_util_1 = __webpack_require__(193);
	var codegen_logic_util_1 = __webpack_require__(194);
	var codegen_facade_1 = __webpack_require__(195);
	var proto_change_detector_1 = __webpack_require__(197);
	/**
	 * The code generator takes a list of proto records and creates a function/class
	 * that "emulates" what the developer would write by hand to implement the same
	 * kind of behaviour.
	 *
	 * This code should be kept in sync with the Dart transformer's
	 * `angular2.transform.template_compiler.change_detector_codegen` library. If you make updates
	 * here, please make equivalent changes there.
	*/
	var IS_CHANGED_LOCAL = "isChanged";
	var CHANGES_LOCAL = "changes";
	var ChangeDetectorJITGenerator = (function () {
	    function ChangeDetectorJITGenerator(definition, changeDetectionUtilVarName, abstractChangeDetectorVarName) {
	        this.changeDetectionUtilVarName = changeDetectionUtilVarName;
	        this.abstractChangeDetectorVarName = abstractChangeDetectorVarName;
	        var propertyBindingRecords = proto_change_detector_1.createPropertyRecords(definition);
	        var eventBindingRecords = proto_change_detector_1.createEventRecords(definition);
	        var propertyBindingTargets = definition.bindingRecords.map(function (b) { return b.target; });
	        this.id = definition.id;
	        this.changeDetectionStrategy = definition.strategy;
	        this.genConfig = definition.genConfig;
	        this.records = propertyBindingRecords;
	        this.propertyBindingTargets = propertyBindingTargets;
	        this.eventBindings = eventBindingRecords;
	        this.directiveRecords = definition.directiveRecords;
	        this._names = new codegen_name_util_1.CodegenNameUtil(this.records, this.eventBindings, this.directiveRecords, this.changeDetectionUtilVarName);
	        this._logic = new codegen_logic_util_1.CodegenLogicUtil(this._names, this.changeDetectionUtilVarName, this.changeDetectionStrategy);
	        this.typeName = codegen_name_util_1.sanitizeName("ChangeDetector_" + this.id);
	    }
	    ChangeDetectorJITGenerator.prototype.generate = function () {
	        var factorySource = "\n      " + this.generateSource() + "\n      return function(dispatcher) {\n        return new " + this.typeName + "(dispatcher);\n      }\n    ";
	        return new Function(this.abstractChangeDetectorVarName, this.changeDetectionUtilVarName, factorySource)(abstract_change_detector_1.AbstractChangeDetector, change_detection_util_1.ChangeDetectionUtil);
	    };
	    ChangeDetectorJITGenerator.prototype.generateSource = function () {
	        var _this = this;
	        return "\n      var " + this.typeName + " = function " + this.typeName + "(dispatcher) {\n        " + this.abstractChangeDetectorVarName + ".call(\n            this, " + JSON.stringify(this.id) + ", dispatcher, " + this.records.length + ",\n            " + this.typeName + ".gen_propertyBindingTargets, " + this.typeName + ".gen_directiveIndices,\n            " + codegen_facade_1.codify(this.changeDetectionStrategy) + ");\n        this.dehydrateDirectives(false);\n      }\n\n      " + this.typeName + ".prototype = Object.create(" + this.abstractChangeDetectorVarName + ".prototype);\n\n      " + this.typeName + ".prototype.detectChangesInRecordsInternal = function(throwOnChange) {\n        " + this._names.genInitLocals() + "\n        var " + IS_CHANGED_LOCAL + " = false;\n        var " + CHANGES_LOCAL + " = null;\n\n        " + this.records.map(function (r) { return _this._genRecord(r); }).join("\n") + "\n      }\n\n      " + this._maybeGenHandleEventInternal() + "\n\n      " + this._genCheckNoChanges() + "\n\n      " + this._maybeGenAfterContentLifecycleCallbacks() + "\n\n      " + this._maybeGenAfterViewLifecycleCallbacks() + "\n\n      " + this._maybeGenHydrateDirectives() + "\n\n      " + this._maybeGenDehydrateDirectives() + "\n\n      " + this._genPropertyBindingTargets() + "\n\n      " + this._genDirectiveIndices() + "\n    ";
	    };
	    ChangeDetectorJITGenerator.prototype._genPropertyBindingTargets = function () {
	        var targets = this._logic.genPropertyBindingTargets(this.propertyBindingTargets, this.genConfig.genDebugInfo);
	        return this.typeName + ".gen_propertyBindingTargets = " + targets + ";";
	    };
	    ChangeDetectorJITGenerator.prototype._genDirectiveIndices = function () {
	        var indices = this._logic.genDirectiveIndices(this.directiveRecords);
	        return this.typeName + ".gen_directiveIndices = " + indices + ";";
	    };
	    ChangeDetectorJITGenerator.prototype._maybeGenHandleEventInternal = function () {
	        var _this = this;
	        if (this.eventBindings.length > 0) {
	            var handlers = this.eventBindings.map(function (eb) { return _this._genEventBinding(eb); }).join("\n");
	            return "\n        " + this.typeName + ".prototype.handleEventInternal = function(eventName, elIndex, locals) {\n          var " + this._names.getPreventDefaultAccesor() + " = false;\n          " + this._names.genInitEventLocals() + "\n          " + handlers + "\n          return " + this._names.getPreventDefaultAccesor() + ";\n        }\n      ";
	        }
	        else {
	            return '';
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genEventBinding = function (eb) {
	        var _this = this;
	        var recs = eb.records.map(function (r) { return _this._genEventBindingEval(eb, r); }).join("\n");
	        return "\n    if (eventName === \"" + eb.eventName + "\" && elIndex === " + eb.elIndex + ") {\n      " + recs + "\n    }";
	    };
	    ChangeDetectorJITGenerator.prototype._genEventBindingEval = function (eb, r) {
	        if (r.lastInBinding) {
	            var evalRecord = this._logic.genEventBindingEvalValue(eb, r);
	            var markPath = this._genMarkPathToRootAsCheckOnce(r);
	            var prevDefault = this._genUpdatePreventDefault(eb, r);
	            return evalRecord + "\n" + markPath + "\n" + prevDefault;
	        }
	        else {
	            return this._logic.genEventBindingEvalValue(eb, r);
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genMarkPathToRootAsCheckOnce = function (r) {
	        var br = r.bindingRecord;
	        if (br.isDefaultChangeDetection()) {
	            return "";
	        }
	        else {
	            return this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markPathToRootAsCheckOnce();";
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genUpdatePreventDefault = function (eb, r) {
	        var local = this._names.getEventLocalName(eb, r.selfIndex);
	        return "if (" + local + " === false) { " + this._names.getPreventDefaultAccesor() + " = true};";
	    };
	    ChangeDetectorJITGenerator.prototype._maybeGenDehydrateDirectives = function () {
	        var destroyPipesCode = this._names.genPipeOnDestroy();
	        if (destroyPipesCode) {
	            destroyPipesCode = "if (destroyPipes) { " + destroyPipesCode + " }";
	        }
	        var dehydrateFieldsCode = this._names.genDehydrateFields();
	        if (!destroyPipesCode && !dehydrateFieldsCode)
	            return '';
	        return this.typeName + ".prototype.dehydrateDirectives = function(destroyPipes) {\n        " + destroyPipesCode + "\n        " + dehydrateFieldsCode + "\n    }";
	    };
	    ChangeDetectorJITGenerator.prototype._maybeGenHydrateDirectives = function () {
	        var hydrateDirectivesCode = this._logic.genHydrateDirectives(this.directiveRecords);
	        var hydrateDetectorsCode = this._logic.genHydrateDetectors(this.directiveRecords);
	        if (!hydrateDirectivesCode && !hydrateDetectorsCode)
	            return '';
	        return this.typeName + ".prototype.hydrateDirectives = function(directives) {\n      " + hydrateDirectivesCode + "\n      " + hydrateDetectorsCode + "\n    }";
	    };
	    ChangeDetectorJITGenerator.prototype._maybeGenAfterContentLifecycleCallbacks = function () {
	        var notifications = this._logic.genContentLifecycleCallbacks(this.directiveRecords);
	        if (notifications.length > 0) {
	            var directiveNotifications = notifications.join("\n");
	            return "\n        " + this.typeName + ".prototype.afterContentLifecycleCallbacksInternal = function() {\n          " + directiveNotifications + "\n        }\n      ";
	        }
	        else {
	            return '';
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._maybeGenAfterViewLifecycleCallbacks = function () {
	        var notifications = this._logic.genViewLifecycleCallbacks(this.directiveRecords);
	        if (notifications.length > 0) {
	            var directiveNotifications = notifications.join("\n");
	            return "\n        " + this.typeName + ".prototype.afterViewLifecycleCallbacksInternal = function() {\n          " + directiveNotifications + "\n        }\n      ";
	        }
	        else {
	            return '';
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genRecord = function (r) {
	        var rec;
	        if (r.isLifeCycleRecord()) {
	            rec = this._genDirectiveLifecycle(r);
	        }
	        else if (r.isPipeRecord()) {
	            rec = this._genPipeCheck(r);
	        }
	        else {
	            rec = this._genReferenceCheck(r);
	        }
	        return "\n      " + this._maybeFirstInBinding(r) + "\n      " + rec + "\n      " + this._maybeGenLastInDirective(r) + "\n    ";
	    };
	    ChangeDetectorJITGenerator.prototype._genDirectiveLifecycle = function (r) {
	        if (r.name === "DoCheck") {
	            return this._genOnCheck(r);
	        }
	        else if (r.name === "OnInit") {
	            return this._genOnInit(r);
	        }
	        else if (r.name === "OnChanges") {
	            return this._genOnChange(r);
	        }
	        else {
	            throw new exceptions_1.BaseException("Unknown lifecycle event '" + r.name + "'");
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genPipeCheck = function (r) {
	        var _this = this;
	        var context = this._names.getLocalName(r.contextIndex);
	        var argString = r.args.map(function (arg) { return _this._names.getLocalName(arg); }).join(", ");
	        var oldValue = this._names.getFieldName(r.selfIndex);
	        var newValue = this._names.getLocalName(r.selfIndex);
	        var pipe = this._names.getPipeName(r.selfIndex);
	        var pipeName = r.name;
	        var init = "\n      if (" + pipe + " === " + this.changeDetectionUtilVarName + ".uninitialized) {\n        " + pipe + " = " + this._names.getPipesAccessorName() + ".get('" + pipeName + "');\n      }\n    ";
	        var read = newValue + " = " + pipe + ".pipe.transform(" + context + ", [" + argString + "]);";
	        var contexOrArgCheck = r.args.map(function (a) { return _this._names.getChangeName(a); });
	        contexOrArgCheck.push(this._names.getChangeName(r.contextIndex));
	        var condition = "!" + pipe + ".pure || (" + contexOrArgCheck.join(" || ") + ")";
	        var check = "\n      if (" + oldValue + " !== " + newValue + ") {\n        " + newValue + " = " + this.changeDetectionUtilVarName + ".unwrapValue(" + newValue + ")\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ";
	        var genCode = r.shouldBeChecked() ? "" + read + check : read;
	        if (r.isUsedByOtherRecord()) {
	            return init + " if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }";
	        }
	        else {
	            return init + " if (" + condition + ") { " + genCode + " }";
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genReferenceCheck = function (r) {
	        var _this = this;
	        var oldValue = this._names.getFieldName(r.selfIndex);
	        var newValue = this._names.getLocalName(r.selfIndex);
	        var read = "\n      " + this._logic.genPropertyBindingEvalValue(r) + "\n    ";
	        var check = "\n      if (" + newValue + " !== " + oldValue + ") {\n        " + this._genChangeMarker(r) + "\n        " + this._genUpdateDirectiveOrElement(r) + "\n        " + this._genAddToChanges(r) + "\n        " + oldValue + " = " + newValue + ";\n      }\n    ";
	        var genCode = r.shouldBeChecked() ? "" + read + check : read;
	        if (r.isPureFunction()) {
	            var condition = r.args.map(function (a) { return _this._names.getChangeName(a); }).join(" || ");
	            if (r.isUsedByOtherRecord()) {
	                return "if (" + condition + ") { " + genCode + " } else { " + newValue + " = " + oldValue + "; }";
	            }
	            else {
	                return "if (" + condition + ") { " + genCode + " }";
	            }
	        }
	        else {
	            return genCode;
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genChangeMarker = function (r) {
	        return r.argumentToPureFunction ? this._names.getChangeName(r.selfIndex) + " = true" : "";
	    };
	    ChangeDetectorJITGenerator.prototype._genUpdateDirectiveOrElement = function (r) {
	        if (!r.lastInBinding)
	            return "";
	        var newValue = this._names.getLocalName(r.selfIndex);
	        var oldValue = this._names.getFieldName(r.selfIndex);
	        var notifyDebug = this.genConfig.logBindingUpdate ? "this.logBindingUpdate(" + newValue + ");" : "";
	        var br = r.bindingRecord;
	        if (br.target.isDirective()) {
	            var directiveProperty = this._names.getDirectiveName(br.directiveRecord.directiveIndex) + "." + br.target.name;
	            return "\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        " + directiveProperty + " = " + newValue + ";\n        " + notifyDebug + "\n        " + IS_CHANGED_LOCAL + " = true;\n      ";
	        }
	        else {
	            return "\n        " + this._genThrowOnChangeCheck(oldValue, newValue) + "\n        this.notifyDispatcher(" + newValue + ");\n        " + notifyDebug + "\n      ";
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genThrowOnChangeCheck = function (oldValue, newValue) {
	        if (this.genConfig.genCheckNoChanges) {
	            return "\n        if(throwOnChange) {\n          this.throwOnChangeError(" + oldValue + ", " + newValue + ");\n        }\n        ";
	        }
	        else {
	            return '';
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genCheckNoChanges = function () {
	        if (this.genConfig.genCheckNoChanges) {
	            return this.typeName + ".prototype.checkNoChanges = function() { this.runDetectChanges(true); }";
	        }
	        else {
	            return '';
	        }
	    };
	    ChangeDetectorJITGenerator.prototype._genAddToChanges = function (r) {
	        var newValue = this._names.getLocalName(r.selfIndex);
	        var oldValue = this._names.getFieldName(r.selfIndex);
	        if (!r.bindingRecord.callOnChanges())
	            return "";
	        return CHANGES_LOCAL + " = this.addChange(" + CHANGES_LOCAL + ", " + oldValue + ", " + newValue + ");";
	    };
	    ChangeDetectorJITGenerator.prototype._maybeFirstInBinding = function (r) {
	        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this.records, r.selfIndex - 1);
	        var firstInBindng = lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
	        return firstInBindng && !r.bindingRecord.isDirectiveLifecycle() ?
	            this._names.getPropertyBindingIndex() + " = " + r.propertyBindingIndex + ";" :
	            '';
	    };
	    ChangeDetectorJITGenerator.prototype._maybeGenLastInDirective = function (r) {
	        if (!r.lastInDirective)
	            return "";
	        return "\n      " + CHANGES_LOCAL + " = null;\n      " + this._genNotifyOnPushDetectors(r) + "\n      " + IS_CHANGED_LOCAL + " = false;\n    ";
	    };
	    ChangeDetectorJITGenerator.prototype._genOnCheck = function (r) {
	        var br = r.bindingRecord;
	        return "if (!throwOnChange) " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".doCheck();";
	    };
	    ChangeDetectorJITGenerator.prototype._genOnInit = function (r) {
	        var br = r.bindingRecord;
	        return "if (!throwOnChange && !" + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onInit();";
	    };
	    ChangeDetectorJITGenerator.prototype._genOnChange = function (r) {
	        var br = r.bindingRecord;
	        return "if (!throwOnChange && " + CHANGES_LOCAL + ") " + this._names.getDirectiveName(br.directiveRecord.directiveIndex) + ".onChanges(" + CHANGES_LOCAL + ");";
	    };
	    ChangeDetectorJITGenerator.prototype._genNotifyOnPushDetectors = function (r) {
	        var br = r.bindingRecord;
	        if (!r.lastInDirective || br.isDefaultChangeDetection())
	            return "";
	        var retVal = "\n      if(" + IS_CHANGED_LOCAL + ") {\n        " + this._names.getDetectorName(br.directiveRecord.directiveIndex) + ".markAsCheckOnce();\n      }\n    ";
	        return retVal;
	    };
	    return ChangeDetectorJITGenerator;
	})();
	exports.ChangeDetectorJITGenerator = ChangeDetectorJITGenerator;
	//# sourceMappingURL=change_detection_jit_generator.js.map

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var change_detection_util_1 = __webpack_require__(183);
	var change_detector_ref_1 = __webpack_require__(188);
	var exceptions_2 = __webpack_require__(189);
	var constants_1 = __webpack_require__(184);
	var profile_1 = __webpack_require__(190);
	var observable_facade_1 = __webpack_require__(192);
	var _scope_check = profile_1.wtfCreateScope("ChangeDetector#check(ascii id, bool throwOnChange)");
	var _Context = (function () {
	    function _Context(element, componentElement, context, locals, injector, expression) {
	        this.element = element;
	        this.componentElement = componentElement;
	        this.context = context;
	        this.locals = locals;
	        this.injector = injector;
	        this.expression = expression;
	    }
	    return _Context;
	})();
	var AbstractChangeDetector = (function () {
	    function AbstractChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, bindingTargets, directiveIndices, strategy) {
	        this.id = id;
	        this.dispatcher = dispatcher;
	        this.numberOfPropertyProtoRecords = numberOfPropertyProtoRecords;
	        this.bindingTargets = bindingTargets;
	        this.directiveIndices = directiveIndices;
	        this.strategy = strategy;
	        this.lightDomChildren = [];
	        this.shadowDomChildren = [];
	        // The names of the below fields must be kept in sync with codegen_name_util.ts or
	        // change detection will fail.
	        this.alreadyChecked = false;
	        this.locals = null;
	        this.mode = null;
	        this.pipes = null;
	        this.ref = new change_detector_ref_1.ChangeDetectorRef(this);
	    }
	    AbstractChangeDetector.prototype.addChild = function (cd) {
	        this.lightDomChildren.push(cd);
	        cd.parent = this;
	    };
	    AbstractChangeDetector.prototype.removeChild = function (cd) { collection_1.ListWrapper.remove(this.lightDomChildren, cd); };
	    AbstractChangeDetector.prototype.addShadowDomChild = function (cd) {
	        this.shadowDomChildren.push(cd);
	        cd.parent = this;
	    };
	    AbstractChangeDetector.prototype.removeShadowDomChild = function (cd) { collection_1.ListWrapper.remove(this.shadowDomChildren, cd); };
	    AbstractChangeDetector.prototype.remove = function () { this.parent.removeChild(this); };
	    AbstractChangeDetector.prototype.handleEvent = function (eventName, elIndex, locals) {
	        var res = this.handleEventInternal(eventName, elIndex, locals);
	        this.markPathToRootAsCheckOnce();
	        return res;
	    };
	    AbstractChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) { return false; };
	    AbstractChangeDetector.prototype.detectChanges = function () { this.runDetectChanges(false); };
	    AbstractChangeDetector.prototype.checkNoChanges = function () { throw new exceptions_1.BaseException("Not implemented"); };
	    AbstractChangeDetector.prototype.runDetectChanges = function (throwOnChange) {
	        if (this.mode === constants_1.ChangeDetectionStrategy.Detached ||
	            this.mode === constants_1.ChangeDetectionStrategy.Checked)
	            return;
	        var s = _scope_check(this.id, throwOnChange);
	        this.detectChangesInRecords(throwOnChange);
	        this._detectChangesInLightDomChildren(throwOnChange);
	        if (!throwOnChange)
	            this.afterContentLifecycleCallbacks();
	        this._detectChangesInShadowDomChildren(throwOnChange);
	        if (!throwOnChange)
	            this.afterViewLifecycleCallbacks();
	        if (this.mode === constants_1.ChangeDetectionStrategy.CheckOnce)
	            this.mode = constants_1.ChangeDetectionStrategy.Checked;
	        this.alreadyChecked = true;
	        profile_1.wtfLeave(s);
	    };
	    // This method is not intended to be overridden. Subclasses should instead provide an
	    // implementation of `detectChangesInRecordsInternal` which does the work of detecting changes
	    // and which this method will call.
	    // This method expects that `detectChangesInRecordsInternal` will set the property
	    // `this.propertyBindingIndex` to the propertyBindingIndex of the first proto record. This is to
	    // facilitate error reporting.
	    AbstractChangeDetector.prototype.detectChangesInRecords = function (throwOnChange) {
	        if (!this.hydrated()) {
	            this.throwDehydratedError();
	        }
	        try {
	            this.detectChangesInRecordsInternal(throwOnChange);
	        }
	        catch (e) {
	            this._throwError(e, e.stack);
	        }
	    };
	    // Subclasses should override this method to perform any work necessary to detect and report
	    // changes. For example, changes should be reported via `ChangeDetectionUtil.addChange`, lifecycle
	    // methods should be called, etc.
	    // This implementation should also set `this.propertyBindingIndex` to the propertyBindingIndex of
	    // the
	    // first proto record to facilitate error reporting. See {@link #detectChangesInRecords}.
	    AbstractChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) { };
	    // This method is not intended to be overridden. Subclasses should instead provide an
	    // implementation of `hydrateDirectives`.
	    AbstractChangeDetector.prototype.hydrate = function (context, locals, directives, pipes) {
	        this.mode = change_detection_util_1.ChangeDetectionUtil.changeDetectionMode(this.strategy);
	        this.context = context;
	        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
	            this.observeComponent(context);
	        }
	        this.locals = locals;
	        this.pipes = pipes;
	        this.hydrateDirectives(directives);
	        this.alreadyChecked = false;
	    };
	    // Subclasses should override this method to hydrate any directives.
	    AbstractChangeDetector.prototype.hydrateDirectives = function (directives) { };
	    // This method is not intended to be overridden. Subclasses should instead provide an
	    // implementation of `dehydrateDirectives`.
	    AbstractChangeDetector.prototype.dehydrate = function () {
	        this.dehydrateDirectives(true);
	        // This is an experimental feature. Works only in Dart.
	        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
	            this._unsubsribeFromObservables();
	        }
	        this.context = null;
	        this.locals = null;
	        this.pipes = null;
	    };
	    // Subclasses should override this method to dehydrate any directives. This method should reverse
	    // any work done in `hydrateDirectives`.
	    AbstractChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) { };
	    AbstractChangeDetector.prototype.hydrated = function () { return this.context !== null; };
	    AbstractChangeDetector.prototype.afterContentLifecycleCallbacks = function () {
	        this.dispatcher.notifyAfterContentChecked();
	        this.afterContentLifecycleCallbacksInternal();
	    };
	    AbstractChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () { };
	    AbstractChangeDetector.prototype.afterViewLifecycleCallbacks = function () {
	        this.dispatcher.notifyAfterViewChecked();
	        this.afterViewLifecycleCallbacksInternal();
	    };
	    AbstractChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () { };
	    AbstractChangeDetector.prototype._detectChangesInLightDomChildren = function (throwOnChange) {
	        var c = this.lightDomChildren;
	        for (var i = 0; i < c.length; ++i) {
	            c[i].runDetectChanges(throwOnChange);
	        }
	    };
	    AbstractChangeDetector.prototype._detectChangesInShadowDomChildren = function (throwOnChange) {
	        var c = this.shadowDomChildren;
	        for (var i = 0; i < c.length; ++i) {
	            c[i].runDetectChanges(throwOnChange);
	        }
	    };
	    AbstractChangeDetector.prototype.markAsCheckOnce = function () { this.mode = constants_1.ChangeDetectionStrategy.CheckOnce; };
	    AbstractChangeDetector.prototype.markPathToRootAsCheckOnce = function () {
	        var c = this;
	        while (lang_1.isPresent(c) && c.mode !== constants_1.ChangeDetectionStrategy.Detached) {
	            if (c.mode === constants_1.ChangeDetectionStrategy.Checked)
	                c.mode = constants_1.ChangeDetectionStrategy.CheckOnce;
	            c = c.parent;
	        }
	    };
	    // This is an experimental feature. Works only in Dart.
	    AbstractChangeDetector.prototype._unsubsribeFromObservables = function () {
	        if (lang_1.isPresent(this.subscriptions)) {
	            for (var i = 0; i < this.subscriptions.length; ++i) {
	                var s = this.subscriptions[i];
	                if (lang_1.isPresent(this.subscriptions[i])) {
	                    s.cancel();
	                    this.subscriptions[i] = null;
	                }
	            }
	        }
	    };
	    // This is an experimental feature. Works only in Dart.
	    AbstractChangeDetector.prototype.observeValue = function (value, index) {
	        var _this = this;
	        if (observable_facade_1.isObservable(value)) {
	            this._createArrayToStoreObservables();
	            if (lang_1.isBlank(this.subscriptions[index])) {
	                this.streams[index] = value.changes;
	                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
	            }
	            else if (this.streams[index] !== value.changes) {
	                this.subscriptions[index].cancel();
	                this.streams[index] = value.changes;
	                this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
	            }
	        }
	        return value;
	    };
	    // This is an experimental feature. Works only in Dart.
	    AbstractChangeDetector.prototype.observeDirective = function (value, index) {
	        var _this = this;
	        if (observable_facade_1.isObservable(value)) {
	            this._createArrayToStoreObservables();
	            var arrayIndex = this.numberOfPropertyProtoRecords + index + 2; // +1 is component
	            this.streams[arrayIndex] = value.changes;
	            this.subscriptions[arrayIndex] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
	        }
	        return value;
	    };
	    // This is an experimental feature. Works only in Dart.
	    AbstractChangeDetector.prototype.observeComponent = function (value) {
	        var _this = this;
	        if (observable_facade_1.isObservable(value)) {
	            this._createArrayToStoreObservables();
	            var index = this.numberOfPropertyProtoRecords + 1;
	            this.streams[index] = value.changes;
	            this.subscriptions[index] = value.changes.listen(function (_) { return _this.ref.markForCheck(); });
	        }
	        return value;
	    };
	    AbstractChangeDetector.prototype._createArrayToStoreObservables = function () {
	        if (lang_1.isBlank(this.subscriptions)) {
	            this.subscriptions = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +
	                this.directiveIndices.length + 2);
	            this.streams = collection_1.ListWrapper.createFixedSize(this.numberOfPropertyProtoRecords +
	                this.directiveIndices.length + 2);
	        }
	    };
	    AbstractChangeDetector.prototype.getDirectiveFor = function (directives, index) {
	        return directives.getDirectiveFor(this.directiveIndices[index]);
	    };
	    AbstractChangeDetector.prototype.getDetectorFor = function (directives, index) {
	        return directives.getDetectorFor(this.directiveIndices[index]);
	    };
	    AbstractChangeDetector.prototype.notifyDispatcher = function (value) {
	        this.dispatcher.notifyOnBinding(this._currentBinding(), value);
	    };
	    AbstractChangeDetector.prototype.logBindingUpdate = function (value) {
	        this.dispatcher.logBindingUpdate(this._currentBinding(), value);
	    };
	    AbstractChangeDetector.prototype.addChange = function (changes, oldValue, newValue) {
	        if (lang_1.isBlank(changes)) {
	            changes = {};
	        }
	        changes[this._currentBinding().name] = change_detection_util_1.ChangeDetectionUtil.simpleChange(oldValue, newValue);
	        return changes;
	    };
	    AbstractChangeDetector.prototype._throwError = function (exception, stack) {
	        var c = this.dispatcher.getDebugContext(this._currentBinding().elementIndex, null);
	        var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector, this._currentBinding().debug) :
	            null;
	        throw new exceptions_2.ChangeDetectionError(this._currentBinding().debug, exception, stack, context);
	    };
	    AbstractChangeDetector.prototype.throwOnChangeError = function (oldValue, newValue) {
	        throw new exceptions_2.ExpressionChangedAfterItHasBeenCheckedException(this._currentBinding().debug, oldValue, newValue, null);
	    };
	    AbstractChangeDetector.prototype.throwDehydratedError = function () { throw new exceptions_2.DehydratedException(); };
	    AbstractChangeDetector.prototype._currentBinding = function () {
	        return this.bindingTargets[this.propertyBindingIndex];
	    };
	    return AbstractChangeDetector;
	})();
	exports.AbstractChangeDetector = AbstractChangeDetector;
	//# sourceMappingURL=abstract_change_detector.js.map

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var constants_1 = __webpack_require__(184);
	var pipe_lifecycle_reflector_1 = __webpack_require__(185);
	var binding_record_1 = __webpack_require__(186);
	var directive_record_1 = __webpack_require__(187);
	/**
	 * Indicates that the result of a {@link PipeMetadata} transformation has changed even though the
	 * reference
	 * has not changed.
	 *
	 * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
	 *
	 * Example:
	 *
	 * ```
	 * if (this._latestValue === this._latestReturnedValue) {
	 *    return this._latestReturnedValue;
	 *  } else {
	 *    this._latestReturnedValue = this._latestValue;
	 *    return WrappedValue.wrap(this._latestValue); // this will force update
	 *  }
	 * ```
	 */
	var WrappedValue = (function () {
	    function WrappedValue(wrapped) {
	        this.wrapped = wrapped;
	    }
	    WrappedValue.wrap = function (value) {
	        var w = _wrappedValues[_wrappedIndex++ % 5];
	        w.wrapped = value;
	        return w;
	    };
	    return WrappedValue;
	})();
	exports.WrappedValue = WrappedValue;
	var _wrappedValues = [
	    new WrappedValue(null),
	    new WrappedValue(null),
	    new WrappedValue(null),
	    new WrappedValue(null),
	    new WrappedValue(null)
	];
	var _wrappedIndex = 0;
	var SimpleChange = (function () {
	    function SimpleChange(previousValue, currentValue) {
	        this.previousValue = previousValue;
	        this.currentValue = currentValue;
	    }
	    SimpleChange.prototype.isFirstChange = function () { return this.previousValue === ChangeDetectionUtil.uninitialized; };
	    return SimpleChange;
	})();
	exports.SimpleChange = SimpleChange;
	var _simpleChangesIndex = 0;
	var _simpleChanges = [
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null),
	    new SimpleChange(null, null)
	];
	function _simpleChange(previousValue, currentValue) {
	    var index = _simpleChangesIndex++ % 20;
	    var s = _simpleChanges[index];
	    s.previousValue = previousValue;
	    s.currentValue = currentValue;
	    return s;
	}
	/* tslint:disable:requireParameterType */
	var ChangeDetectionUtil = (function () {
	    function ChangeDetectionUtil() {
	    }
	    ChangeDetectionUtil.arrayFn0 = function () { return []; };
	    ChangeDetectionUtil.arrayFn1 = function (a1) { return [a1]; };
	    ChangeDetectionUtil.arrayFn2 = function (a1, a2) { return [a1, a2]; };
	    ChangeDetectionUtil.arrayFn3 = function (a1, a2, a3) { return [a1, a2, a3]; };
	    ChangeDetectionUtil.arrayFn4 = function (a1, a2, a3, a4) { return [a1, a2, a3, a4]; };
	    ChangeDetectionUtil.arrayFn5 = function (a1, a2, a3, a4, a5) { return [a1, a2, a3, a4, a5]; };
	    ChangeDetectionUtil.arrayFn6 = function (a1, a2, a3, a4, a5, a6) { return [a1, a2, a3, a4, a5, a6]; };
	    ChangeDetectionUtil.arrayFn7 = function (a1, a2, a3, a4, a5, a6, a7) { return [a1, a2, a3, a4, a5, a6, a7]; };
	    ChangeDetectionUtil.arrayFn8 = function (a1, a2, a3, a4, a5, a6, a7, a8) {
	        return [a1, a2, a3, a4, a5, a6, a7, a8];
	    };
	    ChangeDetectionUtil.arrayFn9 = function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	        return [a1, a2, a3, a4, a5, a6, a7, a8, a9];
	    };
	    ChangeDetectionUtil.operation_negate = function (value) { return !value; };
	    ChangeDetectionUtil.operation_add = function (left, right) { return left + right; };
	    ChangeDetectionUtil.operation_subtract = function (left, right) { return left - right; };
	    ChangeDetectionUtil.operation_multiply = function (left, right) { return left * right; };
	    ChangeDetectionUtil.operation_divide = function (left, right) { return left / right; };
	    ChangeDetectionUtil.operation_remainder = function (left, right) { return left % right; };
	    ChangeDetectionUtil.operation_equals = function (left, right) { return left == right; };
	    ChangeDetectionUtil.operation_not_equals = function (left, right) { return left != right; };
	    ChangeDetectionUtil.operation_identical = function (left, right) { return left === right; };
	    ChangeDetectionUtil.operation_not_identical = function (left, right) { return left !== right; };
	    ChangeDetectionUtil.operation_less_then = function (left, right) { return left < right; };
	    ChangeDetectionUtil.operation_greater_then = function (left, right) { return left > right; };
	    ChangeDetectionUtil.operation_less_or_equals_then = function (left, right) { return left <= right; };
	    ChangeDetectionUtil.operation_greater_or_equals_then = function (left, right) { return left >= right; };
	    ChangeDetectionUtil.operation_logical_and = function (left, right) { return left && right; };
	    ChangeDetectionUtil.operation_logical_or = function (left, right) { return left || right; };
	    ChangeDetectionUtil.cond = function (cond, trueVal, falseVal) { return cond ? trueVal : falseVal; };
	    ChangeDetectionUtil.mapFn = function (keys) {
	        function buildMap(values) {
	            var res = collection_1.StringMapWrapper.create();
	            for (var i = 0; i < keys.length; ++i) {
	                collection_1.StringMapWrapper.set(res, keys[i], values[i]);
	            }
	            return res;
	        }
	        switch (keys.length) {
	            case 0:
	                return function () { return []; };
	            case 1:
	                return function (a1) { return buildMap([a1]); };
	            case 2:
	                return function (a1, a2) { return buildMap([a1, a2]); };
	            case 3:
	                return function (a1, a2, a3) { return buildMap([a1, a2, a3]); };
	            case 4:
	                return function (a1, a2, a3, a4) { return buildMap([a1, a2, a3, a4]); };
	            case 5:
	                return function (a1, a2, a3, a4, a5) { return buildMap([a1, a2, a3, a4, a5]); };
	            case 6:
	                return function (a1, a2, a3, a4, a5, a6) { return buildMap([a1, a2, a3, a4, a5, a6]); };
	            case 7:
	                return function (a1, a2, a3, a4, a5, a6, a7) { return buildMap([a1, a2, a3, a4, a5, a6, a7]); };
	            case 8:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8) { return buildMap([a1, a2, a3, a4, a5, a6, a7, a8]); };
	            case 9:
	                return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) {
	                    return buildMap([a1, a2, a3, a4, a5, a6, a7, a8, a9]);
	                };
	            default:
	                throw new exceptions_1.BaseException("Does not support literal maps with more than 9 elements");
	        }
	    };
	    ChangeDetectionUtil.keyedAccess = function (obj, args) { return obj[args[0]]; };
	    ChangeDetectionUtil.unwrapValue = function (value) {
	        if (value instanceof WrappedValue) {
	            return value.wrapped;
	        }
	        else {
	            return value;
	        }
	    };
	    ChangeDetectionUtil.changeDetectionMode = function (strategy) {
	        return constants_1.isDefaultChangeDetectionStrategy(strategy) ? constants_1.ChangeDetectionStrategy.CheckAlways :
	            constants_1.ChangeDetectionStrategy.CheckOnce;
	    };
	    ChangeDetectionUtil.simpleChange = function (previousValue, currentValue) {
	        return _simpleChange(previousValue, currentValue);
	    };
	    ChangeDetectionUtil.isValueBlank = function (value) { return lang_1.isBlank(value); };
	    ChangeDetectionUtil.s = function (value) { return lang_1.isPresent(value) ? "" + value : ''; };
	    ChangeDetectionUtil.protoByIndex = function (protos, selfIndex) {
	        return selfIndex < 1 ?
	            null :
	            protos[selfIndex - 1]; // self index is shifted by one because of context
	    };
	    ChangeDetectionUtil.callPipeOnDestroy = function (selectedPipe) {
	        if (pipe_lifecycle_reflector_1.implementsOnDestroy(selectedPipe.pipe)) {
	            selectedPipe.pipe.onDestroy();
	        }
	    };
	    ChangeDetectionUtil.bindingTarget = function (mode, elementIndex, name, unit, debug) {
	        return new binding_record_1.BindingTarget(mode, elementIndex, name, unit, debug);
	    };
	    ChangeDetectionUtil.directiveIndex = function (elementIndex, directiveIndex) {
	        return new directive_record_1.DirectiveIndex(elementIndex, directiveIndex);
	    };
	    ChangeDetectionUtil.uninitialized = lang_1.CONST_EXPR(new Object());
	    return ChangeDetectionUtil;
	})();
	exports.ChangeDetectionUtil = ChangeDetectionUtil;
	//# sourceMappingURL=change_detection_util.js.map

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	// TODO:vsavkin Use enums after switching to TypeScript
	var lang_1 = __webpack_require__(159);
	(function (ChangeDetectionStrategy) {
	    /**
	     * `CheckedOnce` means that after calling detectChanges the mode of the change detector
	     * will become `Checked`.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckOnce"] = 0] = "CheckOnce";
	    /**
	     * `Checked` means that the change detector should be skipped until its mode changes to
	     * `CheckOnce`.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["Checked"] = 1] = "Checked";
	    /**
	     * `CheckAlways` means that after calling detectChanges the mode of the change detector
	     * will remain `CheckAlways`.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["CheckAlways"] = 2] = "CheckAlways";
	    /**
	     * `Detached` means that the change detector sub tree is not a part of the main tree and
	     * should be skipped.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["Detached"] = 3] = "Detached";
	    /**
	     * `OnPush` means that the change detector's mode will be set to `CheckOnce` during hydration.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPush"] = 4] = "OnPush";
	    /**
	     * `Default` means that the change detector's mode will be set to `CheckAlways` during hydration.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["Default"] = 5] = "Default";
	    /**
	     * This is an experimental feature. Works only in Dart.
	     */
	    ChangeDetectionStrategy[ChangeDetectionStrategy["OnPushObserve"] = 6] = "OnPushObserve";
	})(exports.ChangeDetectionStrategy || (exports.ChangeDetectionStrategy = {}));
	var ChangeDetectionStrategy = exports.ChangeDetectionStrategy;
	function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
	    return lang_1.isBlank(changeDetectionStrategy) ||
	        changeDetectionStrategy === ChangeDetectionStrategy.Default;
	}
	exports.isDefaultChangeDetectionStrategy = isDefaultChangeDetectionStrategy;
	//# sourceMappingURL=constants.js.map

/***/ },
/* 185 */
/***/ function(module, exports) {

	function implementsOnDestroy(pipe) {
	    return pipe.constructor.prototype.onDestroy;
	}
	exports.implementsOnDestroy = implementsOnDestroy;
	//# sourceMappingURL=pipe_lifecycle_reflector.js.map

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var DIRECTIVE_LIFECYCLE = "directiveLifecycle";
	var BINDING = "native";
	var DIRECTIVE = "directive";
	var ELEMENT_PROPERTY = "elementProperty";
	var ELEMENT_ATTRIBUTE = "elementAttribute";
	var ELEMENT_CLASS = "elementClass";
	var ELEMENT_STYLE = "elementStyle";
	var TEXT_NODE = "textNode";
	var EVENT = "event";
	var HOST_EVENT = "hostEvent";
	var BindingTarget = (function () {
	    function BindingTarget(mode, elementIndex, name, unit, debug) {
	        this.mode = mode;
	        this.elementIndex = elementIndex;
	        this.name = name;
	        this.unit = unit;
	        this.debug = debug;
	    }
	    BindingTarget.prototype.isDirective = function () { return this.mode === DIRECTIVE; };
	    BindingTarget.prototype.isElementProperty = function () { return this.mode === ELEMENT_PROPERTY; };
	    BindingTarget.prototype.isElementAttribute = function () { return this.mode === ELEMENT_ATTRIBUTE; };
	    BindingTarget.prototype.isElementClass = function () { return this.mode === ELEMENT_CLASS; };
	    BindingTarget.prototype.isElementStyle = function () { return this.mode === ELEMENT_STYLE; };
	    BindingTarget.prototype.isTextNode = function () { return this.mode === TEXT_NODE; };
	    return BindingTarget;
	})();
	exports.BindingTarget = BindingTarget;
	var BindingRecord = (function () {
	    function BindingRecord(mode, target, implicitReceiver, ast, setter, lifecycleEvent, directiveRecord) {
	        this.mode = mode;
	        this.target = target;
	        this.implicitReceiver = implicitReceiver;
	        this.ast = ast;
	        this.setter = setter;
	        this.lifecycleEvent = lifecycleEvent;
	        this.directiveRecord = directiveRecord;
	    }
	    BindingRecord.prototype.isDirectiveLifecycle = function () { return this.mode === DIRECTIVE_LIFECYCLE; };
	    BindingRecord.prototype.callOnChanges = function () {
	        return lang_1.isPresent(this.directiveRecord) && this.directiveRecord.callOnChanges;
	    };
	    BindingRecord.prototype.isDefaultChangeDetection = function () {
	        return lang_1.isBlank(this.directiveRecord) || this.directiveRecord.isDefaultChangeDetection();
	    };
	    BindingRecord.createDirectiveDoCheck = function (directiveRecord) {
	        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "DoCheck", directiveRecord);
	    };
	    BindingRecord.createDirectiveOnInit = function (directiveRecord) {
	        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "OnInit", directiveRecord);
	    };
	    BindingRecord.createDirectiveOnChanges = function (directiveRecord) {
	        return new BindingRecord(DIRECTIVE_LIFECYCLE, null, 0, null, null, "OnChanges", directiveRecord);
	    };
	    BindingRecord.createForDirective = function (ast, propertyName, setter, directiveRecord) {
	        var elementIndex = directiveRecord.directiveIndex.elementIndex;
	        var t = new BindingTarget(DIRECTIVE, elementIndex, propertyName, null, ast.toString());
	        return new BindingRecord(DIRECTIVE, t, 0, ast, setter, null, directiveRecord);
	    };
	    BindingRecord.createForElementProperty = function (ast, elementIndex, propertyName) {
	        var t = new BindingTarget(ELEMENT_PROPERTY, elementIndex, propertyName, null, ast.toString());
	        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
	    };
	    BindingRecord.createForElementAttribute = function (ast, elementIndex, attributeName) {
	        var t = new BindingTarget(ELEMENT_ATTRIBUTE, elementIndex, attributeName, null, ast.toString());
	        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
	    };
	    BindingRecord.createForElementClass = function (ast, elementIndex, className) {
	        var t = new BindingTarget(ELEMENT_CLASS, elementIndex, className, null, ast.toString());
	        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
	    };
	    BindingRecord.createForElementStyle = function (ast, elementIndex, styleName, unit) {
	        var t = new BindingTarget(ELEMENT_STYLE, elementIndex, styleName, unit, ast.toString());
	        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
	    };
	    BindingRecord.createForHostProperty = function (directiveIndex, ast, propertyName) {
	        var t = new BindingTarget(ELEMENT_PROPERTY, directiveIndex.elementIndex, propertyName, null, ast.toString());
	        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
	    };
	    BindingRecord.createForHostAttribute = function (directiveIndex, ast, attributeName) {
	        var t = new BindingTarget(ELEMENT_ATTRIBUTE, directiveIndex.elementIndex, attributeName, null, ast.toString());
	        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
	    };
	    BindingRecord.createForHostClass = function (directiveIndex, ast, className) {
	        var t = new BindingTarget(ELEMENT_CLASS, directiveIndex.elementIndex, className, null, ast.toString());
	        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
	    };
	    BindingRecord.createForHostStyle = function (directiveIndex, ast, styleName, unit) {
	        var t = new BindingTarget(ELEMENT_STYLE, directiveIndex.elementIndex, styleName, unit, ast.toString());
	        return new BindingRecord(BINDING, t, directiveIndex, ast, null, null, null);
	    };
	    BindingRecord.createForTextNode = function (ast, elementIndex) {
	        var t = new BindingTarget(TEXT_NODE, elementIndex, null, null, ast.toString());
	        return new BindingRecord(BINDING, t, 0, ast, null, null, null);
	    };
	    BindingRecord.createForEvent = function (ast, eventName, elementIndex) {
	        var t = new BindingTarget(EVENT, elementIndex, eventName, null, ast.toString());
	        return new BindingRecord(EVENT, t, 0, ast, null, null, null);
	    };
	    BindingRecord.createForHostEvent = function (ast, eventName, directiveRecord) {
	        var directiveIndex = directiveRecord.directiveIndex;
	        var t = new BindingTarget(HOST_EVENT, directiveIndex.elementIndex, eventName, null, ast.toString());
	        return new BindingRecord(HOST_EVENT, t, directiveIndex, ast, null, null, directiveRecord);
	    };
	    return BindingRecord;
	})();
	exports.BindingRecord = BindingRecord;
	//# sourceMappingURL=binding_record.js.map

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var constants_1 = __webpack_require__(184);
	var DirectiveIndex = (function () {
	    function DirectiveIndex(elementIndex, directiveIndex) {
	        this.elementIndex = elementIndex;
	        this.directiveIndex = directiveIndex;
	    }
	    Object.defineProperty(DirectiveIndex.prototype, "name", {
	        get: function () { return this.elementIndex + "_" + this.directiveIndex; },
	        enumerable: true,
	        configurable: true
	    });
	    return DirectiveIndex;
	})();
	exports.DirectiveIndex = DirectiveIndex;
	var DirectiveRecord = (function () {
	    function DirectiveRecord(_a) {
	        var _b = _a === void 0 ? {} : _a, directiveIndex = _b.directiveIndex, callAfterContentInit = _b.callAfterContentInit, callAfterContentChecked = _b.callAfterContentChecked, callAfterViewInit = _b.callAfterViewInit, callAfterViewChecked = _b.callAfterViewChecked, callOnChanges = _b.callOnChanges, callDoCheck = _b.callDoCheck, callOnInit = _b.callOnInit, changeDetection = _b.changeDetection;
	        this.directiveIndex = directiveIndex;
	        this.callAfterContentInit = lang_1.normalizeBool(callAfterContentInit);
	        this.callAfterContentChecked = lang_1.normalizeBool(callAfterContentChecked);
	        this.callOnChanges = lang_1.normalizeBool(callOnChanges);
	        this.callAfterViewInit = lang_1.normalizeBool(callAfterViewInit);
	        this.callAfterViewChecked = lang_1.normalizeBool(callAfterViewChecked);
	        this.callDoCheck = lang_1.normalizeBool(callDoCheck);
	        this.callOnInit = lang_1.normalizeBool(callOnInit);
	        this.changeDetection = changeDetection;
	    }
	    DirectiveRecord.prototype.isDefaultChangeDetection = function () {
	        return constants_1.isDefaultChangeDetectionStrategy(this.changeDetection);
	    };
	    return DirectiveRecord;
	})();
	exports.DirectiveRecord = DirectiveRecord;
	//# sourceMappingURL=directive_record.js.map

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	var constants_1 = __webpack_require__(184);
	/**
	 * Controls change detection.
	 *
	 * {@link ChangeDetectorRef} allows requesting checks for detectors that rely on observables. It
	 * also allows detaching and attaching change detector subtrees.
	 */
	var ChangeDetectorRef = (function () {
	    /**
	     * @private
	     */
	    function ChangeDetectorRef(_cd) {
	        this._cd = _cd;
	    }
	    /**
	     * Request to check all OnPush ancestors.
	     */
	    ChangeDetectorRef.prototype.markForCheck = function () { this._cd.markPathToRootAsCheckOnce(); };
	    /**
	     * Detaches the change detector from the change detector tree.
	     *
	     * The detached change detector will not be checked until it is reattached.
	     */
	    ChangeDetectorRef.prototype.detach = function () { this._cd.mode = constants_1.ChangeDetectionStrategy.Detached; };
	    /**
	     * Reattach the change detector to the change detector tree.
	     *
	     * This also requests a check of this change detector. This reattached change detector will be
	     * checked during the next change detection run.
	     */
	    ChangeDetectorRef.prototype.reattach = function () {
	        this._cd.mode = constants_1.ChangeDetectionStrategy.CheckAlways;
	        this.markForCheck();
	    };
	    return ChangeDetectorRef;
	})();
	exports.ChangeDetectorRef = ChangeDetectorRef;
	//# sourceMappingURL=change_detector_ref.js.map

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var exceptions_1 = __webpack_require__(168);
	/**
	 * An error thrown if application changes model breaking the top-down data flow.
	 *
	 * Angular expects that the data flows from top (root) component to child (leaf) components.
	 * This is known as directed acyclic graph. This allows Angular to only execute change detection
	 * once and prevents loops in change detection data flow.
	 *
	 * This exception is only thrown in dev mode.
	 */
	var ExpressionChangedAfterItHasBeenCheckedException = (function (_super) {
	    __extends(ExpressionChangedAfterItHasBeenCheckedException, _super);
	    function ExpressionChangedAfterItHasBeenCheckedException(exp, oldValue, currValue, context) {
	        _super.call(this, ("Expression '" + exp + "' has changed after it was checked. ") +
	            ("Previous value: '" + oldValue + "'. Current value: '" + currValue + "'"));
	    }
	    return ExpressionChangedAfterItHasBeenCheckedException;
	})(exceptions_1.BaseException);
	exports.ExpressionChangedAfterItHasBeenCheckedException = ExpressionChangedAfterItHasBeenCheckedException;
	/**
	 * Thrown when an expression evaluation raises an exception.
	 *
	 * This error wraps the original exception, this is done to attach expression location information.
	 */
	var ChangeDetectionError = (function (_super) {
	    __extends(ChangeDetectionError, _super);
	    function ChangeDetectionError(exp, originalException, originalStack, context) {
	        _super.call(this, originalException + " in [" + exp + "]", originalException, originalStack, context);
	        this.location = exp;
	    }
	    return ChangeDetectionError;
	})(exceptions_1.WrappedException);
	exports.ChangeDetectionError = ChangeDetectionError;
	/**
	 * Thrown when change detector executes on dehydrated view.
	 *
	 * This is angular internal error.
	 */
	var DehydratedException = (function (_super) {
	    __extends(DehydratedException, _super);
	    function DehydratedException() {
	        _super.call(this, 'Attempt to detect changes on a dehydrated detector.');
	    }
	    return DehydratedException;
	})(exceptions_1.BaseException);
	exports.DehydratedException = DehydratedException;
	//# sourceMappingURL=exceptions.js.map

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var impl = __webpack_require__(191);
	// Change exports to const once https://github.com/angular/ts2dart/issues/150
	/**
	 * True if WTF is enabled.
	 */
	exports.wtfEnabled = impl.detectWTF();
	function noopScope(arg0, arg1) {
	    return null;
	}
	/**
	 * Create trace scope.
	 *
	 * Scopes must be strictly nested and are analogous to stack frames, but
	 * do not have to follow the stack frames. Instead it is recommended that they follow logical
	 * nesting. You may want to use
	 * [Event
	 * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
	 * as they are defined in WTF.
	 *
	 * Used to mark scope entry. The return value is used to leave the scope.
	 *
	 *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
	 *
	 *     someMethod() {
	 *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
	 *        // DO SOME WORK HERE
	 *        return wtfLeave(s, 123); // Return value 123
	 *     }
	 *
	 * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
	 * negatively impact the performance of your application. For this reason we recommend that
	 * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
	 * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
	 * exception, will produce incorrect trace, but presence of exception signifies logic error which
	 * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
	 * an exception is expected during normal execution while profiling.
	 *
	 */
	exports.wtfCreateScope = exports.wtfEnabled ? impl.createScope : function (signature, flags) { return noopScope; };
	/**
	 * Used to mark end of Scope.
	 *
	 * - `scope` to end.
	 * - `returnValue` (optional) to be passed to the WTF.
	 *
	 * Returns the `returnValue for easy chaining.
	 */
	exports.wtfLeave = exports.wtfEnabled ? impl.leave : function (s, r) { return r; };
	/**
	 * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
	 * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
	 * enabled.
	 *
	 *     someMethod() {
	 *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
	 *        var future = new Future.delay(5).then((_) {
	 *          wtfEndTimeRange(s);
	 *        });
	 *     }
	 */
	exports.wtfStartTimeRange = exports.wtfEnabled ? impl.startTimeRange : function (rangeType, action) { return null; };
	/**
	 * Ends a async time range operation.
	 * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
	 * enabled.
	 */
	exports.wtfEndTimeRange = exports.wtfEnabled ? impl.endTimeRange : function (r) {
	    return null;
	};
	//# sourceMappingURL=profile.js.map

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var trace;
	var events;
	function detectWTF() {
	    var wtf = lang_1.global['wtf'];
	    if (wtf) {
	        trace = wtf['trace'];
	        if (trace) {
	            events = trace['events'];
	            return true;
	        }
	    }
	    return false;
	}
	exports.detectWTF = detectWTF;
	function createScope(signature, flags) {
	    if (flags === void 0) { flags = null; }
	    return events.createScope(signature, flags);
	}
	exports.createScope = createScope;
	function leave(scope, returnValue) {
	    trace.leaveScope(scope, returnValue);
	    return returnValue;
	}
	exports.leave = leave;
	function startTimeRange(rangeType, action) {
	    return trace.beginTimeRange(rangeType, action);
	}
	exports.startTimeRange = startTimeRange;
	function endTimeRange(range) {
	    trace.endTimeRange(range);
	}
	exports.endTimeRange = endTimeRange;
	//# sourceMappingURL=wtf_impl.js.map

/***/ },
/* 192 */
/***/ function(module, exports) {

	function isObservable(value) {
	    return false;
	}
	exports.isObservable = isObservable;
	//# sourceMappingURL=observable_facade.js.map

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	// The names of these fields must be kept in sync with abstract_change_detector.ts or change
	// detection will fail.
	var _ALREADY_CHECKED_ACCESSOR = "alreadyChecked";
	var _CONTEXT_ACCESSOR = "context";
	var _PROP_BINDING_INDEX = "propertyBindingIndex";
	var _DIRECTIVES_ACCESSOR = "directiveIndices";
	var _DISPATCHER_ACCESSOR = "dispatcher";
	var _LOCALS_ACCESSOR = "locals";
	var _MODE_ACCESSOR = "mode";
	var _PIPES_ACCESSOR = "pipes";
	var _PROTOS_ACCESSOR = "protos";
	// `context` is always first.
	exports.CONTEXT_INDEX = 0;
	var _FIELD_PREFIX = 'this.';
	var _whiteSpaceRegExp = lang_1.RegExpWrapper.create("\\W", "g");
	/**
	 * Returns `s` with all non-identifier characters removed.
	 */
	function sanitizeName(s) {
	    return lang_1.StringWrapper.replaceAll(s, _whiteSpaceRegExp, '');
	}
	exports.sanitizeName = sanitizeName;
	/**
	 * Class responsible for providing field and local variable names for change detector classes.
	 * Also provides some convenience functions, for example, declaring variables, destroying pipes,
	 * and dehydrating the detector.
	 */
	var CodegenNameUtil = (function () {
	    function CodegenNameUtil(_records, _eventBindings, _directiveRecords, _utilName) {
	        this._records = _records;
	        this._eventBindings = _eventBindings;
	        this._directiveRecords = _directiveRecords;
	        this._utilName = _utilName;
	        this._sanitizedNames = collection_1.ListWrapper.createFixedSize(this._records.length + 1);
	        this._sanitizedNames[exports.CONTEXT_INDEX] = _CONTEXT_ACCESSOR;
	        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
	            this._sanitizedNames[i + 1] = sanitizeName("" + this._records[i].name + i);
	        }
	        this._sanitizedEventNames = new collection_1.Map();
	        for (var ebIndex = 0; ebIndex < _eventBindings.length; ++ebIndex) {
	            var eb = _eventBindings[ebIndex];
	            var names = [_CONTEXT_ACCESSOR];
	            for (var i = 0, iLen = eb.records.length; i < iLen; ++i) {
	                names.push(sanitizeName("" + eb.records[i].name + i + "_" + ebIndex));
	            }
	            this._sanitizedEventNames.set(eb, names);
	        }
	    }
	    CodegenNameUtil.prototype._addFieldPrefix = function (name) { return "" + _FIELD_PREFIX + name; };
	    CodegenNameUtil.prototype.getDispatcherName = function () { return this._addFieldPrefix(_DISPATCHER_ACCESSOR); };
	    CodegenNameUtil.prototype.getPipesAccessorName = function () { return this._addFieldPrefix(_PIPES_ACCESSOR); };
	    CodegenNameUtil.prototype.getProtosName = function () { return this._addFieldPrefix(_PROTOS_ACCESSOR); };
	    CodegenNameUtil.prototype.getDirectivesAccessorName = function () { return this._addFieldPrefix(_DIRECTIVES_ACCESSOR); };
	    CodegenNameUtil.prototype.getLocalsAccessorName = function () { return this._addFieldPrefix(_LOCALS_ACCESSOR); };
	    CodegenNameUtil.prototype.getAlreadyCheckedName = function () { return this._addFieldPrefix(_ALREADY_CHECKED_ACCESSOR); };
	    CodegenNameUtil.prototype.getModeName = function () { return this._addFieldPrefix(_MODE_ACCESSOR); };
	    CodegenNameUtil.prototype.getPropertyBindingIndex = function () { return this._addFieldPrefix(_PROP_BINDING_INDEX); };
	    CodegenNameUtil.prototype.getLocalName = function (idx) { return "l_" + this._sanitizedNames[idx]; };
	    CodegenNameUtil.prototype.getEventLocalName = function (eb, idx) {
	        return "l_" + collection_1.MapWrapper.get(this._sanitizedEventNames, eb)[idx];
	    };
	    CodegenNameUtil.prototype.getChangeName = function (idx) { return "c_" + this._sanitizedNames[idx]; };
	    /**
	     * Generate a statement initializing local variables used when detecting changes.
	     */
	    CodegenNameUtil.prototype.genInitLocals = function () {
	        var declarations = [];
	        var assignments = [];
	        for (var i = 0, iLen = this.getFieldCount(); i < iLen; ++i) {
	            if (i == exports.CONTEXT_INDEX) {
	                declarations.push(this.getLocalName(i) + " = " + this.getFieldName(i));
	            }
	            else {
	                var rec = this._records[i - 1];
	                if (rec.argumentToPureFunction) {
	                    var changeName = this.getChangeName(i);
	                    declarations.push(this.getLocalName(i) + "," + changeName);
	                    assignments.push(changeName);
	                }
	                else {
	                    declarations.push("" + this.getLocalName(i));
	                }
	            }
	        }
	        var assignmentsCode = collection_1.ListWrapper.isEmpty(assignments) ? '' : collection_1.ListWrapper.join(assignments, '=') + " = false;";
	        return "var " + collection_1.ListWrapper.join(declarations, ',') + ";" + assignmentsCode;
	    };
	    /**
	     * Generate a statement initializing local variables for event handlers.
	     */
	    CodegenNameUtil.prototype.genInitEventLocals = function () {
	        var _this = this;
	        var res = [(this.getLocalName(exports.CONTEXT_INDEX) + " = " + this.getFieldName(exports.CONTEXT_INDEX))];
	        collection_1.MapWrapper.forEach(this._sanitizedEventNames, function (names, eb) {
	            for (var i = 0; i < names.length; ++i) {
	                if (i !== exports.CONTEXT_INDEX) {
	                    res.push("" + _this.getEventLocalName(eb, i));
	                }
	            }
	        });
	        return res.length > 1 ? "var " + res.join(',') + ";" : '';
	    };
	    CodegenNameUtil.prototype.getPreventDefaultAccesor = function () { return "preventDefault"; };
	    CodegenNameUtil.prototype.getFieldCount = function () { return this._sanitizedNames.length; };
	    CodegenNameUtil.prototype.getFieldName = function (idx) { return this._addFieldPrefix(this._sanitizedNames[idx]); };
	    CodegenNameUtil.prototype.getAllFieldNames = function () {
	        var fieldList = [];
	        for (var k = 0, kLen = this.getFieldCount(); k < kLen; ++k) {
	            if (k === 0 || this._records[k - 1].shouldBeChecked()) {
	                fieldList.push(this.getFieldName(k));
	            }
	        }
	        for (var i = 0, iLen = this._records.length; i < iLen; ++i) {
	            var rec = this._records[i];
	            if (rec.isPipeRecord()) {
	                fieldList.push(this.getPipeName(rec.selfIndex));
	            }
	        }
	        for (var j = 0, jLen = this._directiveRecords.length; j < jLen; ++j) {
	            var dRec = this._directiveRecords[j];
	            fieldList.push(this.getDirectiveName(dRec.directiveIndex));
	            if (!dRec.isDefaultChangeDetection()) {
	                fieldList.push(this.getDetectorName(dRec.directiveIndex));
	            }
	        }
	        return fieldList;
	    };
	    /**
	     * Generates statements which clear all fields so that the change detector is dehydrated.
	     */
	    CodegenNameUtil.prototype.genDehydrateFields = function () {
	        var fields = this.getAllFieldNames();
	        collection_1.ListWrapper.removeAt(fields, exports.CONTEXT_INDEX);
	        if (collection_1.ListWrapper.isEmpty(fields))
	            return '';
	        // At least one assignment.
	        fields.push(this._utilName + ".uninitialized;");
	        return collection_1.ListWrapper.join(fields, ' = ');
	    };
	    /**
	     * Generates statements destroying all pipe variables.
	     */
	    CodegenNameUtil.prototype.genPipeOnDestroy = function () {
	        var _this = this;
	        return collection_1.ListWrapper.join(collection_1.ListWrapper.map(collection_1.ListWrapper.filter(this._records, function (r) { return r.isPipeRecord(); }), function (r) {
	            return _this._utilName + ".callPipeOnDestroy(" + _this.getPipeName(r.selfIndex) + ");";
	        }), '\n');
	    };
	    CodegenNameUtil.prototype.getPipeName = function (idx) {
	        return this._addFieldPrefix(this._sanitizedNames[idx] + "_pipe");
	    };
	    CodegenNameUtil.prototype.getDirectiveName = function (d) {
	        return this._addFieldPrefix("directive_" + d.name);
	    };
	    CodegenNameUtil.prototype.getDetectorName = function (d) { return this._addFieldPrefix("detector_" + d.name); };
	    return CodegenNameUtil;
	})();
	exports.CodegenNameUtil = CodegenNameUtil;
	//# sourceMappingURL=codegen_name_util.js.map

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var codegen_facade_1 = __webpack_require__(195);
	var proto_record_1 = __webpack_require__(196);
	var constants_1 = __webpack_require__(184);
	var exceptions_1 = __webpack_require__(168);
	/**
	 * Class responsible for providing change detection logic for change detector classes.
	 */
	var CodegenLogicUtil = (function () {
	    function CodegenLogicUtil(_names, _utilName, _changeDetection) {
	        this._names = _names;
	        this._utilName = _utilName;
	        this._changeDetection = _changeDetection;
	    }
	    /**
	     * Generates a statement which updates the local variable representing `protoRec` with the current
	     * value of the record. Used by property bindings.
	     */
	    CodegenLogicUtil.prototype.genPropertyBindingEvalValue = function (protoRec) {
	        var _this = this;
	        return this._genEvalValue(protoRec, function (idx) { return _this._names.getLocalName(idx); }, this._names.getLocalsAccessorName());
	    };
	    /**
	     * Generates a statement which updates the local variable representing `protoRec` with the current
	     * value of the record. Used by event bindings.
	     */
	    CodegenLogicUtil.prototype.genEventBindingEvalValue = function (eventRecord, protoRec) {
	        var _this = this;
	        return this._genEvalValue(protoRec, function (idx) { return _this._names.getEventLocalName(eventRecord, idx); }, "locals");
	    };
	    CodegenLogicUtil.prototype._genEvalValue = function (protoRec, getLocalName, localsAccessor) {
	        var context = (protoRec.contextIndex == -1) ?
	            this._names.getDirectiveName(protoRec.directiveIndex) :
	            getLocalName(protoRec.contextIndex);
	        var argString = collection_1.ListWrapper.map(protoRec.args, function (arg) { return getLocalName(arg); }).join(", ");
	        var rhs;
	        switch (protoRec.mode) {
	            case proto_record_1.RecordType.Self:
	                rhs = context;
	                break;
	            case proto_record_1.RecordType.Const:
	                rhs = codegen_facade_1.codify(protoRec.funcOrValue);
	                break;
	            case proto_record_1.RecordType.PropertyRead:
	                rhs = this._observe(context + "." + protoRec.name, protoRec);
	                break;
	            case proto_record_1.RecordType.SafeProperty:
	                var read = this._observe(context + "." + protoRec.name, protoRec);
	                rhs =
	                    this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(read, protoRec);
	                break;
	            case proto_record_1.RecordType.PropertyWrite:
	                rhs = context + "." + protoRec.name + " = " + getLocalName(protoRec.args[0]);
	                break;
	            case proto_record_1.RecordType.Local:
	                rhs = this._observe(localsAccessor + ".get(" + codegen_facade_1.rawString(protoRec.name) + ")", protoRec);
	                break;
	            case proto_record_1.RecordType.InvokeMethod:
	                rhs = this._observe(context + "." + protoRec.name + "(" + argString + ")", protoRec);
	                break;
	            case proto_record_1.RecordType.SafeMethodInvoke:
	                var invoke = context + "." + protoRec.name + "(" + argString + ")";
	                rhs =
	                    this._utilName + ".isValueBlank(" + context + ") ? null : " + this._observe(invoke, protoRec);
	                break;
	            case proto_record_1.RecordType.InvokeClosure:
	                rhs = context + "(" + argString + ")";
	                break;
	            case proto_record_1.RecordType.PrimitiveOp:
	                rhs = this._utilName + "." + protoRec.name + "(" + argString + ")";
	                break;
	            case proto_record_1.RecordType.CollectionLiteral:
	                rhs = this._utilName + "." + protoRec.name + "(" + argString + ")";
	                break;
	            case proto_record_1.RecordType.Interpolate:
	                rhs = this._genInterpolation(protoRec);
	                break;
	            case proto_record_1.RecordType.KeyedRead:
	                rhs = this._observe(context + "[" + getLocalName(protoRec.args[0]) + "]", protoRec);
	                break;
	            case proto_record_1.RecordType.KeyedWrite:
	                rhs = context + "[" + getLocalName(protoRec.args[0]) + "] = " + getLocalName(protoRec.args[1]);
	                break;
	            case proto_record_1.RecordType.Chain:
	                rhs = 'null';
	                break;
	            default:
	                throw new exceptions_1.BaseException("Unknown operation " + protoRec.mode);
	        }
	        return getLocalName(protoRec.selfIndex) + " = " + rhs + ";";
	    };
	    CodegenLogicUtil.prototype._observe = function (exp, rec) {
	        // This is an experimental feature. Works only in Dart.
	        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {
	            return "this.observeValue(" + exp + ", " + rec.selfIndex + ")";
	        }
	        else {
	            return exp;
	        }
	    };
	    CodegenLogicUtil.prototype.genPropertyBindingTargets = function (propertyBindingTargets, genDebugInfo) {
	        var _this = this;
	        var bs = propertyBindingTargets.map(function (b) {
	            if (lang_1.isBlank(b))
	                return "null";
	            var debug = genDebugInfo ? codegen_facade_1.codify(b.debug) : "null";
	            return _this._utilName + ".bindingTarget(" + codegen_facade_1.codify(b.mode) + ", " + b.elementIndex + ", " + codegen_facade_1.codify(b.name) + ", " + codegen_facade_1.codify(b.unit) + ", " + debug + ")";
	        });
	        return "[" + bs.join(", ") + "]";
	    };
	    CodegenLogicUtil.prototype.genDirectiveIndices = function (directiveRecords) {
	        var _this = this;
	        var bs = directiveRecords.map(function (b) {
	            return (_this._utilName + ".directiveIndex(" + b.directiveIndex.elementIndex + ", " + b.directiveIndex.directiveIndex + ")");
	        });
	        return "[" + bs.join(", ") + "]";
	    };
	    CodegenLogicUtil.prototype._genInterpolation = function (protoRec) {
	        var iVals = [];
	        for (var i = 0; i < protoRec.args.length; ++i) {
	            iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[i]));
	            iVals.push(this._utilName + ".s(" + this._names.getLocalName(protoRec.args[i]) + ")");
	        }
	        iVals.push(codegen_facade_1.codify(protoRec.fixedArgs[protoRec.args.length]));
	        return codegen_facade_1.combineGeneratedStrings(iVals);
	    };
	    CodegenLogicUtil.prototype.genHydrateDirectives = function (directiveRecords) {
	        var res = [];
	        for (var i = 0; i < directiveRecords.length; ++i) {
	            var r = directiveRecords[i];
	            res.push(this._names.getDirectiveName(r.directiveIndex) + " = " + this._genReadDirective(i) + ";");
	        }
	        return res.join("\n");
	    };
	    CodegenLogicUtil.prototype._genReadDirective = function (index) {
	        // This is an experimental feature. Works only in Dart.
	        if (this._changeDetection === constants_1.ChangeDetectionStrategy.OnPushObserve) {
	            return "this.observeDirective(this.getDirectiveFor(directives, " + index + "), " + index + ")";
	        }
	        else {
	            return "this.getDirectiveFor(directives, " + index + ")";
	        }
	    };
	    CodegenLogicUtil.prototype.genHydrateDetectors = function (directiveRecords) {
	        var res = [];
	        for (var i = 0; i < directiveRecords.length; ++i) {
	            var r = directiveRecords[i];
	            if (!r.isDefaultChangeDetection()) {
	                res.push(this._names.getDetectorName(r.directiveIndex) + " = this.getDetectorFor(directives, " + i + ");");
	            }
	        }
	        return res.join("\n");
	    };
	    CodegenLogicUtil.prototype.genContentLifecycleCallbacks = function (directiveRecords) {
	        var res = [];
	        // NOTE(kegluneq): Order is important!
	        for (var i = directiveRecords.length - 1; i >= 0; --i) {
	            var dir = directiveRecords[i];
	            if (dir.callAfterContentInit) {
	                res.push("if(! " + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(dir.directiveIndex) + ".afterContentInit();");
	            }
	            if (dir.callAfterContentChecked) {
	                res.push(this._names.getDirectiveName(dir.directiveIndex) + ".afterContentChecked();");
	            }
	        }
	        return res;
	    };
	    CodegenLogicUtil.prototype.genViewLifecycleCallbacks = function (directiveRecords) {
	        var res = [];
	        // NOTE(kegluneq): Order is important!
	        for (var i = directiveRecords.length - 1; i >= 0; --i) {
	            var dir = directiveRecords[i];
	            if (dir.callAfterViewInit) {
	                res.push("if(! " + this._names.getAlreadyCheckedName() + ") " + this._names.getDirectiveName(dir.directiveIndex) + ".afterViewInit();");
	            }
	            if (dir.callAfterViewChecked) {
	                res.push(this._names.getDirectiveName(dir.directiveIndex) + ".afterViewChecked();");
	            }
	        }
	        return res;
	    };
	    return CodegenLogicUtil;
	})();
	exports.CodegenLogicUtil = CodegenLogicUtil;
	//# sourceMappingURL=codegen_logic_util.js.map

/***/ },
/* 195 */
/***/ function(module, exports) {

	/**
	 * Converts `funcOrValue` to a string which can be used in generated code.
	 */
	function codify(obj) {
	    return JSON.stringify(obj);
	}
	exports.codify = codify;
	function rawString(str) {
	    return "'" + str + "'";
	}
	exports.rawString = rawString;
	/**
	 * Combine the strings of generated code into a single interpolated string.
	 * Each element of `vals` is expected to be a string literal or a codegen'd
	 * call to a method returning a string.
	 */
	function combineGeneratedStrings(vals) {
	    return vals.join(' + ');
	}
	exports.combineGeneratedStrings = combineGeneratedStrings;
	//# sourceMappingURL=codegen_facade.js.map

/***/ },
/* 196 */
/***/ function(module, exports) {

	(function (RecordType) {
	    RecordType[RecordType["Self"] = 0] = "Self";
	    RecordType[RecordType["Const"] = 1] = "Const";
	    RecordType[RecordType["PrimitiveOp"] = 2] = "PrimitiveOp";
	    RecordType[RecordType["PropertyRead"] = 3] = "PropertyRead";
	    RecordType[RecordType["PropertyWrite"] = 4] = "PropertyWrite";
	    RecordType[RecordType["Local"] = 5] = "Local";
	    RecordType[RecordType["InvokeMethod"] = 6] = "InvokeMethod";
	    RecordType[RecordType["InvokeClosure"] = 7] = "InvokeClosure";
	    RecordType[RecordType["KeyedRead"] = 8] = "KeyedRead";
	    RecordType[RecordType["KeyedWrite"] = 9] = "KeyedWrite";
	    RecordType[RecordType["Pipe"] = 10] = "Pipe";
	    RecordType[RecordType["Interpolate"] = 11] = "Interpolate";
	    RecordType[RecordType["SafeProperty"] = 12] = "SafeProperty";
	    RecordType[RecordType["CollectionLiteral"] = 13] = "CollectionLiteral";
	    RecordType[RecordType["SafeMethodInvoke"] = 14] = "SafeMethodInvoke";
	    RecordType[RecordType["DirectiveLifecycle"] = 15] = "DirectiveLifecycle";
	    RecordType[RecordType["Chain"] = 16] = "Chain";
	})(exports.RecordType || (exports.RecordType = {}));
	var RecordType = exports.RecordType;
	var ProtoRecord = (function () {
	    function ProtoRecord(mode, name, funcOrValue, args, fixedArgs, contextIndex, directiveIndex, selfIndex, bindingRecord, lastInBinding, lastInDirective, argumentToPureFunction, referencedBySelf, propertyBindingIndex) {
	        this.mode = mode;
	        this.name = name;
	        this.funcOrValue = funcOrValue;
	        this.args = args;
	        this.fixedArgs = fixedArgs;
	        this.contextIndex = contextIndex;
	        this.directiveIndex = directiveIndex;
	        this.selfIndex = selfIndex;
	        this.bindingRecord = bindingRecord;
	        this.lastInBinding = lastInBinding;
	        this.lastInDirective = lastInDirective;
	        this.argumentToPureFunction = argumentToPureFunction;
	        this.referencedBySelf = referencedBySelf;
	        this.propertyBindingIndex = propertyBindingIndex;
	    }
	    ProtoRecord.prototype.isPureFunction = function () {
	        return this.mode === RecordType.Interpolate || this.mode === RecordType.CollectionLiteral;
	    };
	    ProtoRecord.prototype.isUsedByOtherRecord = function () { return !this.lastInBinding || this.referencedBySelf; };
	    ProtoRecord.prototype.shouldBeChecked = function () {
	        return this.argumentToPureFunction || this.lastInBinding || this.isPureFunction() ||
	            this.isPipeRecord();
	    };
	    ProtoRecord.prototype.isPipeRecord = function () { return this.mode === RecordType.Pipe; };
	    ProtoRecord.prototype.isLifeCycleRecord = function () { return this.mode === RecordType.DirectiveLifecycle; };
	    return ProtoRecord;
	})();
	exports.ProtoRecord = ProtoRecord;
	//# sourceMappingURL=proto_record.js.map

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var ast_1 = __webpack_require__(198);
	var change_detection_util_1 = __webpack_require__(183);
	var dynamic_change_detector_1 = __webpack_require__(199);
	var directive_record_1 = __webpack_require__(187);
	var event_binding_1 = __webpack_require__(200);
	var coalesce_1 = __webpack_require__(201);
	var proto_record_1 = __webpack_require__(196);
	var DynamicProtoChangeDetector = (function () {
	    function DynamicProtoChangeDetector(_definition) {
	        this._definition = _definition;
	        this._propertyBindingRecords = createPropertyRecords(_definition);
	        this._eventBindingRecords = createEventRecords(_definition);
	        this._propertyBindingTargets = this._definition.bindingRecords.map(function (b) { return b.target; });
	        this._directiveIndices = this._definition.directiveRecords.map(function (d) { return d.directiveIndex; });
	    }
	    DynamicProtoChangeDetector.prototype.instantiate = function (dispatcher) {
	        return new dynamic_change_detector_1.DynamicChangeDetector(this._definition.id, dispatcher, this._propertyBindingRecords.length, this._propertyBindingTargets, this._directiveIndices, this._definition.strategy, this._propertyBindingRecords, this._eventBindingRecords, this._definition.directiveRecords, this._definition.genConfig);
	    };
	    return DynamicProtoChangeDetector;
	})();
	exports.DynamicProtoChangeDetector = DynamicProtoChangeDetector;
	function createPropertyRecords(definition) {
	    var recordBuilder = new ProtoRecordBuilder();
	    collection_1.ListWrapper.forEachWithIndex(definition.bindingRecords, function (b, index) { return recordBuilder.add(b, definition.variableNames, index); });
	    return coalesce_1.coalesce(recordBuilder.records);
	}
	exports.createPropertyRecords = createPropertyRecords;
	function createEventRecords(definition) {
	    // TODO: vsavkin: remove $event when the compiler handles render-side variables properly
	    var varNames = collection_1.ListWrapper.concat(['$event'], definition.variableNames);
	    return definition.eventRecords.map(function (er) {
	        var records = _ConvertAstIntoProtoRecords.create(er, varNames);
	        var dirIndex = er.implicitReceiver instanceof directive_record_1.DirectiveIndex ? er.implicitReceiver : null;
	        return new event_binding_1.EventBinding(er.target.name, er.target.elementIndex, dirIndex, records);
	    });
	}
	exports.createEventRecords = createEventRecords;
	var ProtoRecordBuilder = (function () {
	    function ProtoRecordBuilder() {
	        this.records = [];
	    }
	    ProtoRecordBuilder.prototype.add = function (b, variableNames, bindingIndex) {
	        var oldLast = collection_1.ListWrapper.last(this.records);
	        if (lang_1.isPresent(oldLast) && oldLast.bindingRecord.directiveRecord == b.directiveRecord) {
	            oldLast.lastInDirective = false;
	        }
	        var numberOfRecordsBefore = this.records.length;
	        this._appendRecords(b, variableNames, bindingIndex);
	        var newLast = collection_1.ListWrapper.last(this.records);
	        if (lang_1.isPresent(newLast) && newLast !== oldLast) {
	            newLast.lastInBinding = true;
	            newLast.lastInDirective = true;
	            this._setArgumentToPureFunction(numberOfRecordsBefore);
	        }
	    };
	    ProtoRecordBuilder.prototype._setArgumentToPureFunction = function (startIndex) {
	        var _this = this;
	        for (var i = startIndex; i < this.records.length; ++i) {
	            var rec = this.records[i];
	            if (rec.isPureFunction()) {
	                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =
	                    true; });
	            }
	            if (rec.mode === proto_record_1.RecordType.Pipe) {
	                rec.args.forEach(function (recordIndex) { return _this.records[recordIndex - 1].argumentToPureFunction =
	                    true; });
	                this.records[rec.contextIndex - 1].argumentToPureFunction = true;
	            }
	        }
	    };
	    ProtoRecordBuilder.prototype._appendRecords = function (b, variableNames, bindingIndex) {
	        if (b.isDirectiveLifecycle()) {
	            this.records.push(new proto_record_1.ProtoRecord(proto_record_1.RecordType.DirectiveLifecycle, b.lifecycleEvent, null, [], [], -1, null, this.records.length + 1, b, false, false, false, false, null));
	        }
	        else {
	            _ConvertAstIntoProtoRecords.append(this.records, b, variableNames, bindingIndex);
	        }
	    };
	    return ProtoRecordBuilder;
	})();
	exports.ProtoRecordBuilder = ProtoRecordBuilder;
	var _ConvertAstIntoProtoRecords = (function () {
	    function _ConvertAstIntoProtoRecords(_records, _bindingRecord, _variableNames, _bindingIndex) {
	        this._records = _records;
	        this._bindingRecord = _bindingRecord;
	        this._variableNames = _variableNames;
	        this._bindingIndex = _bindingIndex;
	    }
	    _ConvertAstIntoProtoRecords.append = function (records, b, variableNames, bindingIndex) {
	        var c = new _ConvertAstIntoProtoRecords(records, b, variableNames, bindingIndex);
	        b.ast.visit(c);
	    };
	    _ConvertAstIntoProtoRecords.create = function (b, variableNames) {
	        var rec = [];
	        _ConvertAstIntoProtoRecords.append(rec, b, variableNames, null);
	        rec[rec.length - 1].lastInBinding = true;
	        return rec;
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitImplicitReceiver = function (ast) { return this._bindingRecord.implicitReceiver; };
	    _ConvertAstIntoProtoRecords.prototype.visitInterpolation = function (ast) {
	        var args = this._visitAll(ast.expressions);
	        return this._addRecord(proto_record_1.RecordType.Interpolate, "interpolate", _interpolationFn(ast.strings), args, ast.strings, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitLiteralPrimitive = function (ast) {
	        return this._addRecord(proto_record_1.RecordType.Const, "literal", ast.value, [], null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitPropertyRead = function (ast) {
	        var receiver = ast.receiver.visit(this);
	        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&
	            ast.receiver instanceof ast_1.ImplicitReceiver) {
	            return this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);
	        }
	        else {
	            return this._addRecord(proto_record_1.RecordType.PropertyRead, ast.name, ast.getter, [], null, receiver);
	        }
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitPropertyWrite = function (ast) {
	        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name) &&
	            ast.receiver instanceof ast_1.ImplicitReceiver) {
	            throw new exceptions_1.BaseException("Cannot reassign a variable binding " + ast.name);
	        }
	        else {
	            var receiver = ast.receiver.visit(this);
	            var value = ast.value.visit(this);
	            return this._addRecord(proto_record_1.RecordType.PropertyWrite, ast.name, ast.setter, [value], null, receiver);
	        }
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitKeyedWrite = function (ast) {
	        var obj = ast.obj.visit(this);
	        var key = ast.key.visit(this);
	        var value = ast.value.visit(this);
	        return this._addRecord(proto_record_1.RecordType.KeyedWrite, null, null, [key, value], null, obj);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitSafePropertyRead = function (ast) {
	        var receiver = ast.receiver.visit(this);
	        return this._addRecord(proto_record_1.RecordType.SafeProperty, ast.name, ast.getter, [], null, receiver);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitMethodCall = function (ast) {
	        var receiver = ast.receiver.visit(this);
	        var args = this._visitAll(ast.args);
	        if (lang_1.isPresent(this._variableNames) && collection_1.ListWrapper.contains(this._variableNames, ast.name)) {
	            var target = this._addRecord(proto_record_1.RecordType.Local, ast.name, ast.name, [], null, receiver);
	            return this._addRecord(proto_record_1.RecordType.InvokeClosure, "closure", null, args, null, target);
	        }
	        else {
	            return this._addRecord(proto_record_1.RecordType.InvokeMethod, ast.name, ast.fn, args, null, receiver);
	        }
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitSafeMethodCall = function (ast) {
	        var receiver = ast.receiver.visit(this);
	        var args = this._visitAll(ast.args);
	        return this._addRecord(proto_record_1.RecordType.SafeMethodInvoke, ast.name, ast.fn, args, null, receiver);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitFunctionCall = function (ast) {
	        var target = ast.target.visit(this);
	        var args = this._visitAll(ast.args);
	        return this._addRecord(proto_record_1.RecordType.InvokeClosure, "closure", null, args, null, target);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitLiteralArray = function (ast) {
	        var primitiveName = "arrayFn" + ast.expressions.length;
	        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, primitiveName, _arrayFn(ast.expressions.length), this._visitAll(ast.expressions), null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitLiteralMap = function (ast) {
	        return this._addRecord(proto_record_1.RecordType.CollectionLiteral, _mapPrimitiveName(ast.keys), change_detection_util_1.ChangeDetectionUtil.mapFn(ast.keys), this._visitAll(ast.values), null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitBinary = function (ast) {
	        var left = ast.left.visit(this);
	        var right = ast.right.visit(this);
	        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, _operationToPrimitiveName(ast.operation), _operationToFunction(ast.operation), [left, right], null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitPrefixNot = function (ast) {
	        var exp = ast.expression.visit(this);
	        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, "operation_negate", change_detection_util_1.ChangeDetectionUtil.operation_negate, [exp], null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitConditional = function (ast) {
	        var c = ast.condition.visit(this);
	        var t = ast.trueExp.visit(this);
	        var f = ast.falseExp.visit(this);
	        return this._addRecord(proto_record_1.RecordType.PrimitiveOp, "cond", change_detection_util_1.ChangeDetectionUtil.cond, [c, t, f], null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitPipe = function (ast) {
	        var value = ast.exp.visit(this);
	        var args = this._visitAll(ast.args);
	        return this._addRecord(proto_record_1.RecordType.Pipe, ast.name, ast.name, args, null, value);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitKeyedRead = function (ast) {
	        var obj = ast.obj.visit(this);
	        var key = ast.key.visit(this);
	        return this._addRecord(proto_record_1.RecordType.KeyedRead, "keyedAccess", change_detection_util_1.ChangeDetectionUtil.keyedAccess, [key], null, obj);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitChain = function (ast) {
	        var _this = this;
	        var args = ast.expressions.map(function (e) { return e.visit(_this); });
	        return this._addRecord(proto_record_1.RecordType.Chain, "chain", null, args, null, 0);
	    };
	    _ConvertAstIntoProtoRecords.prototype.visitIf = function (ast) { throw new exceptions_1.BaseException('Not supported'); };
	    _ConvertAstIntoProtoRecords.prototype._visitAll = function (asts) {
	        var res = collection_1.ListWrapper.createFixedSize(asts.length);
	        for (var i = 0; i < asts.length; ++i) {
	            res[i] = asts[i].visit(this);
	        }
	        return res;
	    };
	    _ConvertAstIntoProtoRecords.prototype._addRecord = function (type, name, funcOrValue, args, fixedArgs, context) {
	        var selfIndex = this._records.length + 1;
	        if (context instanceof directive_record_1.DirectiveIndex) {
	            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, -1, context, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
	        }
	        else {
	            this._records.push(new proto_record_1.ProtoRecord(type, name, funcOrValue, args, fixedArgs, context, null, selfIndex, this._bindingRecord, false, false, false, false, this._bindingIndex));
	        }
	        return selfIndex;
	    };
	    return _ConvertAstIntoProtoRecords;
	})();
	function _arrayFn(length) {
	    switch (length) {
	        case 0:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn0;
	        case 1:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn1;
	        case 2:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn2;
	        case 3:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn3;
	        case 4:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn4;
	        case 5:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn5;
	        case 6:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn6;
	        case 7:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn7;
	        case 8:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn8;
	        case 9:
	            return change_detection_util_1.ChangeDetectionUtil.arrayFn9;
	        default:
	            throw new exceptions_1.BaseException("Does not support literal maps with more than 9 elements");
	    }
	}
	function _mapPrimitiveName(keys) {
	    var stringifiedKeys = collection_1.ListWrapper.join(collection_1.ListWrapper.map(keys, function (k) { return lang_1.isString(k) ? "\"" + k + "\"" : "" + k; }), ", ");
	    return "mapFn([" + stringifiedKeys + "])";
	}
	function _operationToPrimitiveName(operation) {
	    switch (operation) {
	        case '+':
	            return "operation_add";
	        case '-':
	            return "operation_subtract";
	        case '*':
	            return "operation_multiply";
	        case '/':
	            return "operation_divide";
	        case '%':
	            return "operation_remainder";
	        case '==':
	            return "operation_equals";
	        case '!=':
	            return "operation_not_equals";
	        case '===':
	            return "operation_identical";
	        case '!==':
	            return "operation_not_identical";
	        case '<':
	            return "operation_less_then";
	        case '>':
	            return "operation_greater_then";
	        case '<=':
	            return "operation_less_or_equals_then";
	        case '>=':
	            return "operation_greater_or_equals_then";
	        case '&&':
	            return "operation_logical_and";
	        case '||':
	            return "operation_logical_or";
	        default:
	            throw new exceptions_1.BaseException("Unsupported operation " + operation);
	    }
	}
	function _operationToFunction(operation) {
	    switch (operation) {
	        case '+':
	            return change_detection_util_1.ChangeDetectionUtil.operation_add;
	        case '-':
	            return change_detection_util_1.ChangeDetectionUtil.operation_subtract;
	        case '*':
	            return change_detection_util_1.ChangeDetectionUtil.operation_multiply;
	        case '/':
	            return change_detection_util_1.ChangeDetectionUtil.operation_divide;
	        case '%':
	            return change_detection_util_1.ChangeDetectionUtil.operation_remainder;
	        case '==':
	            return change_detection_util_1.ChangeDetectionUtil.operation_equals;
	        case '!=':
	            return change_detection_util_1.ChangeDetectionUtil.operation_not_equals;
	        case '===':
	            return change_detection_util_1.ChangeDetectionUtil.operation_identical;
	        case '!==':
	            return change_detection_util_1.ChangeDetectionUtil.operation_not_identical;
	        case '<':
	            return change_detection_util_1.ChangeDetectionUtil.operation_less_then;
	        case '>':
	            return change_detection_util_1.ChangeDetectionUtil.operation_greater_then;
	        case '<=':
	            return change_detection_util_1.ChangeDetectionUtil.operation_less_or_equals_then;
	        case '>=':
	            return change_detection_util_1.ChangeDetectionUtil.operation_greater_or_equals_then;
	        case '&&':
	            return change_detection_util_1.ChangeDetectionUtil.operation_logical_and;
	        case '||':
	            return change_detection_util_1.ChangeDetectionUtil.operation_logical_or;
	        default:
	            throw new exceptions_1.BaseException("Unsupported operation " + operation);
	    }
	}
	function s(v) {
	    return lang_1.isPresent(v) ? "" + v : '';
	}
	function _interpolationFn(strings) {
	    var length = strings.length;
	    var c0 = length > 0 ? strings[0] : null;
	    var c1 = length > 1 ? strings[1] : null;
	    var c2 = length > 2 ? strings[2] : null;
	    var c3 = length > 3 ? strings[3] : null;
	    var c4 = length > 4 ? strings[4] : null;
	    var c5 = length > 5 ? strings[5] : null;
	    var c6 = length > 6 ? strings[6] : null;
	    var c7 = length > 7 ? strings[7] : null;
	    var c8 = length > 8 ? strings[8] : null;
	    var c9 = length > 9 ? strings[9] : null;
	    switch (length - 1) {
	        case 1:
	            return function (a1) { return c0 + s(a1) + c1; };
	        case 2:
	            return function (a1, a2) { return c0 + s(a1) + c1 + s(a2) + c2; };
	        case 3:
	            return function (a1, a2, a3) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3; };
	        case 4:
	            return function (a1, a2, a3, a4) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4; };
	        case 5:
	            return function (a1, a2, a3, a4, a5) {
	                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5;
	            };
	        case 6:
	            return function (a1, a2, a3, a4, a5, a6) {
	                return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) + c4 + s(a5) + c5 + s(a6) + c6;
	            };
	        case 7:
	            return function (a1, a2, a3, a4, a5, a6, a7) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +
	                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7; };
	        case 8:
	            return function (a1, a2, a3, a4, a5, a6, a7, a8) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 + s(a4) +
	                c4 + s(a5) + c5 + s(a6) + c6 + s(a7) + c7 + s(a8) +
	                c8; };
	        case 9:
	            return function (a1, a2, a3, a4, a5, a6, a7, a8, a9) { return c0 + s(a1) + c1 + s(a2) + c2 + s(a3) + c3 +
	                s(a4) + c4 + s(a5) + c5 + s(a6) + c6 + s(a7) +
	                c7 + s(a8) + c8 + s(a9) + c9; };
	        default:
	            throw new exceptions_1.BaseException("Does not support more than 9 expressions");
	    }
	}
	//# sourceMappingURL=proto_change_detector.js.map

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var AST = (function () {
	    function AST() {
	    }
	    AST.prototype.visit = function (visitor) { return null; };
	    AST.prototype.toString = function () { return "AST"; };
	    return AST;
	})();
	exports.AST = AST;
	var EmptyExpr = (function (_super) {
	    __extends(EmptyExpr, _super);
	    function EmptyExpr() {
	        _super.apply(this, arguments);
	    }
	    EmptyExpr.prototype.visit = function (visitor) {
	        // do nothing
	    };
	    return EmptyExpr;
	})(AST);
	exports.EmptyExpr = EmptyExpr;
	var ImplicitReceiver = (function (_super) {
	    __extends(ImplicitReceiver, _super);
	    function ImplicitReceiver() {
	        _super.apply(this, arguments);
	    }
	    ImplicitReceiver.prototype.visit = function (visitor) { return visitor.visitImplicitReceiver(this); };
	    return ImplicitReceiver;
	})(AST);
	exports.ImplicitReceiver = ImplicitReceiver;
	/**
	 * Multiple expressions separated by a semicolon.
	 */
	var Chain = (function (_super) {
	    __extends(Chain, _super);
	    function Chain(expressions) {
	        _super.call(this);
	        this.expressions = expressions;
	    }
	    Chain.prototype.visit = function (visitor) { return visitor.visitChain(this); };
	    return Chain;
	})(AST);
	exports.Chain = Chain;
	var Conditional = (function (_super) {
	    __extends(Conditional, _super);
	    function Conditional(condition, trueExp, falseExp) {
	        _super.call(this);
	        this.condition = condition;
	        this.trueExp = trueExp;
	        this.falseExp = falseExp;
	    }
	    Conditional.prototype.visit = function (visitor) { return visitor.visitConditional(this); };
	    return Conditional;
	})(AST);
	exports.Conditional = Conditional;
	var If = (function (_super) {
	    __extends(If, _super);
	    function If(condition, trueExp, falseExp) {
	        _super.call(this);
	        this.condition = condition;
	        this.trueExp = trueExp;
	        this.falseExp = falseExp;
	    }
	    If.prototype.visit = function (visitor) { return visitor.visitIf(this); };
	    return If;
	})(AST);
	exports.If = If;
	var PropertyRead = (function (_super) {
	    __extends(PropertyRead, _super);
	    function PropertyRead(receiver, name, getter) {
	        _super.call(this);
	        this.receiver = receiver;
	        this.name = name;
	        this.getter = getter;
	    }
	    PropertyRead.prototype.visit = function (visitor) { return visitor.visitPropertyRead(this); };
	    return PropertyRead;
	})(AST);
	exports.PropertyRead = PropertyRead;
	var PropertyWrite = (function (_super) {
	    __extends(PropertyWrite, _super);
	    function PropertyWrite(receiver, name, setter, value) {
	        _super.call(this);
	        this.receiver = receiver;
	        this.name = name;
	        this.setter = setter;
	        this.value = value;
	    }
	    PropertyWrite.prototype.visit = function (visitor) { return visitor.visitPropertyWrite(this); };
	    return PropertyWrite;
	})(AST);
	exports.PropertyWrite = PropertyWrite;
	var SafePropertyRead = (function (_super) {
	    __extends(SafePropertyRead, _super);
	    function SafePropertyRead(receiver, name, getter) {
	        _super.call(this);
	        this.receiver = receiver;
	        this.name = name;
	        this.getter = getter;
	    }
	    SafePropertyRead.prototype.visit = function (visitor) { return visitor.visitSafePropertyRead(this); };
	    return SafePropertyRead;
	})(AST);
	exports.SafePropertyRead = SafePropertyRead;
	var KeyedRead = (function (_super) {
	    __extends(KeyedRead, _super);
	    function KeyedRead(obj, key) {
	        _super.call(this);
	        this.obj = obj;
	        this.key = key;
	    }
	    KeyedRead.prototype.visit = function (visitor) { return visitor.visitKeyedRead(this); };
	    return KeyedRead;
	})(AST);
	exports.KeyedRead = KeyedRead;
	var KeyedWrite = (function (_super) {
	    __extends(KeyedWrite, _super);
	    function KeyedWrite(obj, key, value) {
	        _super.call(this);
	        this.obj = obj;
	        this.key = key;
	        this.value = value;
	    }
	    KeyedWrite.prototype.visit = function (visitor) { return visitor.visitKeyedWrite(this); };
	    return KeyedWrite;
	})(AST);
	exports.KeyedWrite = KeyedWrite;
	var BindingPipe = (function (_super) {
	    __extends(BindingPipe, _super);
	    function BindingPipe(exp, name, args) {
	        _super.call(this);
	        this.exp = exp;
	        this.name = name;
	        this.args = args;
	    }
	    BindingPipe.prototype.visit = function (visitor) { return visitor.visitPipe(this); };
	    return BindingPipe;
	})(AST);
	exports.BindingPipe = BindingPipe;
	var LiteralPrimitive = (function (_super) {
	    __extends(LiteralPrimitive, _super);
	    function LiteralPrimitive(value) {
	        _super.call(this);
	        this.value = value;
	    }
	    LiteralPrimitive.prototype.visit = function (visitor) { return visitor.visitLiteralPrimitive(this); };
	    return LiteralPrimitive;
	})(AST);
	exports.LiteralPrimitive = LiteralPrimitive;
	var LiteralArray = (function (_super) {
	    __extends(LiteralArray, _super);
	    function LiteralArray(expressions) {
	        _super.call(this);
	        this.expressions = expressions;
	    }
	    LiteralArray.prototype.visit = function (visitor) { return visitor.visitLiteralArray(this); };
	    return LiteralArray;
	})(AST);
	exports.LiteralArray = LiteralArray;
	var LiteralMap = (function (_super) {
	    __extends(LiteralMap, _super);
	    function LiteralMap(keys, values) {
	        _super.call(this);
	        this.keys = keys;
	        this.values = values;
	    }
	    LiteralMap.prototype.visit = function (visitor) { return visitor.visitLiteralMap(this); };
	    return LiteralMap;
	})(AST);
	exports.LiteralMap = LiteralMap;
	var Interpolation = (function (_super) {
	    __extends(Interpolation, _super);
	    function Interpolation(strings, expressions) {
	        _super.call(this);
	        this.strings = strings;
	        this.expressions = expressions;
	    }
	    Interpolation.prototype.visit = function (visitor) { visitor.visitInterpolation(this); };
	    return Interpolation;
	})(AST);
	exports.Interpolation = Interpolation;
	var Binary = (function (_super) {
	    __extends(Binary, _super);
	    function Binary(operation, left, right) {
	        _super.call(this);
	        this.operation = operation;
	        this.left = left;
	        this.right = right;
	    }
	    Binary.prototype.visit = function (visitor) { return visitor.visitBinary(this); };
	    return Binary;
	})(AST);
	exports.Binary = Binary;
	var PrefixNot = (function (_super) {
	    __extends(PrefixNot, _super);
	    function PrefixNot(expression) {
	        _super.call(this);
	        this.expression = expression;
	    }
	    PrefixNot.prototype.visit = function (visitor) { return visitor.visitPrefixNot(this); };
	    return PrefixNot;
	})(AST);
	exports.PrefixNot = PrefixNot;
	var MethodCall = (function (_super) {
	    __extends(MethodCall, _super);
	    function MethodCall(receiver, name, fn, args) {
	        _super.call(this);
	        this.receiver = receiver;
	        this.name = name;
	        this.fn = fn;
	        this.args = args;
	    }
	    MethodCall.prototype.visit = function (visitor) { return visitor.visitMethodCall(this); };
	    return MethodCall;
	})(AST);
	exports.MethodCall = MethodCall;
	var SafeMethodCall = (function (_super) {
	    __extends(SafeMethodCall, _super);
	    function SafeMethodCall(receiver, name, fn, args) {
	        _super.call(this);
	        this.receiver = receiver;
	        this.name = name;
	        this.fn = fn;
	        this.args = args;
	    }
	    SafeMethodCall.prototype.visit = function (visitor) { return visitor.visitSafeMethodCall(this); };
	    return SafeMethodCall;
	})(AST);
	exports.SafeMethodCall = SafeMethodCall;
	var FunctionCall = (function (_super) {
	    __extends(FunctionCall, _super);
	    function FunctionCall(target, args) {
	        _super.call(this);
	        this.target = target;
	        this.args = args;
	    }
	    FunctionCall.prototype.visit = function (visitor) { return visitor.visitFunctionCall(this); };
	    return FunctionCall;
	})(AST);
	exports.FunctionCall = FunctionCall;
	var ASTWithSource = (function (_super) {
	    __extends(ASTWithSource, _super);
	    function ASTWithSource(ast, source, location) {
	        _super.call(this);
	        this.ast = ast;
	        this.source = source;
	        this.location = location;
	    }
	    ASTWithSource.prototype.visit = function (visitor) { return this.ast.visit(visitor); };
	    ASTWithSource.prototype.toString = function () { return this.source + " in " + this.location; };
	    return ASTWithSource;
	})(AST);
	exports.ASTWithSource = ASTWithSource;
	var TemplateBinding = (function () {
	    function TemplateBinding(key, keyIsVar, name, expression) {
	        this.key = key;
	        this.keyIsVar = keyIsVar;
	        this.name = name;
	        this.expression = expression;
	    }
	    return TemplateBinding;
	})();
	exports.TemplateBinding = TemplateBinding;
	var RecursiveAstVisitor = (function () {
	    function RecursiveAstVisitor() {
	    }
	    RecursiveAstVisitor.prototype.visitBinary = function (ast) {
	        ast.left.visit(this);
	        ast.right.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitChain = function (ast) { return this.visitAll(ast.expressions); };
	    RecursiveAstVisitor.prototype.visitConditional = function (ast) {
	        ast.condition.visit(this);
	        ast.trueExp.visit(this);
	        ast.falseExp.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitIf = function (ast) {
	        ast.condition.visit(this);
	        ast.trueExp.visit(this);
	        ast.falseExp.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitPipe = function (ast) {
	        ast.exp.visit(this);
	        this.visitAll(ast.args);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast) {
	        ast.target.visit(this);
	        this.visitAll(ast.args);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast) { return null; };
	    RecursiveAstVisitor.prototype.visitInterpolation = function (ast) { return this.visitAll(ast.expressions); };
	    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast) {
	        ast.obj.visit(this);
	        ast.key.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast) {
	        ast.obj.visit(this);
	        ast.key.visit(this);
	        ast.value.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast) { return this.visitAll(ast.expressions); };
	    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast) { return this.visitAll(ast.values); };
	    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast) { return null; };
	    RecursiveAstVisitor.prototype.visitMethodCall = function (ast) {
	        ast.receiver.visit(this);
	        return this.visitAll(ast.args);
	    };
	    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast) {
	        ast.expression.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast) {
	        ast.receiver.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast) {
	        ast.receiver.visit(this);
	        ast.value.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast) {
	        ast.receiver.visit(this);
	        return null;
	    };
	    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast) {
	        ast.receiver.visit(this);
	        return this.visitAll(ast.args);
	    };
	    RecursiveAstVisitor.prototype.visitAll = function (asts) {
	        var _this = this;
	        collection_1.ListWrapper.forEach(asts, function (ast) { ast.visit(_this); });
	        return null;
	    };
	    return RecursiveAstVisitor;
	})();
	exports.RecursiveAstVisitor = RecursiveAstVisitor;
	var AstTransformer = (function () {
	    function AstTransformer() {
	    }
	    AstTransformer.prototype.visitImplicitReceiver = function (ast) { return ast; };
	    AstTransformer.prototype.visitInterpolation = function (ast) {
	        return new Interpolation(ast.strings, this.visitAll(ast.expressions));
	    };
	    AstTransformer.prototype.visitLiteralPrimitive = function (ast) {
	        return new LiteralPrimitive(ast.value);
	    };
	    AstTransformer.prototype.visitPropertyRead = function (ast) {
	        return new PropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
	    };
	    AstTransformer.prototype.visitPropertyWrite = function (ast) {
	        return new PropertyWrite(ast.receiver.visit(this), ast.name, ast.setter, ast.value);
	    };
	    AstTransformer.prototype.visitSafePropertyRead = function (ast) {
	        return new SafePropertyRead(ast.receiver.visit(this), ast.name, ast.getter);
	    };
	    AstTransformer.prototype.visitMethodCall = function (ast) {
	        return new MethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
	    };
	    AstTransformer.prototype.visitSafeMethodCall = function (ast) {
	        return new SafeMethodCall(ast.receiver.visit(this), ast.name, ast.fn, this.visitAll(ast.args));
	    };
	    AstTransformer.prototype.visitFunctionCall = function (ast) {
	        return new FunctionCall(ast.target.visit(this), this.visitAll(ast.args));
	    };
	    AstTransformer.prototype.visitLiteralArray = function (ast) {
	        return new LiteralArray(this.visitAll(ast.expressions));
	    };
	    AstTransformer.prototype.visitLiteralMap = function (ast) {
	        return new LiteralMap(ast.keys, this.visitAll(ast.values));
	    };
	    AstTransformer.prototype.visitBinary = function (ast) {
	        return new Binary(ast.operation, ast.left.visit(this), ast.right.visit(this));
	    };
	    AstTransformer.prototype.visitPrefixNot = function (ast) { return new PrefixNot(ast.expression.visit(this)); };
	    AstTransformer.prototype.visitConditional = function (ast) {
	        return new Conditional(ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));
	    };
	    AstTransformer.prototype.visitPipe = function (ast) {
	        return new BindingPipe(ast.exp.visit(this), ast.name, this.visitAll(ast.args));
	    };
	    AstTransformer.prototype.visitKeyedRead = function (ast) {
	        return new KeyedRead(ast.obj.visit(this), ast.key.visit(this));
	    };
	    AstTransformer.prototype.visitKeyedWrite = function (ast) {
	        return new KeyedWrite(ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));
	    };
	    AstTransformer.prototype.visitAll = function (asts) {
	        var res = collection_1.ListWrapper.createFixedSize(asts.length);
	        for (var i = 0; i < asts.length; ++i) {
	            res[i] = asts[i].visit(this);
	        }
	        return res;
	    };
	    AstTransformer.prototype.visitChain = function (ast) { return new Chain(this.visitAll(ast.expressions)); };
	    AstTransformer.prototype.visitIf = function (ast) {
	        var falseExp = lang_1.isPresent(ast.falseExp) ? ast.falseExp.visit(this) : null;
	        return new If(ast.condition.visit(this), ast.trueExp.visit(this), falseExp);
	    };
	    return AstTransformer;
	})();
	exports.AstTransformer = AstTransformer;
	//# sourceMappingURL=ast.js.map

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var abstract_change_detector_1 = __webpack_require__(182);
	var change_detection_util_1 = __webpack_require__(183);
	var constants_1 = __webpack_require__(184);
	var proto_record_1 = __webpack_require__(196);
	var DynamicChangeDetector = (function (_super) {
	    __extends(DynamicChangeDetector, _super);
	    function DynamicChangeDetector(id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy, _records, _eventBindings, _directiveRecords, _genConfig) {
	        _super.call(this, id, dispatcher, numberOfPropertyProtoRecords, propertyBindingTargets, directiveIndices, strategy);
	        this._records = _records;
	        this._eventBindings = _eventBindings;
	        this._directiveRecords = _directiveRecords;
	        this._genConfig = _genConfig;
	        this.directives = null;
	        var len = _records.length + 1;
	        this.values = collection_1.ListWrapper.createFixedSize(len);
	        this.localPipes = collection_1.ListWrapper.createFixedSize(len);
	        this.prevContexts = collection_1.ListWrapper.createFixedSize(len);
	        this.changes = collection_1.ListWrapper.createFixedSize(len);
	        this.dehydrateDirectives(false);
	    }
	    DynamicChangeDetector.prototype.handleEventInternal = function (eventName, elIndex, locals) {
	        var _this = this;
	        var preventDefault = false;
	        this._matchingEventBindings(eventName, elIndex)
	            .forEach(function (rec) {
	            var res = _this._processEventBinding(rec, locals);
	            if (res === false) {
	                preventDefault = true;
	            }
	        });
	        return preventDefault;
	    };
	    DynamicChangeDetector.prototype._processEventBinding = function (eb, locals) {
	        var values = collection_1.ListWrapper.createFixedSize(eb.records.length);
	        values[0] = this.values[0];
	        for (var i = 0; i < eb.records.length; ++i) {
	            var proto = eb.records[i];
	            var res = this._calculateCurrValue(proto, values, locals);
	            if (proto.lastInBinding) {
	                this._markPathAsCheckOnce(proto);
	                return res;
	            }
	            else {
	                this._writeSelf(proto, res, values);
	            }
	        }
	        throw new exceptions_1.BaseException("Cannot be reached");
	    };
	    DynamicChangeDetector.prototype._markPathAsCheckOnce = function (proto) {
	        if (!proto.bindingRecord.isDefaultChangeDetection()) {
	            var dir = proto.bindingRecord.directiveRecord;
	            this._getDetectorFor(dir.directiveIndex).markPathToRootAsCheckOnce();
	        }
	    };
	    DynamicChangeDetector.prototype._matchingEventBindings = function (eventName, elIndex) {
	        return collection_1.ListWrapper.filter(this._eventBindings, function (eb) { return eb.eventName == eventName && eb.elIndex === elIndex; });
	    };
	    DynamicChangeDetector.prototype.hydrateDirectives = function (directives) {
	        this.values[0] = this.context;
	        this.directives = directives;
	        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
	            for (var i = 0; i < this.directiveIndices.length; ++i) {
	                var index = this.directiveIndices[i];
	                _super.prototype.observeDirective.call(this, directives.getDirectiveFor(index), i);
	            }
	        }
	    };
	    DynamicChangeDetector.prototype.dehydrateDirectives = function (destroyPipes) {
	        if (destroyPipes) {
	            this._destroyPipes();
	        }
	        this.values[0] = null;
	        this.directives = null;
	        collection_1.ListWrapper.fill(this.values, change_detection_util_1.ChangeDetectionUtil.uninitialized, 1);
	        collection_1.ListWrapper.fill(this.changes, false);
	        collection_1.ListWrapper.fill(this.localPipes, null);
	        collection_1.ListWrapper.fill(this.prevContexts, change_detection_util_1.ChangeDetectionUtil.uninitialized);
	    };
	    DynamicChangeDetector.prototype._destroyPipes = function () {
	        for (var i = 0; i < this.localPipes.length; ++i) {
	            if (lang_1.isPresent(this.localPipes[i])) {
	                change_detection_util_1.ChangeDetectionUtil.callPipeOnDestroy(this.localPipes[i]);
	            }
	        }
	    };
	    DynamicChangeDetector.prototype.checkNoChanges = function () { this.runDetectChanges(true); };
	    DynamicChangeDetector.prototype.detectChangesInRecordsInternal = function (throwOnChange) {
	        var protos = this._records;
	        var changes = null;
	        var isChanged = false;
	        for (var i = 0; i < protos.length; ++i) {
	            var proto = protos[i];
	            var bindingRecord = proto.bindingRecord;
	            var directiveRecord = bindingRecord.directiveRecord;
	            if (this._firstInBinding(proto)) {
	                this.propertyBindingIndex = proto.propertyBindingIndex;
	            }
	            if (proto.isLifeCycleRecord()) {
	                if (proto.name === "DoCheck" && !throwOnChange) {
	                    this._getDirectiveFor(directiveRecord.directiveIndex).doCheck();
	                }
	                else if (proto.name === "OnInit" && !throwOnChange && !this.alreadyChecked) {
	                    this._getDirectiveFor(directiveRecord.directiveIndex).onInit();
	                }
	                else if (proto.name === "OnChanges" && lang_1.isPresent(changes) && !throwOnChange) {
	                    this._getDirectiveFor(directiveRecord.directiveIndex).onChanges(changes);
	                }
	            }
	            else {
	                var change = this._check(proto, throwOnChange, this.values, this.locals);
	                if (lang_1.isPresent(change)) {
	                    this._updateDirectiveOrElement(change, bindingRecord);
	                    isChanged = true;
	                    changes = this._addChange(bindingRecord, change, changes);
	                }
	            }
	            if (proto.lastInDirective) {
	                changes = null;
	                if (isChanged && !bindingRecord.isDefaultChangeDetection()) {
	                    this._getDetectorFor(directiveRecord.directiveIndex).markAsCheckOnce();
	                }
	                isChanged = false;
	            }
	        }
	    };
	    DynamicChangeDetector.prototype._firstInBinding = function (r) {
	        var prev = change_detection_util_1.ChangeDetectionUtil.protoByIndex(this._records, r.selfIndex - 1);
	        return lang_1.isBlank(prev) || prev.bindingRecord !== r.bindingRecord;
	    };
	    DynamicChangeDetector.prototype.afterContentLifecycleCallbacksInternal = function () {
	        var dirs = this._directiveRecords;
	        for (var i = dirs.length - 1; i >= 0; --i) {
	            var dir = dirs[i];
	            if (dir.callAfterContentInit && !this.alreadyChecked) {
	                this._getDirectiveFor(dir.directiveIndex).afterContentInit();
	            }
	            if (dir.callAfterContentChecked) {
	                this._getDirectiveFor(dir.directiveIndex).afterContentChecked();
	            }
	        }
	    };
	    DynamicChangeDetector.prototype.afterViewLifecycleCallbacksInternal = function () {
	        var dirs = this._directiveRecords;
	        for (var i = dirs.length - 1; i >= 0; --i) {
	            var dir = dirs[i];
	            if (dir.callAfterViewInit && !this.alreadyChecked) {
	                this._getDirectiveFor(dir.directiveIndex).afterViewInit();
	            }
	            if (dir.callAfterViewChecked) {
	                this._getDirectiveFor(dir.directiveIndex).afterViewChecked();
	            }
	        }
	    };
	    DynamicChangeDetector.prototype._updateDirectiveOrElement = function (change, bindingRecord) {
	        if (lang_1.isBlank(bindingRecord.directiveRecord)) {
	            _super.prototype.notifyDispatcher.call(this, change.currentValue);
	        }
	        else {
	            var directiveIndex = bindingRecord.directiveRecord.directiveIndex;
	            bindingRecord.setter(this._getDirectiveFor(directiveIndex), change.currentValue);
	        }
	        if (this._genConfig.logBindingUpdate) {
	            _super.prototype.logBindingUpdate.call(this, change.currentValue);
	        }
	    };
	    DynamicChangeDetector.prototype._addChange = function (bindingRecord, change, changes) {
	        if (bindingRecord.callOnChanges()) {
	            return _super.prototype.addChange.call(this, changes, change.previousValue, change.currentValue);
	        }
	        else {
	            return changes;
	        }
	    };
	    DynamicChangeDetector.prototype._getDirectiveFor = function (directiveIndex) { return this.directives.getDirectiveFor(directiveIndex); };
	    DynamicChangeDetector.prototype._getDetectorFor = function (directiveIndex) { return this.directives.getDetectorFor(directiveIndex); };
	    DynamicChangeDetector.prototype._check = function (proto, throwOnChange, values, locals) {
	        if (proto.isPipeRecord()) {
	            return this._pipeCheck(proto, throwOnChange, values);
	        }
	        else {
	            return this._referenceCheck(proto, throwOnChange, values, locals);
	        }
	    };
	    DynamicChangeDetector.prototype._referenceCheck = function (proto, throwOnChange, values, locals) {
	        if (this._pureFuncAndArgsDidNotChange(proto)) {
	            this._setChanged(proto, false);
	            return null;
	        }
	        var currValue = this._calculateCurrValue(proto, values, locals);
	        if (this.strategy === constants_1.ChangeDetectionStrategy.OnPushObserve) {
	            _super.prototype.observeValue.call(this, currValue, proto.selfIndex);
	        }
	        if (proto.shouldBeChecked()) {
	            var prevValue = this._readSelf(proto, values);
	            if (!isSame(prevValue, currValue)) {
	                if (proto.lastInBinding) {
	                    var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);
	                    if (throwOnChange)
	                        this.throwOnChangeError(prevValue, currValue);
	                    this._writeSelf(proto, currValue, values);
	                    this._setChanged(proto, true);
	                    return change;
	                }
	                else {
	                    this._writeSelf(proto, currValue, values);
	                    this._setChanged(proto, true);
	                    return null;
	                }
	            }
	            else {
	                this._setChanged(proto, false);
	                return null;
	            }
	        }
	        else {
	            this._writeSelf(proto, currValue, values);
	            this._setChanged(proto, true);
	            return null;
	        }
	    };
	    DynamicChangeDetector.prototype._calculateCurrValue = function (proto, values, locals) {
	        switch (proto.mode) {
	            case proto_record_1.RecordType.Self:
	                return this._readContext(proto, values);
	            case proto_record_1.RecordType.Const:
	                return proto.funcOrValue;
	            case proto_record_1.RecordType.PropertyRead:
	                var context = this._readContext(proto, values);
	                return proto.funcOrValue(context);
	            case proto_record_1.RecordType.SafeProperty:
	                var context = this._readContext(proto, values);
	                return lang_1.isBlank(context) ? null : proto.funcOrValue(context);
	            case proto_record_1.RecordType.PropertyWrite:
	                var context = this._readContext(proto, values);
	                var value = this._readArgs(proto, values)[0];
	                proto.funcOrValue(context, value);
	                return value;
	            case proto_record_1.RecordType.KeyedWrite:
	                var context = this._readContext(proto, values);
	                var key = this._readArgs(proto, values)[0];
	                var value = this._readArgs(proto, values)[1];
	                context[key] = value;
	                return value;
	            case proto_record_1.RecordType.Local:
	                return locals.get(proto.name);
	            case proto_record_1.RecordType.InvokeMethod:
	                var context = this._readContext(proto, values);
	                var args = this._readArgs(proto, values);
	                return proto.funcOrValue(context, args);
	            case proto_record_1.RecordType.SafeMethodInvoke:
	                var context = this._readContext(proto, values);
	                if (lang_1.isBlank(context)) {
	                    return null;
	                }
	                var args = this._readArgs(proto, values);
	                return proto.funcOrValue(context, args);
	            case proto_record_1.RecordType.KeyedRead:
	                var arg = this._readArgs(proto, values)[0];
	                return this._readContext(proto, values)[arg];
	            case proto_record_1.RecordType.Chain:
	                var args = this._readArgs(proto, values);
	                return args[args.length - 1];
	            case proto_record_1.RecordType.InvokeClosure:
	                return lang_1.FunctionWrapper.apply(this._readContext(proto, values), this._readArgs(proto, values));
	            case proto_record_1.RecordType.Interpolate:
	            case proto_record_1.RecordType.PrimitiveOp:
	            case proto_record_1.RecordType.CollectionLiteral:
	                return lang_1.FunctionWrapper.apply(proto.funcOrValue, this._readArgs(proto, values));
	            default:
	                throw new exceptions_1.BaseException("Unknown operation " + proto.mode);
	        }
	    };
	    DynamicChangeDetector.prototype._pipeCheck = function (proto, throwOnChange, values) {
	        var context = this._readContext(proto, values);
	        var selectedPipe = this._pipeFor(proto, context);
	        if (!selectedPipe.pure || this._argsOrContextChanged(proto)) {
	            var args = this._readArgs(proto, values);
	            var currValue = selectedPipe.pipe.transform(context, args);
	            if (proto.shouldBeChecked()) {
	                var prevValue = this._readSelf(proto, values);
	                if (!isSame(prevValue, currValue)) {
	                    currValue = change_detection_util_1.ChangeDetectionUtil.unwrapValue(currValue);
	                    if (proto.lastInBinding) {
	                        var change = change_detection_util_1.ChangeDetectionUtil.simpleChange(prevValue, currValue);
	                        if (throwOnChange)
	                            this.throwOnChangeError(prevValue, currValue);
	                        this._writeSelf(proto, currValue, values);
	                        this._setChanged(proto, true);
	                        return change;
	                    }
	                    else {
	                        this._writeSelf(proto, currValue, values);
	                        this._setChanged(proto, true);
	                        return null;
	                    }
	                }
	                else {
	                    this._setChanged(proto, false);
	                    return null;
	                }
	            }
	            else {
	                this._writeSelf(proto, currValue, values);
	                this._setChanged(proto, true);
	                return null;
	            }
	        }
	    };
	    DynamicChangeDetector.prototype._pipeFor = function (proto, context) {
	        var storedPipe = this._readPipe(proto);
	        if (lang_1.isPresent(storedPipe))
	            return storedPipe;
	        var pipe = this.pipes.get(proto.name);
	        this._writePipe(proto, pipe);
	        return pipe;
	    };
	    DynamicChangeDetector.prototype._readContext = function (proto, values) {
	        if (proto.contextIndex == -1) {
	            return this._getDirectiveFor(proto.directiveIndex);
	        }
	        else {
	            return values[proto.contextIndex];
	        }
	        return values[proto.contextIndex];
	    };
	    DynamicChangeDetector.prototype._readSelf = function (proto, values) { return values[proto.selfIndex]; };
	    DynamicChangeDetector.prototype._writeSelf = function (proto, value, values) { values[proto.selfIndex] = value; };
	    DynamicChangeDetector.prototype._readPipe = function (proto) { return this.localPipes[proto.selfIndex]; };
	    DynamicChangeDetector.prototype._writePipe = function (proto, value) { this.localPipes[proto.selfIndex] = value; };
	    DynamicChangeDetector.prototype._setChanged = function (proto, value) {
	        if (proto.argumentToPureFunction)
	            this.changes[proto.selfIndex] = value;
	    };
	    DynamicChangeDetector.prototype._pureFuncAndArgsDidNotChange = function (proto) {
	        return proto.isPureFunction() && !this._argsChanged(proto);
	    };
	    DynamicChangeDetector.prototype._argsChanged = function (proto) {
	        var args = proto.args;
	        for (var i = 0; i < args.length; ++i) {
	            if (this.changes[args[i]]) {
	                return true;
	            }
	        }
	        return false;
	    };
	    DynamicChangeDetector.prototype._argsOrContextChanged = function (proto) {
	        return this._argsChanged(proto) || this.changes[proto.contextIndex];
	    };
	    DynamicChangeDetector.prototype._readArgs = function (proto, values) {
	        var res = collection_1.ListWrapper.createFixedSize(proto.args.length);
	        var args = proto.args;
	        for (var i = 0; i < args.length; ++i) {
	            res[i] = values[args[i]];
	        }
	        return res;
	    };
	    return DynamicChangeDetector;
	})(abstract_change_detector_1.AbstractChangeDetector);
	exports.DynamicChangeDetector = DynamicChangeDetector;
	function isSame(a, b) {
	    if (a === b)
	        return true;
	    if (a instanceof String && b instanceof String && a == b)
	        return true;
	    if ((a !== a) && (b !== b))
	        return true;
	    return false;
	}
	//# sourceMappingURL=dynamic_change_detector.js.map

/***/ },
/* 200 */
/***/ function(module, exports) {

	var EventBinding = (function () {
	    function EventBinding(eventName, elIndex, dirIndex, records) {
	        this.eventName = eventName;
	        this.elIndex = elIndex;
	        this.dirIndex = dirIndex;
	        this.records = records;
	    }
	    return EventBinding;
	})();
	exports.EventBinding = EventBinding;
	//# sourceMappingURL=event_binding.js.map

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var proto_record_1 = __webpack_require__(196);
	/**
	 * Removes "duplicate" records. It assuming that record evaluation does not
	 * have side-effects.
	 *
	 * Records that are not last in bindings are removed and all the indices
	 * of the records that depend on them are updated.
	 *
	 * Records that are last in bindings CANNOT be removed, and instead are
	 * replaced with very cheap SELF records.
	 */
	function coalesce(records) {
	    var res = [];
	    var indexMap = new collection_1.Map();
	    for (var i = 0; i < records.length; ++i) {
	        var r = records[i];
	        var record = _replaceIndices(r, res.length + 1, indexMap);
	        var matchingRecord = _findMatching(record, res);
	        if (lang_1.isPresent(matchingRecord) && record.lastInBinding) {
	            res.push(_selfRecord(record, matchingRecord.selfIndex, res.length + 1));
	            indexMap.set(r.selfIndex, matchingRecord.selfIndex);
	            matchingRecord.referencedBySelf = true;
	        }
	        else if (lang_1.isPresent(matchingRecord) && !record.lastInBinding) {
	            if (record.argumentToPureFunction) {
	                matchingRecord.argumentToPureFunction = true;
	            }
	            indexMap.set(r.selfIndex, matchingRecord.selfIndex);
	        }
	        else {
	            res.push(record);
	            indexMap.set(r.selfIndex, record.selfIndex);
	        }
	    }
	    return res;
	}
	exports.coalesce = coalesce;
	function _selfRecord(r, contextIndex, selfIndex) {
	    return new proto_record_1.ProtoRecord(proto_record_1.RecordType.Self, "self", null, [], r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, false, false, r.propertyBindingIndex);
	}
	function _findMatching(r, rs) {
	    return collection_1.ListWrapper.find(rs, function (rr) { return rr.mode !== proto_record_1.RecordType.DirectiveLifecycle && _sameDirIndex(rr, r) &&
	        rr.mode === r.mode && lang_1.looseIdentical(rr.funcOrValue, r.funcOrValue) &&
	        rr.contextIndex === r.contextIndex && lang_1.looseIdentical(rr.name, r.name) &&
	        collection_1.ListWrapper.equals(rr.args, r.args); });
	}
	function _sameDirIndex(a, b) {
	    var di1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.directiveIndex;
	    var ei1 = lang_1.isBlank(a.directiveIndex) ? null : a.directiveIndex.elementIndex;
	    var di2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.directiveIndex;
	    var ei2 = lang_1.isBlank(b.directiveIndex) ? null : b.directiveIndex.elementIndex;
	    return di1 === di2 && ei1 === ei2;
	}
	function _replaceIndices(r, selfIndex, indexMap) {
	    var args = collection_1.ListWrapper.map(r.args, function (a) { return _map(indexMap, a); });
	    var contextIndex = _map(indexMap, r.contextIndex);
	    return new proto_record_1.ProtoRecord(r.mode, r.name, r.funcOrValue, args, r.fixedArgs, contextIndex, r.directiveIndex, selfIndex, r.bindingRecord, r.lastInBinding, r.lastInDirective, r.argumentToPureFunction, r.referencedBySelf, r.propertyBindingIndex);
	}
	function _map(indexMap, value) {
	    var r = indexMap.get(value);
	    return lang_1.isPresent(r) ? r : value;
	}
	//# sourceMappingURL=coalesce.js.map

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	var exceptions_1 = __webpack_require__(168);
	var PregenProtoChangeDetector = (function () {
	    function PregenProtoChangeDetector() {
	    }
	    PregenProtoChangeDetector.isSupported = function () { return false; };
	    PregenProtoChangeDetector.prototype.instantiate = function (dispatcher) {
	        throw new exceptions_1.BaseException('Pregen change detection not supported in Js');
	    };
	    return PregenProtoChangeDetector;
	})();
	exports.PregenProtoChangeDetector = PregenProtoChangeDetector;
	//# sourceMappingURL=pregen_proto_change_detector.js.map

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var di_1 = __webpack_require__(160);
	/**
	 * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
	 */
	var IterableDiffers = (function () {
	    function IterableDiffers(factories) {
	        this.factories = factories;
	    }
	    IterableDiffers.create = function (factories, parent) {
	        if (lang_1.isPresent(parent)) {
	            var copied = collection_1.ListWrapper.clone(parent.factories);
	            factories = factories.concat(copied);
	            return new IterableDiffers(factories);
	        }
	        else {
	            return new IterableDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {@link IterableDifferFactory} and returns a binding used to extend the
	     * inherited {@link IterableDiffers} instance with the provided factories and return a new
	     * {@link IterableDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	           * which will only be applied to the injector for this component and its children.
	           * This step is all that's required to make a new {@link IterableDiffer} available.
	     *
	     * # Example
	     *
	     * ```
	     * @Component({
	     *   viewBindings: [
	     *     IterableDiffers.extend([new ImmutableListDiffer()])
	     *   ]
	     * })
	     * ```
	     */
	    IterableDiffers.extend = function (factories) {
	        return new di_1.Binding(IterableDiffers, {
	            toFactory: function (parent) {
	                if (lang_1.isBlank(parent)) {
	                    // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new exceptions_1.BaseException('Cannot extend IterableDiffers without a parent injector');
	                }
	                return IterableDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[IterableDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
	        });
	    };
	    IterableDiffers.prototype.find = function (iterable) {
	        var factory = collection_1.ListWrapper.find(this.factories, function (f) { return f.supports(iterable); });
	        if (lang_1.isPresent(factory)) {
	            return factory;
	        }
	        else {
	            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + iterable + "'");
	        }
	    };
	    IterableDiffers = __decorate([
	        di_1.Injectable(),
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Array])
	    ], IterableDiffers);
	    return IterableDiffers;
	})();
	exports.IterableDiffers = IterableDiffers;
	//# sourceMappingURL=iterable_differs.js.map

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var lang_2 = __webpack_require__(159);
	var DefaultIterableDifferFactory = (function () {
	    function DefaultIterableDifferFactory() {
	    }
	    DefaultIterableDifferFactory.prototype.supports = function (obj) { return collection_1.isListLikeIterable(obj); };
	    DefaultIterableDifferFactory.prototype.create = function (cdRef) { return new DefaultIterableDiffer(); };
	    DefaultIterableDifferFactory = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], DefaultIterableDifferFactory);
	    return DefaultIterableDifferFactory;
	})();
	exports.DefaultIterableDifferFactory = DefaultIterableDifferFactory;
	var DefaultIterableDiffer = (function () {
	    function DefaultIterableDiffer() {
	        this._collection = null;
	        this._length = null;
	        // Keeps track of the used records at any point in time (during & across `_check()` calls)
	        this._linkedRecords = null;
	        // Keeps track of the removed records at any point in time during `_check()` calls.
	        this._unlinkedRecords = null;
	        this._previousItHead = null;
	        this._itHead = null;
	        this._itTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._movesHead = null;
	        this._movesTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }
	    Object.defineProperty(DefaultIterableDiffer.prototype, "collection", {
	        get: function () { return this._collection; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultIterableDiffer.prototype, "length", {
	        get: function () { return this._length; },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultIterableDiffer.prototype.forEachItem = function (fn) {
	        var record;
	        for (record = this._itHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachPreviousItem = function (fn) {
	        var record;
	        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachAddedItem = function (fn) {
	        var record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachMovedItem = function (fn) {
	        var record;
	        for (record = this._movesHead; record !== null; record = record._nextMoved) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.forEachRemovedItem = function (fn) {
	        var record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    DefaultIterableDiffer.prototype.diff = function (collection) {
	        if (lang_2.isBlank(collection))
	            collection = [];
	        if (!collection_1.isListLikeIterable(collection)) {
	            throw new exceptions_1.BaseException("Error trying to diff '" + collection + "'");
	        }
	        if (this.check(collection)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    DefaultIterableDiffer.prototype.onDestroy = function () { };
	    // todo(vicb): optim for UnmodifiableListView (frozen arrays)
	    DefaultIterableDiffer.prototype.check = function (collection) {
	        var _this = this;
	        this._reset();
	        var record = this._itHead;
	        var mayBeDirty = false;
	        var index;
	        var item;
	        if (lang_2.isArray(collection)) {
	            var list = collection;
	            this._length = collection.length;
	            for (index = 0; index < this._length; index++) {
	                item = list[index];
	                if (record === null || !lang_2.looseIdentical(record.item, item)) {
	                    record = this._mismatch(record, item, index);
	                    mayBeDirty = true;
	                }
	                else if (mayBeDirty) {
	                    // TODO(misko): can we limit this to duplicates only?
	                    record = this._verifyReinsertion(record, item, index);
	                }
	                record = record._next;
	            }
	        }
	        else {
	            index = 0;
	            collection_1.iterateListLike(collection, function (item) {
	                if (record === null || !lang_2.looseIdentical(record.item, item)) {
	                    record = _this._mismatch(record, item, index);
	                    mayBeDirty = true;
	                }
	                else if (mayBeDirty) {
	                    // TODO(misko): can we limit this to duplicates only?
	                    record = _this._verifyReinsertion(record, item, index);
	                }
	                record = record._next;
	                index++;
	            });
	            this._length = index;
	        }
	        this._truncate(record);
	        this._collection = collection;
	        return this.isDirty;
	    };
	    Object.defineProperty(DefaultIterableDiffer.prototype, "isDirty", {
	        // CollectionChanges is considered dirty if it has any additions, moves or removals.
	        get: function () {
	            return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Reset the state of the change objects to show no changes. This means set previousKey to
	     * currentKey, and clear all of the queues (additions, moves, removals).
	     * Set the previousIndexes of moved and added items to their currentIndexes
	     * Reset the list of additions, moves and removals
	     */
	    DefaultIterableDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var record;
	            var nextRecord;
	            for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	                record.previousIndex = record.currentIndex;
	            }
	            this._additionsHead = this._additionsTail = null;
	            for (record = this._movesHead; record !== null; record = nextRecord) {
	                record.previousIndex = record.currentIndex;
	                nextRecord = record._nextMoved;
	            }
	            this._movesHead = this._movesTail = null;
	            this._removalsHead = this._removalsTail = null;
	        }
	    };
	    /**
	     * This is the core function which handles differences between collections.
	     *
	     * - `record` is the record which we saw at this position last time. If null then it is a new
	     *   item.
	     * - `item` is the current item in the collection
	     * - `index` is the position of the item in the collection
	     */
	    DefaultIterableDiffer.prototype._mismatch = function (record, item, index) {
	        // The previous record after which we will append the current one.
	        var previousRecord;
	        if (record === null) {
	            previousRecord = this._itTail;
	        }
	        else {
	            previousRecord = record._prev;
	            // Remove the record from the collection since we know it does not match the item.
	            this._remove(record);
	        }
	        // Attempt to see if we have seen the item before.
	        record = this._linkedRecords === null ? null : this._linkedRecords.get(item, index);
	        if (record !== null) {
	            // We have seen this before, we need to move it forward in the collection.
	            this._moveAfter(record, previousRecord, index);
	        }
	        else {
	            // Never seen it, check evicted list.
	            record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
	            if (record !== null) {
	                // It is an item which we have evicted earlier: reinsert it back into the list.
	                this._reinsertAfter(record, previousRecord, index);
	            }
	            else {
	                // It is a new item: add it.
	                record = this._addAfter(new CollectionChangeRecord(item), previousRecord, index);
	            }
	        }
	        return record;
	    };
	    /**
	     * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
	     *
	     * Use case: `[a, a]` => `[b, a, a]`
	     *
	     * If we did not have this check then the insertion of `b` would:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) leave `a` at index `1` as is. <-- this is wrong!
	     *   3) reinsert `a` at index 2. <-- this is wrong!
	     *
	     * The correct behavior is:
	     *   1) evict first `a`
	     *   2) insert `b` at `0` index.
	     *   3) reinsert `a` at index 1.
	     *   3) move `a` at from `1` to `2`.
	     *
	     *
	     * Double check that we have not evicted a duplicate item. We need to check if the item type may
	     * have already been removed:
	     * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
	     * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
	     * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
	     * at the end.
	     */
	    DefaultIterableDiffer.prototype._verifyReinsertion = function (record, item, index) {
	        var reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(item);
	        if (reinsertRecord !== null) {
	            record = this._reinsertAfter(reinsertRecord, record._prev, index);
	        }
	        else if (record.currentIndex != index) {
	            record.currentIndex = index;
	            this._addToMoves(record, index);
	        }
	        return record;
	    };
	    /**
	     * Get rid of any excess {@link CollectionChangeRecord}s from the previous collection
	     *
	     * - `record` The first excess {@link CollectionChangeRecord}.
	     */
	    DefaultIterableDiffer.prototype._truncate = function (record) {
	        // Anything after that needs to be removed;
	        while (record !== null) {
	            var nextRecord = record._next;
	            this._addToRemovals(this._unlink(record));
	            record = nextRecord;
	        }
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.clear();
	        }
	        if (this._additionsTail !== null) {
	            this._additionsTail._nextAdded = null;
	        }
	        if (this._movesTail !== null) {
	            this._movesTail._nextMoved = null;
	        }
	        if (this._itTail !== null) {
	            this._itTail._next = null;
	        }
	        if (this._removalsTail !== null) {
	            this._removalsTail._nextRemoved = null;
	        }
	    };
	    DefaultIterableDiffer.prototype._reinsertAfter = function (record, prevRecord, index) {
	        if (this._unlinkedRecords !== null) {
	            this._unlinkedRecords.remove(record);
	        }
	        var prev = record._prevRemoved;
	        var next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    DefaultIterableDiffer.prototype._moveAfter = function (record, prevRecord, index) {
	        this._unlink(record);
	        this._insertAfter(record, prevRecord, index);
	        this._addToMoves(record, index);
	        return record;
	    };
	    DefaultIterableDiffer.prototype._addAfter = function (record, prevRecord, index) {
	        this._insertAfter(record, prevRecord, index);
	        if (this._additionsTail === null) {
	            // todo(vicb)
	            // assert(this._additionsHead === null);
	            this._additionsTail = this._additionsHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_additionsTail._nextAdded === null);
	            // assert(record._nextAdded === null);
	            this._additionsTail = this._additionsTail._nextAdded = record;
	        }
	        return record;
	    };
	    DefaultIterableDiffer.prototype._insertAfter = function (record, prevRecord, index) {
	        // todo(vicb)
	        // assert(record != prevRecord);
	        // assert(record._next === null);
	        // assert(record._prev === null);
	        var next = prevRecord === null ? this._itHead : prevRecord._next;
	        // todo(vicb)
	        // assert(next != record);
	        // assert(prevRecord != record);
	        record._next = next;
	        record._prev = prevRecord;
	        if (next === null) {
	            this._itTail = record;
	        }
	        else {
	            next._prev = record;
	        }
	        if (prevRecord === null) {
	            this._itHead = record;
	        }
	        else {
	            prevRecord._next = record;
	        }
	        if (this._linkedRecords === null) {
	            this._linkedRecords = new _DuplicateMap();
	        }
	        this._linkedRecords.put(record);
	        record.currentIndex = index;
	        return record;
	    };
	    DefaultIterableDiffer.prototype._remove = function (record) {
	        return this._addToRemovals(this._unlink(record));
	    };
	    DefaultIterableDiffer.prototype._unlink = function (record) {
	        if (this._linkedRecords !== null) {
	            this._linkedRecords.remove(record);
	        }
	        var prev = record._prev;
	        var next = record._next;
	        // todo(vicb)
	        // assert((record._prev = null) === null);
	        // assert((record._next = null) === null);
	        if (prev === null) {
	            this._itHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        if (next === null) {
	            this._itTail = prev;
	        }
	        else {
	            next._prev = prev;
	        }
	        return record;
	    };
	    DefaultIterableDiffer.prototype._addToMoves = function (record, toIndex) {
	        // todo(vicb)
	        // assert(record._nextMoved === null);
	        if (record.previousIndex === toIndex) {
	            return record;
	        }
	        if (this._movesTail === null) {
	            // todo(vicb)
	            // assert(_movesHead === null);
	            this._movesTail = this._movesHead = record;
	        }
	        else {
	            // todo(vicb)
	            // assert(_movesTail._nextMoved === null);
	            this._movesTail = this._movesTail._nextMoved = record;
	        }
	        return record;
	    };
	    DefaultIterableDiffer.prototype._addToRemovals = function (record) {
	        if (this._unlinkedRecords === null) {
	            this._unlinkedRecords = new _DuplicateMap();
	        }
	        this._unlinkedRecords.put(record);
	        record.currentIndex = null;
	        record._nextRemoved = null;
	        if (this._removalsTail === null) {
	            // todo(vicb)
	            // assert(_removalsHead === null);
	            this._removalsTail = this._removalsHead = record;
	            record._prevRemoved = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(_removalsTail._nextRemoved === null);
	            // assert(record._nextRemoved === null);
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = this._removalsTail._nextRemoved = record;
	        }
	        return record;
	    };
	    DefaultIterableDiffer.prototype.toString = function () {
	        var record;
	        var list = [];
	        for (record = this._itHead; record !== null; record = record._next) {
	            list.push(record);
	        }
	        var previous = [];
	        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
	            previous.push(record);
	        }
	        var additions = [];
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            additions.push(record);
	        }
	        var moves = [];
	        for (record = this._movesHead; record !== null; record = record._nextMoved) {
	            moves.push(record);
	        }
	        var removals = [];
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            removals.push(record);
	        }
	        return "collection: " + list.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
	            "additions: " + additions.join(', ') + "\n" + "moves: " + moves.join(', ') + "\n" +
	            "removals: " + removals.join(', ') + "\n";
	    };
	    return DefaultIterableDiffer;
	})();
	exports.DefaultIterableDiffer = DefaultIterableDiffer;
	var CollectionChangeRecord = (function () {
	    function CollectionChangeRecord(item) {
	        this.item = item;
	        this.currentIndex = null;
	        this.previousIndex = null;
	        this._nextPrevious = null;
	        this._prev = null;
	        this._next = null;
	        this._prevDup = null;
	        this._nextDup = null;
	        this._prevRemoved = null;
	        this._nextRemoved = null;
	        this._nextAdded = null;
	        this._nextMoved = null;
	    }
	    CollectionChangeRecord.prototype.toString = function () {
	        return this.previousIndex === this.currentIndex ?
	            lang_2.stringify(this.item) :
	            lang_2.stringify(this.item) + '[' + lang_2.stringify(this.previousIndex) + '->' +
	                lang_2.stringify(this.currentIndex) + ']';
	    };
	    return CollectionChangeRecord;
	})();
	exports.CollectionChangeRecord = CollectionChangeRecord;
	// A linked list of CollectionChangeRecords with the same CollectionChangeRecord.item
	var _DuplicateItemRecordList = (function () {
	    function _DuplicateItemRecordList() {
	        this._head = null;
	        this._tail = null;
	    }
	    /**
	     * Append the record to the list of duplicates.
	     *
	     * Note: by design all records in the list of duplicates hold the same value in record.item.
	     */
	    _DuplicateItemRecordList.prototype.add = function (record) {
	        if (this._head === null) {
	            this._head = this._tail = record;
	            record._nextDup = null;
	            record._prevDup = null;
	        }
	        else {
	            // todo(vicb)
	            // assert(record.item ==  _head.item ||
	            //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);
	            this._tail._nextDup = record;
	            record._prevDup = this._tail;
	            record._nextDup = null;
	            this._tail = record;
	        }
	    };
	    // Returns a CollectionChangeRecord having CollectionChangeRecord.item == item and
	    // CollectionChangeRecord.currentIndex >= afterIndex
	    _DuplicateItemRecordList.prototype.get = function (item, afterIndex) {
	        var record;
	        for (record = this._head; record !== null; record = record._nextDup) {
	            if ((afterIndex === null || afterIndex < record.currentIndex) &&
	                lang_2.looseIdentical(record.item, item)) {
	                return record;
	            }
	        }
	        return null;
	    };
	    /**
	     * Remove one {@link CollectionChangeRecord} from the list of duplicates.
	     *
	     * Returns whether the list of duplicates is empty.
	     */
	    _DuplicateItemRecordList.prototype.remove = function (record) {
	        // todo(vicb)
	        // assert(() {
	        //  // verify that the record being removed is in the list.
	        //  for (CollectionChangeRecord cursor = _head; cursor != null; cursor = cursor._nextDup) {
	        //    if (identical(cursor, record)) return true;
	        //  }
	        //  return false;
	        //});
	        var prev = record._prevDup;
	        var next = record._nextDup;
	        if (prev === null) {
	            this._head = next;
	        }
	        else {
	            prev._nextDup = next;
	        }
	        if (next === null) {
	            this._tail = prev;
	        }
	        else {
	            next._prevDup = prev;
	        }
	        return this._head === null;
	    };
	    return _DuplicateItemRecordList;
	})();
	var _DuplicateMap = (function () {
	    function _DuplicateMap() {
	        this.map = new Map();
	    }
	    _DuplicateMap.prototype.put = function (record) {
	        // todo(vicb) handle corner cases
	        var key = lang_2.getMapKey(record.item);
	        var duplicates = this.map.get(key);
	        if (!lang_2.isPresent(duplicates)) {
	            duplicates = new _DuplicateItemRecordList();
	            this.map.set(key, duplicates);
	        }
	        duplicates.add(record);
	    };
	    /**
	     * Retrieve the `value` using key. Because the CollectionChangeRecord value maybe one which we
	     * have already iterated over, we use the afterIndex to pretend it is not there.
	     *
	     * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
	     * have any more `a`s needs to return the last `a` not the first or second.
	     */
	    _DuplicateMap.prototype.get = function (value, afterIndex) {
	        if (afterIndex === void 0) { afterIndex = null; }
	        var key = lang_2.getMapKey(value);
	        var recordList = this.map.get(key);
	        return lang_2.isBlank(recordList) ? null : recordList.get(value, afterIndex);
	    };
	    /**
	     * Removes a {@link CollectionChangeRecord} from the list of duplicates.
	     *
	     * The list of duplicates also is removed from the map if it gets empty.
	     */
	    _DuplicateMap.prototype.remove = function (record) {
	        var key = lang_2.getMapKey(record.item);
	        // todo(vicb)
	        // assert(this.map.containsKey(key));
	        var recordList = this.map.get(key);
	        // Remove the list of duplicates when it gets empty
	        if (recordList.remove(record)) {
	            collection_1.MapWrapper.delete(this.map, key);
	        }
	        return record;
	    };
	    Object.defineProperty(_DuplicateMap.prototype, "isEmpty", {
	        get: function () { return collection_1.MapWrapper.size(this.map) === 0; },
	        enumerable: true,
	        configurable: true
	    });
	    _DuplicateMap.prototype.clear = function () { this.map.clear(); };
	    _DuplicateMap.prototype.toString = function () { return '_DuplicateMap(' + lang_2.stringify(this.map) + ')'; };
	    return _DuplicateMap;
	})();
	//# sourceMappingURL=default_iterable_differ.js.map

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var di_1 = __webpack_require__(160);
	/**
	 * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
	 */
	var KeyValueDiffers = (function () {
	    function KeyValueDiffers(factories) {
	        this.factories = factories;
	    }
	    KeyValueDiffers.create = function (factories, parent) {
	        if (lang_1.isPresent(parent)) {
	            var copied = collection_1.ListWrapper.clone(parent.factories);
	            factories = factories.concat(copied);
	            return new KeyValueDiffers(factories);
	        }
	        else {
	            return new KeyValueDiffers(factories);
	        }
	    };
	    /**
	     * Takes an array of {@link KeyValueDifferFactory} and returns a binding used to extend the
	     * inherited {@link KeyValueDiffers} instance with the provided factories and return a new
	     * {@link KeyValueDiffers} instance.
	     *
	     * The following example shows how to extend an existing list of factories,
	           * which will only be applied to the injector for this component and its children.
	           * This step is all that's required to make a new {@link KeyValueDiffer} available.
	     *
	     * # Example
	     *
	     * ```
	     * @Component({
	     *   viewBindings: [
	     *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
	     *   ]
	     * })
	     * ```
	     */
	    KeyValueDiffers.extend = function (factories) {
	        return new di_1.Binding(KeyValueDiffers, {
	            toFactory: function (parent) {
	                if (lang_1.isBlank(parent)) {
	                    // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
	                    // to
	                    // bootstrap(), which would override default pipes instead of extending them.
	                    throw new exceptions_1.BaseException('Cannot extend KeyValueDiffers without a parent injector');
	                }
	                return KeyValueDiffers.create(factories, parent);
	            },
	            // Dependency technically isn't optional, but we can provide a better error message this way.
	            deps: [[KeyValueDiffers, new di_1.SkipSelfMetadata(), new di_1.OptionalMetadata()]]
	        });
	    };
	    KeyValueDiffers.prototype.find = function (kv) {
	        var factory = collection_1.ListWrapper.find(this.factories, function (f) { return f.supports(kv); });
	        if (lang_1.isPresent(factory)) {
	            return factory;
	        }
	        else {
	            throw new exceptions_1.BaseException("Cannot find a differ supporting object '" + kv + "'");
	        }
	    };
	    KeyValueDiffers = __decorate([
	        di_1.Injectable(),
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Array])
	    ], KeyValueDiffers);
	    return KeyValueDiffers;
	})();
	exports.KeyValueDiffers = KeyValueDiffers;
	//# sourceMappingURL=keyvalue_differs.js.map

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var DefaultKeyValueDifferFactory = (function () {
	    function DefaultKeyValueDifferFactory() {
	    }
	    DefaultKeyValueDifferFactory.prototype.supports = function (obj) { return obj instanceof Map || lang_1.isJsObject(obj); };
	    DefaultKeyValueDifferFactory.prototype.create = function (cdRef) { return new DefaultKeyValueDiffer(); };
	    DefaultKeyValueDifferFactory = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], DefaultKeyValueDifferFactory);
	    return DefaultKeyValueDifferFactory;
	})();
	exports.DefaultKeyValueDifferFactory = DefaultKeyValueDifferFactory;
	var DefaultKeyValueDiffer = (function () {
	    function DefaultKeyValueDiffer() {
	        this._records = new Map();
	        this._mapHead = null;
	        this._previousMapHead = null;
	        this._changesHead = null;
	        this._changesTail = null;
	        this._additionsHead = null;
	        this._additionsTail = null;
	        this._removalsHead = null;
	        this._removalsTail = null;
	    }
	    Object.defineProperty(DefaultKeyValueDiffer.prototype, "isDirty", {
	        get: function () {
	            return this._additionsHead !== null || this._changesHead !== null ||
	                this._removalsHead !== null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultKeyValueDiffer.prototype.forEachItem = function (fn) {
	        var record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachPreviousItem = function (fn) {
	        var record;
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachChangedItem = function (fn) {
	        var record;
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachAddedItem = function (fn) {
	        var record;
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.forEachRemovedItem = function (fn) {
	        var record;
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            fn(record);
	        }
	    };
	    DefaultKeyValueDiffer.prototype.diff = function (map) {
	        if (lang_1.isBlank(map))
	            map = collection_1.MapWrapper.createFromPairs([]);
	        if (!(map instanceof Map || lang_1.isJsObject(map))) {
	            throw new exceptions_1.BaseException("Error trying to diff '" + map + "'");
	        }
	        if (this.check(map)) {
	            return this;
	        }
	        else {
	            return null;
	        }
	    };
	    DefaultKeyValueDiffer.prototype.onDestroy = function () { };
	    DefaultKeyValueDiffer.prototype.check = function (map) {
	        var _this = this;
	        this._reset();
	        var records = this._records;
	        var oldSeqRecord = this._mapHead;
	        var lastOldSeqRecord = null;
	        var lastNewSeqRecord = null;
	        var seqChanged = false;
	        this._forEach(map, function (value, key) {
	            var newSeqRecord;
	            if (oldSeqRecord !== null && key === oldSeqRecord.key) {
	                newSeqRecord = oldSeqRecord;
	                if (!lang_1.looseIdentical(value, oldSeqRecord.currentValue)) {
	                    oldSeqRecord.previousValue = oldSeqRecord.currentValue;
	                    oldSeqRecord.currentValue = value;
	                    _this._addToChanges(oldSeqRecord);
	                }
	            }
	            else {
	                seqChanged = true;
	                if (oldSeqRecord !== null) {
	                    oldSeqRecord._next = null;
	                    _this._removeFromSeq(lastOldSeqRecord, oldSeqRecord);
	                    _this._addToRemovals(oldSeqRecord);
	                }
	                if (records.has(key)) {
	                    newSeqRecord = records.get(key);
	                }
	                else {
	                    newSeqRecord = new KVChangeRecord(key);
	                    records.set(key, newSeqRecord);
	                    newSeqRecord.currentValue = value;
	                    _this._addToAdditions(newSeqRecord);
	                }
	            }
	            if (seqChanged) {
	                if (_this._isInRemovals(newSeqRecord)) {
	                    _this._removeFromRemovals(newSeqRecord);
	                }
	                if (lastNewSeqRecord == null) {
	                    _this._mapHead = newSeqRecord;
	                }
	                else {
	                    lastNewSeqRecord._next = newSeqRecord;
	                }
	            }
	            lastOldSeqRecord = oldSeqRecord;
	            lastNewSeqRecord = newSeqRecord;
	            oldSeqRecord = oldSeqRecord === null ? null : oldSeqRecord._next;
	        });
	        this._truncate(lastOldSeqRecord, oldSeqRecord);
	        return this.isDirty;
	    };
	    DefaultKeyValueDiffer.prototype._reset = function () {
	        if (this.isDirty) {
	            var record;
	            // Record the state of the mapping
	            for (record = this._previousMapHead = this._mapHead; record !== null; record = record._next) {
	                record._nextPrevious = record._next;
	            }
	            for (record = this._changesHead; record !== null; record = record._nextChanged) {
	                record.previousValue = record.currentValue;
	            }
	            for (record = this._additionsHead; record != null; record = record._nextAdded) {
	                record.previousValue = record.currentValue;
	            }
	            // todo(vicb) once assert is supported
	            // assert(() {
	            //  var r = _changesHead;
	            //  while (r != null) {
	            //    var nextRecord = r._nextChanged;
	            //    r._nextChanged = null;
	            //    r = nextRecord;
	            //  }
	            //
	            //  r = _additionsHead;
	            //  while (r != null) {
	            //    var nextRecord = r._nextAdded;
	            //    r._nextAdded = null;
	            //    r = nextRecord;
	            //  }
	            //
	            //  r = _removalsHead;
	            //  while (r != null) {
	            //    var nextRecord = r._nextRemoved;
	            //    r._nextRemoved = null;
	            //    r = nextRecord;
	            //  }
	            //
	            //  return true;
	            //});
	            this._changesHead = this._changesTail = null;
	            this._additionsHead = this._additionsTail = null;
	            this._removalsHead = this._removalsTail = null;
	        }
	    };
	    DefaultKeyValueDiffer.prototype._truncate = function (lastRecord, record) {
	        while (record !== null) {
	            if (lastRecord === null) {
	                this._mapHead = null;
	            }
	            else {
	                lastRecord._next = null;
	            }
	            var nextRecord = record._next;
	            // todo(vicb) assert
	            // assert((() {
	            //  record._next = null;
	            //  return true;
	            //}));
	            this._addToRemovals(record);
	            lastRecord = record;
	            record = nextRecord;
	        }
	        for (var rec = this._removalsHead; rec !== null; rec = rec._nextRemoved) {
	            rec.previousValue = rec.currentValue;
	            rec.currentValue = null;
	            collection_1.MapWrapper.delete(this._records, rec.key);
	        }
	    };
	    DefaultKeyValueDiffer.prototype._isInRemovals = function (record) {
	        return record === this._removalsHead || record._nextRemoved !== null ||
	            record._prevRemoved !== null;
	    };
	    DefaultKeyValueDiffer.prototype._addToRemovals = function (record) {
	        // todo(vicb) assert
	        // assert(record._next == null);
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        // assert(record._nextRemoved == null);
	        // assert(record._prevRemoved == null);
	        if (this._removalsHead === null) {
	            this._removalsHead = this._removalsTail = record;
	        }
	        else {
	            this._removalsTail._nextRemoved = record;
	            record._prevRemoved = this._removalsTail;
	            this._removalsTail = record;
	        }
	    };
	    DefaultKeyValueDiffer.prototype._removeFromSeq = function (prev, record) {
	        var next = record._next;
	        if (prev === null) {
	            this._mapHead = next;
	        }
	        else {
	            prev._next = next;
	        }
	        // todo(vicb) assert
	        // assert((() {
	        //  record._next = null;
	        //  return true;
	        //})());
	    };
	    DefaultKeyValueDiffer.prototype._removeFromRemovals = function (record) {
	        // todo(vicb) assert
	        // assert(record._next == null);
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        var prev = record._prevRemoved;
	        var next = record._nextRemoved;
	        if (prev === null) {
	            this._removalsHead = next;
	        }
	        else {
	            prev._nextRemoved = next;
	        }
	        if (next === null) {
	            this._removalsTail = prev;
	        }
	        else {
	            next._prevRemoved = prev;
	        }
	        record._prevRemoved = record._nextRemoved = null;
	    };
	    DefaultKeyValueDiffer.prototype._addToAdditions = function (record) {
	        // todo(vicb): assert
	        // assert(record._next == null);
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        // assert(record._nextRemoved == null);
	        // assert(record._prevRemoved == null);
	        if (this._additionsHead === null) {
	            this._additionsHead = this._additionsTail = record;
	        }
	        else {
	            this._additionsTail._nextAdded = record;
	            this._additionsTail = record;
	        }
	    };
	    DefaultKeyValueDiffer.prototype._addToChanges = function (record) {
	        // todo(vicb) assert
	        // assert(record._nextAdded == null);
	        // assert(record._nextChanged == null);
	        // assert(record._nextRemoved == null);
	        // assert(record._prevRemoved == null);
	        if (this._changesHead === null) {
	            this._changesHead = this._changesTail = record;
	        }
	        else {
	            this._changesTail._nextChanged = record;
	            this._changesTail = record;
	        }
	    };
	    DefaultKeyValueDiffer.prototype.toString = function () {
	        var items = [];
	        var previous = [];
	        var changes = [];
	        var additions = [];
	        var removals = [];
	        var record;
	        for (record = this._mapHead; record !== null; record = record._next) {
	            items.push(lang_1.stringify(record));
	        }
	        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
	            previous.push(lang_1.stringify(record));
	        }
	        for (record = this._changesHead; record !== null; record = record._nextChanged) {
	            changes.push(lang_1.stringify(record));
	        }
	        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
	            additions.push(lang_1.stringify(record));
	        }
	        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
	            removals.push(lang_1.stringify(record));
	        }
	        return "map: " + items.join(', ') + "\n" + "previous: " + previous.join(', ') + "\n" +
	            "additions: " + additions.join(', ') + "\n" + "changes: " + changes.join(', ') + "\n" +
	            "removals: " + removals.join(', ') + "\n";
	    };
	    DefaultKeyValueDiffer.prototype._forEach = function (obj, fn) {
	        if (obj instanceof Map) {
	            collection_1.MapWrapper.forEach(obj, fn);
	        }
	        else {
	            collection_1.StringMapWrapper.forEach(obj, fn);
	        }
	    };
	    return DefaultKeyValueDiffer;
	})();
	exports.DefaultKeyValueDiffer = DefaultKeyValueDiffer;
	var KVChangeRecord = (function () {
	    function KVChangeRecord(key) {
	        this.key = key;
	        this.previousValue = null;
	        this.currentValue = null;
	        this._nextPrevious = null;
	        this._next = null;
	        this._nextAdded = null;
	        this._nextRemoved = null;
	        this._prevRemoved = null;
	        this._nextChanged = null;
	    }
	    KVChangeRecord.prototype.toString = function () {
	        return lang_1.looseIdentical(this.previousValue, this.currentValue) ?
	            lang_1.stringify(this.key) :
	            (lang_1.stringify(this.key) + '[' + lang_1.stringify(this.previousValue) + '->' +
	                lang_1.stringify(this.currentValue) + ']');
	    };
	    return KVChangeRecord;
	})();
	exports.KVChangeRecord = KVChangeRecord;
	//# sourceMappingURL=default_keyvalue_differ.js.map

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	/**
	 * Interface used by Angular to control the change detection strategy for an application.
	 *
	 * Angular implements the following change detection strategies by default:
	 *
	 * - {@link DynamicChangeDetection}: slower, but does not require `eval()`.
	 * - {@link JitChangeDetection}: faster, but requires `eval()`.
	 *
	 * In JavaScript, you should always use `JitChangeDetection`, unless you are in an environment that
	 *has
	 * [CSP](https://developer.mozilla.org/en-US/docs/Web/Security/CSP), such as a Chrome Extension.
	 *
	 * In Dart, use `DynamicChangeDetection` during development. The Angular transformer generates an
	 *analog to the
	 * `JitChangeDetection` strategy at compile time.
	 *
	 *
	 * See: {@link DynamicChangeDetection}, {@link JitChangeDetection},
	 * {@link PreGeneratedChangeDetection}
	 *
	 * # Example
	 * ```javascript
	 * bootstrap(MyApp, [bind(ChangeDetection).toValue(new DynamicChangeDetection())]);
	 * ```
	 */
	var ChangeDetection = (function () {
	    function ChangeDetection() {
	    }
	    ChangeDetection.prototype.getProtoChangeDetector = function (id, definition) {
	        return null;
	    };
	    Object.defineProperty(ChangeDetection.prototype, "generateDetectors", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ChangeDetection.prototype, "genConfig", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    ChangeDetection = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [])
	    ], ChangeDetection);
	    return ChangeDetection;
	})();
	exports.ChangeDetection = ChangeDetection;
	var DebugContext = (function () {
	    function DebugContext(element, componentElement, directive, context, locals, injector) {
	        this.element = element;
	        this.componentElement = componentElement;
	        this.directive = directive;
	        this.context = context;
	        this.locals = locals;
	        this.injector = injector;
	    }
	    return DebugContext;
	})();
	exports.DebugContext = DebugContext;
	var ChangeDetectorGenConfig = (function () {
	    function ChangeDetectorGenConfig(genCheckNoChanges, genDebugInfo, logBindingUpdate, useJit) {
	        this.genCheckNoChanges = genCheckNoChanges;
	        this.genDebugInfo = genDebugInfo;
	        this.logBindingUpdate = logBindingUpdate;
	        this.useJit = useJit;
	    }
	    return ChangeDetectorGenConfig;
	})();
	exports.ChangeDetectorGenConfig = ChangeDetectorGenConfig;
	var ChangeDetectorDefinition = (function () {
	    function ChangeDetectorDefinition(id, strategy, variableNames, bindingRecords, eventRecords, directiveRecords, genConfig) {
	        this.id = id;
	        this.strategy = strategy;
	        this.variableNames = variableNames;
	        this.bindingRecords = bindingRecords;
	        this.eventRecords = eventRecords;
	        this.directiveRecords = directiveRecords;
	        this.genConfig = genConfig;
	    }
	    return ChangeDetectorDefinition;
	})();
	exports.ChangeDetectorDefinition = ChangeDetectorDefinition;
	//# sourceMappingURL=interfaces.js.map

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var decorators_1 = __webpack_require__(162);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	(function (TokenType) {
	    TokenType[TokenType["Character"] = 0] = "Character";
	    TokenType[TokenType["Identifier"] = 1] = "Identifier";
	    TokenType[TokenType["Keyword"] = 2] = "Keyword";
	    TokenType[TokenType["String"] = 3] = "String";
	    TokenType[TokenType["Operator"] = 4] = "Operator";
	    TokenType[TokenType["Number"] = 5] = "Number";
	})(exports.TokenType || (exports.TokenType = {}));
	var TokenType = exports.TokenType;
	var Lexer = (function () {
	    function Lexer() {
	    }
	    Lexer.prototype.tokenize = function (text) {
	        var scanner = new _Scanner(text);
	        var tokens = [];
	        var token = scanner.scanToken();
	        while (token != null) {
	            tokens.push(token);
	            token = scanner.scanToken();
	        }
	        return tokens;
	    };
	    Lexer = __decorate([
	        decorators_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], Lexer);
	    return Lexer;
	})();
	exports.Lexer = Lexer;
	var Token = (function () {
	    function Token(index, type, numValue, strValue) {
	        this.index = index;
	        this.type = type;
	        this.numValue = numValue;
	        this.strValue = strValue;
	    }
	    Token.prototype.isCharacter = function (code) {
	        return (this.type == TokenType.Character && this.numValue == code);
	    };
	    Token.prototype.isNumber = function () { return (this.type == TokenType.Number); };
	    Token.prototype.isString = function () { return (this.type == TokenType.String); };
	    Token.prototype.isOperator = function (operater) {
	        return (this.type == TokenType.Operator && this.strValue == operater);
	    };
	    Token.prototype.isIdentifier = function () { return (this.type == TokenType.Identifier); };
	    Token.prototype.isKeyword = function () { return (this.type == TokenType.Keyword); };
	    Token.prototype.isKeywordVar = function () { return (this.type == TokenType.Keyword && this.strValue == "var"); };
	    Token.prototype.isKeywordNull = function () { return (this.type == TokenType.Keyword && this.strValue == "null"); };
	    Token.prototype.isKeywordUndefined = function () {
	        return (this.type == TokenType.Keyword && this.strValue == "undefined");
	    };
	    Token.prototype.isKeywordTrue = function () { return (this.type == TokenType.Keyword && this.strValue == "true"); };
	    Token.prototype.isKeywordIf = function () { return (this.type == TokenType.Keyword && this.strValue == "if"); };
	    Token.prototype.isKeywordElse = function () { return (this.type == TokenType.Keyword && this.strValue == "else"); };
	    Token.prototype.isKeywordFalse = function () { return (this.type == TokenType.Keyword && this.strValue == "false"); };
	    Token.prototype.toNumber = function () {
	        // -1 instead of NULL ok?
	        return (this.type == TokenType.Number) ? this.numValue : -1;
	    };
	    Token.prototype.toString = function () {
	        switch (this.type) {
	            case TokenType.Character:
	            case TokenType.Identifier:
	            case TokenType.Keyword:
	            case TokenType.Operator:
	            case TokenType.String:
	                return this.strValue;
	            case TokenType.Number:
	                return this.numValue.toString();
	            default:
	                return null;
	        }
	    };
	    return Token;
	})();
	exports.Token = Token;
	function newCharacterToken(index, code) {
	    return new Token(index, TokenType.Character, code, lang_1.StringWrapper.fromCharCode(code));
	}
	function newIdentifierToken(index, text) {
	    return new Token(index, TokenType.Identifier, 0, text);
	}
	function newKeywordToken(index, text) {
	    return new Token(index, TokenType.Keyword, 0, text);
	}
	function newOperatorToken(index, text) {
	    return new Token(index, TokenType.Operator, 0, text);
	}
	function newStringToken(index, text) {
	    return new Token(index, TokenType.String, 0, text);
	}
	function newNumberToken(index, n) {
	    return new Token(index, TokenType.Number, n, "");
	}
	exports.EOF = new Token(-1, TokenType.Character, 0, "");
	exports.$EOF = 0;
	exports.$TAB = 9;
	exports.$LF = 10;
	exports.$VTAB = 11;
	exports.$FF = 12;
	exports.$CR = 13;
	exports.$SPACE = 32;
	exports.$BANG = 33;
	exports.$DQ = 34;
	exports.$HASH = 35;
	exports.$$ = 36;
	exports.$PERCENT = 37;
	exports.$AMPERSAND = 38;
	exports.$SQ = 39;
	exports.$LPAREN = 40;
	exports.$RPAREN = 41;
	exports.$STAR = 42;
	exports.$PLUS = 43;
	exports.$COMMA = 44;
	exports.$MINUS = 45;
	exports.$PERIOD = 46;
	exports.$SLASH = 47;
	exports.$COLON = 58;
	exports.$SEMICOLON = 59;
	exports.$LT = 60;
	exports.$EQ = 61;
	exports.$GT = 62;
	exports.$QUESTION = 63;
	var $0 = 48;
	var $9 = 57;
	var $A = 65, $E = 69, $Z = 90;
	exports.$LBRACKET = 91;
	exports.$BACKSLASH = 92;
	exports.$RBRACKET = 93;
	var $CARET = 94;
	var $_ = 95;
	var $a = 97, $e = 101, $f = 102, $n = 110, $r = 114, $t = 116, $u = 117, $v = 118, $z = 122;
	exports.$LBRACE = 123;
	exports.$BAR = 124;
	exports.$RBRACE = 125;
	var $NBSP = 160;
	var ScannerError = (function (_super) {
	    __extends(ScannerError, _super);
	    function ScannerError(message) {
	        _super.call(this);
	        this.message = message;
	    }
	    ScannerError.prototype.toString = function () { return this.message; };
	    return ScannerError;
	})(exceptions_1.BaseException);
	exports.ScannerError = ScannerError;
	var _Scanner = (function () {
	    function _Scanner(input) {
	        this.input = input;
	        this.peek = 0;
	        this.index = -1;
	        this.length = input.length;
	        this.advance();
	    }
	    _Scanner.prototype.advance = function () {
	        this.peek =
	            ++this.index >= this.length ? exports.$EOF : lang_1.StringWrapper.charCodeAt(this.input, this.index);
	    };
	    _Scanner.prototype.scanToken = function () {
	        var input = this.input, length = this.length, peek = this.peek, index = this.index;
	        // Skip whitespace.
	        while (peek <= exports.$SPACE) {
	            if (++index >= length) {
	                peek = exports.$EOF;
	                break;
	            }
	            else {
	                peek = lang_1.StringWrapper.charCodeAt(input, index);
	            }
	        }
	        this.peek = peek;
	        this.index = index;
	        if (index >= length) {
	            return null;
	        }
	        // Handle identifiers and numbers.
	        if (isIdentifierStart(peek))
	            return this.scanIdentifier();
	        if (isDigit(peek))
	            return this.scanNumber(index);
	        var start = index;
	        switch (peek) {
	            case exports.$PERIOD:
	                this.advance();
	                return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, exports.$PERIOD);
	            case exports.$LPAREN:
	            case exports.$RPAREN:
	            case exports.$LBRACE:
	            case exports.$RBRACE:
	            case exports.$LBRACKET:
	            case exports.$RBRACKET:
	            case exports.$COMMA:
	            case exports.$COLON:
	            case exports.$SEMICOLON:
	                return this.scanCharacter(start, peek);
	            case exports.$SQ:
	            case exports.$DQ:
	                return this.scanString();
	            case exports.$HASH:
	            case exports.$PLUS:
	            case exports.$MINUS:
	            case exports.$STAR:
	            case exports.$SLASH:
	            case exports.$PERCENT:
	            case $CARET:
	                return this.scanOperator(start, lang_1.StringWrapper.fromCharCode(peek));
	            case exports.$QUESTION:
	                return this.scanComplexOperator(start, '?', exports.$PERIOD, '.');
	            case exports.$LT:
	            case exports.$GT:
	                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=');
	            case exports.$BANG:
	            case exports.$EQ:
	                return this.scanComplexOperator(start, lang_1.StringWrapper.fromCharCode(peek), exports.$EQ, '=', exports.$EQ, '=');
	            case exports.$AMPERSAND:
	                return this.scanComplexOperator(start, '&', exports.$AMPERSAND, '&');
	            case exports.$BAR:
	                return this.scanComplexOperator(start, '|', exports.$BAR, '|');
	            case $NBSP:
	                while (isWhitespace(this.peek))
	                    this.advance();
	                return this.scanToken();
	        }
	        this.error("Unexpected character [" + lang_1.StringWrapper.fromCharCode(peek) + "]", 0);
	        return null;
	    };
	    _Scanner.prototype.scanCharacter = function (start, code) {
	        assert(this.peek == code);
	        this.advance();
	        return newCharacterToken(start, code);
	    };
	    _Scanner.prototype.scanOperator = function (start, str) {
	        assert(this.peek == lang_1.StringWrapper.charCodeAt(str, 0));
	        assert(collection_1.SetWrapper.has(OPERATORS, str));
	        this.advance();
	        return newOperatorToken(start, str);
	    };
	    /**
	     * Tokenize a 2/3 char long operator
	     *
	     * @param start start index in the expression
	     * @param one first symbol (always part of the operator)
	     * @param twoCode code point for the second symbol
	     * @param two second symbol (part of the operator when the second code point matches)
	     * @param threeCode code point for the third symbol
	     * @param three third symbol (part of the operator when provided and matches source expression)
	     * @returns {Token}
	     */
	    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {
	        assert(this.peek == lang_1.StringWrapper.charCodeAt(one, 0));
	        this.advance();
	        var str = one;
	        if (this.peek == twoCode) {
	            this.advance();
	            str += two;
	        }
	        if (lang_1.isPresent(threeCode) && this.peek == threeCode) {
	            this.advance();
	            str += three;
	        }
	        assert(collection_1.SetWrapper.has(OPERATORS, str));
	        return newOperatorToken(start, str);
	    };
	    _Scanner.prototype.scanIdentifier = function () {
	        assert(isIdentifierStart(this.peek));
	        var start = this.index;
	        this.advance();
	        while (isIdentifierPart(this.peek))
	            this.advance();
	        var str = this.input.substring(start, this.index);
	        if (collection_1.SetWrapper.has(KEYWORDS, str)) {
	            return newKeywordToken(start, str);
	        }
	        else {
	            return newIdentifierToken(start, str);
	        }
	    };
	    _Scanner.prototype.scanNumber = function (start) {
	        assert(isDigit(this.peek));
	        var simple = (this.index === start);
	        this.advance(); // Skip initial digit.
	        while (true) {
	            if (isDigit(this.peek)) {
	            }
	            else if (this.peek == exports.$PERIOD) {
	                simple = false;
	            }
	            else if (isExponentStart(this.peek)) {
	                this.advance();
	                if (isExponentSign(this.peek))
	                    this.advance();
	                if (!isDigit(this.peek))
	                    this.error('Invalid exponent', -1);
	                simple = false;
	            }
	            else {
	                break;
	            }
	            this.advance();
	        }
	        var str = this.input.substring(start, this.index);
	        // TODO
	        var value = simple ? lang_1.NumberWrapper.parseIntAutoRadix(str) : lang_1.NumberWrapper.parseFloat(str);
	        return newNumberToken(start, value);
	    };
	    _Scanner.prototype.scanString = function () {
	        assert(this.peek == exports.$SQ || this.peek == exports.$DQ);
	        var start = this.index;
	        var quote = this.peek;
	        this.advance(); // Skip initial quote.
	        var buffer;
	        var marker = this.index;
	        var input = this.input;
	        while (this.peek != quote) {
	            if (this.peek == exports.$BACKSLASH) {
	                if (buffer == null)
	                    buffer = new lang_1.StringJoiner();
	                buffer.add(input.substring(marker, this.index));
	                this.advance();
	                var unescapedCode;
	                if (this.peek == $u) {
	                    // 4 character hex code for unicode character.
	                    var hex = input.substring(this.index + 1, this.index + 5);
	                    try {
	                        unescapedCode = lang_1.NumberWrapper.parseInt(hex, 16);
	                    }
	                    catch (e) {
	                        this.error("Invalid unicode escape [\\u" + hex + "]", 0);
	                    }
	                    for (var i = 0; i < 5; i++) {
	                        this.advance();
	                    }
	                }
	                else {
	                    unescapedCode = unescape(this.peek);
	                    this.advance();
	                }
	                buffer.add(lang_1.StringWrapper.fromCharCode(unescapedCode));
	                marker = this.index;
	            }
	            else if (this.peek == exports.$EOF) {
	                this.error('Unterminated quote', 0);
	            }
	            else {
	                this.advance();
	            }
	        }
	        var last = input.substring(marker, this.index);
	        this.advance(); // Skip terminating quote.
	        // Compute the unescaped string value.
	        var unescaped = last;
	        if (buffer != null) {
	            buffer.add(last);
	            unescaped = buffer.toString();
	        }
	        return newStringToken(start, unescaped);
	    };
	    _Scanner.prototype.error = function (message, offset) {
	        var position = this.index + offset;
	        throw new ScannerError("Lexer Error: " + message + " at column " + position + " in expression [" + this.input + "]");
	    };
	    return _Scanner;
	})();
	function isWhitespace(code) {
	    return (code >= exports.$TAB && code <= exports.$SPACE) || (code == $NBSP);
	}
	function isIdentifierStart(code) {
	    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || (code == $_) || (code == exports.$$);
	}
	function isIdentifierPart(code) {
	    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) || ($0 <= code && code <= $9) ||
	        (code == $_) || (code == exports.$$);
	}
	function isDigit(code) {
	    return $0 <= code && code <= $9;
	}
	function isExponentStart(code) {
	    return code == $e || code == $E;
	}
	function isExponentSign(code) {
	    return code == exports.$MINUS || code == exports.$PLUS;
	}
	function unescape(code) {
	    switch (code) {
	        case $n:
	            return exports.$LF;
	        case $f:
	            return exports.$FF;
	        case $r:
	            return exports.$CR;
	        case $t:
	            return exports.$TAB;
	        case $v:
	            return exports.$VTAB;
	        default:
	            return code;
	    }
	}
	var OPERATORS = collection_1.SetWrapper.createFromList([
	    '+',
	    '-',
	    '*',
	    '/',
	    '%',
	    '^',
	    '=',
	    '==',
	    '!=',
	    '===',
	    '!==',
	    '<',
	    '>',
	    '<=',
	    '>=',
	    '&&',
	    '||',
	    '&',
	    '|',
	    '!',
	    '?',
	    '#',
	    '?.'
	]);
	var KEYWORDS = collection_1.SetWrapper.createFromList(['var', 'null', 'undefined', 'true', 'false', 'if', 'else']);
	//# sourceMappingURL=lexer.js.map

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var decorators_1 = __webpack_require__(162);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var lexer_1 = __webpack_require__(208);
	var reflection_1 = __webpack_require__(170);
	var ast_1 = __webpack_require__(198);
	var _implicitReceiver = new ast_1.ImplicitReceiver();
	// TODO(tbosch): Cannot make this const/final right now because of the transpiler...
	var INTERPOLATION_REGEXP = /\{\{(.*?)\}\}/g;
	var ParseException = (function (_super) {
	    __extends(ParseException, _super);
	    function ParseException(message, input, errLocation, ctxLocation) {
	        _super.call(this, "Parser Error: " + message + " " + errLocation + " [" + input + "] in " + ctxLocation);
	    }
	    return ParseException;
	})(exceptions_1.BaseException);
	var Parser = (function () {
	    function Parser(_lexer, providedReflector) {
	        if (providedReflector === void 0) { providedReflector = null; }
	        this._lexer = _lexer;
	        this._reflector = lang_1.isPresent(providedReflector) ? providedReflector : reflection_1.reflector;
	    }
	    Parser.prototype.parseAction = function (input, location) {
	        this._checkNoInterpolation(input, location);
	        var tokens = this._lexer.tokenize(input);
	        var ast = new _ParseAST(input, location, tokens, this._reflector, true).parseChain();
	        return new ast_1.ASTWithSource(ast, input, location);
	    };
	    Parser.prototype.parseBinding = function (input, location) {
	        this._checkNoInterpolation(input, location);
	        var tokens = this._lexer.tokenize(input);
	        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
	        return new ast_1.ASTWithSource(ast, input, location);
	    };
	    Parser.prototype.parseSimpleBinding = function (input, location) {
	        this._checkNoInterpolation(input, location);
	        var tokens = this._lexer.tokenize(input);
	        var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseSimpleBinding();
	        return new ast_1.ASTWithSource(ast, input, location);
	    };
	    Parser.prototype.parseTemplateBindings = function (input, location) {
	        var tokens = this._lexer.tokenize(input);
	        return new _ParseAST(input, location, tokens, this._reflector, false).parseTemplateBindings();
	    };
	    Parser.prototype.parseInterpolation = function (input, location) {
	        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
	        if (parts.length <= 1) {
	            return null;
	        }
	        var strings = [];
	        var expressions = [];
	        for (var i = 0; i < parts.length; i++) {
	            var part = parts[i];
	            if (i % 2 === 0) {
	                // fixed string
	                strings.push(part);
	            }
	            else if (part.trim().length > 0) {
	                var tokens = this._lexer.tokenize(part);
	                var ast = new _ParseAST(input, location, tokens, this._reflector, false).parseChain();
	                expressions.push(ast);
	            }
	            else {
	                throw new ParseException('Blank expressions are not allowed in interpolated strings', input, "at column " + this._findInterpolationErrorColumn(parts, i) + " in", location);
	            }
	        }
	        return new ast_1.ASTWithSource(new ast_1.Interpolation(strings, expressions), input, location);
	    };
	    Parser.prototype.wrapLiteralPrimitive = function (input, location) {
	        return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(input), input, location);
	    };
	    Parser.prototype._checkNoInterpolation = function (input, location) {
	        var parts = lang_1.StringWrapper.split(input, INTERPOLATION_REGEXP);
	        if (parts.length > 1) {
	            throw new ParseException('Got interpolation ({{}}) where expression was expected', input, "at column " + this._findInterpolationErrorColumn(parts, 1) + " in", location);
	        }
	    };
	    Parser.prototype._findInterpolationErrorColumn = function (parts, partInErrIdx) {
	        var errLocation = '';
	        for (var j = 0; j < partInErrIdx; j++) {
	            errLocation += j % 2 === 0 ? parts[j] : "{{" + parts[j] + "}}";
	        }
	        return errLocation.length;
	    };
	    Parser = __decorate([
	        decorators_1.Injectable(), 
	        __metadata('design:paramtypes', [lexer_1.Lexer, reflection_1.Reflector])
	    ], Parser);
	    return Parser;
	})();
	exports.Parser = Parser;
	var _ParseAST = (function () {
	    function _ParseAST(input, location, tokens, reflector, parseAction) {
	        this.input = input;
	        this.location = location;
	        this.tokens = tokens;
	        this.reflector = reflector;
	        this.parseAction = parseAction;
	        this.index = 0;
	    }
	    _ParseAST.prototype.peek = function (offset) {
	        var i = this.index + offset;
	        return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;
	    };
	    Object.defineProperty(_ParseAST.prototype, "next", {
	        get: function () { return this.peek(0); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(_ParseAST.prototype, "inputIndex", {
	        get: function () {
	            return (this.index < this.tokens.length) ? this.next.index : this.input.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    _ParseAST.prototype.advance = function () { this.index++; };
	    _ParseAST.prototype.optionalCharacter = function (code) {
	        if (this.next.isCharacter(code)) {
	            this.advance();
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    _ParseAST.prototype.optionalKeywordVar = function () {
	        if (this.peekKeywordVar()) {
	            this.advance();
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    _ParseAST.prototype.peekKeywordVar = function () { return this.next.isKeywordVar() || this.next.isOperator('#'); };
	    _ParseAST.prototype.expectCharacter = function (code) {
	        if (this.optionalCharacter(code))
	            return;
	        this.error("Missing expected " + lang_1.StringWrapper.fromCharCode(code));
	    };
	    _ParseAST.prototype.optionalOperator = function (op) {
	        if (this.next.isOperator(op)) {
	            this.advance();
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    _ParseAST.prototype.expectOperator = function (operator) {
	        if (this.optionalOperator(operator))
	            return;
	        this.error("Missing expected operator " + operator);
	    };
	    _ParseAST.prototype.expectIdentifierOrKeyword = function () {
	        var n = this.next;
	        if (!n.isIdentifier() && !n.isKeyword()) {
	            this.error("Unexpected token " + n + ", expected identifier or keyword");
	        }
	        this.advance();
	        return n.toString();
	    };
	    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {
	        var n = this.next;
	        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {
	            this.error("Unexpected token " + n + ", expected identifier, keyword, or string");
	        }
	        this.advance();
	        return n.toString();
	    };
	    _ParseAST.prototype.parseChain = function () {
	        var exprs = [];
	        while (this.index < this.tokens.length) {
	            var expr = this.parsePipe();
	            exprs.push(expr);
	            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
	                if (!this.parseAction) {
	                    this.error("Binding expression cannot contain chained expression");
	                }
	                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
	                } // read all semicolons
	            }
	            else if (this.index < this.tokens.length) {
	                this.error("Unexpected token '" + this.next + "'");
	            }
	        }
	        if (exprs.length == 0)
	            return new ast_1.EmptyExpr();
	        if (exprs.length == 1)
	            return exprs[0];
	        return new ast_1.Chain(exprs);
	    };
	    _ParseAST.prototype.parseSimpleBinding = function () {
	        var ast = this.parseChain();
	        if (!SimpleExpressionChecker.check(ast)) {
	            this.error("Simple binding expression can only contain field access and constants'");
	        }
	        return ast;
	    };
	    _ParseAST.prototype.parsePipe = function () {
	        var result = this.parseExpression();
	        if (this.optionalOperator("|")) {
	            if (this.parseAction) {
	                this.error("Cannot have a pipe in an action expression");
	            }
	            do {
	                var name = this.expectIdentifierOrKeyword();
	                var args = [];
	                while (this.optionalCharacter(lexer_1.$COLON)) {
	                    args.push(this.parsePipe());
	                }
	                result = new ast_1.BindingPipe(result, name, args);
	            } while (this.optionalOperator("|"));
	        }
	        return result;
	    };
	    _ParseAST.prototype.parseExpression = function () { return this.parseConditional(); };
	    _ParseAST.prototype.parseConditional = function () {
	        var start = this.inputIndex;
	        var result = this.parseLogicalOr();
	        if (this.optionalOperator('?')) {
	            var yes = this.parsePipe();
	            if (!this.optionalCharacter(lexer_1.$COLON)) {
	                var end = this.inputIndex;
	                var expression = this.input.substring(start, end);
	                this.error("Conditional expression " + expression + " requires all 3 expressions");
	            }
	            var no = this.parsePipe();
	            return new ast_1.Conditional(result, yes, no);
	        }
	        else {
	            return result;
	        }
	    };
	    _ParseAST.prototype.parseLogicalOr = function () {
	        // '||'
	        var result = this.parseLogicalAnd();
	        while (this.optionalOperator('||')) {
	            result = new ast_1.Binary('||', result, this.parseLogicalAnd());
	        }
	        return result;
	    };
	    _ParseAST.prototype.parseLogicalAnd = function () {
	        // '&&'
	        var result = this.parseEquality();
	        while (this.optionalOperator('&&')) {
	            result = new ast_1.Binary('&&', result, this.parseEquality());
	        }
	        return result;
	    };
	    _ParseAST.prototype.parseEquality = function () {
	        // '==','!=','===','!=='
	        var result = this.parseRelational();
	        while (true) {
	            if (this.optionalOperator('==')) {
	                result = new ast_1.Binary('==', result, this.parseRelational());
	            }
	            else if (this.optionalOperator('===')) {
	                result = new ast_1.Binary('===', result, this.parseRelational());
	            }
	            else if (this.optionalOperator('!=')) {
	                result = new ast_1.Binary('!=', result, this.parseRelational());
	            }
	            else if (this.optionalOperator('!==')) {
	                result = new ast_1.Binary('!==', result, this.parseRelational());
	            }
	            else {
	                return result;
	            }
	        }
	    };
	    _ParseAST.prototype.parseRelational = function () {
	        // '<', '>', '<=', '>='
	        var result = this.parseAdditive();
	        while (true) {
	            if (this.optionalOperator('<')) {
	                result = new ast_1.Binary('<', result, this.parseAdditive());
	            }
	            else if (this.optionalOperator('>')) {
	                result = new ast_1.Binary('>', result, this.parseAdditive());
	            }
	            else if (this.optionalOperator('<=')) {
	                result = new ast_1.Binary('<=', result, this.parseAdditive());
	            }
	            else if (this.optionalOperator('>=')) {
	                result = new ast_1.Binary('>=', result, this.parseAdditive());
	            }
	            else {
	                return result;
	            }
	        }
	    };
	    _ParseAST.prototype.parseAdditive = function () {
	        // '+', '-'
	        var result = this.parseMultiplicative();
	        while (true) {
	            if (this.optionalOperator('+')) {
	                result = new ast_1.Binary('+', result, this.parseMultiplicative());
	            }
	            else if (this.optionalOperator('-')) {
	                result = new ast_1.Binary('-', result, this.parseMultiplicative());
	            }
	            else {
	                return result;
	            }
	        }
	    };
	    _ParseAST.prototype.parseMultiplicative = function () {
	        // '*', '%', '/'
	        var result = this.parsePrefix();
	        while (true) {
	            if (this.optionalOperator('*')) {
	                result = new ast_1.Binary('*', result, this.parsePrefix());
	            }
	            else if (this.optionalOperator('%')) {
	                result = new ast_1.Binary('%', result, this.parsePrefix());
	            }
	            else if (this.optionalOperator('/')) {
	                result = new ast_1.Binary('/', result, this.parsePrefix());
	            }
	            else {
	                return result;
	            }
	        }
	    };
	    _ParseAST.prototype.parsePrefix = function () {
	        if (this.optionalOperator('+')) {
	            return this.parsePrefix();
	        }
	        else if (this.optionalOperator('-')) {
	            return new ast_1.Binary('-', new ast_1.LiteralPrimitive(0), this.parsePrefix());
	        }
	        else if (this.optionalOperator('!')) {
	            return new ast_1.PrefixNot(this.parsePrefix());
	        }
	        else {
	            return this.parseCallChain();
	        }
	    };
	    _ParseAST.prototype.parseCallChain = function () {
	        var result = this.parsePrimary();
	        while (true) {
	            if (this.optionalCharacter(lexer_1.$PERIOD)) {
	                result = this.parseAccessMemberOrMethodCall(result, false);
	            }
	            else if (this.optionalOperator('?.')) {
	                result = this.parseAccessMemberOrMethodCall(result, true);
	            }
	            else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
	                var key = this.parsePipe();
	                this.expectCharacter(lexer_1.$RBRACKET);
	                if (this.optionalOperator("=")) {
	                    var value = this.parseConditional();
	                    result = new ast_1.KeyedWrite(result, key, value);
	                }
	                else {
	                    result = new ast_1.KeyedRead(result, key);
	                }
	            }
	            else if (this.optionalCharacter(lexer_1.$LPAREN)) {
	                var args = this.parseCallArguments();
	                this.expectCharacter(lexer_1.$RPAREN);
	                result = new ast_1.FunctionCall(result, args);
	            }
	            else {
	                return result;
	            }
	        }
	    };
	    _ParseAST.prototype.parsePrimary = function () {
	        if (this.optionalCharacter(lexer_1.$LPAREN)) {
	            var result = this.parsePipe();
	            this.expectCharacter(lexer_1.$RPAREN);
	            return result;
	        }
	        else if (this.next.isKeywordNull() || this.next.isKeywordUndefined()) {
	            this.advance();
	            return new ast_1.LiteralPrimitive(null);
	        }
	        else if (this.next.isKeywordTrue()) {
	            this.advance();
	            return new ast_1.LiteralPrimitive(true);
	        }
	        else if (this.next.isKeywordFalse()) {
	            this.advance();
	            return new ast_1.LiteralPrimitive(false);
	        }
	        else if (this.parseAction && this.next.isKeywordIf()) {
	            this.advance();
	            this.expectCharacter(lexer_1.$LPAREN);
	            var condition = this.parseExpression();
	            this.expectCharacter(lexer_1.$RPAREN);
	            var ifExp = this.parseExpressionOrBlock();
	            var elseExp;
	            if (this.next.isKeywordElse()) {
	                this.advance();
	                elseExp = this.parseExpressionOrBlock();
	            }
	            return new ast_1.If(condition, ifExp, elseExp);
	        }
	        else if (this.optionalCharacter(lexer_1.$LBRACKET)) {
	            var elements = this.parseExpressionList(lexer_1.$RBRACKET);
	            this.expectCharacter(lexer_1.$RBRACKET);
	            return new ast_1.LiteralArray(elements);
	        }
	        else if (this.next.isCharacter(lexer_1.$LBRACE)) {
	            return this.parseLiteralMap();
	        }
	        else if (this.next.isIdentifier()) {
	            return this.parseAccessMemberOrMethodCall(_implicitReceiver, false);
	        }
	        else if (this.next.isNumber()) {
	            var value = this.next.toNumber();
	            this.advance();
	            return new ast_1.LiteralPrimitive(value);
	        }
	        else if (this.next.isString()) {
	            var literalValue = this.next.toString();
	            this.advance();
	            return new ast_1.LiteralPrimitive(literalValue);
	        }
	        else if (this.index >= this.tokens.length) {
	            this.error("Unexpected end of expression: " + this.input);
	        }
	        else {
	            this.error("Unexpected token " + this.next);
	        }
	        // error() throws, so we don't reach here.
	        throw new exceptions_1.BaseException("Fell through all cases in parsePrimary");
	    };
	    _ParseAST.prototype.parseExpressionList = function (terminator) {
	        var result = [];
	        if (!this.next.isCharacter(terminator)) {
	            do {
	                result.push(this.parsePipe());
	            } while (this.optionalCharacter(lexer_1.$COMMA));
	        }
	        return result;
	    };
	    _ParseAST.prototype.parseLiteralMap = function () {
	        var keys = [];
	        var values = [];
	        this.expectCharacter(lexer_1.$LBRACE);
	        if (!this.optionalCharacter(lexer_1.$RBRACE)) {
	            do {
	                var key = this.expectIdentifierOrKeywordOrString();
	                keys.push(key);
	                this.expectCharacter(lexer_1.$COLON);
	                values.push(this.parsePipe());
	            } while (this.optionalCharacter(lexer_1.$COMMA));
	            this.expectCharacter(lexer_1.$RBRACE);
	        }
	        return new ast_1.LiteralMap(keys, values);
	    };
	    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, isSafe) {
	        if (isSafe === void 0) { isSafe = false; }
	        var id = this.expectIdentifierOrKeyword();
	        if (this.optionalCharacter(lexer_1.$LPAREN)) {
	            var args = this.parseCallArguments();
	            this.expectCharacter(lexer_1.$RPAREN);
	            var fn = this.reflector.method(id);
	            return isSafe ? new ast_1.SafeMethodCall(receiver, id, fn, args) :
	                new ast_1.MethodCall(receiver, id, fn, args);
	        }
	        else {
	            if (isSafe) {
	                if (this.optionalOperator("=")) {
	                    this.error("The '?.' operator cannot be used in the assignment");
	                }
	                else {
	                    return new ast_1.SafePropertyRead(receiver, id, this.reflector.getter(id));
	                }
	            }
	            else {
	                if (this.optionalOperator("=")) {
	                    if (!this.parseAction) {
	                        this.error("Bindings cannot contain assignments");
	                    }
	                    var value = this.parseConditional();
	                    return new ast_1.PropertyWrite(receiver, id, this.reflector.setter(id), value);
	                }
	                else {
	                    return new ast_1.PropertyRead(receiver, id, this.reflector.getter(id));
	                }
	            }
	        }
	        return null;
	    };
	    _ParseAST.prototype.parseCallArguments = function () {
	        if (this.next.isCharacter(lexer_1.$RPAREN))
	            return [];
	        var positionals = [];
	        do {
	            positionals.push(this.parsePipe());
	        } while (this.optionalCharacter(lexer_1.$COMMA));
	        return positionals;
	    };
	    _ParseAST.prototype.parseExpressionOrBlock = function () {
	        if (this.optionalCharacter(lexer_1.$LBRACE)) {
	            var block = this.parseBlockContent();
	            this.expectCharacter(lexer_1.$RBRACE);
	            return block;
	        }
	        return this.parseExpression();
	    };
	    _ParseAST.prototype.parseBlockContent = function () {
	        if (!this.parseAction) {
	            this.error("Binding expression cannot contain chained expression");
	        }
	        var exprs = [];
	        while (this.index < this.tokens.length && !this.next.isCharacter(lexer_1.$RBRACE)) {
	            var expr = this.parseExpression();
	            exprs.push(expr);
	            if (this.optionalCharacter(lexer_1.$SEMICOLON)) {
	                while (this.optionalCharacter(lexer_1.$SEMICOLON)) {
	                } // read all semicolons
	            }
	        }
	        if (exprs.length == 0)
	            return new ast_1.EmptyExpr();
	        if (exprs.length == 1)
	            return exprs[0];
	        return new ast_1.Chain(exprs);
	    };
	    /**
	     * An identifier, a keyword, a string with an optional `-` inbetween.
	     */
	    _ParseAST.prototype.expectTemplateBindingKey = function () {
	        var result = '';
	        var operatorFound = false;
	        do {
	            result += this.expectIdentifierOrKeywordOrString();
	            operatorFound = this.optionalOperator('-');
	            if (operatorFound) {
	                result += '-';
	            }
	        } while (operatorFound);
	        return result.toString();
	    };
	    _ParseAST.prototype.parseTemplateBindings = function () {
	        var bindings = [];
	        var prefix = null;
	        while (this.index < this.tokens.length) {
	            var keyIsVar = this.optionalKeywordVar();
	            var key = this.expectTemplateBindingKey();
	            if (!keyIsVar) {
	                if (prefix == null) {
	                    prefix = key;
	                }
	                else {
	                    key = prefix + '-' + key;
	                }
	            }
	            this.optionalCharacter(lexer_1.$COLON);
	            var name = null;
	            var expression = null;
	            if (keyIsVar) {
	                if (this.optionalOperator("=")) {
	                    name = this.expectTemplateBindingKey();
	                }
	                else {
	                    name = '\$implicit';
	                }
	            }
	            else if (this.next !== lexer_1.EOF && !this.peekKeywordVar()) {
	                var start = this.inputIndex;
	                var ast = this.parsePipe();
	                var source = this.input.substring(start, this.inputIndex);
	                expression = new ast_1.ASTWithSource(ast, source, this.location);
	            }
	            bindings.push(new ast_1.TemplateBinding(key, keyIsVar, name, expression));
	            if (!this.optionalCharacter(lexer_1.$SEMICOLON)) {
	                this.optionalCharacter(lexer_1.$COMMA);
	            }
	        }
	        return bindings;
	    };
	    _ParseAST.prototype.error = function (message, index) {
	        if (index === void 0) { index = null; }
	        if (lang_1.isBlank(index))
	            index = this.index;
	        var location = (index < this.tokens.length) ? "at column " + (this.tokens[index].index + 1) + " in" :
	            "at the end of the expression";
	        throw new ParseException(message, this.input, location, this.location);
	    };
	    return _ParseAST;
	})();
	exports._ParseAST = _ParseAST;
	var SimpleExpressionChecker = (function () {
	    function SimpleExpressionChecker() {
	        this.simple = true;
	    }
	    SimpleExpressionChecker.check = function (ast) {
	        var s = new SimpleExpressionChecker();
	        ast.visit(s);
	        return s.simple;
	    };
	    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast) { };
	    SimpleExpressionChecker.prototype.visitInterpolation = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast) { };
	    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast) { };
	    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitMethodCall = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast) { this.visitAll(ast.expressions); };
	    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast) { this.visitAll(ast.values); };
	    SimpleExpressionChecker.prototype.visitBinary = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitConditional = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitPipe = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitAll = function (asts) {
	        var res = collection_1.ListWrapper.createFixedSize(asts.length);
	        for (var i = 0; i < asts.length; ++i) {
	            res[i] = asts[i].visit(this);
	        }
	        return res;
	    };
	    SimpleExpressionChecker.prototype.visitChain = function (ast) { this.simple = false; };
	    SimpleExpressionChecker.prototype.visitIf = function (ast) { this.simple = false; };
	    return SimpleExpressionChecker;
	})();
	//# sourceMappingURL=parser.js.map

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var Locals = (function () {
	    function Locals(parent, current) {
	        this.parent = parent;
	        this.current = current;
	    }
	    Locals.prototype.contains = function (name) {
	        if (this.current.has(name)) {
	            return true;
	        }
	        if (lang_1.isPresent(this.parent)) {
	            return this.parent.contains(name);
	        }
	        return false;
	    };
	    Locals.prototype.get = function (name) {
	        if (this.current.has(name)) {
	            return this.current.get(name);
	        }
	        if (lang_1.isPresent(this.parent)) {
	            return this.parent.get(name);
	        }
	        throw new exceptions_1.BaseException("Cannot find '" + name + "'");
	    };
	    Locals.prototype.set = function (name, value) {
	        // TODO(rado): consider removing this check if we can guarantee this is not
	        // exposed to the public API.
	        // TODO: vsavkin maybe it should check only the local map
	        if (this.current.has(name)) {
	            this.current.set(name, value);
	        }
	        else {
	            throw new exceptions_1.BaseException("Setting of new keys post-construction is not supported. Key: " + name + ".");
	        }
	    };
	    Locals.prototype.clearValues = function () { collection_1.MapWrapper.clearValues(this.current); };
	    return Locals;
	})();
	exports.Locals = Locals;
	//# sourceMappingURL=locals.js.map

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var api_1 = __webpack_require__(212);
	exports.ViewEncapsulation = api_1.ViewEncapsulation;
	/**
	 * Declares the available HTML templates for an application.
	 *
	 * Each angular component requires a single `@Component` and at least one `@View` annotation. The
	 * `@View` annotation specifies the HTML template to use, and lists the directives that are active
	 * within the template.
	 *
	 * When a component is instantiated, the template is loaded into the component's shadow root, and
	 * the expressions and statements in the template are evaluated against the component.
	 *
	 * For details on the `@Component` annotation, see {@link ComponentMetadata}.
	 *
	 * ## Example
	 *
	 * ```
	 * @Component({
	 *   selector: 'greet'
	 * })
	 * @View({
	 *   template: 'Hello {{name}}!',
	 *   directives: [GreetUser, Bold]
	 * })
	 * class Greet {
	 *   name: string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 * ```
	 */
	var ViewMetadata = (function () {
	    function ViewMetadata(_a) {
	        var _b = _a === void 0 ? {} : _a, templateUrl = _b.templateUrl, template = _b.template, directives = _b.directives, pipes = _b.pipes, encapsulation = _b.encapsulation, styles = _b.styles, styleUrls = _b.styleUrls;
	        this.templateUrl = templateUrl;
	        this.template = template;
	        this.styleUrls = styleUrls;
	        this.styles = styles;
	        this.directives = directives;
	        this.pipes = pipes;
	        this.encapsulation = encapsulation;
	    }
	    ViewMetadata = __decorate([
	        lang_1.CONST(), 
	        __metadata('design:paramtypes', [Object])
	    ], ViewMetadata);
	    return ViewMetadata;
	})();
	exports.ViewMetadata = ViewMetadata;
	//# sourceMappingURL=view.js.map

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	/**
	 * General notes:
	 *
	 * The methods for creating / destroying views in this API are used in the AppViewHydrator
	 * and RenderViewHydrator as well.
	 *
	 * We are already parsing expressions on the render side:
	 * - this makes the ElementBinders more compact
	 *   (e.g. no need to distinguish interpolations from regular expressions from literals)
	 * - allows to retrieve which properties should be accessed from the event
	 *   by looking at the expression
	 * - we need the parse at least for the `template` attribute to match
	 *   directives in it
	 * - render compiler is not on the critical path as
	 *   its output will be stored in precompiled templates.
	 */
	var EventBinding = (function () {
	    function EventBinding(fullName, source) {
	        this.fullName = fullName;
	        this.source = source;
	    }
	    return EventBinding;
	})();
	exports.EventBinding = EventBinding;
	(function (PropertyBindingType) {
	    PropertyBindingType[PropertyBindingType["PROPERTY"] = 0] = "PROPERTY";
	    PropertyBindingType[PropertyBindingType["ATTRIBUTE"] = 1] = "ATTRIBUTE";
	    PropertyBindingType[PropertyBindingType["CLASS"] = 2] = "CLASS";
	    PropertyBindingType[PropertyBindingType["STYLE"] = 3] = "STYLE";
	})(exports.PropertyBindingType || (exports.PropertyBindingType = {}));
	var PropertyBindingType = exports.PropertyBindingType;
	var ElementPropertyBinding = (function () {
	    function ElementPropertyBinding(type, astWithSource, property, unit) {
	        if (unit === void 0) { unit = null; }
	        this.type = type;
	        this.astWithSource = astWithSource;
	        this.property = property;
	        this.unit = unit;
	    }
	    return ElementPropertyBinding;
	})();
	exports.ElementPropertyBinding = ElementPropertyBinding;
	var RenderElementBinder = (function () {
	    function RenderElementBinder(_a) {
	        var _b = _a === void 0 ? {} : _a, index = _b.index, parentIndex = _b.parentIndex, distanceToParent = _b.distanceToParent, directives = _b.directives, nestedProtoView = _b.nestedProtoView, propertyBindings = _b.propertyBindings, variableBindings = _b.variableBindings, eventBindings = _b.eventBindings, readAttributes = _b.readAttributes;
	        this.index = index;
	        this.parentIndex = parentIndex;
	        this.distanceToParent = distanceToParent;
	        this.directives = directives;
	        this.nestedProtoView = nestedProtoView;
	        this.propertyBindings = propertyBindings;
	        this.variableBindings = variableBindings;
	        this.eventBindings = eventBindings;
	        this.readAttributes = readAttributes;
	    }
	    return RenderElementBinder;
	})();
	exports.RenderElementBinder = RenderElementBinder;
	var DirectiveBinder = (function () {
	    function DirectiveBinder(_a) {
	        var directiveIndex = _a.directiveIndex, propertyBindings = _a.propertyBindings, eventBindings = _a.eventBindings, hostPropertyBindings = _a.hostPropertyBindings;
	        this.directiveIndex = directiveIndex;
	        this.propertyBindings = propertyBindings;
	        this.eventBindings = eventBindings;
	        this.hostPropertyBindings = hostPropertyBindings;
	    }
	    return DirectiveBinder;
	})();
	exports.DirectiveBinder = DirectiveBinder;
	(function (ViewType) {
	    // A view that contains the host element with bound component directive.
	    // Contains a COMPONENT view
	    ViewType[ViewType["HOST"] = 0] = "HOST";
	    // The view of the component
	    // Can contain 0 to n EMBEDDED views
	    ViewType[ViewType["COMPONENT"] = 1] = "COMPONENT";
	    // A view that is embedded into another View via a <template> element
	    // inside of a COMPONENT view
	    ViewType[ViewType["EMBEDDED"] = 2] = "EMBEDDED";
	})(exports.ViewType || (exports.ViewType = {}));
	var ViewType = exports.ViewType;
	var ProtoViewDto = (function () {
	    function ProtoViewDto(_a) {
	        var render = _a.render, elementBinders = _a.elementBinders, variableBindings = _a.variableBindings, type = _a.type, textBindings = _a.textBindings, transitiveNgContentCount = _a.transitiveNgContentCount;
	        this.render = render;
	        this.elementBinders = elementBinders;
	        this.variableBindings = variableBindings;
	        this.type = type;
	        this.textBindings = textBindings;
	        this.transitiveNgContentCount = transitiveNgContentCount;
	    }
	    return ProtoViewDto;
	})();
	exports.ProtoViewDto = ProtoViewDto;
	var RenderDirectiveMetadata = (function () {
	    function RenderDirectiveMetadata(_a) {
	        var id = _a.id, selector = _a.selector, compileChildren = _a.compileChildren, events = _a.events, hostListeners = _a.hostListeners, hostProperties = _a.hostProperties, hostAttributes = _a.hostAttributes, properties = _a.properties, readAttributes = _a.readAttributes, type = _a.type, callOnDestroy = _a.callOnDestroy, callOnChanges = _a.callOnChanges, callDoCheck = _a.callDoCheck, callOnInit = _a.callOnInit, callAfterContentInit = _a.callAfterContentInit, callAfterContentChecked = _a.callAfterContentChecked, callAfterViewInit = _a.callAfterViewInit, callAfterViewChecked = _a.callAfterViewChecked, changeDetection = _a.changeDetection, exportAs = _a.exportAs;
	        this.id = id;
	        this.selector = selector;
	        this.compileChildren = lang_1.isPresent(compileChildren) ? compileChildren : true;
	        this.events = events;
	        this.hostListeners = hostListeners;
	        this.hostAttributes = hostAttributes;
	        this.hostProperties = hostProperties;
	        this.properties = properties;
	        this.readAttributes = readAttributes;
	        this.type = type;
	        this.callOnDestroy = callOnDestroy;
	        this.callOnChanges = callOnChanges;
	        this.callDoCheck = callDoCheck;
	        this.callOnInit = callOnInit;
	        this.callAfterContentInit = callAfterContentInit;
	        this.callAfterContentChecked = callAfterContentChecked;
	        this.callAfterViewInit = callAfterViewInit;
	        this.callAfterViewChecked = callAfterViewChecked;
	        this.changeDetection = changeDetection;
	        this.exportAs = exportAs;
	    }
	    Object.defineProperty(RenderDirectiveMetadata, "DIRECTIVE_TYPE", {
	        get: function () { return 0; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RenderDirectiveMetadata, "COMPONENT_TYPE", {
	        get: function () { return 1; },
	        enumerable: true,
	        configurable: true
	    });
	    RenderDirectiveMetadata.create = function (_a) {
	        var id = _a.id, selector = _a.selector, compileChildren = _a.compileChildren, events = _a.events, host = _a.host, properties = _a.properties, readAttributes = _a.readAttributes, type = _a.type, callOnDestroy = _a.callOnDestroy, callOnChanges = _a.callOnChanges, callDoCheck = _a.callDoCheck, callOnInit = _a.callOnInit, callAfterContentInit = _a.callAfterContentInit, callAfterContentChecked = _a.callAfterContentChecked, callAfterViewInit = _a.callAfterViewInit, callAfterViewChecked = _a.callAfterViewChecked, changeDetection = _a.changeDetection, exportAs = _a.exportAs;
	        var hostListeners = new collection_1.Map();
	        var hostProperties = new collection_1.Map();
	        var hostAttributes = new collection_1.Map();
	        if (lang_1.isPresent(host)) {
	            collection_1.MapWrapper.forEach(host, function (value, key) {
	                var matches = lang_1.RegExpWrapper.firstMatch(RenderDirectiveMetadata._hostRegExp, key);
	                if (lang_1.isBlank(matches)) {
	                    hostAttributes.set(key, value);
	                }
	                else if (lang_1.isPresent(matches[1])) {
	                    hostProperties.set(matches[1], value);
	                }
	                else if (lang_1.isPresent(matches[2])) {
	                    hostListeners.set(matches[2], value);
	                }
	            });
	        }
	        return new RenderDirectiveMetadata({
	            id: id,
	            selector: selector,
	            compileChildren: compileChildren,
	            events: events,
	            hostListeners: hostListeners,
	            hostProperties: hostProperties,
	            hostAttributes: hostAttributes,
	            properties: properties,
	            readAttributes: readAttributes,
	            type: type,
	            callOnDestroy: callOnDestroy,
	            callOnChanges: callOnChanges,
	            callDoCheck: callDoCheck,
	            callOnInit: callOnInit,
	            callAfterContentInit: callAfterContentInit,
	            callAfterContentChecked: callAfterContentChecked,
	            callAfterViewInit: callAfterViewInit,
	            callAfterViewChecked: callAfterViewChecked,
	            changeDetection: changeDetection,
	            exportAs: exportAs
	        });
	    };
	    // group 1: "property" from "[property]"
	    // group 2: "event" from "(event)"
	    RenderDirectiveMetadata._hostRegExp = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))$/g;
	    return RenderDirectiveMetadata;
	})();
	exports.RenderDirectiveMetadata = RenderDirectiveMetadata;
	// An opaque reference to a render proto view
	var RenderProtoViewRef = (function () {
	    function RenderProtoViewRef() {
	    }
	    return RenderProtoViewRef;
	})();
	exports.RenderProtoViewRef = RenderProtoViewRef;
	// An opaque reference to a part of a view
	var RenderFragmentRef = (function () {
	    function RenderFragmentRef() {
	    }
	    return RenderFragmentRef;
	})();
	exports.RenderFragmentRef = RenderFragmentRef;
	// An opaque reference to a view
	var RenderViewRef = (function () {
	    function RenderViewRef() {
	    }
	    return RenderViewRef;
	})();
	exports.RenderViewRef = RenderViewRef;
	/**
	 * How the template and styles of a view should be encapsulated.
	 */
	(function (ViewEncapsulation) {
	    /**
	     * Emulate scoping of styles by preprocessing the style rules
	     * and adding additional attributes to elements. This is the default.
	     */
	    ViewEncapsulation[ViewEncapsulation["Emulated"] = 0] = "Emulated";
	    /**
	     * Uses the native mechanism of the renderer. For the DOM this means creating a ShadowRoot.
	     */
	    ViewEncapsulation[ViewEncapsulation["Native"] = 1] = "Native";
	    /**
	     * Don't scope the template nor the styles.
	     */
	    ViewEncapsulation[ViewEncapsulation["None"] = 2] = "None";
	})(exports.ViewEncapsulation || (exports.ViewEncapsulation = {}));
	var ViewEncapsulation = exports.ViewEncapsulation;
	var ViewDefinition = (function () {
	    function ViewDefinition(_a) {
	        var _b = _a === void 0 ? {} : _a, componentId = _b.componentId, templateAbsUrl = _b.templateAbsUrl, template = _b.template, styleAbsUrls = _b.styleAbsUrls, styles = _b.styles, directives = _b.directives, encapsulation = _b.encapsulation;
	        this.componentId = componentId;
	        this.templateAbsUrl = templateAbsUrl;
	        this.template = template;
	        this.styleAbsUrls = styleAbsUrls;
	        this.styles = styles;
	        this.directives = directives;
	        this.encapsulation = lang_1.isPresent(encapsulation) ? encapsulation : ViewEncapsulation.Emulated;
	    }
	    return ViewDefinition;
	})();
	exports.ViewDefinition = ViewDefinition;
	var RenderProtoViewMergeMapping = (function () {
	    function RenderProtoViewMergeMapping(mergedProtoViewRef, 
	        // Number of fragments in the merged ProtoView.
	        // Fragments are stored in depth first order of nested ProtoViews.
	        fragmentCount, 
	        // Mapping from app element index to render element index.
	        // Mappings of nested ProtoViews are in depth first order, with all
	        // indices for one ProtoView in a consecutive block.
	        mappedElementIndices, 
	        // Number of bound render element.
	        // Note: This could be more than the original ones
	        // as we might have bound a new element for projecting bound text nodes.
	        mappedElementCount, 
	        // Mapping from app text index to render text index.
	        // Mappings of nested ProtoViews are in depth first order, with all
	        // indices for one ProtoView in a consecutive block.
	        mappedTextIndices, 
	        // Mapping from view index to app element index
	        hostElementIndicesByViewIndex, 
	        // Number of contained views by view index
	        nestedViewCountByViewIndex) {
	        this.mergedProtoViewRef = mergedProtoViewRef;
	        this.fragmentCount = fragmentCount;
	        this.mappedElementIndices = mappedElementIndices;
	        this.mappedElementCount = mappedElementCount;
	        this.mappedTextIndices = mappedTextIndices;
	        this.hostElementIndicesByViewIndex = hostElementIndicesByViewIndex;
	        this.nestedViewCountByViewIndex = nestedViewCountByViewIndex;
	    }
	    return RenderProtoViewMergeMapping;
	})();
	exports.RenderProtoViewMergeMapping = RenderProtoViewMergeMapping;
	var RenderCompiler = (function () {
	    function RenderCompiler() {
	    }
	    /**
	     * Creates a ProtoViewDto that contains a single nested component with the given componentId.
	     */
	    RenderCompiler.prototype.compileHost = function (directiveMetadata) { return null; };
	    /**
	     * Compiles a single DomProtoView. Non recursive so that
	     * we don't need to serialize all possible components over the wire,
	     * but only the needed ones based on previous calls.
	     */
	    RenderCompiler.prototype.compile = function (view) { return null; };
	    /**
	     * Merges ProtoViews.
	     * The first entry of the array is the protoview into which all the other entries of the array
	     * should be merged.
	     * If the array contains other arrays, they will be merged before processing the parent array.
	     * The array must contain an entry for every component and embedded ProtoView of the first entry.
	     * @param protoViewRefs Array of ProtoViewRefs or nested
	     * @return the merge result
	     */
	    RenderCompiler.prototype.mergeProtoViewsRecursively = function (protoViewRefs) {
	        return null;
	    };
	    return RenderCompiler;
	})();
	exports.RenderCompiler = RenderCompiler;
	var RenderViewWithFragments = (function () {
	    function RenderViewWithFragments(viewRef, fragmentRefs) {
	        this.viewRef = viewRef;
	        this.fragmentRefs = fragmentRefs;
	    }
	    return RenderViewWithFragments;
	})();
	exports.RenderViewWithFragments = RenderViewWithFragments;
	var Renderer = (function () {
	    function Renderer() {
	    }
	    /**
	     * Creates a root host view that includes the given element.
	     * Note that the fragmentCount needs to be passed in so that we can create a result
	     * synchronously even when dealing with webworkers!
	     *
	     * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type
	     * ProtoViewDto.HOST_VIEW_TYPE
	     * @param {any} hostElementSelector css selector for the host element (will be queried against the
	     * main document)
	     * @return {RenderViewWithFragments} the created view including fragments
	     */
	    Renderer.prototype.createRootHostView = function (hostProtoViewRef, fragmentCount, hostElementSelector) {
	        return null;
	    };
	    /**
	     * Creates a regular view out of the given ProtoView.
	     * Note that the fragmentCount needs to be passed in so that we can create a result
	     * synchronously even when dealing with webworkers!
	     */
	    Renderer.prototype.createView = function (protoViewRef, fragmentCount) {
	        return null;
	    };
	    /**
	     * Destroys the given view after it has been dehydrated and detached
	     */
	    Renderer.prototype.destroyView = function (viewRef) { };
	    /**
	     * Attaches a fragment after another fragment.
	     */
	    Renderer.prototype.attachFragmentAfterFragment = function (previousFragmentRef, fragmentRef) { };
	    /**
	     * Attaches a fragment after an element.
	     */
	    Renderer.prototype.attachFragmentAfterElement = function (elementRef, fragmentRef) { };
	    /**
	     * Detaches a fragment.
	     */
	    Renderer.prototype.detachFragment = function (fragmentRef) { };
	    /**
	     * Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views
	     * inside of the view pool.
	     */
	    Renderer.prototype.hydrateView = function (viewRef) { };
	    /**
	     * Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views
	     * inside of the view pool.
	     */
	    Renderer.prototype.dehydrateView = function (viewRef) { };
	    /**
	     * Returns the native element at the given location.
	     * Attention: In a WebWorker scenario, this should always return null!
	     */
	    Renderer.prototype.getNativeElementSync = function (location) { return null; };
	    /**
	     * Sets a property on an element.
	     */
	    Renderer.prototype.setElementProperty = function (location, propertyName, propertyValue) { };
	    /**
	     * Sets an attribute on an element.
	     */
	    Renderer.prototype.setElementAttribute = function (location, attributeName, attributeValue) { };
	    /**
	     * Sets a class on an element.
	     */
	    Renderer.prototype.setElementClass = function (location, className, isAdd) { };
	    /**
	     * Sets a style on an element.
	     */
	    Renderer.prototype.setElementStyle = function (location, styleName, styleValue) { };
	    /**
	     * Calls a method on an element.
	     */
	    Renderer.prototype.invokeElementMethod = function (location, methodName, args) { };
	    /**
	     * Sets the value of a text node.
	     */
	    Renderer.prototype.setText = function (viewRef, textNodeIndex, text) { };
	    /**
	     * Sets the dispatcher for all events of the given view
	     */
	    Renderer.prototype.setEventDispatcher = function (viewRef, dispatcher) { };
	    return Renderer;
	})();
	exports.Renderer = Renderer;
	//# sourceMappingURL=api.js.map

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for util
	var decorators_1 = __webpack_require__(163);
	exports.Class = decorators_1.Class;
	//# sourceMappingURL=util.js.map

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * This module provides a set of common Pipes.
	 */
	var async_pipe_1 = __webpack_require__(215);
	exports.AsyncPipe = async_pipe_1.AsyncPipe;
	var date_pipe_1 = __webpack_require__(345);
	exports.DatePipe = date_pipe_1.DatePipe;
	var default_pipes_1 = __webpack_require__(347);
	exports.DEFAULT_PIPES = default_pipes_1.DEFAULT_PIPES;
	exports.DEFAULT_PIPES_TOKEN = default_pipes_1.DEFAULT_PIPES_TOKEN;
	var json_pipe_1 = __webpack_require__(350);
	exports.JsonPipe = json_pipe_1.JsonPipe;
	var limit_to_pipe_1 = __webpack_require__(351);
	exports.LimitToPipe = limit_to_pipe_1.LimitToPipe;
	var lowercase_pipe_1 = __webpack_require__(349);
	exports.LowerCasePipe = lowercase_pipe_1.LowerCasePipe;
	var number_pipe_1 = __webpack_require__(353);
	exports.NumberPipe = number_pipe_1.NumberPipe;
	exports.DecimalPipe = number_pipe_1.DecimalPipe;
	exports.PercentPipe = number_pipe_1.PercentPipe;
	exports.CurrencyPipe = number_pipe_1.CurrencyPipe;
	var uppercase_pipe_1 = __webpack_require__(348);
	exports.UpperCasePipe = uppercase_pipe_1.UpperCasePipe;
	var pipes_1 = __webpack_require__(354);
	exports.ProtoPipes = pipes_1.ProtoPipes;
	var pipe_binding_1 = __webpack_require__(356);
	exports.PipeBinding = pipe_binding_1.PipeBinding;
	//# sourceMappingURL=pipes.js.map

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var async_1 = __webpack_require__(216);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var change_detection_1 = __webpack_require__(178);
	var invalid_pipe_argument_exception_1 = __webpack_require__(344);
	var ObservableStrategy = (function () {
	    function ObservableStrategy() {
	    }
	    ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	        return async_1.ObservableWrapper.subscribe(async, updateLatestValue, function (e) { throw e; });
	    };
	    ObservableStrategy.prototype.dispose = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
	    ObservableStrategy.prototype.onDestroy = function (subscription) { async_1.ObservableWrapper.dispose(subscription); };
	    return ObservableStrategy;
	})();
	var PromiseStrategy = (function () {
	    function PromiseStrategy() {
	    }
	    PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
	        return async.then(updateLatestValue);
	    };
	    PromiseStrategy.prototype.dispose = function (subscription) { };
	    PromiseStrategy.prototype.onDestroy = function (subscription) { };
	    return PromiseStrategy;
	})();
	var _promiseStrategy = new PromiseStrategy();
	var _observableStrategy = new ObservableStrategy();
	/**
	 * The `async` pipe subscribes to an Observable or Promise and returns the latest value it has
	 * emitted.
	 * When a new value is emitted, the `async` pipe marks the component to be checked for changes.
	 *
	 * # Example
	 * The example below binds the `time` Observable to the view. Every 500ms, the `time` Observable
	 * updates the view with the current time.
	 *
	 * import {Observable} from 'angular2/core';
	 * @Component({
	 *   selector: "task-cmp"
	 * })
	 * @View({
	 *   template: "Time: {{ time | async }}"
	 * })
	 * class Task {
	 *   time = new Observable<number>(observer => {
	 *     setInterval(_ =>
	 *       observer.next(new Date().getTime()), 500);
	 *   });
	 * }
	 */
	var AsyncPipe = (function () {
	    function AsyncPipe(_ref) {
	        this._ref = _ref;
	        this._latestValue = null;
	        this._latestReturnedValue = null;
	        this._subscription = null;
	        this._obj = null;
	        this._strategy = null;
	    }
	    AsyncPipe.prototype.onDestroy = function () {
	        if (lang_1.isPresent(this._subscription)) {
	            this._dispose();
	        }
	    };
	    AsyncPipe.prototype.transform = function (obj, args) {
	        if (lang_1.isBlank(this._obj)) {
	            if (lang_1.isPresent(obj)) {
	                this._subscribe(obj);
	            }
	            return null;
	        }
	        if (obj !== this._obj) {
	            this._dispose();
	            return this.transform(obj);
	        }
	        if (this._latestValue === this._latestReturnedValue) {
	            return this._latestReturnedValue;
	        }
	        else {
	            this._latestReturnedValue = this._latestValue;
	            return change_detection_1.WrappedValue.wrap(this._latestValue);
	        }
	    };
	    AsyncPipe.prototype._subscribe = function (obj) {
	        var _this = this;
	        this._obj = obj;
	        this._strategy = this._selectStrategy(obj);
	        this._subscription =
	            this._strategy.createSubscription(obj, function (value) { return _this._updateLatestValue(obj, value); });
	    };
	    AsyncPipe.prototype._selectStrategy = function (obj) {
	        if (lang_1.isPromise(obj)) {
	            return _promiseStrategy;
	        }
	        else if (async_1.ObservableWrapper.isObservable(obj)) {
	            return _observableStrategy;
	        }
	        else {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(AsyncPipe, obj);
	        }
	    };
	    AsyncPipe.prototype._dispose = function () {
	        this._strategy.dispose(this._subscription);
	        this._latestValue = null;
	        this._latestReturnedValue = null;
	        this._subscription = null;
	        this._obj = null;
	    };
	    AsyncPipe.prototype._updateLatestValue = function (async, value) {
	        if (async === this._obj) {
	            this._latestValue = value;
	            this._ref.markForCheck();
	        }
	    };
	    AsyncPipe = __decorate([
	        metadata_1.Pipe({ name: 'async', pure: false }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [change_detection_1.ChangeDetectorRef])
	    ], AsyncPipe);
	    return AsyncPipe;
	})();
	exports.AsyncPipe = AsyncPipe;
	//# sourceMappingURL=async_pipe.js.map

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	///<reference path="../../../typings/tsd.d.ts" />
	var lang_1 = __webpack_require__(159);
	var RxNext = __webpack_require__(217);
	var PromiseWrapper = (function () {
	    function PromiseWrapper() {
	    }
	    PromiseWrapper.resolve = function (obj) { return Promise.resolve(obj); };
	    PromiseWrapper.reject = function (obj, _) { return Promise.reject(obj); };
	    // Note: We can't rename this method into `catch`, as this is not a valid
	    // method name in Dart.
	    PromiseWrapper.catchError = function (promise, onError) {
	        return promise.catch(onError);
	    };
	    PromiseWrapper.all = function (promises) {
	        if (promises.length == 0)
	            return Promise.resolve([]);
	        return Promise.all(promises);
	    };
	    PromiseWrapper.then = function (promise, success, rejection) {
	        return promise.then(success, rejection);
	    };
	    PromiseWrapper.wrap = function (computation) {
	        return new Promise(function (res, rej) {
	            try {
	                res(computation());
	            }
	            catch (e) {
	                rej(e);
	            }
	        });
	    };
	    PromiseWrapper.completer = function () {
	        var resolve;
	        var reject;
	        var p = new Promise(function (res, rej) {
	            resolve = res;
	            reject = rej;
	        });
	        return { promise: p, resolve: resolve, reject: reject };
	    };
	    return PromiseWrapper;
	})();
	exports.PromiseWrapper = PromiseWrapper;
	var TimerWrapper = (function () {
	    function TimerWrapper() {
	    }
	    TimerWrapper.setTimeout = function (fn, millis) { return lang_1.global.setTimeout(fn, millis); };
	    TimerWrapper.clearTimeout = function (id) { lang_1.global.clearTimeout(id); };
	    TimerWrapper.setInterval = function (fn, millis) {
	        return lang_1.global.setInterval(fn, millis);
	    };
	    TimerWrapper.clearInterval = function (id) { lang_1.global.clearInterval(id); };
	    return TimerWrapper;
	})();
	exports.TimerWrapper = TimerWrapper;
	var ObservableWrapper = (function () {
	    function ObservableWrapper() {
	    }
	    // TODO(vsavkin): when we use rxnext, try inferring the generic type from the first arg
	    ObservableWrapper.subscribe = function (emitter, onNext, onThrow, onReturn) {
	        if (onThrow === void 0) { onThrow = null; }
	        if (onReturn === void 0) { onReturn = null; }
	        return emitter.observer({ next: onNext, throw: onThrow, return: onReturn });
	    };
	    ObservableWrapper.isObservable = function (obs) { return obs instanceof Observable; };
	    ObservableWrapper.dispose = function (subscription) { subscription.unsubscribe(); };
	    ObservableWrapper.callNext = function (emitter, value) { emitter.next(value); };
	    ObservableWrapper.callThrow = function (emitter, error) { emitter.throw(error); };
	    ObservableWrapper.callReturn = function (emitter) { emitter.return(null); };
	    return ObservableWrapper;
	})();
	exports.ObservableWrapper = ObservableWrapper;
	// TODO: vsavkin change to interface
	var Observable = (function () {
	    function Observable() {
	    }
	    Observable.prototype.observer = function (generator) { return null; };
	    return Observable;
	})();
	exports.Observable = Observable;
	/**
	 * Use by directives and components to emit custom {@link Event}s.
	 *
	 * ## Examples
	 *
	 * In the following example, `Zippy` alternatively emits `open` and `close` events when its
	 * title gets clicked:
	 *
	 * ```
	 * @Component({selector: 'zippy'})
	 * @View({template: `
	 *   <div class="zippy">
	 *     <div (click)="toggle()">Toggle</div>
	 *     <div [hidden]="!visible">
	 *       <ng-content></ng-content>
	 *     </div>
	 *  </div>`})
	 * export class Zippy {
	 *   visible: boolean = true;
	 *   @Event() open: EventEmitter = new EventEmitter();
	 *   @Event() close: EventEmitter = new EventEmitter();
	 *
	 *   toggle() {
	 *     this.visible = !this.visible;
	 *     if (this.visible) {
	 *       this.open.next(null);
	 *     } else {
	 *       this.close.next(null);
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * Use Rx.Observable but provides an adapter to make it work as specified here:
	 * https://github.com/jhusain/observable-spec
	 *
	 * Once a reference implementation of the spec is available, switch to it.
	 */
	var EventEmitter = (function (_super) {
	    __extends(EventEmitter, _super);
	    function EventEmitter() {
	        _super.apply(this, arguments);
	        this._subject = new RxNext.Subject();
	    }
	    EventEmitter.prototype.observer = function (generator) {
	        return this._subject.subscribe(function (value) { setTimeout(function () { return generator.next(value); }); }, function (error) { return generator.throw ? generator.throw(error) : null; }, function () { return generator.return ? generator.return() : null; });
	    };
	    EventEmitter.prototype.toRx = function () { return this; };
	    EventEmitter.prototype.next = function (value) { this._subject.next(value); };
	    EventEmitter.prototype.throw = function (error) { this._subject.error(error); };
	    EventEmitter.prototype.return = function (value) { this._subject.complete(); };
	    return EventEmitter;
	})(Observable);
	exports.EventEmitter = EventEmitter;
	//# sourceMappingURL=async.js.map

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(218);


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _schedulersVirtualTimeScheduler = __webpack_require__(229);

	var _schedulersVirtualTimeScheduler2 = _interopRequireDefault(_schedulersVirtualTimeScheduler);

	var _schedulersTestScheduler = __webpack_require__(230);

	var _schedulersTestScheduler2 = _interopRequireDefault(_schedulersTestScheduler);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var _Observable = __webpack_require__(220);

	var _Observable2 = _interopRequireDefault(_Observable);

	var _Subscriber = __webpack_require__(221);

	var _Subscriber2 = _interopRequireDefault(_Subscriber);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _Notification = __webpack_require__(231);

	var _Notification2 = _interopRequireDefault(_Notification);

	var _subjectsReplaySubject = __webpack_require__(240);

	var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);

	var _subjectsBehaviorSubject = __webpack_require__(241);

	var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);

	var _observablesConnectableObservable = __webpack_require__(242);

	var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);

	var _observablesArrayObservable = __webpack_require__(243);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _observablesDeferObservable = __webpack_require__(246);

	var _observablesDeferObservable2 = _interopRequireDefault(_observablesDeferObservable);

	var _observablesEmptyObservable = __webpack_require__(245);

	var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);

	var _observablesErrorObservable = __webpack_require__(249);

	var _observablesErrorObservable2 = _interopRequireDefault(_observablesErrorObservable);

	var _observablesInfiniteObservable = __webpack_require__(250);

	var _observablesInfiniteObservable2 = _interopRequireDefault(_observablesInfiniteObservable);

	var _observablesIntervalObservable = __webpack_require__(251);

	var _observablesIntervalObservable2 = _interopRequireDefault(_observablesIntervalObservable);

	var _observablesPromiseObservable = __webpack_require__(253);

	var _observablesPromiseObservable2 = _interopRequireDefault(_observablesPromiseObservable);

	var _observablesRangeObservable = __webpack_require__(254);

	var _observablesRangeObservable2 = _interopRequireDefault(_observablesRangeObservable);

	var _observablesTimerObservable = __webpack_require__(255);

	var _observablesTimerObservable2 = _interopRequireDefault(_observablesTimerObservable);

	var _observablesFromEventPatternObservable = __webpack_require__(256);

	var _observablesFromEventPatternObservable2 = _interopRequireDefault(_observablesFromEventPatternObservable);

	var _observablesFromEventObservable = __webpack_require__(257);

	var _observablesFromEventObservable2 = _interopRequireDefault(_observablesFromEventObservable);

	var _observablesForkJoinObservable = __webpack_require__(258);

	var _observablesForkJoinObservable2 = _interopRequireDefault(_observablesForkJoinObservable);

	var _observablesFromObservable = __webpack_require__(259);

	var _observablesFromObservable2 = _interopRequireDefault(_observablesFromObservable);

	var _operatorsConcatStatic = __webpack_require__(263);

	var _operatorsConcatStatic2 = _interopRequireDefault(_operatorsConcatStatic);

	var _operatorsConcat = __webpack_require__(266);

	var _operatorsConcat2 = _interopRequireDefault(_operatorsConcat);

	var _operatorsConcatAll = __webpack_require__(267);

	var _operatorsConcatAll2 = _interopRequireDefault(_operatorsConcatAll);

	var _operatorsConcatMap = __webpack_require__(268);

	var _operatorsConcatMap2 = _interopRequireDefault(_operatorsConcatMap);

	var _operatorsConcatMapTo = __webpack_require__(270);

	var _operatorsConcatMapTo2 = _interopRequireDefault(_operatorsConcatMapTo);

	var _operatorsMerge = __webpack_require__(272);

	var _operatorsMerge2 = _interopRequireDefault(_operatorsMerge);

	var _operatorsMergeStatic = __webpack_require__(264);

	var _operatorsMergeStatic2 = _interopRequireDefault(_operatorsMergeStatic);

	var _operatorsMergeAll = __webpack_require__(273);

	var _operatorsMergeAll2 = _interopRequireDefault(_operatorsMergeAll);

	var _operatorsFlatMap = __webpack_require__(274);

	var _operatorsFlatMap2 = _interopRequireDefault(_operatorsFlatMap);

	var _operatorsFlatMapTo = __webpack_require__(275);

	var _operatorsFlatMapTo2 = _interopRequireDefault(_operatorsFlatMapTo);

	var _operatorsSwitchAll = __webpack_require__(276);

	var _operatorsSwitchAll2 = _interopRequireDefault(_operatorsSwitchAll);

	var _operatorsSwitchLatest = __webpack_require__(277);

	var _operatorsSwitchLatest2 = _interopRequireDefault(_operatorsSwitchLatest);

	var _operatorsSwitchLatestTo = __webpack_require__(278);

	var _operatorsSwitchLatestTo2 = _interopRequireDefault(_operatorsSwitchLatestTo);

	var _operatorsExpand = __webpack_require__(279);

	var _operatorsExpand2 = _interopRequireDefault(_operatorsExpand);

	var _operatorsDo = __webpack_require__(280);

	var _operatorsDo2 = _interopRequireDefault(_operatorsDo);

	var _operatorsMap = __webpack_require__(281);

	var _operatorsMap2 = _interopRequireDefault(_operatorsMap);

	var _operatorsMapTo = __webpack_require__(283);

	var _operatorsMapTo2 = _interopRequireDefault(_operatorsMapTo);

	var _operatorsToArray = __webpack_require__(284);

	var _operatorsToArray2 = _interopRequireDefault(_operatorsToArray);

	var _operatorsCount = __webpack_require__(285);

	var _operatorsCount2 = _interopRequireDefault(_operatorsCount);

	var _operatorsScan = __webpack_require__(286);

	var _operatorsScan2 = _interopRequireDefault(_operatorsScan);

	var _operatorsReduce = __webpack_require__(287);

	var _operatorsReduce2 = _interopRequireDefault(_operatorsReduce);

	var _operatorsStartWith = __webpack_require__(288);

	var _operatorsStartWith2 = _interopRequireDefault(_operatorsStartWith);

	var _operatorsTake = __webpack_require__(289);

	var _operatorsTake2 = _interopRequireDefault(_operatorsTake);

	var _operatorsSkip = __webpack_require__(290);

	var _operatorsSkip2 = _interopRequireDefault(_operatorsSkip);

	var _operatorsSkipUntil = __webpack_require__(291);

	var _operatorsSkipUntil2 = _interopRequireDefault(_operatorsSkipUntil);

	var _operatorsTakeUntil = __webpack_require__(292);

	var _operatorsTakeUntil2 = _interopRequireDefault(_operatorsTakeUntil);

	var _operatorsFilter = __webpack_require__(293);

	var _operatorsFilter2 = _interopRequireDefault(_operatorsFilter);

	var _operatorsDistinctUntilChanged = __webpack_require__(294);

	var _operatorsDistinctUntilChanged2 = _interopRequireDefault(_operatorsDistinctUntilChanged);

	var _operatorsDistinctUntilKeyChanged = __webpack_require__(295);

	var _operatorsDistinctUntilKeyChanged2 = _interopRequireDefault(_operatorsDistinctUntilKeyChanged);

	var _operatorsCombineLatest = __webpack_require__(296);

	var _operatorsCombineLatest2 = _interopRequireDefault(_operatorsCombineLatest);

	var _operatorsCombineLatestStatic = __webpack_require__(299);

	var _operatorsCombineLatestStatic2 = _interopRequireDefault(_operatorsCombineLatestStatic);

	var _operatorsCombineAll = __webpack_require__(300);

	var _operatorsCombineAll2 = _interopRequireDefault(_operatorsCombineAll);

	var _operatorsWithLatestFrom = __webpack_require__(301);

	var _operatorsWithLatestFrom2 = _interopRequireDefault(_operatorsWithLatestFrom);

	var _operatorsZip = __webpack_require__(302);

	var _operatorsZip2 = _interopRequireDefault(_operatorsZip);

	var _operatorsZipStatic = __webpack_require__(303);

	var _operatorsZipStatic2 = _interopRequireDefault(_operatorsZipStatic);

	var _operatorsZipAll = __webpack_require__(304);

	var _operatorsZipAll2 = _interopRequireDefault(_operatorsZipAll);

	var _operatorsPublish = __webpack_require__(305);

	var _operatorsPublish2 = _interopRequireDefault(_operatorsPublish);

	var _operatorsPublishBehavior = __webpack_require__(307);

	var _operatorsPublishBehavior2 = _interopRequireDefault(_operatorsPublishBehavior);

	var _operatorsPublishReplay = __webpack_require__(308);

	var _operatorsPublishReplay2 = _interopRequireDefault(_operatorsPublishReplay);

	var _operatorsMulticast = __webpack_require__(306);

	var _operatorsMulticast2 = _interopRequireDefault(_operatorsMulticast);

	var _operatorsObserveOn = __webpack_require__(309);

	var _operatorsObserveOn2 = _interopRequireDefault(_operatorsObserveOn);

	var _operatorsSubscribeOn = __webpack_require__(310);

	var _operatorsSubscribeOn2 = _interopRequireDefault(_operatorsSubscribeOn);

	var _operatorsPartition = __webpack_require__(312);

	var _operatorsPartition2 = _interopRequireDefault(_operatorsPartition);

	var _operatorsToPromise = __webpack_require__(314);

	var _operatorsToPromise2 = _interopRequireDefault(_operatorsToPromise);

	var _operatorsDefaultIfEmpty = __webpack_require__(315);

	var _operatorsDefaultIfEmpty2 = _interopRequireDefault(_operatorsDefaultIfEmpty);

	var _operatorsMaterialize = __webpack_require__(316);

	var _operatorsMaterialize2 = _interopRequireDefault(_operatorsMaterialize);

	var _operatorsCatch = __webpack_require__(317);

	var _operatorsCatch2 = _interopRequireDefault(_operatorsCatch);

	var _operatorsRetry = __webpack_require__(318);

	var _operatorsRetry2 = _interopRequireDefault(_operatorsRetry);

	var _operatorsRetryWhen = __webpack_require__(319);

	var _operatorsRetryWhen2 = _interopRequireDefault(_operatorsRetryWhen);

	var _operatorsRepeat = __webpack_require__(320);

	var _operatorsRepeat2 = _interopRequireDefault(_operatorsRepeat);

	var _operatorsFinally = __webpack_require__(321);

	var _operatorsFinally2 = _interopRequireDefault(_operatorsFinally);

	var _operatorsTimeout = __webpack_require__(322);

	var _operatorsTimeout2 = _interopRequireDefault(_operatorsTimeout);

	var _operatorsTimeoutWith = __webpack_require__(324);

	var _operatorsTimeoutWith2 = _interopRequireDefault(_operatorsTimeoutWith);

	var _operatorsGroupBy = __webpack_require__(325);

	var _operatorsGroupBy2 = _interopRequireDefault(_operatorsGroupBy);

	var _operatorsWindow = __webpack_require__(329);

	var _operatorsWindow2 = _interopRequireDefault(_operatorsWindow);

	var _operatorsWindowWhen = __webpack_require__(330);

	var _operatorsWindowWhen2 = _interopRequireDefault(_operatorsWindowWhen);

	var _operatorsWindowToggle = __webpack_require__(331);

	var _operatorsWindowToggle2 = _interopRequireDefault(_operatorsWindowToggle);

	var _operatorsWindowTime = __webpack_require__(332);

	var _operatorsWindowTime2 = _interopRequireDefault(_operatorsWindowTime);

	var _operatorsWindowCount = __webpack_require__(333);

	var _operatorsWindowCount2 = _interopRequireDefault(_operatorsWindowCount);

	var _operatorsDelay = __webpack_require__(334);

	var _operatorsDelay2 = _interopRequireDefault(_operatorsDelay);

	var _operatorsThrottle = __webpack_require__(335);

	var _operatorsThrottle2 = _interopRequireDefault(_operatorsThrottle);

	var _operatorsDebounce = __webpack_require__(336);

	var _operatorsDebounce2 = _interopRequireDefault(_operatorsDebounce);

	var _operatorsBuffer = __webpack_require__(337);

	var _operatorsBuffer2 = _interopRequireDefault(_operatorsBuffer);

	var _operatorsBufferCount = __webpack_require__(338);

	var _operatorsBufferCount2 = _interopRequireDefault(_operatorsBufferCount);

	var _operatorsBufferTime = __webpack_require__(339);

	var _operatorsBufferTime2 = _interopRequireDefault(_operatorsBufferTime);

	var _operatorsBufferToggle = __webpack_require__(340);

	var _operatorsBufferToggle2 = _interopRequireDefault(_operatorsBufferToggle);

	var _operatorsBufferWhen = __webpack_require__(341);

	var _operatorsBufferWhen2 = _interopRequireDefault(_operatorsBufferWhen);

	var _operatorsSample = __webpack_require__(342);

	var _operatorsSample2 = _interopRequireDefault(_operatorsSample);

	var _operatorsSampleTime = __webpack_require__(343);

	var _operatorsSampleTime2 = _interopRequireDefault(_operatorsSampleTime);

	_Observable2['default'].defer = _observablesDeferObservable2['default'].create;
	_Observable2['default'].from = _observablesFromObservable2['default'].create;
	_Observable2['default'].fromArray = _observablesArrayObservable2['default'].create;
	_Observable2['default'].fromPromise = _observablesPromiseObservable2['default'].create;
	_Observable2['default'].of = _observablesArrayObservable2['default'].of;
	_Observable2['default'].range = _observablesRangeObservable2['default'].create;
	_Observable2['default'].fromEventPattern = _observablesFromEventPatternObservable2['default'].create;
	_Observable2['default'].forkJoin = _observablesForkJoinObservable2['default'].create;
	_Observable2['default']['throw'] = _observablesErrorObservable2['default'].create;
	_Observable2['default'].empty = _observablesEmptyObservable2['default'].create;
	_Observable2['default'].never = _observablesInfiniteObservable2['default'].create;
	_Observable2['default'].timer = _observablesTimerObservable2['default'].create;
	_Observable2['default'].interval = _observablesIntervalObservable2['default'].create;
	_Observable2['default'].fromEvent = _observablesFromEventObservable2['default'].create;
	var observableProto = _Observable2['default'].prototype;

	_Observable2['default'].concat = _operatorsConcatStatic2['default'];
	observableProto.concat = _operatorsConcat2['default'];
	observableProto.concatAll = _operatorsConcatAll2['default'];
	observableProto.concatMap = _operatorsConcatMap2['default'];
	observableProto.concatMapTo = _operatorsConcatMapTo2['default'];

	_Observable2['default'].merge = _operatorsMergeStatic2['default'];
	observableProto.merge = _operatorsMerge2['default'];
	observableProto.mergeAll = _operatorsMergeAll2['default'];
	observableProto.flatMap = _operatorsFlatMap2['default'];
	observableProto.flatMapTo = _operatorsFlatMapTo2['default'];
	observableProto.switchAll = _operatorsSwitchAll2['default'];
	observableProto.switchLatest = _operatorsSwitchLatest2['default'];
	observableProto.switchLatestTo = _operatorsSwitchLatestTo2['default'];
	observableProto.expand = _operatorsExpand2['default'];

	observableProto['do'] = _operatorsDo2['default'];
	observableProto.map = _operatorsMap2['default'];
	observableProto.mapTo = _operatorsMapTo2['default'];
	observableProto.toArray = _operatorsToArray2['default'];
	observableProto.count = _operatorsCount2['default'];
	observableProto.scan = _operatorsScan2['default'];
	observableProto.reduce = _operatorsReduce2['default'];
	observableProto.startWith = _operatorsStartWith2['default'];

	observableProto.take = _operatorsTake2['default'];
	observableProto.skip = _operatorsSkip2['default'];
	observableProto.takeUntil = _operatorsTakeUntil2['default'];
	observableProto.skipUntil = _operatorsSkipUntil2['default'];
	observableProto.filter = _operatorsFilter2['default'];
	observableProto.distinctUntilChanged = _operatorsDistinctUntilChanged2['default'];
	observableProto.distinctUntilKeyChanged = _operatorsDistinctUntilKeyChanged2['default'];

	_Observable2['default'].combineLatest = _operatorsCombineLatestStatic2['default'];
	observableProto.combineLatest = _operatorsCombineLatest2['default'];
	observableProto.combineAll = _operatorsCombineAll2['default'];
	observableProto.withLatestFrom = _operatorsWithLatestFrom2['default'];

	_Observable2['default'].zip = _operatorsZipStatic2['default'];
	observableProto.zip = _operatorsZip2['default'];
	observableProto.zipAll = _operatorsZipAll2['default'];

	observableProto.publish = _operatorsPublish2['default'];
	observableProto.publishBehavior = _operatorsPublishBehavior2['default'];
	observableProto.publishReplay = _operatorsPublishReplay2['default'];
	observableProto.multicast = _operatorsMulticast2['default'];

	observableProto.observeOn = _operatorsObserveOn2['default'];
	observableProto.subscribeOn = _operatorsSubscribeOn2['default'];

	observableProto.partition = _operatorsPartition2['default'];
	observableProto.toPromise = _operatorsToPromise2['default'];
	observableProto.defaultIfEmpty = _operatorsDefaultIfEmpty2['default'];
	observableProto.materialize = _operatorsMaterialize2['default'];

	observableProto['catch'] = _operatorsCatch2['default'];
	observableProto.retry = _operatorsRetry2['default'];
	observableProto.retryWhen = _operatorsRetryWhen2['default'];
	observableProto.repeat = _operatorsRepeat2['default'];

	observableProto['finally'] = _operatorsFinally2['default'];
	observableProto.timeout = _operatorsTimeout2['default'];
	observableProto.timeoutWith = _operatorsTimeoutWith2['default'];

	observableProto.groupBy = _operatorsGroupBy2['default'];
	observableProto.window = _operatorsWindow2['default'];
	observableProto.windowWhen = _operatorsWindowWhen2['default'];
	observableProto.windowToggle = _operatorsWindowToggle2['default'];
	observableProto.windowTime = _operatorsWindowTime2['default'];
	observableProto.windowCount = _operatorsWindowCount2['default'];

	observableProto.delay = _operatorsDelay2['default'];
	observableProto.throttle = _operatorsThrottle2['default'];
	observableProto.debounce = _operatorsDebounce2['default'];

	observableProto.buffer = _operatorsBuffer2['default'];
	observableProto.bufferCount = _operatorsBufferCount2['default'];
	observableProto.bufferTime = _operatorsBufferTime2['default'];
	observableProto.bufferToggle = _operatorsBufferToggle2['default'];
	observableProto.bufferWhen = _operatorsBufferWhen2['default'];

	observableProto.sample = _operatorsSample2['default'];
	observableProto.sampleTime = _operatorsSampleTime2['default'];
	var Scheduler = {
	    nextTick: _schedulersNextTick2['default'],
	    immediate: _schedulersImmediate2['default']
	};
	exports.Subject = _Subject2['default'];
	exports.Scheduler = Scheduler;
	exports.Observable = _Observable2['default'];
	exports.Subscriber = _Subscriber2['default'];
	exports.Subscription = _Subscription2['default'];
	exports.ReplaySubject = _subjectsReplaySubject2['default'];
	exports.BehaviorSubject = _subjectsBehaviorSubject2['default'];
	exports.ConnectableObservable = _observablesConnectableObservable2['default'];
	exports.Notification = _Notification2['default'];
	exports.VirtualTimeScheduler = _schedulersVirtualTimeScheduler2['default'];
	exports.TestScheduler = _schedulersTestScheduler2['default'];

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscriber = __webpack_require__(221);

	var _Subscriber2 = _interopRequireDefault(_Subscriber);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _subjectsSubjectSubscription = __webpack_require__(228);

	var _subjectsSubjectSubscription2 = _interopRequireDefault(_subjectsSubjectSubscription);

	var subscriptionAdd = _Subscription2['default'].prototype.add;
	var subscriptionRemove = _Subscription2['default'].prototype.remove;
	var subscriptionUnsubscribe = _Subscription2['default'].prototype.unsubscribe;
	var subscriberNext = _Subscriber2['default'].prototype.next;
	var subscriberError = _Subscriber2['default'].prototype.error;
	var subscriberComplete = _Subscriber2['default'].prototype.complete;
	var _subscriberNext = _Subscriber2['default'].prototype._next;
	var _subscriberError = _Subscriber2['default'].prototype._error;
	var _subscriberComplete = _Subscriber2['default'].prototype._complete;
	var _observableSubscribe = _Observable3['default'].prototype._subscribe;

	var Subject = (function (_Observable) {
	    _inherits(Subject, _Observable);

	    function Subject() {
	        _classCallCheck(this, Subject);

	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }

	        _Observable.call.apply(_Observable, [this].concat(args));
	        this.observers = [];
	        this.isUnsubscribed = false;
	        this.dispatching = false;
	        this.errorSignal = false;
	        this.completeSignal = false;
	    }

	    Subject.create = function create(source, destination) {
	        return new BidirectionalSubject(source, destination);
	    };

	    Subject.prototype.lift = function lift(operator) {
	        var subject = new BidirectionalSubject(this, this.destination || this);
	        subject.operator = operator;
	        return subject;
	    };

	    Subject.prototype._subscribe = function _subscribe(subscriber) {
	        if (subscriber.isUnsubscribed) {
	            return;
	        } else if (this.errorSignal) {
	            subscriber.error(this.errorInstance);
	            return;
	        } else if (this.completeSignal) {
	            subscriber.complete();
	            return;
	        } else if (this.isUnsubscribed) {
	            throw new Error("Cannot subscribe to a disposed Subject.");
	        }
	        this.observers.push(subscriber);
	        return new _subjectsSubjectSubscription2['default'](this, subscriber);
	    };

	    Subject.prototype.add = function add(subscription) {
	        subscriptionAdd.call(this, subscription);
	    };

	    Subject.prototype.remove = function remove(subscription) {
	        subscriptionRemove.call(this, subscription);
	    };

	    Subject.prototype.unsubscribe = function unsubscribe() {
	        this.observers = void 0;
	        subscriptionUnsubscribe.call(this);
	    };

	    Subject.prototype.next = function next(value) {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.dispatching = true;
	        this._next(value);
	        this.dispatching = false;
	        if (this.errorSignal) {
	            this.error(this.errorInstance);
	        } else if (this.completeSignal) {
	            this.complete();
	        }
	    };

	    Subject.prototype.error = function error(_error) {
	        if (this.isUnsubscribed || this.completeSignal) {
	            return;
	        }
	        this.errorSignal = true;
	        this.errorInstance = _error;
	        if (this.dispatching) {
	            return;
	        }
	        this._error(_error);
	        this.unsubscribe();
	    };

	    Subject.prototype.complete = function complete() {
	        if (this.isUnsubscribed || this.errorSignal) {
	            return;
	        }
	        this.completeSignal = true;
	        if (this.dispatching) {
	            return;
	        }
	        this._complete();
	        this.unsubscribe();
	    };

	    Subject.prototype._next = function _next(value) {
	        var index = -1;
	        var observers = this.observers.slice(0);
	        var len = observers.length;
	        while (++index < len) {
	            observers[index].next(value);
	        }
	    };

	    Subject.prototype._error = function _error(error) {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization -- block next, complete, and unsubscribe while dispatching
	        this.observers = void 0;
	        this.isUnsubscribed = true;
	        while (++index < len) {
	            observers[index].error(error);
	        }
	        this.isUnsubscribed = false;
	    };

	    Subject.prototype._complete = function _complete() {
	        var index = -1;
	        var observers = this.observers;
	        var len = observers.length;
	        // optimization -- block next, complete, and unsubscribe while dispatching
	        this.observers = void 0; // optimization
	        this.isUnsubscribed = true;
	        while (++index < len) {
	            observers[index].complete();
	        }
	        this.isUnsubscribed = false;
	    };

	    return Subject;
	})(_Observable3['default']);

	exports['default'] = Subject;

	var BidirectionalSubject = (function (_Subject) {
	    _inherits(BidirectionalSubject, _Subject);

	    function BidirectionalSubject(source, destination) {
	        _classCallCheck(this, BidirectionalSubject);

	        _Subject.call(this);
	        this.source = source;
	        this.destination = destination;
	    }

	    BidirectionalSubject.prototype._subscribe = function _subscribe(subscriber) {
	        return _observableSubscribe.call(this, subscriber);
	    };

	    BidirectionalSubject.prototype.next = function next(x) {
	        subscriberNext.call(this, x);
	    };

	    BidirectionalSubject.prototype.error = function error(e) {
	        subscriberError.call(this, e);
	    };

	    BidirectionalSubject.prototype.complete = function complete() {
	        subscriberComplete.call(this);
	    };

	    BidirectionalSubject.prototype._next = function _next(x) {
	        _subscriberNext.call(this, x);
	    };

	    BidirectionalSubject.prototype._error = function _error(e) {
	        _subscriberError.call(this, e);
	    };

	    BidirectionalSubject.prototype._complete = function _complete() {
	        _subscriberComplete.call(this);
	    };

	    return BidirectionalSubject;
	})(Subject);

	module.exports = exports['default'];

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber = __webpack_require__(221);

	var _Subscriber2 = _interopRequireDefault(_Subscriber);

	var _utilSymbol_observable = __webpack_require__(226);

	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */

	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is
	     * called when the Observable is initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or `complete` can be called to notify
	     * of a succesful completion.
	     */

	    function Observable(subscribe) {
	        _classCallCheck(this, Observable);

	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }

	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature.
	    /**
	     * @static
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @returns {Observable} a new cold observable
	     * @description creates a new cold Observable by calling the Observable constructor
	     */

	    /**
	     * @method lift
	     * @param {Operator} the operator defining the operation to take on the observable
	     * @returns {Observable} a new observable with the Operator applied
	     * @description creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     */

	    Observable.prototype.lift = function lift(operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };

	    /**
	     * @method Symbol.observable
	     * @returns {Observable} this instance of the observable
	     * @description an interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     */

	    Observable.prototype[_utilSymbol_observable2['default']] = function () {
	        return this;
	    };

	    /**
	     * @method subscribe
	     * @param {Observer|Function} observerOrNext (optional) either an observer defining all functions to be called,
	     *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
	     * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
	     *  the error will be thrown as unhandled
	     * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
	     * @returns {Subscription} a subscription reference to the registered handlers
	     * @description registers handlers for handling emitted values, error and completions from the observable, and
	     *  executes the observable's subscriber function, which will take action to set up the underlying data stream
	     */

	    Observable.prototype.subscribe = function subscribe(observerOrNext, error, complete) {
	        var subscriber = undefined;
	        if (observerOrNext && typeof observerOrNext === "object") {
	            if (observerOrNext instanceof _Subscriber2['default']) {
	                subscriber = observerOrNext;
	            } else {
	                subscriber = new _Subscriber2['default'](observerOrNext);
	            }
	        } else {
	            var next = observerOrNext;
	            subscriber = _Subscriber2['default'].create(next, error, complete);
	        }
	        subscriber.add(this._subscribe(subscriber));
	        return subscriber;
	    };

	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @returns {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */

	    Observable.prototype.forEach = function forEach(next) {
	        var _this = this;

	        return new Promise(function (resolve, reject) {
	            _this.subscribe(next, reject, resolve);
	        });
	    };

	    Observable.prototype._subscribe = function _subscribe(subscriber) {
	        return this.source._subscribe(this.operator.call(subscriber));
	    };

	    return Observable;
	})();

	exports['default'] = Observable;
	Observable.create = function (subscribe) {
	    return new Observable(subscribe);
	};
	module.exports = exports['default'];

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilNoop = __webpack_require__(222);

	var _utilNoop2 = _interopRequireDefault(_utilNoop);

	var _utilThrowError = __webpack_require__(223);

	var _utilThrowError2 = _interopRequireDefault(_utilThrowError);

	var _utilTryOrOnError = __webpack_require__(224);

	var _utilTryOrOnError2 = _interopRequireDefault(_utilTryOrOnError);

	var _Subscription2 = __webpack_require__(225);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var Subscriber = (function (_Subscription) {
	    _inherits(Subscriber, _Subscription);

	    function Subscriber(destination) {
	        _classCallCheck(this, Subscriber);

	        _Subscription.call(this);
	        this._isUnsubscribed = false;
	        this.destination = destination;
	        if (!destination) {
	            return;
	        }
	        var subscription = destination._subscription;
	        if (subscription) {
	            this._subscription = subscription;
	        } else if (destination instanceof Subscriber) {
	            this._subscription = destination;
	        }
	    }

	    Subscriber.create = function create(next, error, complete) {
	        var subscriber = new Subscriber();
	        subscriber._next = typeof next === "function" && _utilTryOrOnError2['default'](next) || _utilNoop2['default'];
	        subscriber._error = typeof error === "function" && error || _utilThrowError2['default'];
	        subscriber._complete = typeof complete === "function" && complete || _utilNoop2['default'];
	        return subscriber;
	    };

	    Subscriber.prototype._next = function _next(value) {
	        this.destination.next(value);
	    };

	    Subscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };

	    Subscriber.prototype._complete = function _complete() {
	        this.destination.complete();
	    };

	    Subscriber.prototype.add = function add(sub) {
	        // route add to the shared Subscription if it exists
	        var _subscription = this._subscription;
	        if (_subscription) {
	            _subscription.add(sub);
	        } else {
	            _Subscription.prototype.add.call(this, sub);
	        }
	    };

	    Subscriber.prototype.remove = function remove(sub) {
	        // route remove to the shared Subscription if it exists
	        if (this._subscription) {
	            this._subscription.remove(sub);
	        } else {
	            _Subscription.prototype.remove.call(this, sub);
	        }
	    };

	    Subscriber.prototype.unsubscribe = function unsubscribe() {
	        if (this._isUnsubscribed) {
	            return;
	        } else if (this._subscription) {
	            this._isUnsubscribed = true;
	        } else {
	            _Subscription.prototype.unsubscribe.call(this);
	        }
	    };

	    Subscriber.prototype.next = function next(value) {
	        if (!this.isUnsubscribed) {
	            this._next(value);
	        }
	    };

	    Subscriber.prototype.error = function error(_error2) {
	        if (!this.isUnsubscribed) {
	            this._error(_error2);
	            this.unsubscribe();
	        }
	    };

	    Subscriber.prototype.complete = function complete() {
	        if (!this.isUnsubscribed) {
	            this._complete();
	            this.unsubscribe();
	        }
	    };

	    _createClass(Subscriber, [{
	        key: 'isUnsubscribed',
	        get: function get() {
	            var subscription = this._subscription;
	            if (subscription) {
	                // route to the shared Subscription if it exists
	                return this._isUnsubscribed || subscription.isUnsubscribed;
	            } else {
	                return this._isUnsubscribed;
	            }
	        },
	        set: function set(value) {
	            var subscription = this._subscription;
	            if (subscription) {
	                // route to the shared Subscription if it exists
	                subscription.isUnsubscribed = Boolean(value);
	            } else {
	                this._isUnsubscribed = Boolean(value);
	            }
	        }
	    }]);

	    return Subscriber;
	})(_Subscription3['default']);

	exports['default'] = Subscriber;
	module.exports = exports['default'];

/***/ },
/* 222 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = noop;

	function noop() {}

	module.exports = exports["default"];

/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = throwError;

	function throwError(e) {
	  throw e;
	}

	module.exports = exports["default"];

/***/ },
/* 224 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = tryOrOnError;

	function tryOrOnError(target) {
	    function tryCatcher() {
	        try {
	            tryCatcher.target.apply(this, arguments);
	        } catch (e) {
	            this.error(e);
	        }
	    }
	    tryCatcher.target = target;
	    return tryCatcher;
	}

	module.exports = exports["default"];

/***/ },
/* 225 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Subscription = (function () {
	    function Subscription(_unsubscribe) {
	        _classCallCheck(this, Subscription);

	        this.isUnsubscribed = false;
	        if (_unsubscribe) {
	            this._unsubscribe = _unsubscribe;
	        }
	    }

	    Subscription.prototype._unsubscribe = function _unsubscribe() {};

	    Subscription.prototype.unsubscribe = function unsubscribe() {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var unsubscribe = this._unsubscribe;
	        var subscriptions = this._subscriptions;
	        this._subscriptions = void 0;
	        if (unsubscribe) {
	            unsubscribe.call(this);
	        }
	        if (subscriptions != null) {
	            var index = -1;
	            var len = subscriptions.length;
	            while (++index < len) {
	                subscriptions[index].unsubscribe();
	            }
	        }
	    };

	    Subscription.prototype.add = function add(subscription) {
	        // return early if:
	        //  1. the subscription is null
	        //  2. we're attempting to add our this
	        //  3. we're attempting to add the static `empty` Subscription
	        if (!subscription || subscription === this || subscription === Subscription.EMPTY) {
	            return;
	        }
	        var sub = subscription;
	        switch (typeof subscription) {
	            case "function":
	                sub = new Subscription(subscription);
	            case "object":
	                if (sub.isUnsubscribed || typeof sub.unsubscribe !== "function") {
	                    break;
	                } else if (this.isUnsubscribed) {
	                    sub.unsubscribe();
	                } else {
	                    var subscriptions = this._subscriptions || (this._subscriptions = []);
	                    subscriptions.push(sub);
	                }
	                break;
	            default:
	                throw new Error('Unrecognized subscription ' + subscription + ' added to Subscription.');
	        }
	    };

	    Subscription.prototype.remove = function remove(subscription) {
	        // return early if:
	        //  1. the subscription is null
	        //  2. we're attempting to remove ourthis
	        //  3. we're attempting to remove the static `empty` Subscription
	        if (subscription == null || subscription === this || subscription === Subscription.EMPTY) {
	            return;
	        }
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };

	    return Subscription;
	})();

	exports["default"] = Subscription;

	Subscription.EMPTY = (function (empty) {
	    empty.isUnsubscribed = true;
	    return empty;
	})(new Subscription());
	module.exports = exports["default"];

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _root = __webpack_require__(227);

	if (!_root.root.Symbol) {
	    _root.root.Symbol = {};
	}
	if (!_root.root.Symbol.observable) {
	    if (typeof _root.root.Symbol['for'] === 'function') {
	        _root.root.Symbol.observable = _root.root.Symbol['for']('observable');
	    } else {
	        _root.root.Symbol.observable = '@@observable';
	    }
	}
	exports['default'] = _root.root.Symbol.observable;
	module.exports = exports['default'];

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {'use strict';

	exports.__esModule = true;
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	var root = objectTypes[typeof self] && self || objectTypes[typeof window] && window;
	exports.root = root;
	var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
	var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
	var freeGlobal = objectTypes[typeof global] && global;
	if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
	    exports.root = root = freeGlobal;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)(module), (function() { return this; }())))

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subscription2 = __webpack_require__(225);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var SubjectSubscription = (function (_Subscription) {
	    _inherits(SubjectSubscription, _Subscription);

	    function SubjectSubscription(subject, observer) {
	        _classCallCheck(this, SubjectSubscription);

	        _Subscription.call(this);
	        this.subject = subject;
	        this.observer = observer;
	        this.isUnsubscribed = false;
	    }

	    SubjectSubscription.prototype.unsubscribe = function unsubscribe() {
	        if (this.isUnsubscribed) {
	            return;
	        }
	        this.isUnsubscribed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = void 0;
	        if (!observers || observers.length === 0 || subject.isUnsubscribed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.observer);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };

	    return SubjectSubscription;
	})(_Subscription3['default']);

	exports['default'] = SubjectSubscription;
	module.exports = exports['default'];

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _Subscription2 = __webpack_require__(225);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var VirtualTimeScheduler = (function () {
	    function VirtualTimeScheduler() {
	        _classCallCheck(this, VirtualTimeScheduler);

	        this.actions = [];
	        this.active = false;
	        this.scheduled = false;
	        this.index = 0;
	        this.sorted = false;
	        this.frame = 0;
	    }

	    VirtualTimeScheduler.prototype.now = function now() {
	        return 0;
	    };

	    VirtualTimeScheduler.prototype.sortActions = function sortActions() {
	        if (!this.sorted) {
	            this.actions.sort(function (a, b) {
	                return a.delay === b.delay ? a.index > b.index ? 1 : -1 : a.delay > b.delay ? 1 : -1;
	            });
	            this.sorted = true;
	        }
	    };

	    VirtualTimeScheduler.prototype.flush = function flush() {
	        this.sortActions();
	        var actions = this.actions;
	        while (actions.length > 0) {
	            var action = actions.shift();
	            this.frame = action.delay;
	            action.execute();
	        }
	        this.frame = 0;
	    };

	    VirtualTimeScheduler.prototype.schedule = function schedule(work, delay, state) {
	        if (delay === undefined) delay = 0;

	        this.sorted = false;
	        return new VirtualAction(this, work, this.index++).schedule(state, delay);
	    };

	    return VirtualTimeScheduler;
	})();

	exports["default"] = VirtualTimeScheduler;

	var VirtualAction = (function (_Subscription) {
	    _inherits(VirtualAction, _Subscription);

	    function VirtualAction(scheduler, work, index) {
	        _classCallCheck(this, VirtualAction);

	        _Subscription.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.index = index;
	    }

	    VirtualAction.prototype.schedule = function schedule(state) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        if (this.isUnsubscribed) {
	            return this;
	        }
	        var scheduler = this.scheduler;
	        var action = scheduler.frame === this.delay ? this : new VirtualAction(scheduler, this.work, scheduler.index += 1);
	        action.state = state;
	        action.delay = scheduler.frame + delay;
	        scheduler.actions.push(action);
	        return this;
	    };

	    VirtualAction.prototype.execute = function execute() {
	        if (this.isUnsubscribed) {
	            throw new Error("How did did we execute a canceled Action?");
	        }
	        this.work(this.state);
	    };

	    VirtualAction.prototype.unsubscribe = function unsubscribe() {
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = void 0;
	        this.state = void 0;
	        this.scheduler = void 0;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        _Subscription.prototype.unsubscribe.call(this);
	    };

	    return VirtualAction;
	})(_Subscription3["default"]);

	module.exports = exports["default"];

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable = __webpack_require__(220);

	var _Observable2 = _interopRequireDefault(_Observable);

	var _VirtualTimeScheduler2 = __webpack_require__(229);

	var _VirtualTimeScheduler3 = _interopRequireDefault(_VirtualTimeScheduler2);

	var _Notification = __webpack_require__(231);

	var _Notification2 = _interopRequireDefault(_Notification);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var TestScheduler = (function (_VirtualTimeScheduler) {
	    _inherits(TestScheduler, _VirtualTimeScheduler);

	    function TestScheduler(assertDeepEqual) {
	        _classCallCheck(this, TestScheduler);

	        _VirtualTimeScheduler.call(this);
	        this.assertDeepEqual = assertDeepEqual;
	        this.flushTests = [];
	    }

	    TestScheduler.prototype.createColdObservable = function createColdObservable(marbles, values, error) {
	        var _this = this;

	        if (marbles.indexOf('^') !== -1) {
	            throw new Error('cold observable cannot have subscription offset "^"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        return _Observable2['default'].create(function (subscriber) {
	            messages.forEach(function (_ref) {
	                var notification = _ref.notification;
	                var frame = _ref.frame;

	                _this.schedule(function () {
	                    notification.observe(subscriber);
	                }, frame);
	            }, _this);
	        });
	    };

	    TestScheduler.prototype.createHotObservable = function createHotObservable(marbles, values, error) {
	        var _this2 = this;

	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var subject = new _Subject2['default']();
	        messages.forEach(function (_ref2) {
	            var notification = _ref2.notification;
	            var frame = _ref2.frame;

	            _this2.schedule(function () {
	                notification.observe(subject);
	            }, frame);
	        }, this);
	        return subject;
	    };

	    TestScheduler.prototype.expect = function expect(observable) {
	        var _this3 = this;

	        var actual = [];
	        var flushTest = {
	            observable: observable, actual: actual, marbles: null, ready: false
	        };
	        this.schedule(function () {
	            observable.subscribe(function (value) {
	                actual.push({ frame: _this3.frame, notification: _Notification2['default'].createNext(value) });
	            }, function (err) {
	                actual.push({ frame: _this3.frame, notification: _Notification2['default'].createError(err) });
	            }, function () {
	                actual.push({ frame: _this3.frame, notification: _Notification2['default'].createComplete() });
	            });
	        }, 0);
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function toBe(marbles, values, errorValue) {
	                flushTest.ready = true;
	                flushTest.marbles = marbles;
	                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue);
	            }
	        };
	    };

	    TestScheduler.prototype.flush = function flush() {
	        _VirtualTimeScheduler.prototype.flush.call(this);
	        var flushTests = this.flushTests.filter(function (test) {
	            return test.ready;
	        });
	        while (flushTests.length > 0) {
	            var test = flushTests.shift();
	            this.assertDeepEqual(test.actual, test.expected);
	        }
	    };

	    TestScheduler.parseMarbles = function parseMarbles(marbles, values, errorValue) {
	        var len = marbles.length;
	        var results = [];
	        var subIndex = marbles.indexOf('^');
	        var frameOffset = subIndex === -1 ? 0 : subIndex * -10;
	        for (var i = 0; i < len; i++) {
	            var frame = i * 10;
	            var notification = undefined;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                    break;
	                case '|':
	                    notification = _Notification2['default'].createComplete();
	                    break;
	                case '^':
	                    break;
	                case '#':
	                    notification = _Notification2['default'].createError(errorValue || 'error');
	                    break;
	                default:
	                    notification = _Notification2['default'].createNext(values[c]);
	                    break;
	            }
	            frame += frameOffset;
	            if (notification) {
	                results.push({ notification: notification, frame: frame });
	            }
	        }
	        return results;
	    };

	    return TestScheduler;
	})(_VirtualTimeScheduler3['default']);

	exports['default'] = TestScheduler;
	module.exports = exports['default'];

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Observable = __webpack_require__(220);

	var _Observable2 = _interopRequireDefault(_Observable);

	var Notification = (function () {
	    function Notification(kind, value, exception) {
	        _classCallCheck(this, Notification);

	        this.kind = kind;
	        this.value = value;
	        this.exception = exception;
	        this.hasValue = kind === 'N';
	    }

	    Notification.prototype.observe = function observe(observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next(this.value);
	            case 'E':
	                return observer.error(this.exception);
	            case 'C':
	                return observer.complete();
	        }
	    };

	    Notification.prototype['do'] = function _do(next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next(this.value);
	            case 'E':
	                return error(this.exception);
	            case 'C':
	                return complete();
	        }
	    };

	    Notification.prototype.accept = function accept(nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        } else {
	            return this['do'](nextOrObserver, error, complete);
	        }
	    };

	    Notification.prototype.toObservable = function toObservable() {
	        var kind = this.kind;
	        var value = this.value;
	        switch (kind) {
	            case 'N':
	                return _Observable2['default'].of(value);
	            case 'E':
	                return _Observable2['default']['throw'](value);
	            case 'C':
	                return _Observable2['default'].empty();
	        }
	    };

	    Notification.createNext = function createNext(value) {
	        return new Notification('N', value);
	    };

	    Notification.createError = function createError(err) {
	        return new Notification('E', undefined, err);
	    };

	    Notification.createComplete = function createComplete() {
	        return new Notification('C');
	    };

	    return Notification;
	})();

	exports['default'] = Notification;
	module.exports = exports['default'];

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _ImmediateScheduler = __webpack_require__(233);

	var _ImmediateScheduler2 = _interopRequireDefault(_ImmediateScheduler);

	exports['default'] = new _ImmediateScheduler2['default']();
	module.exports = exports['default'];

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _ImmediateAction = __webpack_require__(234);

	var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);

	var _FutureAction = __webpack_require__(235);

	var _FutureAction2 = _interopRequireDefault(_FutureAction);

	var ImmediateScheduler = (function () {
	    function ImmediateScheduler() {
	        _classCallCheck(this, ImmediateScheduler);

	        this.actions = [];
	        this.active = false;
	        this.scheduled = false;
	    }

	    ImmediateScheduler.prototype.now = function now() {
	        return Date.now();
	    };

	    ImmediateScheduler.prototype.flush = function flush() {
	        if (this.active || this.scheduled) {
	            return;
	        }
	        this.active = true;
	        var actions = this.actions;
	        for (var action = undefined; action = actions.shift();) {
	            action.execute();
	        }
	        this.active = false;
	    };

	    ImmediateScheduler.prototype.schedule = function schedule(work, delay, state) {
	        if (delay === undefined) delay = 0;

	        return delay <= 0 ? this.scheduleNow(work, state) : this.scheduleLater(work, delay, state);
	    };

	    ImmediateScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
	        return new _ImmediateAction2['default'](this, work).schedule(state);
	    };

	    ImmediateScheduler.prototype.scheduleLater = function scheduleLater(work, delay, state) {
	        return new _FutureAction2['default'](this, work).schedule(state, delay);
	    };

	    return ImmediateScheduler;
	})();

	exports['default'] = ImmediateScheduler;
	module.exports = exports['default'];

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subscription2 = __webpack_require__(225);

	var _Subscription3 = _interopRequireDefault(_Subscription2);

	var ImmediateAction = (function (_Subscription) {
	    _inherits(ImmediateAction, _Subscription);

	    function ImmediateAction(scheduler, work) {
	        _classCallCheck(this, ImmediateAction);

	        _Subscription.call(this);
	        this.scheduler = scheduler;
	        this.work = work;
	    }

	    ImmediateAction.prototype.schedule = function schedule(state) {
	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        scheduler.flush();
	        return this;
	    };

	    ImmediateAction.prototype.execute = function execute() {
	        if (this.isUnsubscribed) {
	            throw new Error("How did did we execute a canceled Action?");
	        }
	        this.work(this.state);
	    };

	    ImmediateAction.prototype.unsubscribe = function unsubscribe() {
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = void 0;
	        this.state = void 0;
	        this.scheduler = void 0;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        _Subscription.prototype.unsubscribe.call(this);
	    };

	    return ImmediateAction;
	})(_Subscription3["default"]);

	exports["default"] = ImmediateAction;
	module.exports = exports["default"];

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ImmediateAction2 = __webpack_require__(234);

	var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);

	var FutureAction = (function (_ImmediateAction) {
	    _inherits(FutureAction, _ImmediateAction);

	    function FutureAction(scheduler, work) {
	        _classCallCheck(this, FutureAction);

	        _ImmediateAction.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }

	    FutureAction.prototype.schedule = function schedule(state) {
	        var _this = this;

	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.delay = delay;
	        this.state = state;
	        var id = this.id;
	        if (id != null) {
	            this.id = undefined;
	            clearTimeout(id);
	        }
	        var scheduler = this.scheduler;
	        this.id = setTimeout(function () {
	            _this.id = void 0;
	            scheduler.actions.push(_this);
	            scheduler.flush();
	        }, this.delay);
	        return this;
	    };

	    FutureAction.prototype.unsubscribe = function unsubscribe() {
	        var id = this.id;
	        if (id != null) {
	            this.id = void 0;
	            clearTimeout(id);
	        }
	        _ImmediateAction.prototype.unsubscribe.call(this);
	    };

	    return FutureAction;
	})(_ImmediateAction3['default']);

	exports['default'] = FutureAction;
	module.exports = exports['default'];

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _NextTickScheduler = __webpack_require__(237);

	var _NextTickScheduler2 = _interopRequireDefault(_NextTickScheduler);

	exports['default'] = new _NextTickScheduler2['default']();
	module.exports = exports['default'];

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ImmediateScheduler2 = __webpack_require__(233);

	var _ImmediateScheduler3 = _interopRequireDefault(_ImmediateScheduler2);

	var _NextTickAction = __webpack_require__(238);

	var _NextTickAction2 = _interopRequireDefault(_NextTickAction);

	var _ImmediateAction = __webpack_require__(234);

	var _ImmediateAction2 = _interopRequireDefault(_ImmediateAction);

	var NextTickScheduler = (function (_ImmediateScheduler) {
	    _inherits(NextTickScheduler, _ImmediateScheduler);

	    function NextTickScheduler() {
	        _classCallCheck(this, NextTickScheduler);

	        _ImmediateScheduler.apply(this, arguments);
	    }

	    NextTickScheduler.prototype.scheduleNow = function scheduleNow(work, state) {
	        return (this.scheduled ? new _ImmediateAction2['default'](this, work) : new _NextTickAction2['default'](this, work)).schedule(state);
	    };

	    return NextTickScheduler;
	})(_ImmediateScheduler3['default']);

	exports['default'] = NextTickScheduler;
	module.exports = exports['default'];

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilImmediate = __webpack_require__(239);

	var _ImmediateAction2 = __webpack_require__(234);

	var _ImmediateAction3 = _interopRequireDefault(_ImmediateAction2);

	var NextTickAction = (function (_ImmediateAction) {
	    _inherits(NextTickAction, _ImmediateAction);

	    function NextTickAction() {
	        _classCallCheck(this, NextTickAction);

	        _ImmediateAction.apply(this, arguments);
	    }

	    NextTickAction.prototype.schedule = function schedule(state) {
	        var _this = this;

	        if (this.isUnsubscribed) {
	            return this;
	        }
	        this.state = state;
	        var scheduler = this.scheduler;
	        scheduler.actions.push(this);
	        if (!scheduler.scheduled) {
	            scheduler.scheduled = true;
	            this.id = _utilImmediate.Immediate.setImmediate(function () {
	                _this.id = void 0;
	                _this.scheduler.scheduled = false;
	                _this.scheduler.flush();
	            });
	        }
	        return this;
	    };

	    NextTickAction.prototype.unsubscribe = function unsubscribe() {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        _ImmediateAction.prototype.unsubscribe.call(this);
	        if (scheduler.actions.length === 0) {
	            scheduler.active = false;
	            scheduler.scheduled = false;
	            if (id) {
	                this.id = void 0;
	                _utilImmediate.Immediate.clearImmediate(id);
	            }
	        }
	    };

	    return NextTickAction;
	})(_ImmediateAction3['default']);

	exports['default'] = NextTickAction;
	module.exports = exports['default'];

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate) {/**
	All credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	"use strict";

	exports.__esModule = true;

	var _root = __webpack_require__(227);

	var Immediate = {
	    setImmediate: function setImmediate(x) {
	        return 0;
	    },
	    clearImmediate: function clearImmediate(id) {}
	};
	exports.Immediate = Immediate;
	if (_root.root && _root.root.setImmediate) {
	    Immediate.setImmediate = _root.root.setImmediate;
	    Immediate.clearImmediate = _root.root.clearImmediate;
	} else {
	    exports.Immediate = Immediate = (function (global, Immediate) {
	        var nextHandle = 1,
	            // Spec says greater than zero
	        tasksByHandle = {},
	            currentlyRunningATask = false,
	            doc = global.document,
	            setImmediate;
	        // Don't get fooled by e.g. browserify environments.
	        if (({}).toString.call(global.process) === "[object process]") {
	            // For Node.js before 0.9
	            setImmediate = installNextTickImplementation();
	        } else if (canUsePostMessage()) {
	            // For non-IE10 modern browsers
	            setImmediate = installPostMessageImplementation();
	        } else if (global.MessageChannel) {
	            // For web workers, where supported
	            setImmediate = installMessageChannelImplementation();
	        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	            // For IE 68
	            setImmediate = installReadyStateChangeImplementation();
	        } else {
	            // For older browsers
	            setImmediate = installSetTimeoutImplementation();
	        }
	        Immediate.setImmediate = setImmediate;
	        Immediate.clearImmediate = clearImmediate;
	        return Immediate;
	        function clearImmediate(handle) {
	            delete tasksByHandle[handle];
	        }
	        function addFromSetImmediateArguments(args) {
	            tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
	            return nextHandle++;
	        }
	        // This function accepts the same arguments as setImmediate, but
	        // returns a function that requires no arguments.
	        function partiallyApplied(handler) {
	            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	                args[_key - 1] = arguments[_key];
	            }

	            return function () {
	                if (typeof handler === "function") {
	                    handler.apply(undefined, args);
	                } else {
	                    new Function("" + handler)();
	                }
	            };
	        }
	        function runIfPresent(handle) {
	            // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	            // So if we're currently running a task, we'll need to delay this invocation.
	            if (currentlyRunningATask) {
	                // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	                // "too much recursion" error.
	                setTimeout(partiallyApplied(runIfPresent, handle), 0);
	            } else {
	                var task = tasksByHandle[handle];
	                if (task) {
	                    currentlyRunningATask = true;
	                    try {
	                        task();
	                    } finally {
	                        clearImmediate(handle);
	                        currentlyRunningATask = false;
	                    }
	                }
	            }
	        }
	        function installNextTickImplementation() {
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                global.process.nextTick(partiallyApplied(runIfPresent, handle));
	                return handle;
	            };
	        }
	        function canUsePostMessage() {
	            // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	            // where `global.postMessage` means something completely different and can't be used for this purpose.
	            if (global.postMessage && !global.importScripts) {
	                var postMessageIsAsynchronous = true;
	                var oldOnMessage = global.onmessage;
	                global.onmessage = function () {
	                    postMessageIsAsynchronous = false;
	                };
	                global.postMessage("", "*");
	                global.onmessage = oldOnMessage;
	                return postMessageIsAsynchronous;
	            }
	        }
	        function installPostMessageImplementation() {
	            // Installs an event handler on `global` for the `message` event: see
	            // * https://developer.mozilla.org/en/DOM/window.postMessage
	            // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	            var messagePrefix = "setImmediate$" + Math.random() + "$";
	            var onGlobalMessage = function onGlobalMessage(event) {
	                if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
	                    runIfPresent(+event.data.slice(messagePrefix.length));
	                }
	            };
	            if (global.addEventListener) {
	                global.addEventListener("message", onGlobalMessage, false);
	            } else {
	                global.attachEvent("onmessage", onGlobalMessage);
	            }
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                global.postMessage(messagePrefix + handle, "*");
	                return handle;
	            };
	        }
	        function installMessageChannelImplementation() {
	            var channel = new MessageChannel();
	            channel.port1.onmessage = function (event) {
	                var handle = event.data;
	                runIfPresent(handle);
	            };
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                channel.port2.postMessage(handle);
	                return handle;
	            };
	        }
	        function installReadyStateChangeImplementation() {
	            var html = doc.documentElement;
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	                // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	                var script = doc.createElement("script");
	                script.onreadystatechange = function () {
	                    runIfPresent(handle);
	                    script.onreadystatechange = null;
	                    html.removeChild(script);
	                    script = null;
	                };
	                html.appendChild(script);
	                return handle;
	            };
	        }
	        function installSetTimeoutImplementation() {
	            return function setImmediate() {
	                var handle = addFromSetImmediateArguments(arguments);
	                setTimeout(partiallyApplied(runIfPresent, handle), 0);
	                return handle;
	            };
	        }
	    })(_root.root, Immediate);
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24).clearImmediate))

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subject2 = __webpack_require__(219);

	var _Subject3 = _interopRequireDefault(_Subject2);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var ReplaySubject = (function (_Subject) {
	    _inherits(ReplaySubject, _Subject);

	    function ReplaySubject(bufferSize, _windowTime, scheduler) {
	        if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	        if (_windowTime === undefined) _windowTime = Number.POSITIVE_INFINITY;

	        _classCallCheck(this, ReplaySubject);

	        _Subject.call(this);
	        this.events = [];
	        this.bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = _windowTime < 1 ? 1 : _windowTime;
	        this.scheduler = scheduler;
	    }

	    ReplaySubject.prototype._next = function _next(value) {
	        var now = this._getNow();
	        this.events.push(new ReplayEvent(now, value));
	        this._getEvents(now);
	        _Subject.prototype._next.call(this, value);
	    };

	    ReplaySubject.prototype._subscribe = function _subscribe(subscriber) {
	        var events = this._getEvents(this._getNow());
	        var index = -1;
	        var len = events.length;
	        while (!subscriber.isUnsubscribed && ++index < len) {
	            subscriber.next(events[index].value);
	        }
	        return _Subject.prototype._subscribe.call(this, subscriber);
	    };

	    ReplaySubject.prototype._getNow = function _getNow() {
	        return (this.scheduler || _schedulersImmediate2['default']).now();
	    };

	    ReplaySubject.prototype._getEvents = function _getEvents(now) {
	        var bufferSize = this.bufferSize;
	        var _windowTime = this._windowTime;
	        var events = this.events;
	        var eventsCount = events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if (now - events[spliceCount].time < _windowTime) {
	                break;
	            }
	            spliceCount += 1;
	        }
	        if (eventsCount > bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - bufferSize);
	        }
	        if (spliceCount > 0) {
	            events.splice(0, spliceCount);
	        }
	        return events;
	    };

	    return ReplaySubject;
	})(_Subject3['default']);

	exports['default'] = ReplaySubject;

	var ReplayEvent = function ReplayEvent(time, value) {
	    _classCallCheck(this, ReplayEvent);

	    this.time = time;
	    this.value = value;
	};

	module.exports = exports['default'];

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subject2 = __webpack_require__(219);

	var _Subject3 = _interopRequireDefault(_Subject2);

	var BehaviorSubject = (function (_Subject) {
	    _inherits(BehaviorSubject, _Subject);

	    function BehaviorSubject(value) {
	        _classCallCheck(this, BehaviorSubject);

	        _Subject.call(this);
	        this.value = value;
	    }

	    BehaviorSubject.prototype._subscribe = function _subscribe(subscriber) {
	        var subscription = _Subject.prototype._subscribe.call(this, subscriber);
	        if (!subscription) {
	            return;
	        } else if (!subscription.isUnsubscribed) {
	            subscriber.next(this.value);
	        }
	        return subscription;
	    };

	    BehaviorSubject.prototype._next = function _next(value) {
	        _Subject.prototype._next.call(this, this.value = value);
	    };

	    return BehaviorSubject;
	})(_Subject3['default']);

	exports['default'] = BehaviorSubject;
	module.exports = exports['default'];

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable3 = __webpack_require__(220);

	var _Observable4 = _interopRequireDefault(_Observable3);

	var _Subscription3 = __webpack_require__(225);

	var _Subscription4 = _interopRequireDefault(_Subscription3);

	var ConnectableObservable = (function (_Observable) {
	    _inherits(ConnectableObservable, _Observable);

	    function ConnectableObservable(source, subjectFactory) {
	        _classCallCheck(this, ConnectableObservable);

	        _Observable.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	    }

	    ConnectableObservable.prototype._subscribe = function _subscribe(subscriber) {
	        return this._getSubject().subscribe(subscriber);
	    };

	    ConnectableObservable.prototype._getSubject = function _getSubject() {
	        var subject = this.subject;
	        if (subject && !subject.isUnsubscribed) {
	            return subject;
	        }
	        return this.subject = this.subjectFactory();
	    };

	    ConnectableObservable.prototype.connect = function connect() {
	        var source = this.source;
	        var subscription = this.subscription;
	        if (subscription && !subscription.isUnsubscribed) {
	            return subscription;
	        }
	        subscription = source.subscribe(this._getSubject());
	        subscription.add(new ConnectableSubscription(this));
	        return this.subscription = subscription;
	    };

	    ConnectableObservable.prototype.refCount = function refCount() {
	        return new RefCountObservable(this);
	    };

	    return ConnectableObservable;
	})(_Observable4['default']);

	exports['default'] = ConnectableObservable;

	var ConnectableSubscription = (function (_Subscription) {
	    _inherits(ConnectableSubscription, _Subscription);

	    function ConnectableSubscription(connectable) {
	        _classCallCheck(this, ConnectableSubscription);

	        _Subscription.call(this);
	        this.connectable = connectable;
	    }

	    ConnectableSubscription.prototype._unsubscribe = function _unsubscribe() {
	        var connectable = this.connectable;
	        connectable.subject = void 0;
	        connectable.subscription = void 0;
	        this.connectable = void 0;
	    };

	    return ConnectableSubscription;
	})(_Subscription4['default']);

	var RefCountObservable = (function (_Observable2) {
	    _inherits(RefCountObservable, _Observable2);

	    function RefCountObservable(connectable) {
	        var refCount = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        _classCallCheck(this, RefCountObservable);

	        _Observable2.call(this);
	        this.connectable = connectable;
	        this.refCount = refCount;
	    }

	    RefCountObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var connectable = this.connectable;
	        var subscription = connectable.subscribe(subscriber);
	        if (++this.refCount === 1) {
	            this.connection = connectable.connect();
	        }
	        subscription.add(new RefCountSubscription(this));
	        return subscription;
	    };

	    return RefCountObservable;
	})(_Observable4['default']);

	var RefCountSubscription = (function (_Subscription2) {
	    _inherits(RefCountSubscription, _Subscription2);

	    function RefCountSubscription(refCountObservable) {
	        _classCallCheck(this, RefCountSubscription);

	        _Subscription2.call(this);
	        this.refCountObservable = refCountObservable;
	    }

	    RefCountSubscription.prototype._unsubscribe = function _unsubscribe() {
	        var observable = this.refCountObservable;
	        if (--observable.refCount === 0) {
	            observable.connection.unsubscribe();
	            observable.connection = void 0;
	        }
	    };

	    return RefCountSubscription;
	})(_Subscription4['default']);

	module.exports = exports['default'];

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _ScalarObservable = __webpack_require__(244);

	var _ScalarObservable2 = _interopRequireDefault(_ScalarObservable);

	var _EmptyObservable = __webpack_require__(245);

	var _EmptyObservable2 = _interopRequireDefault(_EmptyObservable);

	var ArrayObservable = (function (_Observable) {
	    _inherits(ArrayObservable, _Observable);

	    function ArrayObservable(array, scheduler) {
	        _classCallCheck(this, ArrayObservable);

	        _Observable.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	    }

	    ArrayObservable.create = function create(array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };

	    ArrayObservable.of = function of() {
	        for (var _len = arguments.length, array = Array(_len), _key = 0; _key < _len; _key++) {
	            array[_key] = arguments[_key];
	        }

	        var scheduler = array[array.length - 1];
	        if (scheduler && typeof scheduler.schedule === "function") {
	            array.pop();
	        } else {
	            scheduler = void 0;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        } else if (len === 1) {
	            return new _ScalarObservable2['default'](array[0], scheduler);
	        } else {
	            return new _EmptyObservable2['default'](scheduler);
	        }
	    };

	    ArrayObservable.dispatch = function dispatch(state) {
	        var array = state.array;
	        var index = state.index;
	        var count = state.count;
	        var subscriber = state.subscriber;

	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };

	    ArrayObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            }));
	        } else {
	            do {
	                if (index >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(array[index++]);
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };

	    return ArrayObservable;
	})(_Observable3['default']);

	exports['default'] = ArrayObservable;
	module.exports = exports['default'];

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var ScalarObservable = (function (_Observable) {
	    _inherits(ScalarObservable, _Observable);

	    function ScalarObservable(value, scheduler) {
	        _classCallCheck(this, ScalarObservable);

	        _Observable.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	    }

	    ScalarObservable.create = function create(value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };

	    ScalarObservable.dispatch = function dispatch(state) {
	        var done = state.done;
	        var value = state.value;
	        var subscriber = state.subscriber;

	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };

	    ScalarObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            }));
	        } else {
	            subscriber.next(value);
	            if (!subscriber.isUnsubscribed) {
	                subscriber.complete();
	            }
	        }
	    };

	    return ScalarObservable;
	})(_Observable3['default']);

	exports['default'] = ScalarObservable;
	module.exports = exports['default'];

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var EmptyObservable = (function (_Observable) {
	    _inherits(EmptyObservable, _Observable);

	    function EmptyObservable(scheduler) {
	        _classCallCheck(this, EmptyObservable);

	        _Observable.call(this);
	        this.scheduler = scheduler;
	    }

	    EmptyObservable.create = function create(scheduler) {
	        return new EmptyObservable(scheduler);
	    };

	    EmptyObservable.dispatch = function dispatch(_ref) {
	        var subscriber = _ref.subscriber;

	        subscriber.complete();
	    };

	    EmptyObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber }));
	        } else {
	            subscriber.complete();
	        }
	    };

	    return EmptyObservable;
	})(_Observable3['default']);

	exports['default'] = EmptyObservable;
	module.exports = exports['default'];

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var DeferObservable = (function (_Observable) {
	    _inherits(DeferObservable, _Observable);

	    function DeferObservable(observableFactory) {
	        _classCallCheck(this, DeferObservable);

	        _Observable.call(this);
	        this.observableFactory = observableFactory;
	    }

	    DeferObservable.create = function create(observableFactory) {
	        return new DeferObservable(observableFactory);
	    };

	    DeferObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var result = _utilTryCatch2['default'](this.observableFactory)();
	        if (result === _utilErrorObject.errorObject) {
	            subscriber.error(_utilErrorObject.errorObject.e);
	        } else {
	            result.subscribe(subscriber);
	        }
	    };

	    return DeferObservable;
	})(_Observable3['default']);

	exports['default'] = DeferObservable;
	module.exports = exports['default'];

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = tryCatch;

	var _errorObject = __webpack_require__(248);

	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    } catch (e) {
	        _errorObject.errorObject.e = e;
	        return _errorObject.errorObject;
	    }
	}

	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	;
	module.exports = exports['default'];

/***/ },
/* 248 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	var errorObject = { e: {} };
	exports.errorObject = errorObject;

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var ErrorObservable = (function (_Observable) {
	    _inherits(ErrorObservable, _Observable);

	    function ErrorObservable(error, scheduler) {
	        _classCallCheck(this, ErrorObservable);

	        _Observable.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }

	    ErrorObservable.create = function create(error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };

	    ErrorObservable.dispatch = function dispatch(_ref) {
	        var error = _ref.error;
	        var subscriber = _ref.subscriber;

	        subscriber.error(error);
	    };

	    ErrorObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            }));
	        } else {
	            subscriber.error(error);
	        }
	    };

	    return ErrorObservable;
	})(_Observable3['default']);

	exports['default'] = ErrorObservable;
	module.exports = exports['default'];

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var InfiniteObservable = (function (_Observable) {
	    _inherits(InfiniteObservable, _Observable);

	    function InfiniteObservable() {
	        _classCallCheck(this, InfiniteObservable);

	        _Observable.call(this);
	    }

	    InfiniteObservable.create = function create() {
	        return new InfiniteObservable();
	    };

	    InfiniteObservable.prototype._subscribe = function _subscribe(subscriber) {};

	    return InfiniteObservable;
	})(_Observable3['default']);

	exports['default'] = InfiniteObservable;
	module.exports = exports['default'];

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilIsNumeric = __webpack_require__(252);

	var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var IntervalObservable = (function (_Observable) {
	    _inherits(IntervalObservable, _Observable);

	    function IntervalObservable() {
	        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	        _classCallCheck(this, IntervalObservable);

	        _Observable.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!_utilIsNumeric2['default'](period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== "function") {
	            this.scheduler = _schedulersNextTick2['default'];
	        }
	    }

	    IntervalObservable.create = function create() {
	        var period = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	        return new IntervalObservable(period, scheduler);
	    };

	    IntervalObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var subscriber = state.subscriber;
	        var period = state.period;

	        subscriber.next(index);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };

	    IntervalObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };

	    return IntervalObservable;
	})(_Observable3['default']);

	exports['default'] = IntervalObservable;
	module.exports = exports['default'];

/***/ },
/* 252 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = isNumeric;
	var is_array = Array.isArray;

	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !is_array(val) && val - parseFloat(val) + 1 >= 0;
	}

	;
	module.exports = exports["default"];

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var PromiseObservable = (function (_Observable) {
	    _inherits(PromiseObservable, _Observable);

	    function PromiseObservable(promise, scheduler) {
	        _classCallCheck(this, PromiseObservable);

	        _Observable.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	        this._isScalar = false;
	    }

	    PromiseObservable.create = function create(promise) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

	        return new PromiseObservable(promise, scheduler);
	    };

	    PromiseObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var _this = this;

	        var scheduler = this.scheduler;
	        var promise = this.promise;
	        if (scheduler === _schedulersImmediate2['default']) {
	            if (this._isScalar) {
	                subscriber.next(this.value);
	                subscriber.complete();
	            } else {
	                promise.then(function (value) {
	                    _this._isScalar = true;
	                    _this.value = value;
	                    subscriber.next(value);
	                    subscriber.complete();
	                }, function (err) {
	                    return subscriber.error(err);
	                });
	            }
	        } else {
	            var _ret = (function () {
	                var subscription = new _Subscription2['default']();
	                if (_this._isScalar) {
	                    var value = _this.value;
	                    subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                } else {
	                    promise.then(function (value) {
	                        _this._isScalar = true;
	                        _this.value = value;
	                        subscription.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }, function (err) {
	                        return subscription.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    });
	                }
	                return {
	                    v: subscription
	                };
	            })();

	            if (typeof _ret === 'object') return _ret.v;
	        }
	    };

	    return PromiseObservable;
	})(_Observable3['default']);

	exports['default'] = PromiseObservable;

	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;

	    subscriber.next(value);
	    subscriber.complete();
	}
	function dispatchError(_ref2) {
	    var err = _ref2.err;
	    var subscriber = _ref2.subscriber;

	    subscriber.error(err);
	}
	module.exports = exports['default'];

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var RangeObservable = (function (_Observable) {
	    _inherits(RangeObservable, _Observable);

	    function RangeObservable(start, end, scheduler) {
	        _classCallCheck(this, RangeObservable);

	        _Observable.call(this);
	        this.start = start;
	        this.end = end;
	        this.scheduler = scheduler;
	    }

	    RangeObservable.create = function create(start, end, scheduler) {
	        if (start === undefined) start = 0;
	        if (end === undefined) end = 0;

	        return new RangeObservable(start, end, scheduler);
	    };

	    RangeObservable.dispatch = function dispatch(state) {
	        var start = state.start;
	        var index = state.index;
	        var end = state.end;
	        var subscriber = state.subscriber;

	        if (index >= end) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };

	    RangeObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var start = this.start;
	        var end = this.end;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, end: end, start: start, subscriber: subscriber
	            }));
	        } else {
	            do {
	                if (index++ >= end) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };

	    return RangeObservable;
	})(_Observable3['default']);

	exports['default'] = RangeObservable;
	module.exports = exports['default'];

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _utilIsNumeric = __webpack_require__(252);

	var _utilIsNumeric2 = _interopRequireDefault(_utilIsNumeric);

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var TimerObservable = (function (_Observable) {
	    _inherits(TimerObservable, _Observable);

	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === undefined) dueTime = 0;

	        _classCallCheck(this, TimerObservable);

	        _Observable.call(this);
	        this.dueTime = dueTime;
	        this.period = period;
	        this.scheduler = scheduler;
	        if (_utilIsNumeric2['default'](period)) {
	            this._period = Number(period) < 1 && 1 || Number(period);
	        } else if (period && typeof period.schedule === "function") {
	            scheduler = period;
	        }
	        if (!scheduler || typeof scheduler.schedule !== "function") {
	            scheduler = _schedulersNextTick2['default'];
	        }
	        this.scheduler = scheduler;
	    }

	    TimerObservable.create = function create(dueTime, period, scheduler) {
	        if (dueTime === undefined) dueTime = 0;

	        return new TimerObservable(dueTime, period, scheduler);
	    };

	    TimerObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var period = state.period;
	        var subscriber = state.subscriber;

	        var action = this;
	        subscriber.next(index);
	        if (typeof period === "undefined") {
	            subscriber.complete();
	            return;
	        } else if (subscriber.isUnsubscribed) {
	            return;
	        }
	        if (typeof action.delay === 'undefined') {
	            action.add(action.scheduler.schedule(TimerObservable.dispatch, period, {
	                index: index + 1, period: period, subscriber: subscriber
	            }));
	        } else {
	            state.index = index + 1;
	            action.schedule(state, period);
	        }
	    };

	    TimerObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var period = this._period;
	        var dueTime = this.dueTime;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(TimerObservable.dispatch, dueTime, { index: index, period: period, subscriber: subscriber }));
	    };

	    return TimerObservable;
	})(_Observable3['default']);

	exports['default'] = TimerObservable;
	module.exports = exports['default'];

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var FromEventPatternObservable = (function (_Observable) {
	    _inherits(FromEventPatternObservable, _Observable);

	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _classCallCheck(this, FromEventPatternObservable);

	        _Observable.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }

	    FromEventPatternObservable.create = function create(addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	        ;
	    };

	    FromEventPatternObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var addHandler = this.addHandler;
	        var removeHandler = this.removeHandler;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = _utilTryCatch2['default'](selector).apply(null, arguments);
	            if (result === _utilErrorObject.errorObject) {
	                subscriber.error(result.e);
	            } else {
	                subscriber.next(result);
	            }
	        } : function (e) {
	            subscriber.next(e);
	        };
	        var result = _utilTryCatch2['default'](addHandler)(handler);
	        if (result === _utilErrorObject.errorObject) {
	            subscriber.error(result.e);
	        }
	        subscriber.add(new _Subscription2['default'](function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler);
	        }));
	    };

	    return FromEventPatternObservable;
	})(_Observable3['default']);

	exports['default'] = FromEventPatternObservable;
	module.exports = exports['default'];

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var FromEventObservable = (function (_Observable) {
	    _inherits(FromEventObservable, _Observable);

	    function FromEventObservable(sourceObj, eventName, selector) {
	        _classCallCheck(this, FromEventObservable);

	        _Observable.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	    }

	    FromEventObservable.create = function create(sourceObj, eventName, selector) {
	        return new FromEventObservable(sourceObj, eventName, selector);
	    };

	    FromEventObservable.setupSubscription = function setupSubscription(sourceObj, eventName, handler, subscriber) {
	        var unsubscribe = undefined;
	        var tag = sourceObj.toString();
	        if (tag === '[object NodeList]' || tag === '[object HTMLCollection]') {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber);
	            }
	        } else if (typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function') {
	            sourceObj.addEventListener(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.removeEventListener(eventName, handler);
	            };
	        } else if (typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function') {
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.off(eventName, handler);
	            };
	        } else if (typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function') {
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () {
	                return sourceObj.removeListener(eventName, handler);
	            };
	        }
	        subscriber.add(new _Subscription2['default'](unsubscribe));
	    };

	    FromEventObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var selector = this.selector;
	        var handler = selector ? function (e) {
	            var result = _utilTryCatch2['default'](selector)(e);
	            if (result === _utilErrorObject.errorObject) {
	                subscriber.error(result.e);
	            } else {
	                subscriber.next(result);
	            }
	        } : function (e) {
	            return subscriber.next(e);
	        };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber);
	    };

	    return FromEventObservable;
	})(_Observable3['default']);

	exports['default'] = FromEventObservable;
	module.exports = exports['default'];

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var ForkJoinObservable = (function (_Observable) {
	    _inherits(ForkJoinObservable, _Observable);

	    function ForkJoinObservable(observables) {
	        _classCallCheck(this, ForkJoinObservable);

	        _Observable.call(this);
	        this.observables = observables;
	    }

	    ForkJoinObservable.create = function create() {
	        for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	            observables[_key] = arguments[_key];
	        }

	        return new ForkJoinObservable(observables);
	    };

	    ForkJoinObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var observables = this.observables;
	        var len = observables.length;
	        var context = { complete: 0, total: len, values: emptyArray(len) };
	        for (var i = 0; i < len; i++) {
	            observables[i].subscribe(new AllSubscriber(subscriber, this, i, context));
	        }
	    };

	    return ForkJoinObservable;
	})(_Observable3['default']);

	exports['default'] = ForkJoinObservable;

	var AllSubscriber = (function (_Subscriber) {
	    _inherits(AllSubscriber, _Subscriber);

	    function AllSubscriber(destination, parent, index, context) {
	        _classCallCheck(this, AllSubscriber);

	        _Subscriber.call(this, destination);
	        this.parent = parent;
	        this.index = index;
	        this.context = context;
	    }

	    AllSubscriber.prototype._next = function _next(value) {
	        this._value = value;
	    };

	    AllSubscriber.prototype._complete = function _complete() {
	        var context = this.context;
	        context.values[this.index] = this._value;
	        if (context.values.every(hasValue)) {
	            this.destination.next(context.values);
	            this.destination.complete();
	        }
	    };

	    return AllSubscriber;
	})(_Subscriber3['default']);

	function hasValue(x) {
	    return x !== null;
	}
	function emptyArray(len) {
	    var arr = [];
	    for (var i = 0; i < len; i++) {
	        arr.push(null);
	    }
	    return arr;
	}
	module.exports = exports['default'];

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _PromiseObservable = __webpack_require__(253);

	var _PromiseObservable2 = _interopRequireDefault(_PromiseObservable);

	var _IteratorObservable = __webpack_require__(260);

	var _IteratorObservable2 = _interopRequireDefault(_IteratorObservable);

	var _ArrayObservable = __webpack_require__(243);

	var _ArrayObservable2 = _interopRequireDefault(_ArrayObservable);

	var _utilSymbol_observable = __webpack_require__(226);

	var _utilSymbol_observable2 = _interopRequireDefault(_utilSymbol_observable);

	var _utilSymbol_iterator = __webpack_require__(261);

	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _operatorsObserveOnSupport = __webpack_require__(262);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var isArray = Array.isArray;

	var FromObservable = (function (_Observable) {
	    _inherits(FromObservable, _Observable);

	    function FromObservable(ish, scheduler) {
	        _classCallCheck(this, FromObservable);

	        _Observable.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }

	    FromObservable.create = function create(ish) {
	        var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

	        if (ish) {
	            if (isArray(ish)) {
	                return new _ArrayObservable2['default'](ish, scheduler);
	            } else if (typeof ish.then === 'function') {
	                return new _PromiseObservable2['default'](ish, scheduler);
	            } else if (typeof ish[_utilSymbol_observable2['default']] === 'function') {
	                if (ish instanceof _Observable3['default']) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            } else if (typeof ish[_utilSymbol_iterator2['default']] === 'function') {
	                return new _IteratorObservable2['default'](ish, null, null, scheduler);
	            }
	        }
	        throw new TypeError(typeof ish + ' is not observable');
	    };

	    FromObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler === _schedulersImmediate2['default']) {
	            return this.ish[_utilSymbol_observable2['default']]().subscribe(subscriber);
	        } else {
	            return this.ish[_utilSymbol_observable2['default']]().subscribe(new _operatorsObserveOnSupport.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };

	    return FromObservable;
	})(_Observable3['default']);

	exports['default'] = FromObservable;
	module.exports = exports['default'];

/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _utilRoot = __webpack_require__(227);

	var _utilSymbol_iterator = __webpack_require__(261);

	var _utilSymbol_iterator2 = _interopRequireDefault(_utilSymbol_iterator);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var IteratorObservable = (function (_Observable) {
	    _inherits(IteratorObservable, _Observable);

	    function IteratorObservable(iterator, project, thisArg, scheduler) {
	        _classCallCheck(this, IteratorObservable);

	        _Observable.call(this);
	        this.iterator = iterator;
	        this.project = project;
	        this.thisArg = thisArg;
	        this.scheduler = scheduler;
	    }

	    IteratorObservable.create = function create(iterator, project, thisArg, scheduler) {
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        if (project && typeof project !== "function") {
	            throw new Error('When provided, `project` must be a function.');
	        }
	        return new IteratorObservable(iterator, project, thisArg, scheduler);
	    };

	    IteratorObservable.dispatch = function dispatch(state) {
	        var index = state.index;
	        var hasError = state.hasError;
	        var thisArg = state.thisArg;
	        var project = state.project;
	        var iterator = state.iterator;
	        var subscriber = state.subscriber;

	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        if (project) {
	            result = _utilTryCatch2['default'](project).call(thisArg, result.value, index);
	            if (result === _utilErrorObject.errorObject) {
	                state.error = _utilErrorObject.errorObject.e;
	                state.hasError = true;
	            } else {
	                subscriber.next(result);
	                state.index = index + 1;
	            }
	        } else {
	            subscriber.next(result.value);
	            state.index = index + 1;
	        }
	        if (subscriber.isUnsubscribed) {
	            return;
	        }
	        this.schedule(state);
	    };

	    IteratorObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var index = 0;
	        var project = this.project;
	        var thisArg = this.thisArg;
	        var iterator = getIterator(Object(this.iterator));
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            subscriber.add(scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, thisArg: thisArg, project: project, iterator: iterator, subscriber: subscriber
	            }));
	        } else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                } else if (project) {
	                    result = _utilTryCatch2['default'](project).call(thisArg, result.value, index++);
	                    if (result === _utilErrorObject.errorObject) {
	                        subscriber.error(_utilErrorObject.errorObject.e);
	                        break;
	                    }
	                    subscriber.next(result);
	                } else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.isUnsubscribed) {
	                    break;
	                }
	            } while (true);
	        }
	    };

	    return IteratorObservable;
	})(_Observable3['default']);

	exports['default'] = IteratorObservable;

	var maxSafeInteger = Math.pow(2, 53) - 1;

	var StringIterator = (function () {
	    function StringIterator(str) {
	        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var len = arguments.length <= 2 || arguments[2] === undefined ? str.length : arguments[2];
	        return (function () {
	            _classCallCheck(this, StringIterator);

	            this.str = str;
	            this.idx = idx;
	            this.len = len;
	        }).apply(this, arguments);
	    }

	    StringIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };

	    StringIterator.prototype.next = function next() {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };

	    return StringIterator;
	})();

	var ArrayIterator = (function () {
	    function ArrayIterator(arr) {
	        var idx = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var len = arguments.length <= 2 || arguments[2] === undefined ? toLength(arr) : arguments[2];
	        return (function () {
	            _classCallCheck(this, ArrayIterator);

	            this.arr = arr;
	            this.idx = idx;
	            this.len = len;
	        }).apply(this, arguments);
	    }

	    ArrayIterator.prototype[_utilSymbol_iterator2['default']] = function () {
	        return this;
	    };

	    ArrayIterator.prototype.next = function next() {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };

	    return ArrayIterator;
	})();

	function getIterator(o) {
	    var i = o[_utilSymbol_iterator2['default']];
	    if (!i && typeof o === 'string') {
	        return new StringIterator(o);
	    }
	    if (!i && o.length !== undefined) {
	        return new ArrayIterator(o);
	    }
	    if (!i) {
	        throw new TypeError('Object is not iterable');
	    }
	    return o[_utilSymbol_iterator2['default']]();
	}
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && _utilRoot.root.isFinite(value);
	}
	function isNan(n) {
	    return n !== n;
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}
	module.exports = exports['default'];

/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _root = __webpack_require__(227);

	if (!_root.root.Symbol) {
	    _root.root.Symbol = {};
	}
	if (!_root.root.Symbol.iterator) {
	    if (typeof _root.root.Symbol['for'] === 'function') {
	        _root.root.Symbol.iterator = _root.root.Symbol['for']('iterator');
	    } else if (_root.root.Set && typeof new _root.root.Set()['@@iterator'] === 'function') {
	        _root.root.Symbol.iterator = '@@iterator';
	    } else {
	        _root.root.Symbol.iterator = '_es6shim_iterator_';
	    }
	}
	exports['default'] = _root.root.Symbol.iterator;

	// // Shim in iterator support
	// export var $iterator$ = (typeof Symbol === 'function' && Symbol.iterator) || '_es6shim_iterator_';
	// // Bug for mozilla version
	// if (root.Set && typeof new root.Set()['@@iterator'] === 'function') {
	//     $iterator$ = '@@iterator';
	// }
	module.exports = exports['default'];

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Notification = __webpack_require__(231);

	var _Notification2 = _interopRequireDefault(_Notification);

	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        _classCallCheck(this, ObserveOnOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ObserveOnOperator.prototype.call = function call(subscriber) {
	        return new ObserveOnSubscriber(subscriber, this.scheduler, this.delay);
	    };

	    return ObserveOnOperator;
	})();

	exports.ObserveOnOperator = ObserveOnOperator;

	var ObserveOnSubscriber = (function (_Subscriber) {
	    _inherits(ObserveOnSubscriber, _Subscriber);

	    function ObserveOnSubscriber(destination, scheduler) {
	        var delay = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

	        _classCallCheck(this, ObserveOnSubscriber);

	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ObserveOnSubscriber.dispatch = function dispatch(_ref) {
	        var notification = _ref.notification;
	        var destination = _ref.destination;

	        notification.observe(destination);
	    };

	    ObserveOnSubscriber.prototype._next = function _next(x) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createNext(x), this.destination)));
	    };

	    ObserveOnSubscriber.prototype._error = function _error(e) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createError(e), this.destination)));
	    };

	    ObserveOnSubscriber.prototype._complete = function _complete() {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(_Notification2['default'].createComplete(), this.destination)));
	    };

	    return ObserveOnSubscriber;
	})(_Subscriber3['default']);

	exports.ObserveOnSubscriber = ObserveOnSubscriber;

	var ObserveOnMessage = function ObserveOnMessage(notification, destination) {
	    _classCallCheck(this, ObserveOnMessage);

	    this.notification = notification;
	    this.destination = destination;
	};

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concat;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mergeStatic = __webpack_require__(264);

	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	function concat() {
	    var scheduler = _schedulersImmediate2['default'];

	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var len = observables.length;
	    if (typeof observables[observables.length - 1].schedule === 'function') {
	        scheduler = observables.pop();
	        observables.push(1, scheduler);
	    }
	    return _mergeStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = merge;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(243);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _mergeSupport = __webpack_require__(265);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	function merge() {
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = _schedulersImmediate2['default'];

	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var last = observables[observables.length - 1];
	    if (typeof last.schedule === 'function') {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    } else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (observables.length === 1) {
	        return observables[0];
	    }
	    return new _observablesArrayObservable2['default'](observables, scheduler).lift(new _mergeSupport.MergeOperator(concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var MergeOperator = (function () {
	    function MergeOperator() {
	        var concurrent = arguments.length <= 0 || arguments[0] === undefined ? Number.POSITIVE_INFINITY : arguments[0];

	        _classCallCheck(this, MergeOperator);

	        this.concurrent = concurrent;
	    }

	    MergeOperator.prototype.call = function call(subscriber) {
	        return new MergeSubscriber(subscriber, this.concurrent);
	    };

	    return MergeOperator;
	})();

	exports.MergeOperator = MergeOperator;

	var MergeSubscriber = (function (_Subscriber) {
	    _inherits(MergeSubscriber, _Subscriber);

	    function MergeSubscriber(destination, concurrent) {
	        _classCallCheck(this, MergeSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.active = 0;
	        this.stopped = false;
	        this.buffer = [];
	        this.concurrent = concurrent;
	    }

	    MergeSubscriber.prototype._next = function _next(value) {
	        var active = this.active;
	        if (active < this.concurrent) {
	            var index = this.count;
	            var observable = this._project(value, index);
	            if (observable) {
	                this.count = index + 1;
	                this.active = active + 1;
	                this.add(this._subscribeInner(observable, value, index));
	            }
	        } else {
	            this._buffer(value);
	        }
	    };

	    MergeSubscriber.prototype.complete = function complete() {
	        this.stopped = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            _Subscriber.prototype.complete.call(this);
	        }
	    };

	    MergeSubscriber.prototype._unsubscribe = function _unsubscribe() {
	        this.buffer = void 0;
	    };

	    MergeSubscriber.prototype._project = function _project(value, index) {
	        return value;
	    };

	    MergeSubscriber.prototype._buffer = function _buffer(value) {
	        this.buffer.push(value);
	    };

	    MergeSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        var destination = this.destination;
	        if (observable._isScalar) {
	            destination.next(observable.value);
	            this._innerComplete();
	        } else {
	            var subscriber = new MergeInnerSubscriber(destination, this);
	            observable._subscribe(subscriber);
	            return subscriber;
	        }
	    };

	    MergeSubscriber.prototype._innerComplete = function _innerComplete() {
	        var buffer = this.buffer;
	        var active = this.active -= 1;
	        var stopped = this.stopped;
	        var pending = buffer.length;
	        if (stopped && active === 0 && pending === 0) {
	            _Subscriber.prototype.complete.call(this);
	        } else if (active < this.concurrent && pending > 0) {
	            this._next(buffer.shift());
	        }
	    };

	    return MergeSubscriber;
	})(_Subscriber4['default']);

	exports.MergeSubscriber = MergeSubscriber;

	var MergeInnerSubscriber = (function (_Subscriber2) {
	    _inherits(MergeInnerSubscriber, _Subscriber2);

	    function MergeInnerSubscriber(destination, parent) {
	        _classCallCheck(this, MergeInnerSubscriber);

	        _Subscriber2.call(this, destination);
	        this.parent = parent;
	    }

	    MergeInnerSubscriber.prototype._complete = function _complete() {
	        this.parent._innerComplete();
	    };

	    return MergeInnerSubscriber;
	})(_Subscriber4['default']);

	exports.MergeInnerSubscriber = MergeInnerSubscriber;

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatProto;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mergeStatic = __webpack_require__(264);

	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

	function concatProto() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    observables.unshift(this);
	    observables.push(1);
	    return _mergeStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatAll;

	var _mergeSupport = __webpack_require__(265);

	function concatAll() {
	    return this.lift(new _mergeSupport.MergeOperator(1));
	}

	module.exports = exports['default'];

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatMap;

	var _flatMapSupport = __webpack_require__(269);

	function concatMap(project, projectResult) {
	    return this.lift(new _flatMapSupport.FlatMapOperator(project, projectResult, 1));
	}

	module.exports = exports['default'];

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _mergeSupport = __webpack_require__(265);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var FlatMapOperator = (function () {
	    function FlatMapOperator(project, projectResult) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

	        _classCallCheck(this, FlatMapOperator);

	        this.project = project;
	        this.projectResult = projectResult;
	        this.concurrent = concurrent;
	    }

	    FlatMapOperator.prototype.call = function call(subscriber) {
	        return new FlatMapSubscriber(subscriber, this.concurrent, this.project, this.projectResult);
	    };

	    return FlatMapOperator;
	})();

	exports.FlatMapOperator = FlatMapOperator;

	var FlatMapSubscriber = (function (_MergeSubscriber) {
	    _inherits(FlatMapSubscriber, _MergeSubscriber);

	    function FlatMapSubscriber(destination, concurrent, project, projectResult) {
	        _classCallCheck(this, FlatMapSubscriber);

	        _MergeSubscriber.call(this, destination, concurrent);
	        this.project = project;
	        this.projectResult = projectResult;
	    }

	    FlatMapSubscriber.prototype._project = function _project(value, index) {
	        var observable = _utilTryCatch2['default'](this.project).call(this, value, index);
	        if (observable === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	            return null;
	        }
	        return observable;
	    };

	    FlatMapSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        var projectResult = this.projectResult;
	        if (projectResult) {
	            return observable._subscribe(new FlatMapInnerSubscriber(this.destination, this, value, index, projectResult));
	        } else if (observable._isScalar) {
	            this.destination.next(observable.value);
	            this._innerComplete();
	        } else {
	            return observable._subscribe(new _mergeSupport.MergeInnerSubscriber(this.destination, this));
	        }
	    };

	    return FlatMapSubscriber;
	})(_mergeSupport.MergeSubscriber);

	exports.FlatMapSubscriber = FlatMapSubscriber;

	var FlatMapInnerSubscriber = (function (_MergeInnerSubscriber) {
	    _inherits(FlatMapInnerSubscriber, _MergeInnerSubscriber);

	    function FlatMapInnerSubscriber(destination, parent, value, index, project) {
	        _classCallCheck(this, FlatMapInnerSubscriber);

	        _MergeInnerSubscriber.call(this, destination, parent);
	        this.count = 0;
	        this.value = value;
	        this.index = index;
	        this.project = project;
	    }

	    FlatMapInnerSubscriber.prototype._next = function _next(value) {
	        var result = value;
	        var index = this.count++;
	        result = _utilTryCatch2['default'](this.project).call(this, this.value, value, this.index, index);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(result);
	        }
	    };

	    return FlatMapInnerSubscriber;
	})(_mergeSupport.MergeInnerSubscriber);

	exports.FlatMapInnerSubscriber = FlatMapInnerSubscriber;

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = concatMapTo;

	var _flatMapToSupport = __webpack_require__(271);

	function concatMapTo(observable, projectResult) {
	    return this.lift(new _flatMapToSupport.FlatMapToOperator(observable, projectResult, 1));
	}

	module.exports = exports['default'];

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _flatMapSupport = __webpack_require__(269);

	var FlatMapToOperator = (function () {
	    function FlatMapToOperator(observable, projectResult) {
	        var concurrent = arguments.length <= 2 || arguments[2] === undefined ? Number.POSITIVE_INFINITY : arguments[2];

	        _classCallCheck(this, FlatMapToOperator);

	        this.observable = observable;
	        this.projectResult = projectResult;
	        this.concurrent = concurrent;
	    }

	    FlatMapToOperator.prototype.call = function call(subscriber) {
	        return new FlatMapToSubscriber(subscriber, this.concurrent, this.observable, this.projectResult);
	    };

	    return FlatMapToOperator;
	})();

	exports.FlatMapToOperator = FlatMapToOperator;

	var FlatMapToSubscriber = (function (_FlatMapSubscriber) {
	    _inherits(FlatMapToSubscriber, _FlatMapSubscriber);

	    function FlatMapToSubscriber(destination, concurrent, observable, projectResult) {
	        _classCallCheck(this, FlatMapToSubscriber);

	        _FlatMapSubscriber.call(this, destination, concurrent, null, projectResult);
	        this.observable = observable;
	    }

	    FlatMapToSubscriber.prototype._project = function _project(value, index) {
	        return this.observable;
	    };

	    return FlatMapToSubscriber;
	})(_flatMapSupport.FlatMapSubscriber);

	exports.FlatMapToSubscriber = FlatMapToSubscriber;

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = merge;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _mergeStatic = __webpack_require__(264);

	var _mergeStatic2 = _interopRequireDefault(_mergeStatic);

	function merge() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    observables.unshift(this);
	    return _mergeStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = mergeAll;

	var _mergeSupport = __webpack_require__(265);

	function mergeAll(concurrent) {
	    return this.lift(new _mergeSupport.MergeOperator(concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = flatMap;

	var _flatMapSupport = __webpack_require__(269);

	function flatMap(project, projectResult, concurrent) {
	    return this.lift(new _flatMapSupport.FlatMapOperator(project, projectResult, concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = flatMapTo;

	var _flatMapToSupport = __webpack_require__(271);

	function flatMapTo(observable, projectResult, concurrent) {
	    return this.lift(new _flatMapToSupport.FlatMapToOperator(observable, projectResult, concurrent));
	}

	module.exports = exports['default'];

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = switchAll;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _mergeSupport = __webpack_require__(265);

	function switchAll() {
	    return this.lift(new SwitchOperator());
	}

	var SwitchOperator = (function () {
	    function SwitchOperator() {
	        _classCallCheck(this, SwitchOperator);
	    }

	    SwitchOperator.prototype.call = function call(subscriber) {
	        return new SwitchSubscriber(subscriber);
	    };

	    return SwitchOperator;
	})();

	var SwitchSubscriber = (function (_MergeSubscriber) {
	    _inherits(SwitchSubscriber, _MergeSubscriber);

	    function SwitchSubscriber(destination) {
	        _classCallCheck(this, SwitchSubscriber);

	        _MergeSubscriber.call(this, destination, 1);
	    }

	    SwitchSubscriber.prototype._buffer = function _buffer(value) {
	        var active = this.active;
	        if (active > 0) {
	            this.active = active - 1;
	            var inner = this.innerSubscription;
	            if (inner) {
	                inner.unsubscribe();
	                this.innerSubscription = null;
	            }
	        }
	        this._next(value);
	    };

	    SwitchSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        this.innerSubscription = new _Subscription2['default']();
	        this.innerSubscription.add(_MergeSubscriber.prototype._subscribeInner.call(this, observable, value, index));
	        return this.innerSubscription;
	    };

	    return SwitchSubscriber;
	})(_mergeSupport.MergeSubscriber);

	module.exports = exports['default'];

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = switchLatest;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _flatMapSupport = __webpack_require__(269);

	function switchLatest(project, projectResult) {
	    return this.lift(new SwitchLatestOperator(project, projectResult));
	}

	var SwitchLatestOperator = (function (_FlatMapOperator) {
	    _inherits(SwitchLatestOperator, _FlatMapOperator);

	    function SwitchLatestOperator(project, projectResult) {
	        _classCallCheck(this, SwitchLatestOperator);

	        _FlatMapOperator.call(this, project, projectResult, 1);
	    }

	    SwitchLatestOperator.prototype.call = function call(subscriber) {
	        return new SwitchLatestSubscriber(subscriber, this.project, this.projectResult);
	    };

	    return SwitchLatestOperator;
	})(_flatMapSupport.FlatMapOperator);

	var SwitchLatestSubscriber = (function (_FlatMapSubscriber) {
	    _inherits(SwitchLatestSubscriber, _FlatMapSubscriber);

	    function SwitchLatestSubscriber(destination, project, projectResult) {
	        _classCallCheck(this, SwitchLatestSubscriber);

	        _FlatMapSubscriber.call(this, destination, 1, project, projectResult);
	    }

	    SwitchLatestSubscriber.prototype._buffer = function _buffer(value) {
	        var active = this.active;
	        if (active > 0) {
	            this.active = active - 1;
	            var inner = this.innerSubscription;
	            if (inner) {
	                inner.unsubscribe();
	            }
	        }
	        this._next(value);
	    };

	    SwitchLatestSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        this.innerSubscription = new _Subscription2['default']();
	        this.innerSubscription.add(_FlatMapSubscriber.prototype._subscribeInner.call(this, observable, value, index));
	        return this.innerSubscription;
	    };

	    return SwitchLatestSubscriber;
	})(_flatMapSupport.FlatMapSubscriber);

	module.exports = exports['default'];

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = switchLatestTo;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _flatMapToSupport = __webpack_require__(271);

	function switchLatestTo(observable, projectResult) {
	    return this.lift(new SwitchLatestToOperator(observable, projectResult));
	}

	var SwitchLatestToOperator = (function (_FlatMapToOperator) {
	    _inherits(SwitchLatestToOperator, _FlatMapToOperator);

	    function SwitchLatestToOperator(observable, projectResult) {
	        _classCallCheck(this, SwitchLatestToOperator);

	        _FlatMapToOperator.call(this, observable, projectResult, 1);
	    }

	    SwitchLatestToOperator.prototype.call = function call(subscriber) {
	        return new SwitchLatestToSubscriber(subscriber, this.observable, this.projectResult);
	    };

	    return SwitchLatestToOperator;
	})(_flatMapToSupport.FlatMapToOperator);

	var SwitchLatestToSubscriber = (function (_FlatMapToSubscriber) {
	    _inherits(SwitchLatestToSubscriber, _FlatMapToSubscriber);

	    function SwitchLatestToSubscriber(destination, observable, projectResult) {
	        _classCallCheck(this, SwitchLatestToSubscriber);

	        _FlatMapToSubscriber.call(this, destination, 1, observable, projectResult);
	    }

	    SwitchLatestToSubscriber.prototype._buffer = function _buffer(value) {
	        var active = this.active;
	        if (active > 0) {
	            this.active = active - 1;
	            var inner = this.innerSubscription;
	            if (inner) {
	                inner.unsubscribe();
	            }
	        }
	        this._next(value);
	    };

	    SwitchLatestToSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        return this.innerSubscription = _FlatMapToSubscriber.prototype._subscribeInner.call(this, observable, value, index);
	    };

	    return SwitchLatestToSubscriber;
	})(_flatMapToSupport.FlatMapToSubscriber);

	module.exports = exports['default'];

/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = expand;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _mergeSupport = __webpack_require__(265);

	var _observablesEmptyObservable = __webpack_require__(245);

	var _observablesEmptyObservable2 = _interopRequireDefault(_observablesEmptyObservable);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function expand(project) {
	    return this.lift(new ExpandOperator(project));
	}

	var ExpandOperator = (function () {
	    function ExpandOperator(project) {
	        _classCallCheck(this, ExpandOperator);

	        this.project = project;
	    }

	    ExpandOperator.prototype.call = function call(subscriber) {
	        return new ExpandSubscriber(subscriber, this.project);
	    };

	    return ExpandOperator;
	})();

	var ExpandSubscriber = (function (_MergeSubscriber) {
	    _inherits(ExpandSubscriber, _MergeSubscriber);

	    function ExpandSubscriber(destination, project) {
	        _classCallCheck(this, ExpandSubscriber);

	        _MergeSubscriber.call(this, destination, Number.POSITIVE_INFINITY);
	        this.project = project;
	    }

	    ExpandSubscriber.prototype._project = function _project(value, index) {
	        var observable = _utilTryCatch2['default'](this.project).call(this, value, index);
	        if (observable === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	            return null;
	        }
	        return observable;
	    };

	    ExpandSubscriber.prototype._subscribeInner = function _subscribeInner(observable, value, index) {
	        if (observable._isScalar) {
	            this.destination.next(observable.value);
	            this._innerComplete();
	            this._next(observable.value);
	        } else if (observable instanceof _observablesEmptyObservable2['default']) {
	            this._innerComplete();
	        } else {
	            return observable._subscribe(new ExpandInnerSubscriber(this.destination, this));
	        }
	    };

	    return ExpandSubscriber;
	})(_mergeSupport.MergeSubscriber);

	var ExpandInnerSubscriber = (function (_MergeInnerSubscriber) {
	    _inherits(ExpandInnerSubscriber, _MergeInnerSubscriber);

	    function ExpandInnerSubscriber(destination, parent) {
	        _classCallCheck(this, ExpandInnerSubscriber);

	        _MergeInnerSubscriber.call(this, destination, parent);
	    }

	    ExpandInnerSubscriber.prototype._next = function _next(value) {
	        this.destination.next(value);
	        this.parent.next(value);
	    };

	    return ExpandInnerSubscriber;
	})(_mergeSupport.MergeInnerSubscriber);

	module.exports = exports['default'];

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = _do;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilNoop = __webpack_require__(222);

	var _utilNoop2 = _interopRequireDefault(_utilNoop);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function _do(next, error, complete) {
	    return this.lift(new DoOperator(next || _utilNoop2['default'], error || _utilNoop2['default'], complete || _utilNoop2['default']));
	}

	var DoOperator = (function () {
	    function DoOperator(next, error, complete) {
	        _classCallCheck(this, DoOperator);

	        this.next = next;
	        this.error = error;
	        this.complete = complete;
	    }

	    DoOperator.prototype.call = function call(subscriber) {
	        return new DoSubscriber(subscriber, this.next, this.error, this.complete);
	    };

	    return DoOperator;
	})();

	var DoSubscriber = (function (_Subscriber) {
	    _inherits(DoSubscriber, _Subscriber);

	    function DoSubscriber(destination, next, error, complete) {
	        _classCallCheck(this, DoSubscriber);

	        _Subscriber.call(this, destination);
	        this.__next = next;
	        this.__error = error;
	        this.__complete = complete;
	    }

	    DoSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.__next)(x);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(x);
	        }
	    };

	    DoSubscriber.prototype._error = function _error(e) {
	        var result = _utilTryCatch2['default'](this.__error)(e);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.error(e);
	        }
	    };

	    DoSubscriber.prototype._complete = function _complete() {
	        var result = _utilTryCatch2['default'](this.__complete)();
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.complete();
	        }
	    };

	    return DoSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = map;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var _utilBindCallback = __webpack_require__(282);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	/**
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the returned observable
	 *
	 * @param {Function} project the function to create projection
	 * @param {any} [thisArg] an optional argument to define what `this` is in the project function
	 * @returns {Observable} a observable of projected values
	 */

	function map(project, thisArg) {
	    return this.lift(new MapOperator(project, thisArg));
	}

	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        _classCallCheck(this, MapOperator);

	        this.project = _utilBindCallback2['default'](project, thisArg, 2);
	    }

	    MapOperator.prototype.call = function call(subscriber) {
	        return new MapSubscriber(subscriber, this.project);
	    };

	    return MapOperator;
	})();

	var MapSubscriber = (function (_Subscriber) {
	    _inherits(MapSubscriber, _Subscriber);

	    function MapSubscriber(destination, project) {
	        _classCallCheck(this, MapSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.project = project;
	    }

	    MapSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.project)(x, this.count++);
	        if (result === _utilErrorObject.errorObject) {
	            this.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.destination.next(result);
	        }
	    };

	    return MapSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 282 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bindCallback;

	function bindCallback(func, thisArg, argCount) {
	    if (typeof thisArg === 'undefined') {
	        return func;
	    }
	    switch (argCount) {
	        case 0:
	            return function () {
	                return func.call(thisArg);
	            };
	        case 1:
	            return function (arg) {
	                return func.call(thisArg, arg);
	            };
	        case 2:
	            return function (value, index) {
	                return func.call(thisArg, value, index);
	            };
	        case 3:
	            return function (value, index, collection) {
	                return func.call(thisArg, value, index, collection);
	            };
	    }
	    return function () {
	        return func.apply(thisArg, arguments);
	    };
	}

	;
	module.exports = exports['default'];

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = mapTo;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	/**
	 * Maps every value to the same value every time.
	 * @param {any} value the value to map each incoming value to
	 * @returns {Observable} an observable of the passed value that emits everytime the source does
	 */

	function mapTo(value) {
	    return this.lift(new MapToOperator(value));
	}

	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        _classCallCheck(this, MapToOperator);

	        this.value = value;
	    }

	    MapToOperator.prototype.call = function call(subscriber) {
	        return new MapToSubscriber(subscriber, this.value);
	    };

	    return MapToOperator;
	})();

	var MapToSubscriber = (function (_Subscriber) {
	    _inherits(MapToSubscriber, _Subscriber);

	    function MapToSubscriber(destination, value) {
	        _classCallCheck(this, MapToSubscriber);

	        _Subscriber.call(this, destination);
	        this.value = value;
	    }

	    MapToSubscriber.prototype._next = function _next(x) {
	        this.destination.next(this.value);
	    };

	    return MapToSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = toArray;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function toArray() {
	    return this.lift(new ToArrayOperator());
	}

	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	        _classCallCheck(this, ToArrayOperator);
	    }

	    ToArrayOperator.prototype.call = function call(subscriber) {
	        return new ToArraySubscriber(subscriber);
	    };

	    return ToArrayOperator;
	})();

	var ToArraySubscriber = (function (_Subscriber) {
	    _inherits(ToArraySubscriber, _Subscriber);

	    function ToArraySubscriber(destination) {
	        _classCallCheck(this, ToArraySubscriber);

	        _Subscriber.call(this, destination);
	        this.array = [];
	    }

	    ToArraySubscriber.prototype._next = function _next(x) {
	        this.array.push(x);
	    };

	    ToArraySubscriber.prototype._complete = function _complete() {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };

	    return ToArraySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = count;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function count() {
	    return this.lift(new CountOperator());
	}

	var CountOperator = (function () {
	    function CountOperator() {
	        _classCallCheck(this, CountOperator);
	    }

	    CountOperator.prototype.call = function call(subscriber) {
	        return new CountSubscriber(subscriber);
	    };

	    return CountOperator;
	})();

	var CountSubscriber = (function (_Subscriber) {
	    _inherits(CountSubscriber, _Subscriber);

	    function CountSubscriber(destination) {
	        _classCallCheck(this, CountSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	    }

	    CountSubscriber.prototype._next = function _next(x) {
	        this.count += 1;
	    };

	    CountSubscriber.prototype._complete = function _complete() {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };

	    return CountSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = scan;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function scan(project, acc) {
	    return this.lift(new ScanOperator(project));
	}

	var ScanOperator = (function () {
	    function ScanOperator(project, acc) {
	        _classCallCheck(this, ScanOperator);

	        this.acc = acc;
	        this.project = project;
	    }

	    ScanOperator.prototype.call = function call(subscriber) {
	        return new ScanSubscriber(subscriber, this.project, this.acc);
	    };

	    return ScanOperator;
	})();

	var ScanSubscriber = (function (_Subscriber) {
	    _inherits(ScanSubscriber, _Subscriber);

	    function ScanSubscriber(destination, project, acc) {
	        _classCallCheck(this, ScanSubscriber);

	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        this.acc = acc;
	        this.project = project;
	        this.hasSeed = typeof acc !== "undefined";
	    }

	    ScanSubscriber.prototype._next = function _next(x) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.destination.next(this.acc = result);
	            }
	        } else {
	            return this.destination.next((this.hasValue = true) && (this.acc = x));
	        }
	    };

	    ScanSubscriber.prototype._complete = function _complete() {
	        if (!this.hasValue && this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };

	    return ScanSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = reduce;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function reduce(project, acc) {
	    return this.lift(new ReduceOperator(project, acc));
	}

	var ReduceOperator = (function () {
	    function ReduceOperator(project, acc) {
	        _classCallCheck(this, ReduceOperator);

	        this.acc = acc;
	        this.project = project;
	    }

	    ReduceOperator.prototype.call = function call(subscriber) {
	        return new ReduceSubscriber(subscriber, this.project, this.acc);
	    };

	    return ReduceOperator;
	})();

	var ReduceSubscriber = (function (_Subscriber) {
	    _inherits(ReduceSubscriber, _Subscriber);

	    function ReduceSubscriber(destination, project, acc) {
	        _classCallCheck(this, ReduceSubscriber);

	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        this.acc = acc;
	        this.project = project;
	        this.hasSeed = typeof acc !== "undefined";
	    }

	    ReduceSubscriber.prototype._next = function _next(x) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            var result = _utilTryCatch2['default'](this.project).call(this, this.acc, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.acc = result;
	            }
	        } else {
	            this.acc = x;
	            this.hasValue = true;
	        }
	    };

	    ReduceSubscriber.prototype._complete = function _complete() {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };

	    return ReduceSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = startWith;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesScalarObservable = __webpack_require__(244);

	var _observablesScalarObservable2 = _interopRequireDefault(_observablesScalarObservable);

	var _concatStatic = __webpack_require__(263);

	var _concatStatic2 = _interopRequireDefault(_concatStatic);

	function startWith(x) {
	    return _concatStatic2['default'](new _observablesScalarObservable2['default'](x), this);
	}

	module.exports = exports['default'];

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = take;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function take(total) {
	    return this.lift(new TakeOperator(total));
	}

	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        _classCallCheck(this, TakeOperator);

	        this.total = total;
	    }

	    TakeOperator.prototype.call = function call(subscriber) {
	        return new TakeSubscriber(subscriber, this.total);
	    };

	    return TakeOperator;
	})();

	var TakeSubscriber = (function (_Subscriber) {
	    _inherits(TakeSubscriber, _Subscriber);

	    function TakeSubscriber(destination, total) {
	        _classCallCheck(this, TakeSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.total = total;
	    }

	    TakeSubscriber.prototype._next = function _next(x) {
	        var total = this.total;
	        if (++this.count <= total) {
	            this.destination.next(x);
	            if (this.count === total) {
	                this.destination.complete();
	            }
	        }
	    };

	    return TakeSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = skip;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function skip(total) {
	    return this.lift(new SkipOperator(total));
	}

	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        _classCallCheck(this, SkipOperator);

	        this.total = total;
	    }

	    SkipOperator.prototype.call = function call(subscriber) {
	        return new SkipSubscriber(subscriber, this.total);
	    };

	    return SkipOperator;
	})();

	var SkipSubscriber = (function (_Subscriber) {
	    _inherits(SkipSubscriber, _Subscriber);

	    function SkipSubscriber(destination, total) {
	        _classCallCheck(this, SkipSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.total = total;
	    }

	    SkipSubscriber.prototype._next = function _next(x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };

	    return SkipSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = skipUntil;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	function skipUntil(total) {
	    return this.lift(new SkipUntilOperator(total));
	}

	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        _classCallCheck(this, SkipUntilOperator);

	        this.notifier = notifier;
	    }

	    SkipUntilOperator.prototype.call = function call(subscriber) {
	        return new SkipUntilSubscriber(subscriber, this.notifier);
	    };

	    return SkipUntilOperator;
	})();

	var SkipUntilSubscriber = (function (_Subscriber) {
	    _inherits(SkipUntilSubscriber, _Subscriber);

	    function SkipUntilSubscriber(destination, notifier) {
	        _classCallCheck(this, SkipUntilSubscriber);

	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.notificationSubscriber = new NotificationSubscriber();
	        this.add(this.notifier.subscribe(this.notificationSubscriber));
	    }

	    SkipUntilSubscriber.prototype._next = function _next(x) {
	        if (this.notificationSubscriber.hasNotified) {
	            this.destination.next(x);
	        }
	    };

	    return SkipUntilSubscriber;
	})(_Subscriber4['default']);

	var NotificationSubscriber = (function (_Subscriber2) {
	    _inherits(NotificationSubscriber, _Subscriber2);

	    function NotificationSubscriber() {
	        _classCallCheck(this, NotificationSubscriber);

	        _Subscriber2.call(this, null);
	        this.hasNotified = false;
	    }

	    NotificationSubscriber.prototype._next = function _next() {
	        this.hasNotified = true;
	        this.unsubscribe();
	    };

	    return NotificationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = takeUntil;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	function takeUntil(observable) {
	    return this.lift(new TakeUntilOperator(observable));
	}

	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(observable) {
	        _classCallCheck(this, TakeUntilOperator);

	        this.observable = observable;
	    }

	    TakeUntilOperator.prototype.call = function call(subscriber) {
	        return new TakeUntilSubscriber(subscriber, this.observable);
	    };

	    return TakeUntilOperator;
	})();

	var TakeUntilSubscriber = (function (_Subscriber) {
	    _inherits(TakeUntilSubscriber, _Subscriber);

	    function TakeUntilSubscriber(destination, observable) {
	        _classCallCheck(this, TakeUntilSubscriber);

	        _Subscriber.call(this, destination);
	        this.add(observable._subscribe(new TakeUntilInnerSubscriber(destination)));
	    }

	    return TakeUntilSubscriber;
	})(_Subscriber4['default']);

	var TakeUntilInnerSubscriber = (function (_Subscriber2) {
	    _inherits(TakeUntilInnerSubscriber, _Subscriber2);

	    function TakeUntilInnerSubscriber(destination) {
	        _classCallCheck(this, TakeUntilInnerSubscriber);

	        _Subscriber2.call(this, destination);
	    }

	    TakeUntilInnerSubscriber.prototype._next = function _next() {
	        this.destination.complete();
	    };

	    TakeUntilInnerSubscriber.prototype._error = function _error(e) {
	        this.destination.error(e);
	    };

	    TakeUntilInnerSubscriber.prototype._complete = function _complete() {};

	    return TakeUntilInnerSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = filter;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var _utilBindCallback = __webpack_require__(282);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	/**
	 * Similar to the well-known `Array.prototype.filter` method, this operator filters values down to a set
	 * allowed by a `select` function
	 *
	 * @param {Function} select a function that is used to select the resulting values
	 *  if it returns `true`, the value is emitted, if `false` the value is not passed to the resulting observable
	 * @param {any} [thisArg] an optional argument to determine the value of `this` in the `select` function
	 * @returns {Observable} an observable of values allowed by the select function
	 */

	function filter(select, thisArg) {
	    return this.lift(new FilterOperator(select, thisArg));
	}

	var FilterOperator = (function () {
	    function FilterOperator(select, thisArg) {
	        _classCallCheck(this, FilterOperator);

	        this.select = _utilBindCallback2['default'](select, thisArg, 2);
	    }

	    FilterOperator.prototype.call = function call(subscriber) {
	        return new FilterSubscriber(subscriber, this.select);
	    };

	    return FilterOperator;
	})();

	var FilterSubscriber = (function (_Subscriber) {
	    _inherits(FilterSubscriber, _Subscriber);

	    function FilterSubscriber(destination, select) {
	        _classCallCheck(this, FilterSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = 0;
	        this.select = select;
	    }

	    FilterSubscriber.prototype._next = function _next(x) {
	        var result = _utilTryCatch2['default'](this.select)(x, this.count++);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else if (Boolean(result)) {
	            this.destination.next(x);
	        }
	    };

	    return FilterSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = distinctUntilChanged;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var _utilBindCallback = __webpack_require__(282);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	function distinctUntilChanged(compare, thisArg) {
	    return this.lift(new DistinctUntilChangedOperator(thisArg ? _utilBindCallback2['default'](compare, thisArg, 2) : compare));
	}

	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare) {
	        _classCallCheck(this, DistinctUntilChangedOperator);

	        this.compare = compare;
	    }

	    DistinctUntilChangedOperator.prototype.call = function call(subscriber) {
	        return new DistinctUntilChangedSubscriber(subscriber, this.compare);
	    };

	    return DistinctUntilChangedOperator;
	})();

	var DistinctUntilChangedSubscriber = (function (_Subscriber) {
	    _inherits(DistinctUntilChangedSubscriber, _Subscriber);

	    function DistinctUntilChangedSubscriber(destination, compare) {
	        _classCallCheck(this, DistinctUntilChangedSubscriber);

	        _Subscriber.call(this, destination);
	        this.hasValue = false;
	        if (typeof compare === "function") {
	            this.compare = compare;
	        }
	    }

	    DistinctUntilChangedSubscriber.prototype.compare = function compare(x, y) {
	        return x === y;
	    };

	    DistinctUntilChangedSubscriber.prototype._next = function _next(x) {
	        var result = false;
	        if (this.hasValue) {
	            result = _utilTryCatch2['default'](this.compare)(this.value, x);
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	                return;
	            }
	        } else {
	            this.hasValue = true;
	        }
	        if (Boolean(result) === false) {
	            this.value = x;
	            this.destination.next(x);
	        }
	    };

	    return DistinctUntilChangedSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = distinctUntilKeyChanged;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _distinctUntilChanged = __webpack_require__(294);

	var _distinctUntilChanged2 = _interopRequireDefault(_distinctUntilChanged);

	function distinctUntilKeyChanged(key, compare, thisArg) {
	    return _distinctUntilChanged2['default'].call(this, function (x, y) {
	        if (compare) {
	            return compare.call(thisArg, x[key], y[key]);
	        }
	        return x[key] === y[key];
	    });
	}

	module.exports = exports['default'];

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = combineLatest;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(243);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _combineLatestSupport = __webpack_require__(297);

	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    observables.unshift(this);
	    return new _observablesArrayObservable2['default'](observables).lift(new _combineLatestSupport.CombineLatestOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.combineLatest = combineLatest;
	exports.combineLatestProto = combineLatestProto;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _observablesArrayObservable = __webpack_require__(243);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _zipSupport = __webpack_require__(298);

	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new CombineLatestOperator(project));
	}

	function combineLatestProto() {
	    for (var _len2 = arguments.length, observables = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        observables[_key2] = arguments[_key2];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    observables.unshift(this);
	    return new _observablesArrayObservable2['default'](observables).lift(new CombineLatestOperator(project));
	}

	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        _classCallCheck(this, CombineLatestOperator);

	        this.project = project;
	    }

	    CombineLatestOperator.prototype.call = function call(subscriber) {
	        return new CombineLatestSubscriber(subscriber, this.project);
	    };

	    return CombineLatestOperator;
	})();

	exports.CombineLatestOperator = CombineLatestOperator;

	var CombineLatestSubscriber = (function (_ZipSubscriber) {
	    _inherits(CombineLatestSubscriber, _ZipSubscriber);

	    function CombineLatestSubscriber(destination, project) {
	        _classCallCheck(this, CombineLatestSubscriber);

	        _ZipSubscriber.call(this, destination, project, []);
	        this.limit = 0;
	    }

	    CombineLatestSubscriber.prototype._subscribeInner = function _subscribeInner(observable, values, index, total) {
	        return observable._subscribe(new CombineLatestInnerSubscriber(this.destination, this, values, index, total));
	    };

	    CombineLatestSubscriber.prototype._innerComplete = function _innerComplete(innerSubscriber) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };

	    return CombineLatestSubscriber;
	})(_zipSupport.ZipSubscriber);

	exports.CombineLatestSubscriber = CombineLatestSubscriber;

	var CombineLatestInnerSubscriber = (function (_ZipInnerSubscriber) {
	    _inherits(CombineLatestInnerSubscriber, _ZipInnerSubscriber);

	    function CombineLatestInnerSubscriber(destination, parent, values, index, total) {
	        _classCallCheck(this, CombineLatestInnerSubscriber);

	        _ZipInnerSubscriber.call(this, destination, parent, values, index, total);
	    }

	    CombineLatestInnerSubscriber.prototype._next = function _next(x) {
	        var index = this.index;
	        var total = this.total;
	        var parent = this.parent;
	        var values = this.values;
	        var valueBox = values[index];
	        var limit = undefined;
	        if (valueBox) {
	            valueBox[0] = x;
	            limit = parent.limit;
	        } else {
	            limit = parent.limit += 1;
	            values[index] = [x];
	        }
	        if (limit >= total) {
	            this._projectNext(values, parent.project);
	        }
	    };

	    return CombineLatestInnerSubscriber;
	})(_zipSupport.ZipInnerSubscriber);

	exports.CombineLatestInnerSubscriber = CombineLatestInnerSubscriber;

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports.mapValue = mapValue;
	exports.hasValue = hasValue;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        _classCallCheck(this, ZipOperator);

	        this.project = project;
	    }

	    ZipOperator.prototype.call = function call(subscriber) {
	        return new ZipSubscriber(subscriber, this.project);
	    };

	    return ZipOperator;
	})();

	exports.ZipOperator = ZipOperator;

	var ZipSubscriber = (function (_Subscriber) {
	    _inherits(ZipSubscriber, _Subscriber);

	    function ZipSubscriber(destination, project) {
	        var values = arguments.length <= 2 || arguments[2] === undefined ? Object.create(null) : arguments[2];

	        _classCallCheck(this, ZipSubscriber);

	        _Subscriber.call(this, destination);
	        this.active = 0;
	        this.observables = [];
	        this.limit = Number.POSITIVE_INFINITY;
	        this.project = typeof project === "function" ? project : null;
	        this.values = values;
	    }

	    ZipSubscriber.prototype._next = function _next(observable) {
	        this.observables.push(observable);
	    };

	    ZipSubscriber.prototype._complete = function _complete() {
	        var values = this.values;
	        var observables = this.observables;
	        var index = -1;
	        var len = observables.length;
	        this.active = len;
	        while (++index < len) {
	            this.add(this._subscribeInner(observables[index], values, index, len));
	        }
	    };

	    ZipSubscriber.prototype._subscribeInner = function _subscribeInner(observable, values, index, total) {
	        return observable._subscribe(new ZipInnerSubscriber(this.destination, this, values, index, total));
	    };

	    ZipSubscriber.prototype._innerComplete = function _innerComplete(innerSubscriber) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        } else {
	            this.limit = innerSubscriber.events;
	        }
	    };

	    return ZipSubscriber;
	})(_Subscriber4['default']);

	exports.ZipSubscriber = ZipSubscriber;

	function arrayInitialize(length) {
	    var arr = Array(length);
	    for (var i = 0; i < length; i++) {
	        arr[i] = null;
	    }
	    return arr;
	}

	var ZipInnerSubscriber = (function (_Subscriber2) {
	    _inherits(ZipInnerSubscriber, _Subscriber2);

	    function ZipInnerSubscriber(destination, parent, values, index, total) {
	        _classCallCheck(this, ZipInnerSubscriber);

	        _Subscriber2.call(this, destination);
	        this.events = 0;
	        this.parent = parent;
	        this.values = values;
	        this.index = index;
	        this.total = total;
	    }

	    ZipInnerSubscriber.prototype._next = function _next(x) {
	        var parent = this.parent;
	        var events = this.events;
	        var total = this.total;
	        var limit = parent.limit;
	        if (events >= limit) {
	            this.destination.complete();
	            return;
	        }
	        var index = this.index;
	        var values = this.values;
	        var zipped = values[events] || (values[events] = arrayInitialize(total));
	        zipped[index] = [x];
	        if (zipped.every(hasValue)) {
	            this._projectNext(zipped, parent.project);
	            values[events] = undefined;
	        }
	        this.events = events + 1;
	    };

	    ZipInnerSubscriber.prototype._projectNext = function _projectNext(values, project) {
	        if (project && typeof project === "function") {
	            var result = _utilTryCatch2['default'](project).apply(null, values.map(mapValue));
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	                return;
	            } else {
	                this.destination.next(result);
	            }
	        } else {
	            this.destination.next(values.map(mapValue));
	        }
	    };

	    ZipInnerSubscriber.prototype._complete = function _complete() {
	        this.parent._innerComplete(this);
	    };

	    return ZipInnerSubscriber;
	})(_Subscriber4['default']);

	exports.ZipInnerSubscriber = ZipInnerSubscriber;

	function mapValue(xs) {
	    return xs[0];
	}

	function hasValue(xs) {
	    return xs && xs.length === 1;
	}

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = combineLatest;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(243);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _combineLatestSupport = __webpack_require__(297);

	function combineLatest() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new _combineLatestSupport.CombineLatestOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = combineAll;

	var _combineLatestSupport = __webpack_require__(297);

	function combineAll(project) {
	    return this.lift(new _combineLatestSupport.CombineLatestOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = withLatestFrom;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function withLatestFrom() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	    }

	    var project = args.pop();
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}

	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        _classCallCheck(this, WithLatestFromOperator);

	        this.observables = observables;
	        this.project = project;
	    }

	    WithLatestFromOperator.prototype.call = function call(subscriber) {
	        return new WithLatestFromSubscriber(subscriber, this.observables, this.project);
	    };

	    return WithLatestFromOperator;
	})();

	var WithLatestFromSubscriber = (function (_Subscriber) {
	    _inherits(WithLatestFromSubscriber, _Subscriber);

	    function WithLatestFromSubscriber(destination, observables, project) {
	        _classCallCheck(this, WithLatestFromSubscriber);

	        _Subscriber.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        var len = observables.length;
	        this.values = new Array(len);
	        this.toSet = len;
	        for (var i = 0; i < len; i++) {
	            this.add(observables[i]._subscribe(new WithLatestInnerSubscriber(this, i)));
	        }
	    }

	    WithLatestFromSubscriber.prototype.notifyValue = function notifyValue(index, value) {
	        this.values[index] = value;
	        this.toSet--;
	    };

	    WithLatestFromSubscriber.prototype._next = function _next(value) {
	        if (this.toSet === 0) {
	            var values = this.values;
	            var result = _utilTryCatch2['default'](this.project)([value].concat(values));
	            if (result === _utilErrorObject.errorObject) {
	                this.destination.error(result.e);
	            } else {
	                this.destination.next(result);
	            }
	        }
	    };

	    return WithLatestFromSubscriber;
	})(_Subscriber4['default']);

	var WithLatestInnerSubscriber = (function (_Subscriber2) {
	    _inherits(WithLatestInnerSubscriber, _Subscriber2);

	    function WithLatestInnerSubscriber(parent, valueIndex) {
	        _classCallCheck(this, WithLatestInnerSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.valueIndex = valueIndex;
	    }

	    WithLatestInnerSubscriber.prototype._next = function _next(value) {
	        this.parent.notifyValue(this.valueIndex, value);
	    };

	    WithLatestInnerSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WithLatestInnerSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WithLatestInnerSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = zipProto;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _zipStatic = __webpack_require__(303);

	var _zipStatic2 = _interopRequireDefault(_zipStatic);

	function zipProto() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    observables.unshift(this);
	    return _zipStatic2['default'].apply(this, observables);
	}

	module.exports = exports['default'];

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = zip;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesArrayObservable = __webpack_require__(243);

	var _observablesArrayObservable2 = _interopRequireDefault(_observablesArrayObservable);

	var _zipSupport = __webpack_require__(298);

	function zip() {
	    for (var _len = arguments.length, observables = Array(_len), _key = 0; _key < _len; _key++) {
	        observables[_key] = arguments[_key];
	    }

	    var project = observables[observables.length - 1];
	    if (typeof project === "function") {
	        observables.pop();
	    }
	    return new _observablesArrayObservable2['default'](observables).lift(new _zipSupport.ZipOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = zipAll;

	var _zipSupport = __webpack_require__(298);

	function zipAll(project) {
	    return this.lift(new _zipSupport.ZipOperator(project));
	}

	module.exports = exports['default'];

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = publish;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _multicast = __webpack_require__(306);

	var _multicast2 = _interopRequireDefault(_multicast);

	function subjectFactory() {
	    return new _Subject2['default']();
	}

	function publish() {
	    return _multicast2['default'].call(this, subjectFactory);
	}

	module.exports = exports['default'];

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = multicast;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesConnectableObservable = __webpack_require__(242);

	var _observablesConnectableObservable2 = _interopRequireDefault(_observablesConnectableObservable);

	function multicast(subjectFactory) {
	    return new _observablesConnectableObservable2['default'](this, subjectFactory);
	}

	module.exports = exports['default'];

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = publishBehavior;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _subjectsBehaviorSubject = __webpack_require__(241);

	var _subjectsBehaviorSubject2 = _interopRequireDefault(_subjectsBehaviorSubject);

	var _multicast = __webpack_require__(306);

	var _multicast2 = _interopRequireDefault(_multicast);

	function publishBehavior(value) {
	    return _multicast2['default'].call(this, function () {
	        return new _subjectsBehaviorSubject2['default'](value);
	    });
	}

	module.exports = exports['default'];

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = publishReplay;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _subjectsReplaySubject = __webpack_require__(240);

	var _subjectsReplaySubject2 = _interopRequireDefault(_subjectsReplaySubject);

	var _multicast = __webpack_require__(306);

	var _multicast2 = _interopRequireDefault(_multicast);

	function publishReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === undefined) bufferSize = Number.POSITIVE_INFINITY;
	    if (windowTime === undefined) windowTime = Number.POSITIVE_INFINITY;

	    return _multicast2['default'].call(this, function () {
	        return new _subjectsReplaySubject2['default'](bufferSize, windowTime, scheduler);
	    });
	}

	module.exports = exports['default'];

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = observeOn;

	var _observeOnSupport = __webpack_require__(262);

	function observeOn(scheduler) {
	    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    return this.lift(new _observeOnSupport.ObserveOnOperator(scheduler, delay));
	}

	module.exports = exports['default'];

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = subscribeOn;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _observablesSubscribeOnObservable = __webpack_require__(311);

	var _observablesSubscribeOnObservable2 = _interopRequireDefault(_observablesSubscribeOnObservable);

	function subscribeOn(scheduler) {
	    var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    return new _observablesSubscribeOnObservable2['default'](this, delay, scheduler);
	}

	module.exports = exports['default'];

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Observable2 = __webpack_require__(220);

	var _Observable3 = _interopRequireDefault(_Observable2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	var SubscribeOnObservable = (function (_Observable) {
	    _inherits(SubscribeOnObservable, _Observable);

	    function SubscribeOnObservable(source) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	        _classCallCheck(this, SubscribeOnObservable);

	        _Observable.call(this);
	        this.source = source;
	        this.delayTime = delay;
	        this.scheduler = scheduler;
	    }

	    SubscribeOnObservable.create = function create(source) {
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
	        var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	        return new SubscribeOnObservable(source, delay, scheduler);
	    };

	    SubscribeOnObservable.dispatch = function dispatch(_ref) {
	        var source = _ref.source;
	        var subscriber = _ref.subscriber;

	        return source.subscribe(subscriber);
	    };

	    SubscribeOnObservable.prototype._subscribe = function _subscribe(subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        }));
	    };

	    return SubscribeOnObservable;
	})(_Observable3['default']);

	exports['default'] = SubscribeOnObservable;
	module.exports = exports['default'];

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = partition;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _utilNot = __webpack_require__(313);

	var _utilNot2 = _interopRequireDefault(_utilNot);

	var _filter = __webpack_require__(293);

	var _filter2 = _interopRequireDefault(_filter);

	function partition(predicate, thisArg) {
	    return [_filter2['default'].call(this, predicate), _filter2['default'].call(this, _utilNot2['default'](predicate, thisArg))];
	}

	module.exports = exports['default'];

/***/ },
/* 313 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = not;

	function not(pred, thisArg) {
	    function notPred() {
	        return !notPred.pred.apply(notPred.thisArg, arguments);
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}

	module.exports = exports["default"];

/***/ },
/* 314 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = toPromise;

	function toPromise() {
	    var _this = this;

	    var PromiseCtor = arguments.length <= 0 || arguments[0] === undefined ? Promise : arguments[0];

	    return new PromiseCtor(function (resolve, reject) {
	        var value = undefined;
	        _this.subscribe(function (x) {
	            return value = x;
	        }, function (err) {
	            return reject(err);
	        }, function () {
	            return resolve(value);
	        });
	    });
	}

	module.exports = exports["default"];

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = defaultIfEmpty;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function defaultIfEmpty() {
	    var defaultValue = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}

	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        _classCallCheck(this, DefaultIfEmptyOperator);

	        this.defaultValue = defaultValue;
	    }

	    DefaultIfEmptyOperator.prototype.call = function call(subscriber) {
	        return new DefaultIfEmptySubscriber(subscriber, this.defaultValue);
	    };

	    return DefaultIfEmptyOperator;
	})();

	var DefaultIfEmptySubscriber = (function (_Subscriber) {
	    _inherits(DefaultIfEmptySubscriber, _Subscriber);

	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _classCallCheck(this, DefaultIfEmptySubscriber);

	        _Subscriber.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }

	    DefaultIfEmptySubscriber.prototype._next = function _next(x) {
	        this.isEmpty = false;
	        this.destination.next(x);
	    };

	    DefaultIfEmptySubscriber.prototype._complete = function _complete() {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };

	    return DefaultIfEmptySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = materialize;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Notification = __webpack_require__(231);

	var _Notification2 = _interopRequireDefault(_Notification);

	function materialize() {
	    return this.lift(new MaterializeOperator());
	}

	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	        _classCallCheck(this, MaterializeOperator);
	    }

	    MaterializeOperator.prototype.call = function call(subscriber) {
	        return new MaterializeSubscriber(subscriber);
	    };

	    return MaterializeOperator;
	})();

	var MaterializeSubscriber = (function (_Subscriber) {
	    _inherits(MaterializeSubscriber, _Subscriber);

	    function MaterializeSubscriber(destination) {
	        _classCallCheck(this, MaterializeSubscriber);

	        _Subscriber.call(this, destination);
	    }

	    MaterializeSubscriber.prototype._next = function _next(value) {
	        this.destination.next(_Notification2['default'].createNext(value));
	    };

	    MaterializeSubscriber.prototype._error = function _error(err) {
	        var destination = this.destination;
	        destination.next(_Notification2['default'].createError(err));
	        destination.complete();
	    };

	    MaterializeSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        destination.next(_Notification2['default'].createComplete());
	        destination.complete();
	    };

	    return MaterializeSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = _catch;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function _catch(selector) {
	    var catchOperator = new CatchOperator(selector);
	    var caught = this.lift(catchOperator);
	    catchOperator.caught = caught;
	    return caught;
	}

	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        _classCallCheck(this, CatchOperator);

	        this.selector = selector;
	    }

	    CatchOperator.prototype.call = function call(subscriber) {
	        return new CatchSubscriber(subscriber, this.selector, this.caught);
	    };

	    return CatchOperator;
	})();

	var CatchSubscriber = (function (_Subscriber) {
	    _inherits(CatchSubscriber, _Subscriber);

	    function CatchSubscriber(destination, selector, caught) {
	        _classCallCheck(this, CatchSubscriber);

	        _Subscriber.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }

	    CatchSubscriber.prototype._error = function _error(err) {
	        var result = _utilTryCatch2['default'](this.selector)(err, this.caught);
	        if (result === _utilErrorObject.errorObject) {
	            this.destination.error(_utilErrorObject.errorObject.e);
	        } else {
	            this.add(result.subscribe(this.destination));
	        }
	    };

	    return CatchSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = retry;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function retry() {
	    var count = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];

	    return this.lift(new RetryOperator(count, this));
	}

	var RetryOperator = (function () {
	    function RetryOperator(count, original) {
	        _classCallCheck(this, RetryOperator);

	        this.count = count;
	        this.original = original;
	    }

	    RetryOperator.prototype.call = function call(subscriber) {
	        return new RetrySubscriber(subscriber, this.count, this.original);
	    };

	    return RetryOperator;
	})();

	var RetrySubscriber = (function (_Subscriber) {
	    _inherits(RetrySubscriber, _Subscriber);

	    function RetrySubscriber(destination, count, original) {
	        _classCallCheck(this, RetrySubscriber);

	        _Subscriber.call(this, destination);
	        this.count = count;
	        this.original = original;
	        this.retries = 0;
	    }

	    RetrySubscriber.prototype._error = function _error(err) {
	        var count = this.count;
	        if (count && count === (this.retries += 1)) {
	            this.destination.error(err);
	        } else {
	            this.resubscribe();
	        }
	    };

	    RetrySubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };

	    return RetrySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = retryWhen;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function retryWhen(notifier) {
	    return this.lift(new RetryWhenOperator(notifier, this));
	}

	var RetryWhenOperator = (function () {
	    function RetryWhenOperator(notifier, original) {
	        _classCallCheck(this, RetryWhenOperator);

	        this.notifier = notifier;
	        this.original = original;
	    }

	    RetryWhenOperator.prototype.call = function call(subscriber) {
	        return new RetryWhenSubscriber(subscriber, this.notifier, this.original);
	    };

	    return RetryWhenOperator;
	})();

	var RetryWhenSubscriber = (function (_Subscriber) {
	    _inherits(RetryWhenSubscriber, _Subscriber);

	    function RetryWhenSubscriber(destination, notifier, original) {
	        _classCallCheck(this, RetryWhenSubscriber);

	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.original = original;
	    }

	    RetryWhenSubscriber.prototype._error = function _error(err) {
	        if (!this.retryNotifications) {
	            this.errors = new _Subject2['default']();
	            var notifications = _utilTryCatch2['default'](this.notifier).call(this, this.errors);
	            if (notifications === _utilErrorObject.errorObject) {
	                this.destination.error(_utilErrorObject.errorObject.e);
	            } else {
	                this.retryNotifications = notifications;
	                this.add(notifications._subscribe(new RetryNotificationSubscriber(this)));
	            }
	        }
	        this.errors.next(err);
	    };

	    RetryWhenSubscriber.prototype.finalError = function finalError(err) {
	        this.destination.error(err);
	    };

	    RetryWhenSubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };

	    return RetryWhenSubscriber;
	})(_Subscriber4['default']);

	var RetryNotificationSubscriber = (function (_Subscriber2) {
	    _inherits(RetryNotificationSubscriber, _Subscriber2);

	    function RetryNotificationSubscriber(parent) {
	        _classCallCheck(this, RetryNotificationSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    RetryNotificationSubscriber.prototype._next = function _next(value) {
	        this.parent.resubscribe();
	    };

	    RetryNotificationSubscriber.prototype._error = function _error(err) {
	        this.parent.finalError(err);
	    };

	    RetryNotificationSubscriber.prototype._complete = function _complete() {
	        this.parent.complete();
	    };

	    return RetryNotificationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = repeat;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function repeat(count) {
	    return this.lift(new RepeatOperator(count, this));
	}

	var RepeatOperator = (function () {
	    function RepeatOperator(count, original) {
	        _classCallCheck(this, RepeatOperator);

	        this.count = count;
	        this.original = original;
	    }

	    RepeatOperator.prototype.call = function call(subscriber) {
	        return new RepeatSubscriber(subscriber, this.count, this.original);
	    };

	    return RepeatOperator;
	})();

	var RepeatSubscriber = (function (_Subscriber) {
	    _inherits(RepeatSubscriber, _Subscriber);

	    function RepeatSubscriber(destination, count, original) {
	        _classCallCheck(this, RepeatSubscriber);

	        _Subscriber.call(this, destination);
	        this.count = count;
	        this.original = original;
	        this.repeated = 0;
	    }

	    RepeatSubscriber.prototype._complete = function _complete() {
	        if (this.count === (this.repeated += 1)) {
	            this.destination.complete();
	        } else {
	            this.resubscribe();
	        }
	    };

	    RepeatSubscriber.prototype.resubscribe = function resubscribe() {
	        this.original.subscribe(this);
	    };

	    return RepeatSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = _finally;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilBindCallback = __webpack_require__(282);

	var _utilBindCallback2 = _interopRequireDefault(_utilBindCallback);

	function _finally(finallySelector, thisArg) {
	    return this.lift(new FinallyOperator(thisArg ? _utilBindCallback2['default'](finallySelector, thisArg, 2) : finallySelector));
	}

	var FinallyOperator = (function () {
	    function FinallyOperator(finallySelector) {
	        _classCallCheck(this, FinallyOperator);

	        this.finallySelector = finallySelector;
	    }

	    FinallyOperator.prototype.call = function call(subscriber) {
	        return new FinallySubscriber(subscriber, this.finallySelector);
	    };

	    return FinallyOperator;
	})();

	var FinallySubscriber = (function (_Subscriber) {
	    _inherits(FinallySubscriber, _Subscriber);

	    function FinallySubscriber(destination, finallySelector) {
	        _classCallCheck(this, FinallySubscriber);

	        _Subscriber.call(this, destination);
	        this.add(new _Subscription2['default'](finallySelector));
	    }

	    return FinallySubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = timeout;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var _utilIsDate = __webpack_require__(323);

	var _utilIsDate2 = _interopRequireDefault(_utilIsDate);

	function timeout(due) {
	    var errorToSend = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];

	    var waitFor = _utilIsDate2['default'](due) ? +due - Date.now() : due;
	    return this.lift(new TimeoutOperator(waitFor, errorToSend, scheduler));
	}

	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, errorToSend, scheduler) {
	        _classCallCheck(this, TimeoutOperator);

	        this.waitFor = waitFor;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	    }

	    TimeoutOperator.prototype.call = function call(subscriber) {
	        return new TimeoutSubscriber(subscriber, this.waitFor, this.errorToSend, this.scheduler);
	    };

	    return TimeoutOperator;
	})();

	var TimeoutSubscriber = (function (_Subscriber) {
	    _inherits(TimeoutSubscriber, _Subscriber);

	    function TimeoutSubscriber(destination, waitFor, errorToSend, scheduler) {
	        _classCallCheck(this, TimeoutSubscriber);

	        _Subscriber.call(this, destination);
	        this.waitFor = waitFor;
	        this.errorToSend = errorToSend;
	        this.scheduler = scheduler;
	        var delay = waitFor;
	        scheduler.schedule(dispatchTimeout, delay, { subscriber: this });
	    }

	    TimeoutSubscriber.prototype.sendTimeoutError = function sendTimeoutError() {
	        this.error(this.errorToSend || new Error('timeout'));
	    };

	    return TimeoutSubscriber;
	})(_Subscriber3['default']);

	function dispatchTimeout(state) {
	    var subscriber = state.subscriber;
	    subscriber.sendTimeoutError();
	}
	module.exports = exports['default'];

/***/ },
/* 323 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;
	exports["default"] = isDate;

	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}

	module.exports = exports["default"];

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = timeoutWith;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	var _utilIsDate = __webpack_require__(323);

	var _utilIsDate2 = _interopRequireDefault(_utilIsDate);

	function timeoutWith(due, withObservable) {
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersImmediate2['default'] : arguments[2];

	    var waitFor = _utilIsDate2['default'](due) ? +due - Date.now() : due;
	    return this.lift(new TimeoutWithOperator(waitFor, withObservable, scheduler));
	}

	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, withObservable, scheduler) {
	        _classCallCheck(this, TimeoutWithOperator);

	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }

	    TimeoutWithOperator.prototype.call = function call(subscriber) {
	        return new TimeoutWithSubscriber(subscriber, this.waitFor, this.withObservable, this.scheduler);
	    };

	    return TimeoutWithOperator;
	})();

	var TimeoutWithSubscriber = (function (_Subscriber) {
	    _inherits(TimeoutWithSubscriber, _Subscriber);

	    function TimeoutWithSubscriber(destination, waitFor, withObservable, scheduler) {
	        _classCallCheck(this, TimeoutWithSubscriber);

	        _Subscriber.call(this, destination);
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        var delay = waitFor;
	        scheduler.schedule(dispatchTimeout, delay, { subscriber: this });
	    }

	    TimeoutWithSubscriber.prototype.handleTimeout = function handleTimeout() {
	        var withObservable = this.withObservable;
	        this.add(withObservable.subscribe(this));
	    };

	    return TimeoutWithSubscriber;
	})(_Subscriber3['default']);

	function dispatchTimeout(state) {
	    var subscriber = state.subscriber;
	    subscriber.handleTimeout();
	}
	module.exports = exports['default'];

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = groupBy;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilMap = __webpack_require__(326);

	var _utilMap2 = _interopRequireDefault(_utilMap);

	var _utilFastMap = __webpack_require__(327);

	var _utilFastMap2 = _interopRequireDefault(_utilFastMap);

	var _subjectsGroupSubject = __webpack_require__(328);

	var _subjectsGroupSubject2 = _interopRequireDefault(_subjectsGroupSubject);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function groupBy(keySelector, elementSelector, durationSelector) {
	    return this.lift(new GroupByOperator(keySelector, durationSelector, elementSelector));
	}

	var GroupByOperator = (function () {
	    function GroupByOperator(keySelector, durationSelector, elementSelector) {
	        _classCallCheck(this, GroupByOperator);

	        this.keySelector = keySelector;
	        this.durationSelector = durationSelector;
	        this.elementSelector = elementSelector;
	    }

	    GroupByOperator.prototype.call = function call(subscriber) {
	        return new GroupBySubscriber(subscriber, this.keySelector, this.durationSelector, this.elementSelector);
	    };

	    return GroupByOperator;
	})();

	var GroupBySubscriber = (function (_Subscriber) {
	    _inherits(GroupBySubscriber, _Subscriber);

	    function GroupBySubscriber(destination, keySelector, durationSelector, elementSelector) {
	        _classCallCheck(this, GroupBySubscriber);

	        _Subscriber.call(this, destination);
	        this.keySelector = keySelector;
	        this.durationSelector = durationSelector;
	        this.elementSelector = elementSelector;
	        this.groups = null;
	    }

	    GroupBySubscriber.prototype._next = function _next(x) {
	        var key = _utilTryCatch2['default'](this.keySelector)(x);
	        if (key === _utilErrorObject.errorObject) {
	            this.error(key.e);
	        } else {
	            var groups = this.groups;
	            var elementSelector = this.elementSelector;
	            var durationSelector = this.durationSelector;
	            if (!groups) {
	                groups = this.groups = typeof key === 'string' ? new _utilFastMap2['default']() : new _utilMap2['default']();
	            }
	            var group = groups.get(key);
	            if (!group) {
	                groups.set(key, group = new _subjectsGroupSubject2['default'](key));
	                if (durationSelector) {
	                    var duration = _utilTryCatch2['default'](durationSelector)(group);
	                    if (duration === _utilErrorObject.errorObject) {
	                        this.error(duration.e);
	                    } else {
	                        this.add(duration._subscribe(new GroupDurationSubscriber(group, this)));
	                    }
	                }
	                this.destination.next(group);
	            }
	            if (elementSelector) {
	                var value = _utilTryCatch2['default'](elementSelector)(x);
	                if (value === _utilErrorObject.errorObject) {
	                    group.error(value.e);
	                } else {
	                    group.next(value);
	                }
	            } else {
	                group.next(x);
	            }
	        }
	    };

	    GroupBySubscriber.prototype._error = function _error(err) {
	        var _this = this;

	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	                _this.removeGroup(key);
	            });
	        }
	        this.destination.error(err);
	    };

	    GroupBySubscriber.prototype._complete = function _complete() {
	        var _this2 = this;

	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	                _this2.removeGroup(group);
	            });
	        }
	        this.destination.complete();
	    };

	    GroupBySubscriber.prototype.removeGroup = function removeGroup(key) {
	        this.groups[key] = null;
	    };

	    return GroupBySubscriber;
	})(_Subscriber4['default']);

	var GroupDurationSubscriber = (function (_Subscriber2) {
	    _inherits(GroupDurationSubscriber, _Subscriber2);

	    function GroupDurationSubscriber(group, parent) {
	        _classCallCheck(this, GroupDurationSubscriber);

	        _Subscriber2.call(this, null);
	        this.group = group;
	        this.parent = parent;
	    }

	    GroupDurationSubscriber.prototype._next = function _next(value) {
	        var group = this.group;
	        group.complete();
	        this.parent.removeGroup(group.key);
	    };

	    GroupDurationSubscriber.prototype._error = function _error(err) {
	        var group = this.group;
	        group.error(err);
	        this.parent.removeGroup(group.key);
	    };

	    GroupDurationSubscriber.prototype._complete = function _complete() {
	        var group = this.group;
	        group.complete();
	        this.parent.removeGroup(group.key);
	    };

	    return GroupDurationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	var _root = __webpack_require__(227);

	exports['default'] = _root.root.Map || (function () {
	    function Map() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    Map.prototype['delete'] = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    Map.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    Map.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        } else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    Map.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return Map;
	})();

	module.exports = exports['default'];

/***/ },
/* 327 */
/***/ function(module, exports) {

	"use strict";

	exports.__esModule = true;

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var FastMap = (function () {
	    function FastMap() {
	        _classCallCheck(this, FastMap);

	        this.size = 0;
	        this._values = {};
	    }

	    FastMap.prototype["delete"] = function _delete(key) {
	        this._values[key] = null;
	        return true;
	    };

	    FastMap.prototype.set = function set(key, value) {
	        this._values[key] = value;
	        return this;
	    };

	    FastMap.prototype.get = function get(key) {
	        return this._values[key];
	    };

	    FastMap.prototype.forEach = function forEach(cb, thisArg) {
	        var values = this._values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key)) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };

	    FastMap.prototype.clear = function clear() {
	        this._values = {};
	    };

	    return FastMap;
	})();

	exports["default"] = FastMap;
	module.exports = exports["default"];

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Subject2 = __webpack_require__(219);

	var _Subject3 = _interopRequireDefault(_Subject2);

	var GroupSubject = (function (_Subject) {
	    _inherits(GroupSubject, _Subject);

	    function GroupSubject(key) {
	        _classCallCheck(this, GroupSubject);

	        _Subject.call(this);
	        this.key = key;
	    }

	    return GroupSubject;
	})(_Subject3['default']);

	exports['default'] = GroupSubject;
	module.exports = exports['default'];

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = window;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	function window(closingNotifier) {
	    return this.lift(new WindowOperator(closingNotifier));
	}

	var WindowOperator = (function () {
	    function WindowOperator(closingNotifier) {
	        _classCallCheck(this, WindowOperator);

	        this.closingNotifier = closingNotifier;
	    }

	    WindowOperator.prototype.call = function call(subscriber) {
	        return new WindowSubscriber(subscriber, this.closingNotifier);
	    };

	    return WindowOperator;
	})();

	var WindowSubscriber = (function (_Subscriber) {
	    _inherits(WindowSubscriber, _Subscriber);

	    function WindowSubscriber(destination, closingNotifier) {
	        _classCallCheck(this, WindowSubscriber);

	        _Subscriber.call(this, destination);
	        this.closingNotifier = closingNotifier;
	        this.window = new _Subject2['default']();
	        this.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this)));
	        this.openWindow();
	    }

	    WindowSubscriber.prototype._next = function _next(value) {
	        this.window.next(value);
	    };

	    WindowSubscriber.prototype._error = function _error(err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };

	    WindowSubscriber.prototype._complete = function _complete() {
	        this.window.complete();
	        this.destination.complete();
	    };

	    WindowSubscriber.prototype.openWindow = function openWindow() {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        this.destination.next(this.window = new _Subject2['default']());
	    };

	    return WindowSubscriber;
	})(_Subscriber4['default']);

	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

	    function WindowClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openWindow();
	    };

	    return WindowClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = window;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function window(closingSelector) {
	    return this.lift(new WindowOperator(closingSelector));
	}

	var WindowOperator = (function () {
	    function WindowOperator(closingSelector) {
	        _classCallCheck(this, WindowOperator);

	        this.closingSelector = closingSelector;
	    }

	    WindowOperator.prototype.call = function call(subscriber) {
	        return new WindowSubscriber(subscriber, this.closingSelector);
	    };

	    return WindowOperator;
	})();

	var WindowSubscriber = (function (_Subscriber) {
	    _inherits(WindowSubscriber, _Subscriber);

	    function WindowSubscriber(destination, closingSelector) {
	        _classCallCheck(this, WindowSubscriber);

	        _Subscriber.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.window = new _Subject2['default']();
	        this.openWindow();
	    }

	    WindowSubscriber.prototype._next = function _next(value) {
	        this.window.next(value);
	    };

	    WindowSubscriber.prototype._error = function _error(err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };

	    WindowSubscriber.prototype._complete = function _complete() {
	        this.window.complete();
	        this.destination.complete();
	    };

	    WindowSubscriber.prototype.openWindow = function openWindow() {
	        var prevClosingNotification = this.closingNotification;
	        if (prevClosingNotification) {
	            this.remove(prevClosingNotification);
	            prevClosingNotification.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        this.destination.next(this.window = new _Subject2['default']());
	        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.destination.error(err);
	            this.window.error(err);
	        } else {
	            var closingNotification = this.closingNotification = new _Subscription2['default']();
	            this.add(closingNotification.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this))));
	        }
	    };

	    return WindowSubscriber;
	})(_Subscriber4['default']);

	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

	    function WindowClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openWindow();
	    };

	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WindowClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = windowToggle;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber4 = __webpack_require__(221);

	var _Subscriber5 = _interopRequireDefault(_Subscriber4);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function windowToggle(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}

	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        _classCallCheck(this, WindowToggleOperator);

	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }

	    WindowToggleOperator.prototype.call = function call(subscriber) {
	        return new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector);
	    };

	    return WindowToggleOperator;
	})();

	var WindowToggleSubscriber = (function (_Subscriber) {
	    _inherits(WindowToggleSubscriber, _Subscriber);

	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _classCallCheck(this, WindowToggleSubscriber);

	        _Subscriber.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.windows = [];
	        this.add(this.openings._subscribe(new WindowToggleOpeningsSubscriber(this)));
	    }

	    WindowToggleSubscriber.prototype._next = function _next(value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	    };

	    WindowToggleSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };

	    WindowToggleSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };

	    WindowToggleSubscriber.prototype.openWindow = function openWindow(value) {
	        var window = new _Subject2['default']();
	        this.windows.push(window);
	        this.destination.next(window);
	        var windowContext = {
	            window: window,
	            subscription: new _Subscription2['default']()
	        };
	        var closingSelector = this.closingSelector;
	        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            this.error(closingNotifier.e);
	        } else {
	            this.add(windowContext.subscription.add(closingNotifier._subscribe(new WindowClosingNotifierSubscriber(this, windowContext))));
	        }
	    };

	    WindowToggleSubscriber.prototype.closeWindow = function closeWindow(windowContext) {
	        var window = windowContext.window;
	        var subscription = windowContext.subscription;

	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	        window.complete();
	        this.remove(subscription);
	    };

	    return WindowToggleSubscriber;
	})(_Subscriber5['default']);

	var WindowClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(WindowClosingNotifierSubscriber, _Subscriber2);

	    function WindowClosingNotifierSubscriber(parent, windowContext) {
	        _classCallCheck(this, WindowClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.windowContext = windowContext;
	    }

	    WindowClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.closeWindow(this.windowContext);
	    };

	    WindowClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WindowClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WindowClosingNotifierSubscriber;
	})(_Subscriber5['default']);

	var WindowToggleOpeningsSubscriber = (function (_Subscriber3) {
	    _inherits(WindowToggleOpeningsSubscriber, _Subscriber3);

	    function WindowToggleOpeningsSubscriber(parent) {
	        _classCallCheck(this, WindowToggleOpeningsSubscriber);

	        _Subscriber3.call(this);
	        this.parent = parent;
	    }

	    WindowToggleOpeningsSubscriber.prototype._next = function _next(value) {
	        this.parent.openWindow(value);
	    };

	    WindowToggleOpeningsSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    WindowToggleOpeningsSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return WindowToggleOpeningsSubscriber;
	})(_Subscriber5['default']);

	module.exports = exports['default'];

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = windowTime;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function windowTime(windowTimeSpan) {
	    var windowCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler));
	}

	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, scheduler) {
	        _classCallCheck(this, WindowTimeOperator);

	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	    }

	    WindowTimeOperator.prototype.call = function call(subscriber) {
	        return new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.scheduler);
	    };

	    return WindowTimeOperator;
	})();

	var WindowTimeSubscriber = (function (_Subscriber) {
	    _inherits(WindowTimeSubscriber, _Subscriber);

	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, scheduler) {
	        _classCallCheck(this, WindowTimeSubscriber);

	        _Subscriber.call(this, destination);
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.scheduler = scheduler;
	        this.windows = [];
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var _window = this.openWindow();
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, { subscriber: this, window: _window, context: null }));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler }));
	        } else {
	            var _window2 = this.openWindow();
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, { subscriber: this, window: _window2, windowTimeSpan: windowTimeSpan }));
	        }
	    }

	    WindowTimeSubscriber.prototype._next = function _next(value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            windows[i].next(value);
	        }
	    };

	    WindowTimeSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };

	    WindowTimeSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().complete();
	        }
	        this.destination.complete();
	    };

	    WindowTimeSubscriber.prototype.openWindow = function openWindow() {
	        var window = new _Subject2['default']();
	        this.windows.push(window);
	        this.destination.next(window);
	        return window;
	    };

	    WindowTimeSubscriber.prototype.closeWindow = function closeWindow(window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };

	    return WindowTimeSubscriber;
	})(_Subscriber3['default']);

	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var windowTimeSpan = state.windowTimeSpan;
	    var window = state.window;

	    if (window) {
	        window.complete();
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan;
	    var subscriber = state.subscriber;
	    var scheduler = state.scheduler;
	    var windowCreationInterval = state.windowCreationInterval;

	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    action.add(context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, { subscriber: subscriber, window: window, context: context }));
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(_ref) {
	    var subscriber = _ref.subscriber;
	    var window = _ref.window;
	    var context = _ref.context;

	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}
	module.exports = exports['default'];

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = windowCount;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Subject = __webpack_require__(219);

	var _Subject2 = _interopRequireDefault(_Subject);

	function windowCount(windowSize) {
	    var startWindowEvery = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}

	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        _classCallCheck(this, WindowCountOperator);

	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }

	    WindowCountOperator.prototype.call = function call(subscriber) {
	        return new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery);
	    };

	    return WindowCountOperator;
	})();

	var WindowCountSubscriber = (function (_Subscriber) {
	    _inherits(WindowCountSubscriber, _Subscriber);

	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _classCallCheck(this, WindowCountSubscriber);

	        _Subscriber.call(this, destination);
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [{ count: 0, notified: false, window: new _Subject2['default']() }];
	        this.count = 0;
	    }

	    WindowCountSubscriber.prototype._next = function _next(value) {
	        var count = this.count += 1;
	        var startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        if (count % startWindowEvery === 0) {
	            var _window = new _Subject2['default']();
	            windows.push({ count: 0, notified: false, window: _window });
	        }
	        for (var i = 0; i < len; i++) {
	            var w = windows[i];
	            var _window2 = w.window;
	            if (!w.notified) {
	                w.notified = true;
	                this.destination.next(_window2);
	            }
	            _window2.next(value);
	            if (windowSize === (w.count += 1)) {
	                _window2.complete();
	            }
	        }
	    };

	    WindowCountSubscriber.prototype._error = function _error(err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().window.error(err);
	        }
	        this.destination.error(err);
	    };

	    WindowCountSubscriber.prototype._complete = function _complete() {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().window.complete();
	        }
	        this.destination.complete();
	    };

	    return WindowCountSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = delay;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _Notification = __webpack_require__(231);

	var _Notification2 = _interopRequireDefault(_Notification);

	var _schedulersImmediate = __webpack_require__(232);

	var _schedulersImmediate2 = _interopRequireDefault(_schedulersImmediate);

	function delay(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersImmediate2['default'] : arguments[1];

	    return this.lift(new DelayOperator(delay, scheduler));
	}

	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        _classCallCheck(this, DelayOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    DelayOperator.prototype.call = function call(subscriber) {
	        return new DelaySubscriber(subscriber, this.delay, this.scheduler);
	    };

	    return DelayOperator;
	})();

	var DelaySubscriber = (function (_Subscriber) {
	    _inherits(DelaySubscriber, _Subscriber);

	    function DelaySubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, DelaySubscriber);

	        _Subscriber.call(this, destination);
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    DelaySubscriber.dispatch = function dispatch(state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var _delay = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, _delay);
	        } else {
	            source.active = false;
	        }
	    };

	    DelaySubscriber.prototype._next = function _next(x) {
	        if (this.errored) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createNext(x)));
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };

	    DelaySubscriber.prototype._error = function _error(e) {
	        var scheduler = this.scheduler;
	        this.errored = true;
	        this.queue = [new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createError(e))];
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };

	    DelaySubscriber.prototype._complete = function _complete() {
	        if (this.errored) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        this.queue.push(new DelayMessage(scheduler.now() + this.delay, _Notification2['default'].createComplete()));
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };

	    DelaySubscriber.prototype._schedule = function _schedule(scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };

	    return DelaySubscriber;
	})(_Subscriber3['default']);

	var DelayMessage = function DelayMessage(time, notification) {
	    _classCallCheck(this, DelayMessage);

	    this.time = time;
	    this.notification = notification;
	};

	module.exports = exports['default'];

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = throttle;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function throttle(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	    return this.lift(new ThrottleOperator(delay, scheduler));
	}

	var ThrottleOperator = (function () {
	    function ThrottleOperator(delay, scheduler) {
	        _classCallCheck(this, ThrottleOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ThrottleOperator.prototype.call = function call(subscriber) {
	        return new ThrottleSubscriber(subscriber, this.delay, this.scheduler);
	    };

	    return ThrottleOperator;
	})();

	var ThrottleSubscriber = (function (_Subscriber) {
	    _inherits(ThrottleSubscriber, _Subscriber);

	    function ThrottleSubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, ThrottleSubscriber);

	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    ThrottleSubscriber.prototype._next = function _next(x) {
	        this.clearThrottle();
	        this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.delay, { value: x, subscriber: this }));
	    };

	    ThrottleSubscriber.prototype.throttledNext = function throttledNext(x) {
	        this.clearThrottle();
	        this.destination.next(x);
	    };

	    ThrottleSubscriber.prototype.clearThrottle = function clearThrottle() {
	        var throttled = this.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            throttled.unsubscribe();
	            this.throttled = null;
	        }
	    };

	    return ThrottleSubscriber;
	})(_Subscriber3['default']);

	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;

	    subscriber.throttledNext(value);
	}
	module.exports = exports['default'];

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = debounce;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function debounce(dueTime) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	    return this.lift(new DebounceOperator(dueTime, scheduler));
	}

	var DebounceOperator = (function () {
	    function DebounceOperator(dueTime, scheduler) {
	        _classCallCheck(this, DebounceOperator);

	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }

	    DebounceOperator.prototype.call = function call(subscriber) {
	        return new DebounceSubscriber(subscriber, this.dueTime, this.scheduler);
	    };

	    return DebounceOperator;
	})();

	var DebounceSubscriber = (function (_Subscriber) {
	    _inherits(DebounceSubscriber, _Subscriber);

	    function DebounceSubscriber(destination, dueTime, scheduler) {
	        _classCallCheck(this, DebounceSubscriber);

	        _Subscriber.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }

	    DebounceSubscriber.prototype._next = function _next(value) {
	        if (!this.debounced) {
	            this.add(this.debounced = this.scheduler.schedule(dispatchNext, this.dueTime, { value: value, subscriber: this }));
	        }
	    };

	    DebounceSubscriber.prototype.clearDebounce = function clearDebounce() {
	        var debounced = this.debounced;
	        if (debounced) {
	            debounced.unsubscribe();
	            this.remove(debounced);
	        }
	    };

	    DebounceSubscriber.prototype.debouncedNext = function debouncedNext(value) {
	        this.clearDebounce();
	        this.destination.next(value);
	    };

	    return DebounceSubscriber;
	})(_Subscriber3['default']);

	function dispatchNext(_ref) {
	    var value = _ref.value;
	    var subscriber = _ref.subscriber;

	    subscriber.debouncedNext(value);
	}
	module.exports = exports['default'];

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = buffer;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	/**
	 * buffers the incoming observable values until the passed `closingNotifier` emits a value, at which point
	 * it emits the buffer on the returned observable and starts a new buffer internally, awaiting the
	 * next time `closingNotifier` emits
	 *
	 * @param {Observable<any>} closingNotifier an observable, that signals the buffer to be emitted from the returned observable
	 * @returns {Observable<T[]>} an observable of buffers, which are arrays of values
	 */

	function buffer(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}

	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        _classCallCheck(this, BufferOperator);

	        this.closingNotifier = closingNotifier;
	    }

	    BufferOperator.prototype.call = function call(subscriber) {
	        return new BufferSubscriber(subscriber, this.closingNotifier);
	    };

	    return BufferOperator;
	})();

	var BufferSubscriber = (function (_Subscriber) {
	    _inherits(BufferSubscriber, _Subscriber);

	    function BufferSubscriber(destination, closingNotifier) {
	        _classCallCheck(this, BufferSubscriber);

	        _Subscriber.call(this, destination);
	        this.buffer = [];
	        this.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
	    }

	    BufferSubscriber.prototype._next = function _next(value) {
	        this.buffer.push(value);
	    };

	    BufferSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };

	    BufferSubscriber.prototype._complete = function _complete() {
	        this.flushBuffer();
	        this.destination.complete();
	    };

	    BufferSubscriber.prototype.flushBuffer = function flushBuffer() {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };

	    return BufferSubscriber;
	})(_Subscriber4['default']);

	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

	    function BufferClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    BufferClosingNotifierSubscriber.prototype._next = function _next(value) {
	        this.parent.flushBuffer();
	    };

	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferCount;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	function bufferCount(bufferSize) {
	    var startBufferEvery = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}

	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        _classCallCheck(this, BufferCountOperator);

	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	    }

	    BufferCountOperator.prototype.call = function call(subscriber) {
	        return new BufferCountSubscriber(subscriber, this.bufferSize, this.startBufferEvery);
	    };

	    return BufferCountOperator;
	})();

	var BufferCountSubscriber = (function (_Subscriber) {
	    _inherits(BufferCountSubscriber, _Subscriber);

	    function BufferCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _classCallCheck(this, BufferCountSubscriber);

	        _Subscriber.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [[]];
	        this.count = 0;
	    }

	    BufferCountSubscriber.prototype._next = function _next(value) {
	        var count = this.count += 1;
	        var destination = this.destination;
	        var bufferSize = this.bufferSize;
	        var startBufferEvery = this.startBufferEvery == null ? bufferSize : this.startBufferEvery;
	        var buffers = this.buffers;
	        var len = buffers.length;
	        var remove = -1;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = 0; i < len; i++) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                remove = i;
	                this.destination.next(buffer);
	            }
	        }
	        if (remove !== -1) {
	            buffers.splice(remove, 1);
	        }
	    };

	    BufferCountSubscriber.prototype._error = function _error(err) {
	        this.destination.error(err);
	    };

	    BufferCountSubscriber.prototype._complete = function _complete() {
	        var destination = this.destination;
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        destination.complete();
	    };

	    return BufferCountSubscriber;
	})(_Subscriber3['default']);

	module.exports = exports['default'];

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferTime;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function bufferTime(bufferTimeSpan) {
	    var bufferCreationInterval = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	    var scheduler = arguments.length <= 2 || arguments[2] === undefined ? _schedulersNextTick2['default'] : arguments[2];

	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler));
	}

	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _classCallCheck(this, BufferTimeOperator);

	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	    }

	    BufferTimeOperator.prototype.call = function call(subscriber) {
	        return new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.scheduler);
	    };

	    return BufferTimeOperator;
	})();

	var BufferTimeSubscriber = (function (_Subscriber) {
	    _inherits(BufferTimeSubscriber, _Subscriber);

	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, scheduler) {
	        _classCallCheck(this, BufferTimeSubscriber);

	        _Subscriber.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.scheduler = scheduler;
	        this.buffers = [];
	        var buffer = this.openBuffer();
	        if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
	            this.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: this, buffer: buffer }));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler }));
	        } else {
	            this.add(scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, { subscriber: this, buffer: buffer, bufferTimeSpan: bufferTimeSpan }));
	        }
	    }

	    BufferTimeSubscriber.prototype._next = function _next(value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };

	    BufferTimeSubscriber.prototype._error = function _error(err) {
	        this.buffers.length = 0;
	        this.destination.error(err);
	    };

	    BufferTimeSubscriber.prototype._complete = function _complete() {
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            this.destination.next(buffers.shift());
	        }
	        this.destination.complete();
	    };

	    BufferTimeSubscriber.prototype.openBuffer = function openBuffer() {
	        var buffer = [];
	        this.buffers.push(buffer);
	        return buffer;
	    };

	    BufferTimeSubscriber.prototype.closeBuffer = function closeBuffer(buffer) {
	        this.destination.next(buffer);
	        var buffers = this.buffers;
	        buffers.splice(buffers.indexOf(buffer), 1);
	    };

	    return BufferTimeSubscriber;
	})(_Subscriber3['default']);

	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevBuffer = state.buffer;
	    if (prevBuffer) {
	        subscriber.closeBuffer(prevBuffer);
	    }
	    state.buffer = subscriber.openBuffer();
	    this.schedule(state, state.bufferTimeSpan);
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval;
	    var bufferTimeSpan = state.bufferTimeSpan;
	    var subscriber = state.subscriber;
	    var scheduler = state.scheduler;

	    var buffer = subscriber.openBuffer();
	    var action = this;
	    action.add(scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, buffer: buffer }));
	    action.schedule(state, bufferCreationInterval);
	}
	function dispatchBufferClose(_ref) {
	    var subscriber = _ref.subscriber;
	    var buffer = _ref.buffer;

	    subscriber.closeBuffer(buffer);
	}
	module.exports = exports['default'];

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferToggle;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber4 = __webpack_require__(221);

	var _Subscriber5 = _interopRequireDefault(_Subscriber4);

	var _Subscription = __webpack_require__(225);

	var _Subscription2 = _interopRequireDefault(_Subscription);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function bufferToggle(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}

	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        _classCallCheck(this, BufferToggleOperator);

	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }

	    BufferToggleOperator.prototype.call = function call(subscriber) {
	        return new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector);
	    };

	    return BufferToggleOperator;
	})();

	var BufferToggleSubscriber = (function (_Subscriber) {
	    _inherits(BufferToggleSubscriber, _Subscriber);

	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _classCallCheck(this, BufferToggleSubscriber);

	        _Subscriber.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.buffers = [];
	        this.add(this.openings._subscribe(new BufferToggleOpeningsSubscriber(this)));
	    }

	    BufferToggleSubscriber.prototype._next = function _next(value) {
	        var buffers = this.buffers;
	        var len = buffers.length;
	        for (var i = 0; i < len; i++) {
	            buffers[i].push(value);
	        }
	    };

	    BufferToggleSubscriber.prototype._error = function _error(err) {
	        this.buffers = null;
	        this.destination.error(err);
	    };

	    BufferToggleSubscriber.prototype._complete = function _complete() {
	        var buffers = this.buffers;
	        while (buffers.length > 0) {
	            this.destination.next(buffers.shift());
	        }
	        this.destination.complete();
	    };

	    BufferToggleSubscriber.prototype.openBuffer = function openBuffer(value) {
	        var closingSelector = this.closingSelector;
	        var buffers = this.buffers;
	        var closingNotifier = _utilTryCatch2['default'](closingSelector)(value);
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.buffers = null;
	            this.destination.error(err);
	        } else {
	            var buffer = [];
	            var context = {
	                buffer: buffer,
	                subscription: new _Subscription2['default']()
	            };
	            buffers.push(buffer);
	            this.add(context.subscription.add(closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this, context))));
	        }
	    };

	    BufferToggleSubscriber.prototype.closeBuffer = function closeBuffer(context) {
	        var buffer = context.buffer;
	        var subscription = context.subscription;

	        var buffers = this.buffers;
	        this.destination.next(buffer);
	        buffers.splice(buffers.indexOf(buffer), 1);
	        this.remove(subscription);
	        subscription.unsubscribe();
	    };

	    return BufferToggleSubscriber;
	})(_Subscriber5['default']);

	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

	    function BufferClosingNotifierSubscriber(parent, context) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	        this.context = context;
	    }

	    BufferClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.closeBuffer(this.context);
	    };

	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferClosingNotifierSubscriber;
	})(_Subscriber5['default']);

	var BufferToggleOpeningsSubscriber = (function (_Subscriber3) {
	    _inherits(BufferToggleOpeningsSubscriber, _Subscriber3);

	    function BufferToggleOpeningsSubscriber(parent) {
	        _classCallCheck(this, BufferToggleOpeningsSubscriber);

	        _Subscriber3.call(this, null);
	        this.parent = parent;
	    }

	    BufferToggleOpeningsSubscriber.prototype._next = function _next(value) {
	        this.parent.openBuffer(value);
	    };

	    BufferToggleOpeningsSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferToggleOpeningsSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferToggleOpeningsSubscriber;
	})(_Subscriber5['default']);

	module.exports = exports['default'];

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = bufferWhen;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	var _utilTryCatch = __webpack_require__(247);

	var _utilTryCatch2 = _interopRequireDefault(_utilTryCatch);

	var _utilErrorObject = __webpack_require__(248);

	function bufferWhen(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}

	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        _classCallCheck(this, BufferWhenOperator);

	        this.closingSelector = closingSelector;
	    }

	    BufferWhenOperator.prototype.call = function call(subscriber) {
	        return new BufferWhenSubscriber(subscriber, this.closingSelector);
	    };

	    return BufferWhenOperator;
	})();

	var BufferWhenSubscriber = (function (_Subscriber) {
	    _inherits(BufferWhenSubscriber, _Subscriber);

	    function BufferWhenSubscriber(destination, closingSelector) {
	        _classCallCheck(this, BufferWhenSubscriber);

	        _Subscriber.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.openBuffer();
	    }

	    BufferWhenSubscriber.prototype._next = function _next(value) {
	        this.buffer.push(value);
	    };

	    BufferWhenSubscriber.prototype._error = function _error(err) {
	        this.buffer = null;
	        this.destination.error(err);
	    };

	    BufferWhenSubscriber.prototype._complete = function _complete() {
	        var buffer = this.buffer;
	        this.destination.next(buffer);
	        this.buffer = null;
	        this.destination.complete();
	    };

	    BufferWhenSubscriber.prototype.openBuffer = function openBuffer() {
	        var prevClosingNotification = this.closingNotification;
	        if (prevClosingNotification) {
	            this.remove(prevClosingNotification);
	            prevClosingNotification.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = _utilTryCatch2['default'](this.closingSelector)();
	        if (closingNotifier === _utilErrorObject.errorObject) {
	            var err = closingNotifier.e;
	            this.buffer = null;
	            this.destination.error(err);
	        } else {
	            this.add(this.closingNotification = closingNotifier._subscribe(new BufferClosingNotifierSubscriber(this)));
	        }
	    };

	    return BufferWhenSubscriber;
	})(_Subscriber4['default']);

	var BufferClosingNotifierSubscriber = (function (_Subscriber2) {
	    _inherits(BufferClosingNotifierSubscriber, _Subscriber2);

	    function BufferClosingNotifierSubscriber(parent) {
	        _classCallCheck(this, BufferClosingNotifierSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    BufferClosingNotifierSubscriber.prototype._next = function _next() {
	        this.parent.openBuffer();
	    };

	    BufferClosingNotifierSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    BufferClosingNotifierSubscriber.prototype._complete = function _complete() {
	        // noop
	    };

	    return BufferClosingNotifierSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = sample;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber3 = __webpack_require__(221);

	var _Subscriber4 = _interopRequireDefault(_Subscriber3);

	function sample(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}

	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        _classCallCheck(this, SampleOperator);

	        this.notifier = notifier;
	    }

	    SampleOperator.prototype.call = function call(subscriber) {
	        return new SampleSubscriber(subscriber, this.notifier);
	    };

	    return SampleOperator;
	})();

	var SampleSubscriber = (function (_Subscriber) {
	    _inherits(SampleSubscriber, _Subscriber);

	    function SampleSubscriber(destination, notifier) {
	        _classCallCheck(this, SampleSubscriber);

	        _Subscriber.call(this, destination);
	        this.notifier = notifier;
	        this.hasValue = false;
	        this.add(notifier._subscribe(new SampleNoficationSubscriber(this)));
	    }

	    SampleSubscriber.prototype._next = function _next(value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };

	    SampleSubscriber.prototype.notifyNext = function notifyNext() {
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	        }
	    };

	    return SampleSubscriber;
	})(_Subscriber4['default']);

	var SampleNoficationSubscriber = (function (_Subscriber2) {
	    _inherits(SampleNoficationSubscriber, _Subscriber2);

	    function SampleNoficationSubscriber(parent) {
	        _classCallCheck(this, SampleNoficationSubscriber);

	        _Subscriber2.call(this, null);
	        this.parent = parent;
	    }

	    SampleNoficationSubscriber.prototype._next = function _next() {
	        this.parent.notifyNext();
	    };

	    SampleNoficationSubscriber.prototype._error = function _error(err) {
	        this.parent.error(err);
	    };

	    SampleNoficationSubscriber.prototype._complete = function _complete() {
	        //noop
	    };

	    return SampleNoficationSubscriber;
	})(_Subscriber4['default']);

	module.exports = exports['default'];

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = sampleTime;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var _Subscriber2 = __webpack_require__(221);

	var _Subscriber3 = _interopRequireDefault(_Subscriber2);

	var _schedulersNextTick = __webpack_require__(236);

	var _schedulersNextTick2 = _interopRequireDefault(_schedulersNextTick);

	function sampleTime(delay) {
	    var scheduler = arguments.length <= 1 || arguments[1] === undefined ? _schedulersNextTick2['default'] : arguments[1];

	    return this.lift(new SampleTimeOperator(delay, scheduler));
	}

	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(delay, scheduler) {
	        _classCallCheck(this, SampleTimeOperator);

	        this.delay = delay;
	        this.scheduler = scheduler;
	    }

	    SampleTimeOperator.prototype.call = function call(subscriber) {
	        return new SampleTimeSubscriber(subscriber, this.delay, this.scheduler);
	    };

	    return SampleTimeOperator;
	})();

	var SampleTimeSubscriber = (function (_Subscriber) {
	    _inherits(SampleTimeSubscriber, _Subscriber);

	    function SampleTimeSubscriber(destination, delay, scheduler) {
	        _classCallCheck(this, SampleTimeSubscriber);

	        _Subscriber.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, delay, { subscriber: this, delay: delay }));
	    }

	    SampleTimeSubscriber.prototype._next = function _next(value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };

	    SampleTimeSubscriber.prototype.notifyNext = function notifyNext() {
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	        }
	    };

	    return SampleTimeSubscriber;
	})(_Subscriber3['default']);

	function dispatchNotification(state) {
	    var subscriber = state.subscriber;
	    var delay = state.delay;

	    subscriber.notifyNext();
	    this.schedule(state, delay);
	}
	module.exports = exports['default'];

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var exceptions_1 = __webpack_require__(168);
	var InvalidPipeArgumentException = (function (_super) {
	    __extends(InvalidPipeArgumentException, _super);
	    function InvalidPipeArgumentException(type, value) {
	        _super.call(this, "Invalid argument '" + value + "' for pipe '" + type + "'");
	    }
	    return InvalidPipeArgumentException;
	})(exceptions_1.BaseException);
	exports.InvalidPipeArgumentException = InvalidPipeArgumentException;
	//# sourceMappingURL=invalid_pipe_argument_exception.js.map

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var intl_1 = __webpack_require__(346);
	var di_1 = __webpack_require__(160);
	var metadata_1 = __webpack_require__(157);
	var collection_1 = __webpack_require__(166);
	var invalid_pipe_argument_exception_1 = __webpack_require__(344);
	// TODO: move to a global configurable location along with other i18n components.
	var defaultLocale = 'en-US';
	/**
	 * WARNING: this pipe uses the Internationalization API.
	 * Therefore it is only reliable in Chrome and Opera browsers.
	 *
	 * Formats a date value to a string based on the requested format.
	 *
	 * # Usage
	 *
	 *     expression | date[:format]
	 *
	 * where `expression` is a date object or a number (milliseconds since UTC epoch) and
	 * `format` indicates which date/time components to include:
	 *
	 *  | Component | Symbol | Short Form   | Long Form         | Numeric   | 2-digit   |
	 *  |-----------|:------:|--------------|-------------------|-----------|-----------|
	 *  | era       |   G    | G (AD)       | GGGG (Anno Domini)| -         | -         |
	 *  | year      |   y    | -            | -                 | y (2015)  | yy (15)   |
	 *  | month     |   M    | MMM (Sep)    | MMMM (September)  | M (9)     | MM (09)   |
	 *  | day       |   d    | -            | -                 | d (3)     | dd (03)   |
	 *  | weekday   |   E    | EEE (Sun)    | EEEE (Sunday)     | -         | -         |
	 *  | hour      |   j    | -            | -                 | j (13)    | jj (13)   |
	 *  | hour12    |   h    | -            | -                 | h (1 PM)  | hh (01 PM)|
	 *  | hour24    |   H    | -            | -                 | H (13)    | HH (13)   |
	 *  | minute    |   m    | -            | -                 | m (5)     | mm (05)   |
	 *  | second    |   s    | -            | -                 | s (9)     | ss (09)   |
	 *  | timezone  |   z    | -            | z (Pacific Standard Time)| -  | -         |
	 *  | timezone  |   Z    | Z (GMT-8:00) | -                 | -         | -         |
	 *
	 * In javascript, only the components specified will be respected (not the ordering,
	 * punctuations, ...) and details of the the formatting will be dependent on the locale.
	 * On the other hand in Dart version, you can also include quoted text as well as some extra
	 * date/time components such as quarter. For more information see:
	 * https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/intl/intl.DateFormat.
	 *
	 * `format` can also be one of the following predefined formats:
	 *
	 *  - `'medium'`: equivalent to `'yMMMdjms'` (e.g. Sep 3, 2010, 12:05:08 PM for en-US)
	 *  - `'short'`: equivalent to `'yMdjm'` (e.g. 9/3/2010, 12:05 PM for en-US)
	 *  - `'fullDate'`: equivalent to `'yMMMMEEEEd'` (e.g. Friday, September 3, 2010 for en-US)
	 *  - `'longDate'`: equivalent to `'yMMMMd'` (e.g. September 3, 2010)
	 *  - `'mediumDate'`: equivalent to `'yMMMd'` (e.g. Sep 3, 2010 for en-US)
	 *  - `'shortDate'`: equivalent to `'yMd'` (e.g. 9/3/2010 for en-US)
	 *  - `'mediumTime'`: equivalent to `'jms'` (e.g. 12:05:08 PM for en-US)
	 *  - `'shortTime'`: equivalent to `'jm'` (e.g. 12:05 PM for en-US)
	 *
	 * Timezone of the formatted text will be the local system timezone of the end-users machine.
	 *
	 * # Examples
	 *
	 * Assuming `dateObj` is (year: 2015, month: 6, day: 15, hour: 21, minute: 43, second: 11)
	 * in the _local_ time and locale is 'en-US':
	 *
	 *     {{ dateObj | date }}               // output is 'Jun 15, 2015'
	 *     {{ dateObj | date:'medium' }}      // output is 'Jun 15, 2015, 9:43:11 PM'
	 *     {{ dateObj | date:'shortTime' }}   // output is '9:43 PM'
	 *     {{ dateObj | date:'mmss' }}        // output is '43:11'
	 */
	var DatePipe = (function () {
	    function DatePipe() {
	    }
	    DatePipe.prototype.transform = function (value, args) {
	        if (lang_1.isBlank(value))
	            return null;
	        if (!this.supports(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(DatePipe, value);
	        }
	        var pattern = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'mediumDate';
	        if (lang_1.isNumber(value)) {
	            value = lang_1.DateWrapper.fromMillis(value);
	        }
	        if (collection_1.StringMapWrapper.contains(DatePipe._ALIASES, pattern)) {
	            pattern = collection_1.StringMapWrapper.get(DatePipe._ALIASES, pattern);
	        }
	        return intl_1.DateFormatter.format(value, defaultLocale, pattern);
	    };
	    DatePipe.prototype.supports = function (obj) { return lang_1.isDate(obj) || lang_1.isNumber(obj); };
	    DatePipe._ALIASES = {
	        'medium': 'yMMMdjms',
	        'short': 'yMdjm',
	        'fullDate': 'yMMMMEEEEd',
	        'longDate': 'yMMMMd',
	        'mediumDate': 'yMMMd',
	        'shortDate': 'yMd',
	        'mediumTime': 'jms',
	        'shortTime': 'jm'
	    };
	    DatePipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'date' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], DatePipe);
	    return DatePipe;
	})();
	exports.DatePipe = DatePipe;
	//# sourceMappingURL=date_pipe.js.map

/***/ },
/* 346 */
/***/ function(module, exports) {

	(function (NumberFormatStyle) {
	    NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
	    NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
	    NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
	})(exports.NumberFormatStyle || (exports.NumberFormatStyle = {}));
	var NumberFormatStyle = exports.NumberFormatStyle;
	var NumberFormatter = (function () {
	    function NumberFormatter() {
	    }
	    NumberFormatter.format = function (number, locale, style, _a) {
	        var _b = _a === void 0 ? {} : _a, _c = _b.minimumIntegerDigits, minimumIntegerDigits = _c === void 0 ? 1 : _c, _d = _b.minimumFractionDigits, minimumFractionDigits = _d === void 0 ? 0 : _d, _e = _b.maximumFractionDigits, maximumFractionDigits = _e === void 0 ? 3 : _e, currency = _b.currency, _f = _b.currencyAsSymbol, currencyAsSymbol = _f === void 0 ? false : _f;
	        var intlOptions = {
	            minimumIntegerDigits: minimumIntegerDigits,
	            minimumFractionDigits: minimumFractionDigits,
	            maximumFractionDigits: maximumFractionDigits
	        };
	        intlOptions.style = NumberFormatStyle[style].toLowerCase();
	        if (style == NumberFormatStyle.Currency) {
	            intlOptions.currency = currency;
	            intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
	        }
	        return new Intl.NumberFormat(locale, intlOptions).format(number);
	    };
	    return NumberFormatter;
	})();
	exports.NumberFormatter = NumberFormatter;
	function digitCondition(len) {
	    return len == 2 ? '2-digit' : 'numeric';
	}
	function nameCondition(len) {
	    return len < 4 ? 'short' : 'long';
	}
	function extractComponents(pattern) {
	    var ret = {};
	    var i = 0, j;
	    while (i < pattern.length) {
	        j = i;
	        while (j < pattern.length && pattern[j] == pattern[i])
	            j++;
	        var len = j - i;
	        switch (pattern[i]) {
	            case 'G':
	                ret.era = nameCondition(len);
	                break;
	            case 'y':
	                ret.year = digitCondition(len);
	                break;
	            case 'M':
	                if (len >= 3)
	                    ret.month = nameCondition(len);
	                else
	                    ret.month = digitCondition(len);
	                break;
	            case 'd':
	                ret.day = digitCondition(len);
	                break;
	            case 'E':
	                ret.weekday = nameCondition(len);
	                break;
	            case 'j':
	                ret.hour = digitCondition(len);
	                break;
	            case 'h':
	                ret.hour = digitCondition(len);
	                ret.hour12 = true;
	                break;
	            case 'H':
	                ret.hour = digitCondition(len);
	                ret.hour12 = false;
	                break;
	            case 'm':
	                ret.minute = digitCondition(len);
	                break;
	            case 's':
	                ret.second = digitCondition(len);
	                break;
	            case 'z':
	                ret.timeZoneName = 'long';
	                break;
	            case 'Z':
	                ret.timeZoneName = 'short';
	                break;
	        }
	        i = j;
	    }
	    return ret;
	}
	var dateFormatterCache = new Map();
	var DateFormatter = (function () {
	    function DateFormatter() {
	    }
	    DateFormatter.format = function (date, locale, pattern) {
	        var key = locale + pattern;
	        if (dateFormatterCache.has(key)) {
	            return dateFormatterCache.get(key).format(date);
	        }
	        var formatter = new Intl.DateTimeFormat(locale, extractComponents(pattern));
	        dateFormatterCache.set(key, formatter);
	        return formatter.format(date);
	    };
	    return DateFormatter;
	})();
	exports.DateFormatter = DateFormatter;
	//# sourceMappingURL=intl.js.map

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	var async_pipe_1 = __webpack_require__(215);
	var uppercase_pipe_1 = __webpack_require__(348);
	var lowercase_pipe_1 = __webpack_require__(349);
	var json_pipe_1 = __webpack_require__(350);
	var limit_to_pipe_1 = __webpack_require__(351);
	var date_pipe_1 = __webpack_require__(345);
	var number_pipe_1 = __webpack_require__(353);
	var lang_1 = __webpack_require__(159);
	var di_1 = __webpack_require__(160);
	var DEFAULT_PIPES_LIST = lang_1.CONST_EXPR([
	    async_pipe_1.AsyncPipe,
	    uppercase_pipe_1.UpperCasePipe,
	    lowercase_pipe_1.LowerCasePipe,
	    json_pipe_1.JsonPipe,
	    limit_to_pipe_1.LimitToPipe,
	    number_pipe_1.DecimalPipe,
	    number_pipe_1.PercentPipe,
	    number_pipe_1.CurrencyPipe,
	    date_pipe_1.DatePipe
	]);
	exports.DEFAULT_PIPES_TOKEN = lang_1.CONST_EXPR(new di_1.OpaqueToken("Default Pipes"));
	exports.DEFAULT_PIPES = lang_1.CONST_EXPR(new di_1.Binding(exports.DEFAULT_PIPES_TOKEN, { toValue: DEFAULT_PIPES_LIST }));
	//# sourceMappingURL=default_pipes.js.map

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var invalid_pipe_argument_exception_1 = __webpack_require__(344);
	/**
	 * Implements uppercase transforms to text.
	 *
	 * # Example
	 *
	 * In this example we transform the user text uppercase.
	 *
	 *  ```
	 * @Component({
	 *   selector: "username-cmp"
	 * })
	 * @View({
	 *   template: "Username: {{ user | uppercase }}"
	 * })
	 * class Username {
	 *   user:string;
	 * }
	 *
	 * ```
	 */
	var UpperCasePipe = (function () {
	    function UpperCasePipe() {
	    }
	    UpperCasePipe.prototype.transform = function (value, args) {
	        if (args === void 0) { args = null; }
	        if (lang_1.isBlank(value))
	            return value;
	        if (!lang_1.isString(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(UpperCasePipe, value);
	        }
	        return lang_1.StringWrapper.toUpperCase(value);
	    };
	    UpperCasePipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'uppercase' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], UpperCasePipe);
	    return UpperCasePipe;
	})();
	exports.UpperCasePipe = UpperCasePipe;
	//# sourceMappingURL=uppercase_pipe.js.map

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var di_1 = __webpack_require__(160);
	var metadata_1 = __webpack_require__(157);
	var invalid_pipe_argument_exception_1 = __webpack_require__(344);
	/**
	 * Implements lowercase transforms to text.
	 *
	 * # Example
	 *
	 * In this example we transform the user text lowercase.
	 *
	 *  ```
	 * @Component({
	 *   selector: "username-cmp"
	 * })
	 * @View({
	 *   template: "Username: {{ user | lowercase }}"
	 * })
	 * class Username {
	 *   user:string;
	 * }
	 *
	 * ```
	 */
	var LowerCasePipe = (function () {
	    function LowerCasePipe() {
	    }
	    LowerCasePipe.prototype.transform = function (value, args) {
	        if (args === void 0) { args = null; }
	        if (lang_1.isBlank(value))
	            return value;
	        if (!lang_1.isString(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LowerCasePipe, value);
	        }
	        return lang_1.StringWrapper.toLowerCase(value);
	    };
	    LowerCasePipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'lowercase' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], LowerCasePipe);
	    return LowerCasePipe;
	})();
	exports.LowerCasePipe = LowerCasePipe;
	//# sourceMappingURL=lowercase_pipe.js.map

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var di_1 = __webpack_require__(160);
	var metadata_1 = __webpack_require__(157);
	/**
	 * Implements json transforms to any object.
	 *
	 * # Example
	 *
	 * In this example we transform the user object to json.
	 *
	 *  ```
	 * @Component({
	 *   selector: "user-cmp"
	 * })
	 * @View({
	 *   template: "User: {{ user | json }}"
	 * })
	 * class Username {
	 *  user:Object
	 *  constructor() {
	 *    this.user = { name: "PatrickJS" };
	 *  }
	 * }
	 *
	 * ```
	 */
	var JsonPipe = (function () {
	    function JsonPipe() {
	    }
	    JsonPipe.prototype.transform = function (value, args) {
	        if (args === void 0) { args = null; }
	        return lang_1.Json.stringify(value);
	    };
	    JsonPipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'json' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], JsonPipe);
	    return JsonPipe;
	})();
	exports.JsonPipe = JsonPipe;
	//# sourceMappingURL=json_pipe.js.map

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var math_1 = __webpack_require__(352);
	var di_1 = __webpack_require__(160);
	var metadata_1 = __webpack_require__(157);
	var invalid_pipe_argument_exception_1 = __webpack_require__(344);
	/**
	 * Creates a new Array or String containing only a prefix/suffix of the
	 * elements.
	 *
	 * The number of elements to return is specified by the `limitTo` parameter.
	 *
	 * # Usage
	 *
	 *     expression | limitTo:number
	 *
	 * Where the input expression is a [Array] or [String], and `limitTo` is:
	 *
	 * - **a positive integer**: return _number_ items from the beginning of the list or string
	 * expression.
	 * - **a negative integer**: return _number_ items from the end of the list or string expression.
	 * - **`|limitTo|` greater than the size of the expression**: return the entire expression.
	 *
	 * When operating on a [Array], the returned list is always a copy even when all
	 * the elements are being returned.
	 *
	 * # Examples
	 *
	 * ## Array Example
	 *
	 * Assuming `var collection = ['a', 'b', 'c']`, this `ng-for` directive:
	 *
	 *     <li *ng-for="var i in collection | limitTo:2">{{i}}</li>
	 *
	 * produces the following:
	 *
	 *     <li>a</li>
	 *     <li>b</li>
	 *
	 * ## String Examples
	 *
	 *     {{ 'abcdefghij' | limitTo: 4 }}       // output is 'abcd'
	 *     {{ 'abcdefghij' | limitTo: -4 }}      // output is 'ghij'
	 *     {{ 'abcdefghij' | limitTo: -100 }}    // output is 'abcdefghij'
	 */
	var LimitToPipe = (function () {
	    function LimitToPipe() {
	    }
	    LimitToPipe.prototype.supports = function (obj) { return lang_1.isString(obj) || lang_1.isArray(obj); };
	    LimitToPipe.prototype.transform = function (value, args) {
	        if (args === void 0) { args = null; }
	        if (lang_1.isBlank(args) || args.length == 0) {
	            throw new exceptions_1.BaseException('limitTo pipe requires one argument');
	        }
	        if (!this.supports(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(LimitToPipe, value);
	        }
	        if (lang_1.isBlank(value))
	            return value;
	        var limit = args[0];
	        var left = 0, right = math_1.Math.min(limit, value.length);
	        if (limit < 0) {
	            left = math_1.Math.max(0, value.length + limit);
	            right = value.length;
	        }
	        if (lang_1.isString(value)) {
	            return lang_1.StringWrapper.substring(value, left, right);
	        }
	        return collection_1.ListWrapper.slice(value, left, right);
	    };
	    LimitToPipe = __decorate([
	        metadata_1.Pipe({ name: 'limitTo' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], LimitToPipe);
	    return LimitToPipe;
	})();
	exports.LimitToPipe = LimitToPipe;
	//# sourceMappingURL=limit_to_pipe.js.map

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	exports.Math = lang_1.global.Math;
	exports.NaN = typeof exports.NaN;
	//# sourceMappingURL=math.js.map

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var intl_1 = __webpack_require__(346);
	var di_1 = __webpack_require__(160);
	var metadata_1 = __webpack_require__(157);
	var collection_1 = __webpack_require__(166);
	var invalid_pipe_argument_exception_1 = __webpack_require__(344);
	var defaultLocale = 'en-US';
	var _re = lang_1.RegExpWrapper.create('^(\\d+)?\\.((\\d+)(\\-(\\d+))?)?$');
	var NumberPipe = (function () {
	    function NumberPipe() {
	    }
	    NumberPipe._format = function (value, style, digits, currency, currencyAsSymbol) {
	        if (currency === void 0) { currency = null; }
	        if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
	        if (lang_1.isBlank(value))
	            return null;
	        if (!lang_1.isNumber(value)) {
	            throw new invalid_pipe_argument_exception_1.InvalidPipeArgumentException(NumberPipe, value);
	        }
	        var minInt = 1, minFraction = 0, maxFraction = 3;
	        if (lang_1.isPresent(digits)) {
	            var parts = lang_1.RegExpWrapper.firstMatch(_re, digits);
	            if (lang_1.isBlank(parts)) {
	                throw new exceptions_1.BaseException(digits + " is not a valid digit info for number pipes");
	            }
	            if (lang_1.isPresent(parts[1])) {
	                minInt = lang_1.NumberWrapper.parseIntAutoRadix(parts[1]);
	            }
	            if (lang_1.isPresent(parts[3])) {
	                minFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[3]);
	            }
	            if (lang_1.isPresent(parts[5])) {
	                maxFraction = lang_1.NumberWrapper.parseIntAutoRadix(parts[5]);
	            }
	        }
	        return intl_1.NumberFormatter.format(value, defaultLocale, style, {
	            minimumIntegerDigits: minInt,
	            minimumFractionDigits: minFraction,
	            maximumFractionDigits: maxFraction,
	            currency: currency,
	            currencyAsSymbol: currencyAsSymbol
	        });
	    };
	    NumberPipe = __decorate([
	        lang_1.CONST(),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], NumberPipe);
	    return NumberPipe;
	})();
	exports.NumberPipe = NumberPipe;
	/**
	 * WARNING: this pipe uses the Internationalization API.
	 * Therefore it is only reliable in Chrome and Opera browsers.
	 *
	 * Formats a number as local text. i.e. group sizing and seperator and other locale-specific
	 * configurations are based on the active locale.
	 *
	 * # Usage
	 *
	 *     expression | number[:digitInfo]
	 *
	 * where `expression` is a number and `digitInfo` has the following format:
	 *
	 *     {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
	 *
	 * - minIntegerDigits is the minimum number of integer digits to use. Defaults to 1.
	 * - minFractionDigits is the minimum number of digits after fraction. Defaults to 0.
	 * - maxFractionDigits is the maximum number of digits after fraction. Defaults to 3.
	 *
	 * For more information on the acceptable range for each of these numbers and other
	 * details see your native internationalization library.
	 *
	 * # Examples
	 *
	 *     {{ 123 | number }}              // output is 123
	 *     {{ 123.1 | number: '.2-3' }}    // output is 123.10
	 *     {{ 1 | number: '2.2' }}         // output is 01.00
	 */
	var DecimalPipe = (function (_super) {
	    __extends(DecimalPipe, _super);
	    function DecimalPipe() {
	        _super.apply(this, arguments);
	    }
	    DecimalPipe.prototype.transform = function (value, args) {
	        var digits = collection_1.ListWrapper.first(args);
	        return NumberPipe._format(value, intl_1.NumberFormatStyle.Decimal, digits);
	    };
	    DecimalPipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'number' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], DecimalPipe);
	    return DecimalPipe;
	})(NumberPipe);
	exports.DecimalPipe = DecimalPipe;
	/**
	 * WARNING: this pipe uses the Internationalization API.
	 * Therefore it is only reliable in Chrome and Opera browsers.
	 *
	 * Formats a number as local percent.
	 *
	 * # Usage
	 *
	 *     expression | percent[:digitInfo]
	 *
	 * For more information about `digitInfo` see {@link DecimalPipe}
	 */
	var PercentPipe = (function (_super) {
	    __extends(PercentPipe, _super);
	    function PercentPipe() {
	        _super.apply(this, arguments);
	    }
	    PercentPipe.prototype.transform = function (value, args) {
	        var digits = collection_1.ListWrapper.first(args);
	        return NumberPipe._format(value, intl_1.NumberFormatStyle.Percent, digits);
	    };
	    PercentPipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'percent' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], PercentPipe);
	    return PercentPipe;
	})(NumberPipe);
	exports.PercentPipe = PercentPipe;
	/**
	 * WARNING: this pipe uses the Internationalization API.
	 * Therefore it is only reliable in Chrome and Opera browsers.
	 *
	 * Formats a number as local currency.
	 *
	 * # Usage
	 *
	 *     expression | currency[:currencyCode[:symbolDisplay[:digitInfo]]]
	 *
	 * where `currencyCode` is the ISO 4217 currency code, such as "USD" for the US dollar and
	 * "EUR" for the euro. `symbolDisplay` is a boolean indicating whether to use the currency
	 * symbol (e.g. $) or the currency code (e.g. USD) in the output. The default for this value
	 * is `false`.
	 * For more information about `digitInfo` see {@link DecimalPipe}
	 */
	var CurrencyPipe = (function (_super) {
	    __extends(CurrencyPipe, _super);
	    function CurrencyPipe() {
	        _super.apply(this, arguments);
	    }
	    CurrencyPipe.prototype.transform = function (value, args) {
	        var currencyCode = lang_1.isPresent(args) && args.length > 0 ? args[0] : 'USD';
	        var symbolDisplay = lang_1.isPresent(args) && args.length > 1 ? args[1] : false;
	        var digits = lang_1.isPresent(args) && args.length > 2 ? args[2] : null;
	        return NumberPipe._format(value, intl_1.NumberFormatStyle.Currency, digits, currencyCode, symbolDisplay);
	    };
	    CurrencyPipe = __decorate([
	        lang_1.CONST(),
	        metadata_1.Pipe({ name: 'currency' }),
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], CurrencyPipe);
	    return CurrencyPipe;
	})(NumberPipe);
	exports.CurrencyPipe = CurrencyPipe;
	//# sourceMappingURL=number_pipe.js.map

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var cd = __webpack_require__(355);
	var ProtoPipes = (function () {
	    function ProtoPipes(bindings) {
	        var _this = this;
	        /**
	         * Map of {@link PipeMetadata} names to {@link PipeMetadata} implementations.
	         */
	        this.config = {};
	        bindings.forEach(function (b) { return _this.config[b.name] = b; });
	    }
	    ProtoPipes.prototype.get = function (name) {
	        var binding = this.config[name];
	        if (lang_1.isBlank(binding))
	            throw new exceptions_1.BaseException("Cannot find pipe '" + name + "'.");
	        return binding;
	    };
	    return ProtoPipes;
	})();
	exports.ProtoPipes = ProtoPipes;
	var Pipes = (function () {
	    function Pipes(proto, injector) {
	        this.proto = proto;
	        this.injector = injector;
	        this._config = {};
	    }
	    Pipes.prototype.get = function (name) {
	        var cached = collection_1.StringMapWrapper.get(this._config, name);
	        if (lang_1.isPresent(cached))
	            return cached;
	        var p = this.proto.get(name);
	        var transform = this.injector.instantiateResolved(p);
	        var res = new cd.SelectedPipe(transform, p.pure);
	        if (p.pure) {
	            collection_1.StringMapWrapper.set(this._config, name, res);
	        }
	        return res;
	    };
	    return Pipes;
	})();
	exports.Pipes = Pipes;
	//# sourceMappingURL=pipes.js.map

/***/ },
/* 355 */
/***/ function(module, exports) {

	var SelectedPipe = (function () {
	    function SelectedPipe(pipe, pure) {
	        this.pipe = pipe;
	        this.pure = pure;
	    }
	    return SelectedPipe;
	})();
	exports.SelectedPipe = SelectedPipe;
	//# sourceMappingURL=pipes.js.map

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var binding_1 = __webpack_require__(167);
	var di_1 = __webpack_require__(160);
	var PipeBinding = (function (_super) {
	    __extends(PipeBinding, _super);
	    function PipeBinding(name, pure, key, resolvedFactories, multiBinding) {
	        _super.call(this, key, resolvedFactories, multiBinding);
	        this.name = name;
	        this.pure = pure;
	    }
	    PipeBinding.createFromType = function (type, metadata) {
	        var binding = new di_1.Binding(type, { toClass: type });
	        var rb = binding_1.resolveBinding(binding);
	        return new PipeBinding(metadata.name, metadata.pure, rb.key, rb.resolvedFactories, rb.multiBinding);
	    };
	    return PipeBinding;
	})(di_1.ResolvedBinding);
	exports.PipeBinding = PipeBinding;
	//# sourceMappingURL=pipe_binding.js.map

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for Facade
	var lang_1 = __webpack_require__(159);
	exports.Type = lang_1.Type;
	var async_1 = __webpack_require__(216);
	exports.Observable = async_1.Observable;
	exports.EventEmitter = async_1.EventEmitter;
	var exceptions_1 = __webpack_require__(168);
	exports.WrappedException = exceptions_1.WrappedException;
	//# sourceMappingURL=facade.js.map

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for Application
	var application_ref_1 = __webpack_require__(359);
	exports.ApplicationRef = application_ref_1.ApplicationRef;
	var application_tokens_1 = __webpack_require__(360);
	exports.APP_COMPONENT = application_tokens_1.APP_COMPONENT;
	//# sourceMappingURL=application.js.map

/***/ },
/* 359 */
/***/ function(module, exports) {

	/**
	 * Represents a Angular's representation of an Application.
	 *
	 * `ApplicationRef` represents a running application instance. Use it to retrieve the host
	 * component, injector,
	 * or dispose of an application.
	 */
	var ApplicationRef = (function () {
	    /**
	     * @private
	     */
	    function ApplicationRef(hostComponent, hostComponentType, injector) {
	        this._hostComponent = hostComponent;
	        this._injector = injector;
	        this._hostComponentType = hostComponentType;
	    }
	    Object.defineProperty(ApplicationRef.prototype, "hostComponentType", {
	        /**
	         * Returns the current {@link ComponentMetadata} type.
	         */
	        get: function () { return this._hostComponentType; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ApplicationRef.prototype, "hostComponent", {
	        /**
	         * Returns the current {@link ComponentMetadata} instance.
	         */
	        get: function () { return this._hostComponent.instance; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose (un-load) the application.
	     */
	    ApplicationRef.prototype.dispose = function () {
	        // TODO: We also need to clean up the Zone, ... here!
	        this._hostComponent.dispose();
	    };
	    Object.defineProperty(ApplicationRef.prototype, "injector", {
	        /**
	         * Returns the root application {@link Injector}.
	         */
	        get: function () { return this._injector; },
	        enumerable: true,
	        configurable: true
	    });
	    return ApplicationRef;
	})();
	exports.ApplicationRef = ApplicationRef;
	//# sourceMappingURL=application_ref.js.map

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	/**
	 *  @private
	 */
	exports.APP_COMPONENT_REF_PROMISE = lang_1.CONST_EXPR(new di_1.OpaqueToken('Promise<ComponentRef>'));
	/**
	 * An {@link angular2/di/OpaqueToken} representing the application root type in the {@link
	 * Injector}.
	 *
	 * ```
	 * @Component(...)
	 * @View(...)
	 * class MyApp {
	 *   ...
	 * }
	 *
	 * bootstrap(MyApp).then((appRef:ApplicationRef) {
	 *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);
	 * });
	 *
	 * ```
	 */
	exports.APP_COMPONENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppComponent'));
	//# sourceMappingURL=application_tokens.js.map

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	// Note: This file only exists so that Dart users can import
	// bootstrap from angular2/bootstrap. JS users should import
	// from angular2/core.
	var application_common_1 = __webpack_require__(362);
	exports.bootstrap = application_common_1.commonBootstrap;
	//# sourceMappingURL=bootstrap.js.map

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	var pipes_1 = __webpack_require__(214);
	var forms_1 = __webpack_require__(363);
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var browser_adapter_1 = __webpack_require__(440);
	var dom_adapter_1 = __webpack_require__(386);
	var compiler_1 = __webpack_require__(381);
	var reflection_1 = __webpack_require__(170);
	var change_detection_1 = __webpack_require__(179);
	var view_loader_1 = __webpack_require__(406);
	var style_url_resolver_1 = __webpack_require__(409);
	var style_inliner_1 = __webpack_require__(408);
	var view_resolver_1 = __webpack_require__(398);
	var directive_resolver_1 = __webpack_require__(380);
	var pipe_resolver_1 = __webpack_require__(399);
	var collection_1 = __webpack_require__(166);
	var async_1 = __webpack_require__(216);
	var ng_zone_1 = __webpack_require__(432);
	var life_cycle_1 = __webpack_require__(442);
	var xhr_1 = __webpack_require__(407);
	var xhr_impl_1 = __webpack_require__(443);
	var event_manager_1 = __webpack_require__(431);
	var key_events_1 = __webpack_require__(444);
	var hammer_gestures_1 = __webpack_require__(445);
	var component_url_mapper_1 = __webpack_require__(379);
	var url_resolver_1 = __webpack_require__(401);
	var app_root_url_1 = __webpack_require__(402);
	var anchor_based_app_root_url_1 = __webpack_require__(447);
	var dynamic_component_loader_1 = __webpack_require__(403);
	var testability_1 = __webpack_require__(448);
	var view_pool_1 = __webpack_require__(392);
	var view_manager_1 = __webpack_require__(388);
	var view_manager_utils_1 = __webpack_require__(389);
	var view_listener_1 = __webpack_require__(393);
	var proto_view_factory_1 = __webpack_require__(400);
	var api_1 = __webpack_require__(212);
	var render_1 = __webpack_require__(405);
	var element_schema_registry_1 = __webpack_require__(427);
	var dom_element_schema_registry_1 = __webpack_require__(450);
	var shared_styles_host_1 = __webpack_require__(410);
	var view_ref_1 = __webpack_require__(384);
	var application_tokens_1 = __webpack_require__(360);
	var wtf_init_1 = __webpack_require__(451);
	var platform_bindings_1 = __webpack_require__(452);
	var application_ref_1 = __webpack_require__(359);
	var _rootInjector;
	// Contains everything that is safe to share between applications.
	var _rootBindings = [di_1.bind(reflection_1.Reflector).toValue(reflection_1.reflector), testability_1.TestabilityRegistry];
	function _injectorBindings(appComponentType) {
	    var bestChangeDetection = new change_detection_1.DynamicChangeDetection();
	    if (change_detection_1.PreGeneratedChangeDetection.isSupported()) {
	        bestChangeDetection = new change_detection_1.PreGeneratedChangeDetection();
	    }
	    else if (change_detection_1.JitChangeDetection.isSupported()) {
	        bestChangeDetection = new change_detection_1.JitChangeDetection();
	    }
	    return [
	        di_1.bind(render_1.DOCUMENT)
	            .toValue(dom_adapter_1.DOM.defaultDoc()),
	        di_1.bind(application_tokens_1.APP_COMPONENT).toValue(appComponentType),
	        di_1.bind(application_tokens_1.APP_COMPONENT_REF_PROMISE)
	            .toFactory(function (dynamicComponentLoader, injector, testability, registry) {
	            // TODO(rado): investigate whether to support bindings on root component.
	            return dynamicComponentLoader.loadAsRoot(appComponentType, null, injector)
	                .then(function (componentRef) {
	                registry.registerApplication(componentRef.location.nativeElement, testability);
	                return componentRef;
	            });
	        }, [dynamic_component_loader_1.DynamicComponentLoader, di_1.Injector, testability_1.Testability, testability_1.TestabilityRegistry]),
	        di_1.bind(appComponentType)
	            .toFactory(function (p) { return p.then(function (ref) { return ref.instance; }); }, [application_tokens_1.APP_COMPONENT_REF_PROMISE]),
	        di_1.bind(life_cycle_1.LifeCycle).toFactory(function (exceptionHandler) { return new life_cycle_1.LifeCycle(null, lang_1.assertionsEnabled()); }, [exceptions_1.ExceptionHandler]),
	        event_manager_1.EventManager,
	        new di_1.Binding(event_manager_1.EVENT_MANAGER_PLUGINS, { toClass: event_manager_1.DomEventsPlugin, multi: true }),
	        new di_1.Binding(event_manager_1.EVENT_MANAGER_PLUGINS, { toClass: key_events_1.KeyEventsPlugin, multi: true }),
	        new di_1.Binding(event_manager_1.EVENT_MANAGER_PLUGINS, { toClass: hammer_gestures_1.HammerGesturesPlugin, multi: true }),
	        render_1.DomRenderer,
	        di_1.bind(api_1.Renderer).toAlias(render_1.DomRenderer),
	        render_1.APP_ID_RANDOM_BINDING,
	        render_1.TemplateCloner,
	        di_1.bind(render_1.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE).toValue(20),
	        render_1.DefaultDomCompiler,
	        di_1.bind(element_schema_registry_1.ElementSchemaRegistry).toValue(new dom_element_schema_registry_1.DomElementSchemaRegistry()),
	        di_1.bind(api_1.RenderCompiler).toAlias(render_1.DefaultDomCompiler),
	        shared_styles_host_1.DomSharedStylesHost,
	        di_1.bind(shared_styles_host_1.SharedStylesHost).toAlias(shared_styles_host_1.DomSharedStylesHost),
	        proto_view_factory_1.ProtoViewFactory,
	        view_pool_1.AppViewPool,
	        di_1.bind(view_pool_1.APP_VIEW_POOL_CAPACITY).toValue(10000),
	        view_manager_1.AppViewManager,
	        view_manager_utils_1.AppViewManagerUtils,
	        view_listener_1.AppViewListener,
	        compiler_1.Compiler,
	        compiler_1.CompilerCache,
	        view_resolver_1.ViewResolver,
	        pipes_1.DEFAULT_PIPES,
	        di_1.bind(change_detection_1.IterableDiffers).toValue(change_detection_1.defaultIterableDiffers),
	        di_1.bind(change_detection_1.KeyValueDiffers).toValue(change_detection_1.defaultKeyValueDiffers),
	        di_1.bind(change_detection_1.ChangeDetection).toValue(bestChangeDetection),
	        view_loader_1.ViewLoader,
	        directive_resolver_1.DirectiveResolver,
	        pipe_resolver_1.PipeResolver,
	        change_detection_1.Parser,
	        change_detection_1.Lexer,
	        platform_bindings_1.EXCEPTION_BINDING,
	        di_1.bind(xhr_1.XHR).toValue(new xhr_impl_1.XHRImpl()),
	        component_url_mapper_1.ComponentUrlMapper,
	        url_resolver_1.UrlResolver,
	        style_url_resolver_1.StyleUrlResolver,
	        style_inliner_1.StyleInliner,
	        dynamic_component_loader_1.DynamicComponentLoader,
	        testability_1.Testability,
	        anchor_based_app_root_url_1.AnchorBasedAppRootUrl,
	        di_1.bind(app_root_url_1.AppRootUrl).toAlias(anchor_based_app_root_url_1.AnchorBasedAppRootUrl),
	        forms_1.FORM_BINDINGS
	    ];
	}
	function createNgZone() {
	    return new ng_zone_1.NgZone({ enableLongStackTrace: lang_1.assertionsEnabled() });
	}
	exports.createNgZone = createNgZone;
	/**
	 * Bootstrapping for Angular applications.
	 *
	 * You instantiate an Angular application by explicitly specifying a component to use as the root
	 * component for your
	 * application via the `bootstrap()` method.
	 *
	 * ## Simple Example
	 *
	 * Assuming this `index.html`:
	 *
	 * ```html
	 * <html>
	 *   <!-- load Angular script tags here. -->
	 *   <body>
	 *     <my-app>loading...</my-app>
	 *   </body>
	 * </html>
	 * ```
	 *
	 * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike
	 * Angular 1, Angular 2
	 * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well
	 * as architectural
	 * changes in Angular 2. This means that `index.html` can safely be processed using server-side
	 * technologies such as
	 * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2
	 * component double-curly
	 * `{{ syntax }}`.
	 *
	 * We can use this script code:
	 *
	 * ```
	 * @Component({
	 *    selector: 'my-app'
	 * })
	 * @View({
	 *    template: 'Hello {{ name }}!'
	 * })
	 * class MyApp {
	 *   name:string;
	 *
	 *   constructor() {
	 *     this.name = 'World';
	 *   }
	 * }
	 *
	 * main() {
	 *   return bootstrap(MyApp);
	 * }
	 * ```
	 *
	 * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument,
	 * Angular performs the
	 * following tasks:
	 *
	 *  1. It uses the component's `selector` property to locate the DOM element which needs to be
	 * upgraded into
	 *     the angular component.
	 *  2. It creates a new child injector (from the platform injector). Optionally, you can also
	 * override the injector configuration for an app by
	 * invoking `bootstrap` with the `componentInjectableBindings` argument.
	 *  3. It creates a new `Zone` and connects it to the angular application's change detection domain
	 * instance.
	 *  4. It creates a shadow DOM on the selected component's host element and loads the template into
	 * it.
	 *  5. It instantiates the specified component.
	 *  6. Finally, Angular performs change detection to apply the initial data bindings for the
	 * application.
	 *
	 *
	 * ## Instantiating Multiple Applications on a Single Page
	 *
	 * There are two ways to do this.
	 *
	 *
	 * ### Isolated Applications
	 *
	 * Angular creates a new application each time that the `bootstrap()` method is invoked. When
	 * multiple applications
	 * are created for a page, Angular treats each application as independent within an isolated change
	 * detection and
	 * `Zone` domain. If you need to share data between applications, use the strategy described in the
	 * next
	 * section, "Applications That Share Change Detection."
	 *
	 *
	 * ### Applications That Share Change Detection
	 *
	 * If you need to bootstrap multiple applications that share common data, the applications must
	 * share a common
	 * change detection and zone. To do that, create a meta-component that lists the application
	 * components in its template.
	 * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you
	 * ensure that only a
	 * single change detection zone is created and therefore data can be shared across the applications.
	 *
	 *
	 * ## Platform Injector
	 *
	 * When working within a browser window, there are many singleton resources: cookies, title,
	 * location, and others.
	 * Angular services that represent these resources must likewise be shared across all Angular
	 * applications that
	 * occupy the same browser window.  For this reason, Angular creates exactly one global platform
	 * injector which stores
	 * all shared services, and each angular application injector has the platform injector as its
	 * parent.
	 *
	 * Each application has its own private injector as well. When there are multiple applications on a
	 * page, Angular treats
	 * each application injector's services as private to that application.
	 *
	 *
	 * # API
	 * - `appComponentType`: The root component which should act as the application. This is a reference
	 * to a `Type`
	 *   which is annotated with `@Component(...)`.
	 * - `componentInjectableBindings`: An additional set of bindings that can be added to the app
	 * injector
	 * to override default injection behavior.
	 * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for
	 * unhandled exceptions.
	 *
	 * Returns a `Promise` of {@link ApplicationRef}.
	 */
	function commonBootstrap(appComponentType, componentInjectableBindings) {
	    if (componentInjectableBindings === void 0) { componentInjectableBindings = null; }
	    browser_adapter_1.BrowserDomAdapter.makeCurrent();
	    wtf_init_1.wtfInit();
	    var bootstrapProcess = async_1.PromiseWrapper.completer();
	    var zone = createNgZone();
	    zone.run(function () {
	        var exceptionHandler;
	        try {
	            var appInjector = _createAppInjector(appComponentType, componentInjectableBindings, zone);
	            exceptionHandler = appInjector.get(exceptions_1.ExceptionHandler);
	            zone.overrideOnErrorHandler(function (e, s) { return exceptionHandler.call(e, s); });
	            var compRefToken = appInjector.get(application_tokens_1.APP_COMPONENT_REF_PROMISE);
	            var tick = function (componentRef) {
	                var appChangeDetector = view_ref_1.internalView(componentRef.hostView).changeDetector;
	                // retrieve life cycle: may have already been created if injected in root component
	                var lc = appInjector.get(life_cycle_1.LifeCycle);
	                lc.registerWith(zone, appChangeDetector);
	                lc.tick(); // the first tick that will bootstrap the app
	                bootstrapProcess.resolve(new application_ref_1.ApplicationRef(componentRef, appComponentType, appInjector));
	            };
	            var tickResult = async_1.PromiseWrapper.then(compRefToken, tick);
	            async_1.PromiseWrapper.then(tickResult, function (_) { }); // required for Dart to trigger the default error handler
	            async_1.PromiseWrapper.then(tickResult, null, function (err, stackTrace) { bootstrapProcess.reject(err, stackTrace); });
	        }
	        catch (e) {
	            if (lang_1.isPresent(exceptionHandler)) {
	                exceptionHandler.call(e, e.stack);
	            }
	            else {
	                // The error happened during the creation of an injector, most likely because of a bug in
	                // DI.
	                // We cannot use the provided exception handler, so we default to writing to the DOM.
	                dom_adapter_1.DOM.logError(e);
	            }
	            bootstrapProcess.reject(e, e.stack);
	        }
	    });
	    return bootstrapProcess.promise;
	}
	exports.commonBootstrap = commonBootstrap;
	function _createAppInjector(appComponentType, bindings, zone) {
	    if (lang_1.isBlank(_rootInjector))
	        _rootInjector = di_1.Injector.resolveAndCreate(_rootBindings);
	    var mergedBindings = lang_1.isPresent(bindings) ? collection_1.ListWrapper.concat(_injectorBindings(appComponentType), bindings) :
	        _injectorBindings(appComponentType);
	    mergedBindings.push(di_1.bind(ng_zone_1.NgZone).toValue(zone));
	    return _rootInjector.resolveAndCreateChild(mergedBindings);
	}
	//# sourceMappingURL=application_common.js.map

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * This module is used for handling user input, by defining and building a {@link ControlGroup} that
	 * consists of
	 * {@link Control} objects, and mapping them onto the DOM. {@link Control} objects can then be used
	 * to read information
	 * from the form DOM elements.
	 *
	 * This module is not included in the `angular2` module; you must import the forms module
	 * explicitly.
	 *
	 */
	var model_1 = __webpack_require__(364);
	exports.AbstractControl = model_1.AbstractControl;
	exports.Control = model_1.Control;
	exports.ControlGroup = model_1.ControlGroup;
	exports.ControlArray = model_1.ControlArray;
	var abstract_control_directive_1 = __webpack_require__(366);
	exports.AbstractControlDirective = abstract_control_directive_1.AbstractControlDirective;
	var control_container_1 = __webpack_require__(367);
	exports.ControlContainer = control_container_1.ControlContainer;
	var ng_control_name_1 = __webpack_require__(368);
	exports.NgControlName = ng_control_name_1.NgControlName;
	var ng_form_control_1 = __webpack_require__(371);
	exports.NgFormControl = ng_form_control_1.NgFormControl;
	var ng_model_1 = __webpack_require__(372);
	exports.NgModel = ng_model_1.NgModel;
	var ng_control_1 = __webpack_require__(369);
	exports.NgControl = ng_control_1.NgControl;
	var ng_control_group_1 = __webpack_require__(373);
	exports.NgControlGroup = ng_control_group_1.NgControlGroup;
	var ng_form_model_1 = __webpack_require__(374);
	exports.NgFormModel = ng_form_model_1.NgFormModel;
	var ng_form_1 = __webpack_require__(375);
	exports.NgForm = ng_form_1.NgForm;
	var default_value_accessor_1 = __webpack_require__(376);
	exports.DefaultValueAccessor = default_value_accessor_1.DefaultValueAccessor;
	var checkbox_value_accessor_1 = __webpack_require__(435);
	exports.CheckboxControlValueAccessor = checkbox_value_accessor_1.CheckboxControlValueAccessor;
	var select_control_value_accessor_1 = __webpack_require__(436);
	exports.NgSelectOption = select_control_value_accessor_1.NgSelectOption;
	exports.SelectControlValueAccessor = select_control_value_accessor_1.SelectControlValueAccessor;
	var directives_1 = __webpack_require__(437);
	exports.FORM_DIRECTIVES = directives_1.FORM_DIRECTIVES;
	var validators_1 = __webpack_require__(365);
	exports.NG_VALIDATORS = validators_1.NG_VALIDATORS;
	exports.Validators = validators_1.Validators;
	var validators_2 = __webpack_require__(438);
	exports.DefaultValidators = validators_2.DefaultValidators;
	var form_builder_1 = __webpack_require__(439);
	exports.FormBuilder = form_builder_1.FormBuilder;
	var form_builder_2 = __webpack_require__(439);
	var lang_1 = __webpack_require__(159);
	exports.FORM_BINDINGS = lang_1.CONST_EXPR([form_builder_2.FormBuilder]);
	//# sourceMappingURL=forms.js.map

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var lang_1 = __webpack_require__(159);
	var async_1 = __webpack_require__(216);
	var collection_1 = __webpack_require__(166);
	var validators_1 = __webpack_require__(365);
	/**
	 * Indicates that a Control is valid, i.e. that no errors exist in the input value.
	 */
	exports.VALID = "VALID";
	/**
	 * Indicates that a Control is invalid, i.e. that an error exists in the input value.
	 */
	exports.INVALID = "INVALID";
	function isControl(c) {
	    return c instanceof AbstractControl;
	}
	exports.isControl = isControl;
	function _find(c, path) {
	    if (lang_1.isBlank(path))
	        return null;
	    if (!(path instanceof Array)) {
	        path = lang_1.StringWrapper.split(path, new RegExp("/"));
	    }
	    if (path instanceof Array && collection_1.ListWrapper.isEmpty(path))
	        return null;
	    return collection_1.ListWrapper.reduce(path, function (v, name) {
	        if (v instanceof ControlGroup) {
	            return lang_1.isPresent(v.controls[name]) ? v.controls[name] : null;
	        }
	        else if (v instanceof ControlArray) {
	            var index = name;
	            return lang_1.isPresent(v.at(index)) ? v.at(index) : null;
	        }
	        else {
	            return null;
	        }
	    }, c);
	}
	/**
	 * Omitting from external API doc as this is really an abstract internal concept.
	 */
	var AbstractControl = (function () {
	    function AbstractControl(validator) {
	        this.validator = validator;
	        this._pristine = true;
	        this._touched = false;
	    }
	    Object.defineProperty(AbstractControl.prototype, "value", {
	        get: function () { return this._value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "status", {
	        get: function () { return this._status; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "valid", {
	        get: function () { return this._status === exports.VALID; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "errors", {
	        get: function () { return this._errors; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "pristine", {
	        get: function () { return this._pristine; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "dirty", {
	        get: function () { return !this.pristine; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "touched", {
	        get: function () { return this._touched; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "untouched", {
	        get: function () { return !this._touched; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControl.prototype, "valueChanges", {
	        get: function () { return this._valueChanges; },
	        enumerable: true,
	        configurable: true
	    });
	    AbstractControl.prototype.markAsTouched = function () { this._touched = true; };
	    AbstractControl.prototype.markAsDirty = function (_a) {
	        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	        onlySelf = lang_1.isPresent(onlySelf) ? onlySelf : false;
	        this._pristine = false;
	        if (lang_1.isPresent(this._parent) && !onlySelf) {
	            this._parent.markAsDirty({ onlySelf: onlySelf });
	        }
	    };
	    AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };
	    AbstractControl.prototype.updateValidity = function (_a) {
	        var onlySelf = (_a === void 0 ? {} : _a).onlySelf;
	        onlySelf = lang_1.isPresent(onlySelf) ? onlySelf : false;
	        this._errors = this.validator(this);
	        this._status = lang_1.isPresent(this._errors) ? exports.INVALID : exports.VALID;
	        if (lang_1.isPresent(this._parent) && !onlySelf) {
	            this._parent.updateValidity({ onlySelf: onlySelf });
	        }
	    };
	    AbstractControl.prototype.updateValueAndValidity = function (_a) {
	        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;
	        onlySelf = lang_1.isPresent(onlySelf) ? onlySelf : false;
	        emitEvent = lang_1.isPresent(emitEvent) ? emitEvent : true;
	        this._updateValue();
	        if (emitEvent) {
	            async_1.ObservableWrapper.callNext(this._valueChanges, this._value);
	        }
	        this._errors = this.validator(this);
	        this._status = lang_1.isPresent(this._errors) ? exports.INVALID : exports.VALID;
	        if (lang_1.isPresent(this._parent) && !onlySelf) {
	            this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	        }
	    };
	    AbstractControl.prototype.find = function (path) { return _find(this, path); };
	    AbstractControl.prototype.getError = function (errorCode, path) {
	        if (path === void 0) { path = null; }
	        var c = lang_1.isPresent(path) && !collection_1.ListWrapper.isEmpty(path) ? this.find(path) : this;
	        if (lang_1.isPresent(c) && lang_1.isPresent(c._errors)) {
	            return collection_1.StringMapWrapper.get(c._errors, errorCode);
	        }
	        else {
	            return null;
	        }
	    };
	    AbstractControl.prototype.hasError = function (errorCode, path) {
	        if (path === void 0) { path = null; }
	        return lang_1.isPresent(this.getError(errorCode, path));
	    };
	    AbstractControl.prototype._updateValue = function () { };
	    return AbstractControl;
	})();
	exports.AbstractControl = AbstractControl;
	/**
	 * Defines a part of a form that cannot be divided into other controls.
	 *
	 * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
	 * with
	 * {@link ControlGroup} and {@link ControlArray}.
	 */
	var Control = (function (_super) {
	    __extends(Control, _super);
	    function Control(value, validator) {
	        if (value === void 0) { value = null; }
	        if (validator === void 0) { validator = validators_1.Validators.nullValidator; }
	        _super.call(this, validator);
	        this._value = value;
	        this.updateValidity({ onlySelf: true });
	        this._valueChanges = new async_1.EventEmitter();
	    }
	    Control.prototype.updateValue = function (value, _a) {
	        var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange;
	        emitModelToViewChange = lang_1.isPresent(emitModelToViewChange) ? emitModelToViewChange : true;
	        this._value = value;
	        if (lang_1.isPresent(this._onChange) && emitModelToViewChange)
	            this._onChange(this._value);
	        this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });
	    };
	    Control.prototype.registerOnChange = function (fn) { this._onChange = fn; };
	    return Control;
	})(AbstractControl);
	exports.Control = Control;
	/**
	 * Defines a part of a form, of fixed length, that can contain other controls.
	 *
	 * A ControlGroup aggregates the values and errors of each {@link Control} in the group. Thus, if
	 * one of the controls
	 * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,
	 * the entire group
	 * changes as well.
	 *
	 * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with
	 * {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other controls,
	 * but is of variable
	 * length.
	 */
	var ControlGroup = (function (_super) {
	    __extends(ControlGroup, _super);
	    function ControlGroup(controls, optionals, validator) {
	        if (optionals === void 0) { optionals = null; }
	        if (validator === void 0) { validator = validators_1.Validators.group; }
	        _super.call(this, validator);
	        this.controls = controls;
	        this._optionals = lang_1.isPresent(optionals) ? optionals : {};
	        this._valueChanges = new async_1.EventEmitter();
	        this._setParentForControls();
	        this._value = this._reduceValue();
	        this.updateValidity({ onlySelf: true });
	    }
	    ControlGroup.prototype.addControl = function (name, c) {
	        this.controls[name] = c;
	        c.setParent(this);
	    };
	    ControlGroup.prototype.removeControl = function (name) { collection_1.StringMapWrapper.delete(this.controls, name); };
	    ControlGroup.prototype.include = function (controlName) {
	        collection_1.StringMapWrapper.set(this._optionals, controlName, true);
	        this.updateValueAndValidity();
	    };
	    ControlGroup.prototype.exclude = function (controlName) {
	        collection_1.StringMapWrapper.set(this._optionals, controlName, false);
	        this.updateValueAndValidity();
	    };
	    ControlGroup.prototype.contains = function (controlName) {
	        var c = collection_1.StringMapWrapper.contains(this.controls, controlName);
	        return c && this._included(controlName);
	    };
	    ControlGroup.prototype._setParentForControls = function () {
	        var _this = this;
	        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) { control.setParent(_this); });
	    };
	    ControlGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };
	    ControlGroup.prototype._reduceValue = function () {
	        return this._reduceChildren({}, function (acc, control, name) {
	            acc[name] = control.value;
	            return acc;
	        });
	    };
	    ControlGroup.prototype._reduceChildren = function (initValue, fn) {
	        var _this = this;
	        var res = initValue;
	        collection_1.StringMapWrapper.forEach(this.controls, function (control, name) {
	            if (_this._included(name)) {
	                res = fn(res, control, name);
	            }
	        });
	        return res;
	    };
	    ControlGroup.prototype._included = function (controlName) {
	        var isOptional = collection_1.StringMapWrapper.contains(this._optionals, controlName);
	        return !isOptional || collection_1.StringMapWrapper.get(this._optionals, controlName);
	    };
	    return ControlGroup;
	})(AbstractControl);
	exports.ControlGroup = ControlGroup;
	/**
	 * Defines a part of a form, of variable length, that can contain other controls.
	 *
	 * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
	 * one of the controls
	 * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,
	 * the entire group
	 * changes as well.
	 *
	 * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
	 * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
	 * other controls, but is of fixed length.
	 */
	var ControlArray = (function (_super) {
	    __extends(ControlArray, _super);
	    function ControlArray(controls, validator) {
	        if (validator === void 0) { validator = validators_1.Validators.array; }
	        _super.call(this, validator);
	        this.controls = controls;
	        this._valueChanges = new async_1.EventEmitter();
	        this._setParentForControls();
	        this._updateValue();
	        this.updateValidity({ onlySelf: true });
	    }
	    ControlArray.prototype.at = function (index) { return this.controls[index]; };
	    ControlArray.prototype.push = function (control) {
	        this.controls.push(control);
	        control.setParent(this);
	        this.updateValueAndValidity();
	    };
	    ControlArray.prototype.insert = function (index, control) {
	        collection_1.ListWrapper.insert(this.controls, index, control);
	        control.setParent(this);
	        this.updateValueAndValidity();
	    };
	    ControlArray.prototype.removeAt = function (index) {
	        collection_1.ListWrapper.removeAt(this.controls, index);
	        this.updateValueAndValidity();
	    };
	    Object.defineProperty(ControlArray.prototype, "length", {
	        get: function () { return this.controls.length; },
	        enumerable: true,
	        configurable: true
	    });
	    ControlArray.prototype._updateValue = function () { this._value = collection_1.ListWrapper.map(this.controls, function (c) { return c.value; }); };
	    ControlArray.prototype._setParentForControls = function () {
	        var _this = this;
	        collection_1.ListWrapper.forEach(this.controls, function (control) { control.setParent(_this); });
	    };
	    return ControlArray;
	})(AbstractControl);
	exports.ControlArray = ControlArray;
	//# sourceMappingURL=model.js.map

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var lang_2 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var di_1 = __webpack_require__(160);
	exports.NG_VALIDATORS = lang_2.CONST_EXPR(new di_1.OpaqueToken("NgValidators"));
	/**
	 * Provides a set of validators used by form controls.
	 *
	 * # Example
	 *
	 * ```
	 * var loginControl = new Control("", Validators.required)
	 * ```
	 */
	var Validators = (function () {
	    function Validators() {
	    }
	    Validators.required = function (c) {
	        return lang_1.isBlank(c.value) || c.value == "" ? { "required": true } : null;
	    };
	    Validators.nullValidator = function (c) { return null; };
	    Validators.compose = function (validators) {
	        if (lang_1.isBlank(validators))
	            return Validators.nullValidator;
	        return function (c) {
	            var res = collection_1.ListWrapper.reduce(validators, function (res, validator) {
	                var errors = validator(c);
	                return lang_1.isPresent(errors) ? collection_1.StringMapWrapper.merge(res, errors) : res;
	            }, {});
	            return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
	        };
	    };
	    Validators.group = function (c) {
	        var res = {};
	        collection_1.StringMapWrapper.forEach(c.controls, function (control, name) {
	            if (c.contains(name) && lang_1.isPresent(control.errors)) {
	                Validators._mergeErrors(control, res);
	            }
	        });
	        return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
	    };
	    Validators.array = function (c) {
	        var res = {};
	        collection_1.ListWrapper.forEach(c.controls, function (control) {
	            if (lang_1.isPresent(control.errors)) {
	                Validators._mergeErrors(control, res);
	            }
	        });
	        return collection_1.StringMapWrapper.isEmpty(res) ? null : res;
	    };
	    Validators._mergeErrors = function (control, res) {
	        collection_1.StringMapWrapper.forEach(control.errors, function (value, error) {
	            if (!collection_1.StringMapWrapper.contains(res, error)) {
	                res[error] = [];
	            }
	            var current = res[error];
	            current.push(control);
	        });
	    };
	    return Validators;
	})();
	exports.Validators = Validators;
	//# sourceMappingURL=validators.js.map

/***/ },
/* 366 */
/***/ function(module, exports) {

	var AbstractControlDirective = (function () {
	    function AbstractControlDirective() {
	    }
	    Object.defineProperty(AbstractControlDirective.prototype, "control", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "value", {
	        get: function () { return this.control.value; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "valid", {
	        get: function () { return this.control.valid; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "errors", {
	        get: function () { return this.control.errors; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "pristine", {
	        get: function () { return this.control.pristine; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "dirty", {
	        get: function () { return this.control.dirty; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "touched", {
	        get: function () { return this.control.touched; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AbstractControlDirective.prototype, "untouched", {
	        get: function () { return this.control.untouched; },
	        enumerable: true,
	        configurable: true
	    });
	    return AbstractControlDirective;
	})();
	exports.AbstractControlDirective = AbstractControlDirective;
	//# sourceMappingURL=abstract_control_directive.js.map

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var abstract_control_directive_1 = __webpack_require__(366);
	/**
	 * A directive that contains a group of [NgControl].
	 *
	 * Only used by the forms module.
	 */
	var ControlContainer = (function (_super) {
	    __extends(ControlContainer, _super);
	    function ControlContainer() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ControlContainer.prototype, "formDirective", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ControlContainer.prototype, "path", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    return ControlContainer;
	})(abstract_control_directive_1.AbstractControlDirective);
	exports.ControlContainer = ControlContainer;
	//# sourceMappingURL=control_container.js.map

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var lang_1 = __webpack_require__(159);
	var async_1 = __webpack_require__(216);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var control_container_1 = __webpack_require__(367);
	var ng_control_1 = __webpack_require__(369);
	var shared_1 = __webpack_require__(370);
	var validators_1 = __webpack_require__(365);
	var controlNameBinding = lang_1.CONST_EXPR(new di_1.Binding(ng_control_1.NgControl, { toAlias: di_1.forwardRef(function () { return NgControlName; }) }));
	/**
	 * Creates and binds a control with a specified name to a DOM element.
	 *
	 * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.

	 * # Example
	 *
	 * In this example, we create the login and password controls.
	 * We can work with each control separately: check its validity, get its value, listen to its
	 changes.
	 *
	 *  ```
	 * @Component({selector: "login-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: `
	 *              <form #f="form" (submit)='onLogIn(f.value)'>
	 *                Login <input type='text' ng-control='login' #l="form">
	 *                <div *ng-if="!l.valid">Login is invalid</div>
	 *
	 *                Password <input type='password' ng-control='password'>

	 *                <button type='submit'>Log in!</button>
	 *              </form>
	 *      `})
	 * class LoginComp {
	 *  onLogIn(value) {
	 *    // value === {login: 'some login', password: 'some password'}
	 *  }
	 * }
	 *  ```
	 *
	 * We can also use ng-model to bind a domain model to the form.
	 *
	 *  ```
	 * @Component({selector: "login-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: `
	 *              <form (submit)='onLogIn()'>
	 *                Login <input type='text' ng-control='login' [(ng-model)]="credentials.login">
	 *                Password <input type='password' ng-control='password'
	 [(ng-model)]="credentials.password">
	 *                <button type='submit'>Log in!</button>
	 *              </form>
	 *      `})
	 * class LoginComp {
	 *  credentials: {login:string, password:string};
	 *
	 *  onLogIn() {
	 *    // this.credentials.login === "some login"
	 *    // this.credentials.password === "some password"
	 *  }
	 * }
	 *  ```
	 */
	var NgControlName = (function (_super) {
	    __extends(NgControlName, _super);
	    function NgControlName(parent, validators) {
	        _super.call(this);
	        this.update = new async_1.EventEmitter();
	        this._added = false;
	        this._parent = parent;
	        this.validators = validators;
	    }
	    NgControlName.prototype.onChanges = function (c) {
	        if (!this._added) {
	            this.formDirective.addControl(this);
	            this._added = true;
	        }
	        if (shared_1.isPropertyUpdated(c, this.viewModel)) {
	            this.viewModel = this.model;
	            this.formDirective.updateModel(this, this.model);
	        }
	    };
	    NgControlName.prototype.onDestroy = function () { this.formDirective.removeControl(this); };
	    NgControlName.prototype.viewToModelUpdate = function (newValue) {
	        this.viewModel = newValue;
	        async_1.ObservableWrapper.callNext(this.update, newValue);
	    };
	    Object.defineProperty(NgControlName.prototype, "path", {
	        get: function () { return shared_1.controlPath(this.name, this._parent); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "formDirective", {
	        get: function () { return this._parent.formDirective; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "control", {
	        get: function () { return this.formDirective.getControl(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlName.prototype, "validator", {
	        get: function () { return validators_1.Validators.compose(this.validators); },
	        enumerable: true,
	        configurable: true
	    });
	    NgControlName = __decorate([
	        metadata_1.Directive({
	            selector: '[ng-control]',
	            bindings: [controlNameBinding],
	            properties: ['name: ngControl', 'model: ngModel'],
	            events: ['update: ngModel'],
	            exportAs: 'form'
	        }),
	        __param(0, di_1.Host()),
	        __param(0, di_1.SkipSelf()),
	        __param(1, di_1.Optional()),
	        __param(1, di_1.Inject(validators_1.NG_VALIDATORS)), 
	        __metadata('design:paramtypes', [control_container_1.ControlContainer, Array])
	    ], NgControlName);
	    return NgControlName;
	})(ng_control_1.NgControl);
	exports.NgControlName = NgControlName;
	//# sourceMappingURL=ng_control_name.js.map

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var abstract_control_directive_1 = __webpack_require__(366);
	/**
	 * An abstract class that all control directive extend.
	 *
	 * It binds a {@link Control} object to a DOM element.
	 */
	var NgControl = (function (_super) {
	    __extends(NgControl, _super);
	    function NgControl() {
	        _super.apply(this, arguments);
	        this.name = null;
	        this.valueAccessor = null;
	    }
	    Object.defineProperty(NgControl.prototype, "validator", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControl.prototype, "path", {
	        get: function () { return null; },
	        enumerable: true,
	        configurable: true
	    });
	    NgControl.prototype.viewToModelUpdate = function (newValue) { };
	    return NgControl;
	})(abstract_control_directive_1.AbstractControlDirective);
	exports.NgControl = NgControl;
	//# sourceMappingURL=ng_control.js.map

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var validators_1 = __webpack_require__(365);
	function controlPath(name, parent) {
	    var p = collection_1.ListWrapper.clone(parent.path);
	    p.push(name);
	    return p;
	}
	exports.controlPath = controlPath;
	function setUpControl(c, dir) {
	    if (lang_1.isBlank(c))
	        _throwError(dir, "Cannot find control");
	    if (lang_1.isBlank(dir.valueAccessor))
	        _throwError(dir, "No value accessor for");
	    c.validator = validators_1.Validators.compose([c.validator, dir.validator]);
	    dir.valueAccessor.writeValue(c.value);
	    // view -> model
	    dir.valueAccessor.registerOnChange(function (newValue) {
	        dir.viewToModelUpdate(newValue);
	        c.updateValue(newValue, { emitModelToViewChange: false });
	        c.markAsDirty();
	    });
	    // model -> view
	    c.registerOnChange(function (newValue) { return dir.valueAccessor.writeValue(newValue); });
	    // touched
	    dir.valueAccessor.registerOnTouched(function () { return c.markAsTouched(); });
	}
	exports.setUpControl = setUpControl;
	function _throwError(dir, message) {
	    var path = collection_1.ListWrapper.join(dir.path, " -> ");
	    throw new exceptions_1.BaseException(message + " '" + path + "'");
	}
	function setProperty(renderer, elementRef, propName, propValue) {
	    renderer.setElementProperty(elementRef, propName, propValue);
	}
	exports.setProperty = setProperty;
	function isPropertyUpdated(changes, viewModel) {
	    if (!collection_1.StringMapWrapper.contains(changes, "model"))
	        return false;
	    var change = changes["model"];
	    if (change.isFirstChange())
	        return true;
	    return !lang_1.looseIdentical(viewModel, change.currentValue);
	}
	exports.isPropertyUpdated = isPropertyUpdated;
	//# sourceMappingURL=shared.js.map

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var lang_1 = __webpack_require__(159);
	var async_1 = __webpack_require__(216);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var ng_control_1 = __webpack_require__(369);
	var validators_1 = __webpack_require__(365);
	var shared_1 = __webpack_require__(370);
	var formControlBinding = lang_1.CONST_EXPR(new di_1.Binding(ng_control_1.NgControl, { toAlias: di_1.forwardRef(function () { return NgFormControl; }) }));
	/**
	 * Binds an existing control to a DOM element.
	 *
	 * # Example
	 *
	 * In this example, we bind the control to an input element. When the value of the input element
	 * changes, the value of
	 * the control will reflect that change. Likewise, if the value of the control changes, the input
	 * element reflects that
	 * change.
	 *
	 *  ```
	 * @Component({selector: "login-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: "<input type='text' [ng-form-control]='loginControl'>"
	 *      })
	 * class LoginComp {
	 *  loginControl:Control;
	 *
	 *  constructor() {
	 *    this.loginControl = new Control('');
	 *  }
	 * }
	 *
	 *  ```
	 *
	 * We can also use ng-model to bind a domain model to the form.
	 *
	 *  ```
	 * @Component({selector: "login-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: "<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>"
	 *      })
	 * class LoginComp {
	 *  loginControl:Control;
	 *  login:string;
	 *
	 *  constructor() {
	 *    this.loginControl = new Control('');
	 *  }
	 * }
	 *  ```
	 */
	var NgFormControl = (function (_super) {
	    __extends(NgFormControl, _super);
	    function NgFormControl(validators) {
	        _super.call(this);
	        this.update = new async_1.EventEmitter();
	        this._added = false;
	        this.validators = validators;
	    }
	    NgFormControl.prototype.onChanges = function (c) {
	        if (!this._added) {
	            shared_1.setUpControl(this.form, this);
	            this.form.updateValidity();
	            this._added = true;
	        }
	        if (shared_1.isPropertyUpdated(c, this.viewModel)) {
	            this.form.updateValue(this.model);
	            this.viewModel = this.model;
	        }
	    };
	    Object.defineProperty(NgFormControl.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormControl.prototype, "control", {
	        get: function () { return this.form; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormControl.prototype, "validator", {
	        get: function () { return validators_1.Validators.compose(this.validators); },
	        enumerable: true,
	        configurable: true
	    });
	    NgFormControl.prototype.viewToModelUpdate = function (newValue) {
	        this.viewModel = newValue;
	        async_1.ObservableWrapper.callNext(this.update, newValue);
	    };
	    NgFormControl = __decorate([
	        metadata_1.Directive({
	            selector: '[ng-form-control]',
	            bindings: [formControlBinding],
	            properties: ['form: ngFormControl', 'model: ngModel'],
	            events: ['update: ngModel'],
	            exportAs: 'form'
	        }),
	        __param(0, di_1.Optional()),
	        __param(0, di_1.Inject(validators_1.NG_VALIDATORS)), 
	        __metadata('design:paramtypes', [Array])
	    ], NgFormControl);
	    return NgFormControl;
	})(ng_control_1.NgControl);
	exports.NgFormControl = NgFormControl;
	//# sourceMappingURL=ng_form_control.js.map

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var lang_1 = __webpack_require__(159);
	var async_1 = __webpack_require__(216);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var ng_control_1 = __webpack_require__(369);
	var model_1 = __webpack_require__(364);
	var validators_1 = __webpack_require__(365);
	var shared_1 = __webpack_require__(370);
	var formControlBinding = lang_1.CONST_EXPR(new di_1.Binding(ng_control_1.NgControl, { toAlias: di_1.forwardRef(function () { return NgModel; }) }));
	/**
	 * Binds a domain model to the form.
	 *
	 * # Example
	 *  ```
	 * @Component({selector: "search-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: `
	              <input type='text' [(ng-model)]="searchQuery">
	 *      `})
	 * class SearchComp {
	 *  searchQuery: string;
	 * }
	 *  ```
	 */
	var NgModel = (function (_super) {
	    __extends(NgModel, _super);
	    function NgModel(validators) {
	        _super.call(this);
	        this._control = new model_1.Control();
	        this._added = false;
	        this.update = new async_1.EventEmitter();
	        this.validators = validators;
	    }
	    NgModel.prototype.onChanges = function (c) {
	        if (!this._added) {
	            shared_1.setUpControl(this._control, this);
	            this._control.updateValidity();
	            this._added = true;
	        }
	        if (shared_1.isPropertyUpdated(c, this.viewModel)) {
	            this._control.updateValue(this.model);
	            this.viewModel = this.model;
	        }
	    };
	    Object.defineProperty(NgModel.prototype, "control", {
	        get: function () { return this._control; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModel.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgModel.prototype, "validator", {
	        get: function () { return validators_1.Validators.compose(this.validators); },
	        enumerable: true,
	        configurable: true
	    });
	    NgModel.prototype.viewToModelUpdate = function (newValue) {
	        this.viewModel = newValue;
	        async_1.ObservableWrapper.callNext(this.update, newValue);
	    };
	    NgModel = __decorate([
	        metadata_1.Directive({
	            selector: '[ng-model]:not([ng-control]):not([ng-form-control])',
	            bindings: [formControlBinding],
	            properties: ['model: ngModel'],
	            events: ['update: ngModel'],
	            exportAs: 'form'
	        }),
	        __param(0, di_1.Optional()),
	        __param(0, di_1.Inject(validators_1.NG_VALIDATORS)), 
	        __metadata('design:paramtypes', [Array])
	    ], NgModel);
	    return NgModel;
	})(ng_control_1.NgControl);
	exports.NgModel = NgModel;
	//# sourceMappingURL=ng_model.js.map

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var control_container_1 = __webpack_require__(367);
	var shared_1 = __webpack_require__(370);
	var controlGroupBinding = lang_1.CONST_EXPR(new di_1.Binding(control_container_1.ControlContainer, { toAlias: di_1.forwardRef(function () { return NgControlGroup; }) }));
	/**
	 * Creates and binds a control group to a DOM element.
	 *
	 * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
	 *
	 * # Example
	 *
	 * In this example, we create the credentials and personal control groups.
	 * We can work with each group separately: check its validity, get its value, listen to its changes.
	 *
	 *  ```
	 * @Component({selector: "signup-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: `
	 *              <form #f="form" (submit)='onSignUp(f.value)'>
	 *                <div ng-control-group='credentials' #credentials="form">
	 *                  Login <input type='text' ng-control='login'>
	 *                  Password <input type='password' ng-control='password'>
	 *                </div>
	 *                <div *ng-if="!credentials.valid">Credentials are invalid</div>
	 *
	 *                <div ng-control-group='personal'>
	 *                  Name <input type='text' ng-control='name'>
	 *                </div>
	 *                <button type='submit'>Sign Up!</button>
	 *              </form>
	 *      `})
	 * class SignupComp {
	 *  onSignUp(value) {
	 *    // value === {personal: {name: 'some name'},
	 *    //  credentials: {login: 'some login', password: 'some password'}}
	 *  }
	 * }
	 *
	 *  ```
	 */
	var NgControlGroup = (function (_super) {
	    __extends(NgControlGroup, _super);
	    function NgControlGroup(_parent) {
	        _super.call(this);
	        this._parent = _parent;
	    }
	    NgControlGroup.prototype.onInit = function () { this.formDirective.addControlGroup(this); };
	    NgControlGroup.prototype.onDestroy = function () { this.formDirective.removeControlGroup(this); };
	    Object.defineProperty(NgControlGroup.prototype, "control", {
	        get: function () { return this.formDirective.getControlGroup(this); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlGroup.prototype, "path", {
	        get: function () { return shared_1.controlPath(this.name, this._parent); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgControlGroup.prototype, "formDirective", {
	        get: function () { return this._parent.formDirective; },
	        enumerable: true,
	        configurable: true
	    });
	    NgControlGroup = __decorate([
	        metadata_1.Directive({
	            selector: '[ng-control-group]',
	            bindings: [controlGroupBinding],
	            properties: ['name: ng-control-group'],
	            exportAs: 'form'
	        }),
	        __param(0, di_1.Host()),
	        __param(0, di_1.SkipSelf()), 
	        __metadata('design:paramtypes', [control_container_1.ControlContainer])
	    ], NgControlGroup);
	    return NgControlGroup;
	})(control_container_1.ControlContainer);
	exports.NgControlGroup = NgControlGroup;
	//# sourceMappingURL=ng_control_group.js.map

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var async_1 = __webpack_require__(216);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var control_container_1 = __webpack_require__(367);
	var shared_1 = __webpack_require__(370);
	var formDirectiveBinding = lang_1.CONST_EXPR(new di_1.Binding(control_container_1.ControlContainer, { toAlias: di_1.forwardRef(function () { return NgFormModel; }) }));
	/**
	 * Binds an existing control group to a DOM element.
	 *
	 * # Example
	 *
	 * In this example, we bind the control group to the form element, and we bind the login and
	 * password controls to the
	 * login and password elements.
	 *
	 *  ```
	 * @Component({selector: "login-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: "<form [ng-form-model]='loginForm'>" +
	 *              "Login <input type='text' ng-control='login'>" +
	 *              "Password <input type='password' ng-control='password'>" +
	 *              "<button (click)="onLogin()">Login</button>" +
	 *              "</form>"
	 *      })
	 * class LoginComp {
	 *  loginForm:ControlGroup;
	 *
	 *  constructor() {
	 *    this.loginForm = new ControlGroup({
	 *      login: new Control(""),
	 *      password: new Control("")
	 *    });
	 *  }
	 *
	 *  onLogin() {
	 *    // this.loginForm.value
	 *  }
	 * }
	 *
	 *  ```
	 *
	 * We can also use ng-model to bind a domain model to the form.
	 *
	 *  ```
	 * @Component({selector: "login-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: "<form [ng-form-model]='loginForm'>" +
	 *              "Login <input type='text' ng-control='login' [(ng-model)]='login'>" +
	 *              "Password <input type='password' ng-control='password' [(ng-model)]='password'>" +
	 *              "<button (click)="onLogin()">Login</button>" +
	 *              "</form>"
	 *      })
	 * class LoginComp {
	 *  credentials:{login:string, password:string}
	 *  loginForm:ControlGroup;
	 *
	 *  constructor() {
	 *    this.loginForm = new ControlGroup({
	 *      login: new Control(""),
	 *      password: new Control("")
	 *    });
	 *  }
	 *
	 *  onLogin() {
	 *    // this.credentials.login === 'some login'
	 *    // this.credentials.password === 'some password'
	 *  }
	 * }
	 *  ```
	 */
	var NgFormModel = (function (_super) {
	    __extends(NgFormModel, _super);
	    function NgFormModel() {
	        _super.apply(this, arguments);
	        this.form = null;
	        this.directives = [];
	        this.ngSubmit = new async_1.EventEmitter();
	    }
	    NgFormModel.prototype.onChanges = function (_) { this._updateDomValue(); };
	    Object.defineProperty(NgFormModel.prototype, "formDirective", {
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormModel.prototype, "control", {
	        get: function () { return this.form; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgFormModel.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    NgFormModel.prototype.addControl = function (dir) {
	        var c = this.form.find(dir.path);
	        shared_1.setUpControl(c, dir);
	        c.updateValidity();
	        this.directives.push(dir);
	    };
	    NgFormModel.prototype.getControl = function (dir) { return this.form.find(dir.path); };
	    NgFormModel.prototype.removeControl = function (dir) { collection_1.ListWrapper.remove(this.directives, dir); };
	    NgFormModel.prototype.addControlGroup = function (dir) { };
	    NgFormModel.prototype.removeControlGroup = function (dir) { };
	    NgFormModel.prototype.getControlGroup = function (dir) {
	        return this.form.find(dir.path);
	    };
	    NgFormModel.prototype.updateModel = function (dir, value) {
	        var c = this.form.find(dir.path);
	        c.updateValue(value);
	    };
	    NgFormModel.prototype.onSubmit = function () {
	        async_1.ObservableWrapper.callNext(this.ngSubmit, null);
	        return false;
	    };
	    NgFormModel.prototype._updateDomValue = function () {
	        var _this = this;
	        collection_1.ListWrapper.forEach(this.directives, function (dir) {
	            var c = _this.form.find(dir.path);
	            dir.valueAccessor.writeValue(c.value);
	        });
	    };
	    NgFormModel = __decorate([
	        metadata_1.Directive({
	            selector: '[ng-form-model]',
	            bindings: [formDirectiveBinding],
	            properties: ['form: ng-form-model'],
	            host: {
	                '(submit)': 'onSubmit()',
	            },
	            events: ['ngSubmit'],
	            exportAs: 'form'
	        }), 
	        __metadata('design:paramtypes', [])
	    ], NgFormModel);
	    return NgFormModel;
	})(control_container_1.ControlContainer);
	exports.NgFormModel = NgFormModel;
	//# sourceMappingURL=ng_form_model.js.map

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var async_1 = __webpack_require__(216);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var control_container_1 = __webpack_require__(367);
	var model_1 = __webpack_require__(364);
	var shared_1 = __webpack_require__(370);
	var formDirectiveBinding = lang_1.CONST_EXPR(new di_1.Binding(control_container_1.ControlContainer, { toAlias: di_1.forwardRef(function () { return NgForm; }) }));
	/**
	 * Creates and binds a form object to a DOM element.
	 *
	 * # Example
	 *
	 *  ```
	 * @Component({selector: "signup-comp"})
	 * @View({
	 *      directives: [FORM_DIRECTIVES],
	 *      template: `
	 *              <form #f="form" (submit)='onSignUp(f.value)'>
	 *                <div ng-control-group='credentials' #credentials="form">
	 *                  Login <input type='text' ng-control='login'>
	 *                  Password <input type='password' ng-control='password'>
	 *                </div>
	 *                <div *ng-if="!credentials.valid">Credentials are invalid</div>
	 *
	 *                <div ng-control-group='personal'>
	 *                  Name <input type='text' ng-control='name'>
	 *                </div>
	 *                <button type='submit'>Sign Up!</button>
	 *              </form>
	 *      `})
	 * class SignupComp {
	 *  onSignUp(value) {
	 *    // value === {personal: {name: 'some name'},
	 *    //  credentials: {login: 'some login', password: 'some password'}}
	 *  }
	 * }
	 *
	 *  ```
	 */
	var NgForm = (function (_super) {
	    __extends(NgForm, _super);
	    function NgForm() {
	        _super.call(this);
	        this.ngSubmit = new async_1.EventEmitter();
	        this.form = new model_1.ControlGroup({});
	    }
	    Object.defineProperty(NgForm.prototype, "formDirective", {
	        get: function () { return this; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "control", {
	        get: function () { return this.form; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "path", {
	        get: function () { return []; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgForm.prototype, "controls", {
	        get: function () { return this.form.controls; },
	        enumerable: true,
	        configurable: true
	    });
	    NgForm.prototype.addControl = function (dir) {
	        var _this = this;
	        this._later(function (_) {
	            var container = _this._findContainer(dir.path);
	            var c = new model_1.Control();
	            shared_1.setUpControl(c, dir);
	            container.addControl(dir.name, c);
	            c.updateValidity();
	        });
	    };
	    NgForm.prototype.getControl = function (dir) { return this.form.find(dir.path); };
	    NgForm.prototype.removeControl = function (dir) {
	        var _this = this;
	        this._later(function (_) {
	            var container = _this._findContainer(dir.path);
	            if (lang_1.isPresent(container)) {
	                container.removeControl(dir.name);
	                container.updateValidity();
	            }
	        });
	    };
	    NgForm.prototype.addControlGroup = function (dir) {
	        var _this = this;
	        this._later(function (_) {
	            var container = _this._findContainer(dir.path);
	            var c = new model_1.ControlGroup({});
	            container.addControl(dir.name, c);
	            c.updateValidity();
	        });
	    };
	    NgForm.prototype.removeControlGroup = function (dir) {
	        var _this = this;
	        this._later(function (_) {
	            var container = _this._findContainer(dir.path);
	            if (lang_1.isPresent(container)) {
	                container.removeControl(dir.name);
	                container.updateValidity();
	            }
	        });
	    };
	    NgForm.prototype.getControlGroup = function (dir) {
	        return this.form.find(dir.path);
	    };
	    NgForm.prototype.updateModel = function (dir, value) {
	        var _this = this;
	        this._later(function (_) {
	            var c = _this.form.find(dir.path);
	            c.updateValue(value);
	        });
	    };
	    NgForm.prototype.onSubmit = function () {
	        async_1.ObservableWrapper.callNext(this.ngSubmit, null);
	        return false;
	    };
	    NgForm.prototype._findContainer = function (path) {
	        collection_1.ListWrapper.removeLast(path);
	        return collection_1.ListWrapper.isEmpty(path) ? this.form : this.form.find(path);
	    };
	    NgForm.prototype._later = function (fn) {
	        var c = async_1.PromiseWrapper.completer();
	        async_1.PromiseWrapper.then(c.promise, fn, function (_) { });
	        c.resolve(null);
	    };
	    NgForm = __decorate([
	        metadata_1.Directive({
	            selector: 'form:not([ng-no-form]):not([ng-form-model]),ng-form,[ng-form]',
	            bindings: [formDirectiveBinding],
	            host: {
	                '(submit)': 'onSubmit()',
	            },
	            events: ['ngSubmit'],
	            exportAs: 'form'
	        }), 
	        __metadata('design:paramtypes', [])
	    ], NgForm);
	    return NgForm;
	})(control_container_1.ControlContainer);
	exports.NgForm = NgForm;
	//# sourceMappingURL=ng_form.js.map

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var metadata_1 = __webpack_require__(157);
	var compiler_1 = __webpack_require__(377);
	var render_1 = __webpack_require__(404);
	var di_1 = __webpack_require__(160);
	var ng_control_1 = __webpack_require__(369);
	var lang_1 = __webpack_require__(159);
	var shared_1 = __webpack_require__(370);
	/**
	 * The default accessor for writing a value and listening to changes that is used by the
	 * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
	 *
	 *  # Example
	 *  ```
	 *  <input type="text" [(ng-model)]="searchQuery">
	 *  ```
	 */
	var DefaultValueAccessor = (function () {
	    function DefaultValueAccessor(cd, _renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	        this._cd = cd;
	        cd.valueAccessor = this;
	    }
	    DefaultValueAccessor.prototype.writeValue = function (value) {
	        // both this.value and setProperty are required at the moment
	        // remove when a proper imperative API is provided
	        var normalizedValue = lang_1.isBlank(value) ? '' : value;
	        shared_1.setProperty(this._renderer, this._elementRef, 'value', normalizedValue);
	    };
	    Object.defineProperty(DefaultValueAccessor.prototype, "ngClassUntouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultValueAccessor.prototype, "ngClassTouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultValueAccessor.prototype, "ngClassPristine", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultValueAccessor.prototype, "ngClassDirty", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultValueAccessor.prototype, "ngClassValid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultValueAccessor.prototype, "ngClassInvalid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    DefaultValueAccessor = __decorate([
	        metadata_1.Directive({
	            selector: 'input:not([type=checkbox])[ng-control],textarea[ng-control],input:not([type=checkbox])[ng-form-control],textarea[ng-form-control],input:not([type=checkbox])[ng-model],textarea[ng-model]',
	            host: {
	                '(change)': 'onChange($event.target.value)',
	                '(input)': 'onChange($event.target.value)',
	                '(blur)': 'onTouched()',
	                '[class.ng-untouched]': 'ngClassUntouched',
	                '[class.ng-touched]': 'ngClassTouched',
	                '[class.ng-pristine]': 'ngClassPristine',
	                '[class.ng-dirty]': 'ngClassDirty',
	                '[class.ng-valid]': 'ngClassValid',
	                '[class.ng-invalid]': 'ngClassInvalid'
	            }
	        }),
	        __param(0, di_1.Self()), 
	        __metadata('design:paramtypes', [ng_control_1.NgControl, render_1.Renderer, compiler_1.ElementRef])
	    ], DefaultValueAccessor);
	    return DefaultValueAccessor;
	})();
	exports.DefaultValueAccessor = DefaultValueAccessor;
	//# sourceMappingURL=default_value_accessor.js.map

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for compiler
	var interfaces_1 = __webpack_require__(378);
	exports.AfterContentInit = interfaces_1.AfterContentInit;
	exports.AfterContentChecked = interfaces_1.AfterContentChecked;
	exports.AfterViewInit = interfaces_1.AfterViewInit;
	exports.AfterViewChecked = interfaces_1.AfterViewChecked;
	exports.OnChanges = interfaces_1.OnChanges;
	exports.OnDestroy = interfaces_1.OnDestroy;
	exports.OnInit = interfaces_1.OnInit;
	exports.DoCheck = interfaces_1.DoCheck;
	var component_url_mapper_1 = __webpack_require__(379);
	exports.ComponentUrlMapper = component_url_mapper_1.ComponentUrlMapper;
	var directive_resolver_1 = __webpack_require__(380);
	exports.DirectiveResolver = directive_resolver_1.DirectiveResolver;
	var compiler_1 = __webpack_require__(381);
	exports.Compiler = compiler_1.Compiler;
	var view_manager_1 = __webpack_require__(388);
	exports.AppViewManager = view_manager_1.AppViewManager;
	var query_list_1 = __webpack_require__(396);
	exports.QueryList = query_list_1.QueryList;
	var dynamic_component_loader_1 = __webpack_require__(403);
	exports.DynamicComponentLoader = dynamic_component_loader_1.DynamicComponentLoader;
	var element_ref_1 = __webpack_require__(390);
	exports.ElementRef = element_ref_1.ElementRef;
	var template_ref_1 = __webpack_require__(391);
	exports.TemplateRef = template_ref_1.TemplateRef;
	var view_ref_1 = __webpack_require__(384);
	exports.ViewRef = view_ref_1.ViewRef;
	exports.ProtoViewRef = view_ref_1.ProtoViewRef;
	var view_container_ref_1 = __webpack_require__(394);
	exports.ViewContainerRef = view_container_ref_1.ViewContainerRef;
	var view_1 = __webpack_require__(382);
	exports.AppView = view_1.AppView;
	exports.AppProtoView = view_1.AppProtoView;
	exports.AppProtoViewMergeMapping = view_1.AppProtoViewMergeMapping;
	exports.AppViewContainer = view_1.AppViewContainer;
	var dynamic_component_loader_2 = __webpack_require__(403);
	exports.ComponentRef = dynamic_component_loader_2.ComponentRef;
	var element_injector_1 = __webpack_require__(387);
	exports.ElementInjector = element_injector_1.ElementInjector;
	exports.PreBuiltObjects = element_injector_1.PreBuiltObjects;
	exports.TreeNode = element_injector_1.TreeNode;
	exports.ProtoElementInjector = element_injector_1.ProtoElementInjector;
	exports.DirectiveBinding = element_injector_1.DirectiveBinding;
	exports.EventEmitterAccessor = element_injector_1.EventEmitterAccessor;
	var element_binder_1 = __webpack_require__(383);
	exports.ElementBinder = element_binder_1.ElementBinder;
	//# sourceMappingURL=compiler.js.map

/***/ },
/* 378 */
/***/ function(module, exports) {

	/**
	 * Lifecycle hooks are guaranteed to be called in the following order:
	 * - `OnChanges` (if any bindings have changed),
	 * - `OnInit` (after the first check only),
	 * - `DoCheck`,
	 * - `AfterContentInit`,
	 * - `AfterContentChecked`,
	 * - `OnDestroy` (at the very end before destruction)
	 */
	/**
	 * Notify a directive when any of its bindings have changed.
	 *
	 * `onChanges` is called right after the directive's bindings have been checked,
	 * and before any of its children's bindings have been checked.
	 *
	 * It is invoked only if at least one of the directive's bindings has changed.
	 *
	 * ## Example:
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements OnChanges {
	 *   propA;
	 *   propB;
	 *
	 *   onChanges(changes: {[idx: string, PropertyUpdate]}): void {
	 *     // This will get called after any of the properties have been updated.
	 *     if (changes['propA']) {
	 *       // if propA was updated
	 *     }
	 *     if (changes['propA']) {
	 *       // if propB was updated
	 *     }
	 *   }
	 * }
	 *  ```
	 */
	var OnChanges = (function () {
	    function OnChanges() {
	    }
	    OnChanges.prototype.onChanges = function (changes) { };
	    return OnChanges;
	})();
	exports.OnChanges = OnChanges;
	/**
	 * Notify a directive when it has been checked the first time.
	 *
	 * `onInit` is called right after the directive's bindings have been checked for the first time,
	 * and before any of its children's bindings have been checked.
	 *
	 * It is invoked only once.
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent @implements OnInit {
	 *   onInit(): void {
	 *   }
	 * }
	 *  ```
	 */
	var OnInit = (function () {
	    function OnInit() {
	    }
	    OnInit.prototype.onInit = function () { };
	    return OnInit;
	})();
	exports.OnInit = OnInit;
	/**
	 * Overrides the default change detection.
	 *
	 * `doCheck()` gets called to check the changes in the directives instead of the default
	 * change detection mechanism.
	 *
	 * It is invoked every time the change detection is triggered.
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements DoCheck {
	 *   doCheck(): void {
	 *     // Custom logic to detect changes
	 *   }
	 * }
	 *  ```
	 */
	var DoCheck = (function () {
	    function DoCheck() {
	    }
	    DoCheck.prototype.doCheck = function () { };
	    return DoCheck;
	})();
	exports.DoCheck = DoCheck;
	/**
	 * Notify a directive whenever a {@link ViewMetadata} that contains it is destroyed.
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements OnDestroy {
	 *   onDestroy(): void {
	 *     // invoked to notify directive of the containing view destruction.
	 *   }
	 * }
	 * ```
	 */
	var OnDestroy = (function () {
	    function OnDestroy() {
	    }
	    OnDestroy.prototype.onDestroy = function () { };
	    return OnDestroy;
	})();
	exports.OnDestroy = OnDestroy;
	/**
	 * Notify a directive when the bindings of all its content children have been checked the first
	 * time (whether they have changed or not).
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements AfterContentInit {
	 *   afterContentInit(): void {
	 *   }
	 * }
	 *  ```
	 */
	var AfterContentInit = (function () {
	    function AfterContentInit() {
	    }
	    AfterContentInit.prototype.afterContentInit = function () { };
	    return AfterContentInit;
	})();
	exports.AfterContentInit = AfterContentInit;
	/**
	 * Notify a directive when the bindings of all its content children have been checked (whether
	 * they have changed or not).
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements AfterContentChecked {
	 *   afterContentChecked(): void {
	 *   }
	 * }
	 *  ```
	 */
	var AfterContentChecked = (function () {
	    function AfterContentChecked() {
	    }
	    AfterContentChecked.prototype.afterContentChecked = function () { };
	    return AfterContentChecked;
	})();
	exports.AfterContentChecked = AfterContentChecked;
	/**
	 * Notify a directive when the bindings of all its view children have been checked the first time
	 * (whether they have changed or not).
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements AfterViewInit {
	 *   afterViewInit(): void {
	 *   }
	 * }
	 *  ```
	 */
	var AfterViewInit = (function () {
	    function AfterViewInit() {
	    }
	    AfterViewInit.prototype.afterViewInit = function () { };
	    return AfterViewInit;
	})();
	exports.AfterViewInit = AfterViewInit;
	/**
	 * Notify a directive when the bindings of all its view children have been checked (whether they
	 * have changed or not).
	 *
	 * ## Example
	 *
	 * ```
	 * @Component(...)
	 * class MyComponent implements AfterViewChecked {
	 *   afterViewChecked(): void {
	 *   }
	 * }
	 *  ```
	 */
	var AfterViewChecked = (function () {
	    function AfterViewChecked() {
	    }
	    AfterViewChecked.prototype.afterViewChecked = function () { };
	    return AfterViewChecked;
	})();
	exports.AfterViewChecked = AfterViewChecked;
	//# sourceMappingURL=interfaces.js.map

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var reflection_1 = __webpack_require__(170);
	/**
	 * Resolve a `Type` from a {@link ComponentMetadata} into a URL.
	 *
	 * This interface can be overridden by the application developer to create custom behavior.
	 *
	 * See {@link Compiler}
	 */
	var ComponentUrlMapper = (function () {
	    function ComponentUrlMapper() {
	    }
	    /**
	     * Returns the base URL to the component source file.
	     * The returned URL could be:
	     * - an absolute URL,
	     * - a path relative to the application
	     */
	    ComponentUrlMapper.prototype.getUrl = function (component) {
	        return reflection_1.reflector.isReflectionEnabled() ? reflection_1.reflector.importUri(component) : './';
	    };
	    ComponentUrlMapper = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], ComponentUrlMapper);
	    return ComponentUrlMapper;
	})();
	exports.ComponentUrlMapper = ComponentUrlMapper;
	var RuntimeComponentUrlMapper = (function (_super) {
	    __extends(RuntimeComponentUrlMapper, _super);
	    function RuntimeComponentUrlMapper() {
	        _super.call(this);
	        this._componentUrls = new collection_1.Map();
	    }
	    RuntimeComponentUrlMapper.prototype.setComponentUrl = function (component, url) { this._componentUrls.set(component, url); };
	    RuntimeComponentUrlMapper.prototype.getUrl = function (component) {
	        var url = this._componentUrls.get(component);
	        if (lang_1.isPresent(url))
	            return url;
	        return _super.prototype.getUrl.call(this, component);
	    };
	    return RuntimeComponentUrlMapper;
	})(ComponentUrlMapper);
	exports.RuntimeComponentUrlMapper = RuntimeComponentUrlMapper;
	//# sourceMappingURL=component_url_mapper.js.map

/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var metadata_1 = __webpack_require__(157);
	var reflection_1 = __webpack_require__(170);
	/**
	 * Resolve a `Type` for {@link DirectiveMetadata}.
	 *
	 * This interface can be overridden by the application developer to create custom behavior.
	 *
	 * See {@link Compiler}
	 */
	var DirectiveResolver = (function () {
	    function DirectiveResolver() {
	    }
	    /**
	     * Return {@link DirectiveMetadata} for a given `Type`.
	     */
	    DirectiveResolver.prototype.resolve = function (type) {
	        var typeMetadata = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));
	        if (lang_1.isPresent(typeMetadata)) {
	            for (var i = 0; i < typeMetadata.length; i++) {
	                var metadata = typeMetadata[i];
	                if (metadata instanceof metadata_1.DirectiveMetadata) {
	                    var propertyMetadata = reflection_1.reflector.propMetadata(type);
	                    return this._mergeWithPropertyMetadata(metadata, propertyMetadata);
	                }
	            }
	        }
	        throw new exceptions_1.BaseException("No Directive annotation found on " + lang_1.stringify(type));
	    };
	    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata) {
	        var properties = [];
	        var events = [];
	        var host = {};
	        collection_1.StringMapWrapper.forEach(propertyMetadata, function (metadata, propName) {
	            metadata.forEach(function (a) {
	                if (a instanceof metadata_1.PropertyMetadata) {
	                    if (lang_1.isPresent(a.bindingPropertyName)) {
	                        properties.push(propName + ": " + a.bindingPropertyName);
	                    }
	                    else {
	                        properties.push(propName);
	                    }
	                }
	                if (a instanceof metadata_1.EventMetadata) {
	                    if (lang_1.isPresent(a.bindingPropertyName)) {
	                        events.push(propName + ": " + a.bindingPropertyName);
	                    }
	                    else {
	                        events.push(propName);
	                    }
	                }
	                if (a instanceof metadata_1.HostBindingMetadata) {
	                    if (lang_1.isPresent(a.hostPropertyName)) {
	                        host[("[" + a.hostPropertyName + "]")] = propName;
	                    }
	                    else {
	                        host[("[" + propName + "]")] = propName;
	                    }
	                }
	                if (a instanceof metadata_1.HostListenerMetadata) {
	                    var args = lang_1.isPresent(a.args) ? a.args.join(', ') : '';
	                    host[("(" + a.eventName + ")")] = propName + "(" + args + ")";
	                }
	            });
	        });
	        return this._merge(dm, properties, events, host);
	    };
	    DirectiveResolver.prototype._merge = function (dm, properties, events, host) {
	        var mergedProperties = lang_1.isPresent(dm.properties) ? collection_1.ListWrapper.concat(dm.properties, properties) : properties;
	        var mergedEvents = lang_1.isPresent(dm.events) ? collection_1.ListWrapper.concat(dm.events, events) : events;
	        var mergedHost = lang_1.isPresent(dm.host) ? collection_1.StringMapWrapper.merge(dm.host, host) : host;
	        if (dm instanceof metadata_1.ComponentMetadata) {
	            return new metadata_1.ComponentMetadata({
	                selector: dm.selector,
	                properties: mergedProperties,
	                events: mergedEvents,
	                host: mergedHost,
	                bindings: dm.bindings,
	                exportAs: dm.exportAs,
	                compileChildren: dm.compileChildren,
	                changeDetection: dm.changeDetection,
	                viewBindings: dm.viewBindings
	            });
	        }
	        else {
	            return new metadata_1.DirectiveMetadata({
	                selector: dm.selector,
	                properties: mergedProperties,
	                events: mergedEvents,
	                host: mergedHost,
	                bindings: dm.bindings,
	                exportAs: dm.exportAs,
	                compileChildren: dm.compileChildren
	            });
	        }
	    };
	    DirectiveResolver = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], DirectiveResolver);
	    return DirectiveResolver;
	})();
	exports.DirectiveResolver = DirectiveResolver;
	//# sourceMappingURL=directive_resolver.js.map

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var di_1 = __webpack_require__(160);
	var pipes_1 = __webpack_require__(214);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var async_1 = __webpack_require__(216);
	var collection_1 = __webpack_require__(166);
	var directive_resolver_1 = __webpack_require__(380);
	var view_1 = __webpack_require__(382);
	var element_injector_1 = __webpack_require__(387);
	var view_resolver_1 = __webpack_require__(398);
	var pipe_resolver_1 = __webpack_require__(399);
	var component_url_mapper_1 = __webpack_require__(379);
	var proto_view_factory_1 = __webpack_require__(400);
	var url_resolver_1 = __webpack_require__(401);
	var app_root_url_1 = __webpack_require__(402);
	var profile_1 = __webpack_require__(190);
	var pipe_binding_1 = __webpack_require__(356);
	var api_1 = __webpack_require__(212);
	/**
	 * Cache that stores the AppProtoView of the template of a component.
	 * Used to prevent duplicate work and resolve cyclic dependencies.
	 */
	var CompilerCache = (function () {
	    function CompilerCache() {
	        this._cache = new collection_1.Map();
	        this._hostCache = new collection_1.Map();
	    }
	    CompilerCache.prototype.set = function (component, protoView) { this._cache.set(component, protoView); };
	    CompilerCache.prototype.get = function (component) {
	        var result = this._cache.get(component);
	        return lang_1.normalizeBlank(result);
	    };
	    CompilerCache.prototype.setHost = function (component, protoView) {
	        this._hostCache.set(component, protoView);
	    };
	    CompilerCache.prototype.getHost = function (component) {
	        var result = this._hostCache.get(component);
	        return lang_1.normalizeBlank(result);
	    };
	    CompilerCache.prototype.clear = function () {
	        this._cache.clear();
	        this._hostCache.clear();
	    };
	    CompilerCache = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], CompilerCache);
	    return CompilerCache;
	})();
	exports.CompilerCache = CompilerCache;
	/**
	 *
	 * ## URL Resolution
	 *
	 * ```
	 * var appRootUrl: AppRootUrl = ...;
	 * var componentUrlMapper: ComponentUrlMapper = ...;
	 * var urlResolver: UrlResolver = ...;
	 *
	 * var componentType: Type = ...;
	 * var componentAnnotation: ComponentAnnotation = ...;
	 * var viewAnnotation: ViewAnnotation = ...;
	 *
	 * // Resolving a URL
	 *
	 * var url = viewAnnotation.templateUrl;
	 * var componentUrl = componentUrlMapper.getUrl(componentType);
	 * var componentResolvedUrl = urlResolver.resolve(appRootUrl.value, componentUrl);
	 * var templateResolvedUrl = urlResolver.resolve(componetResolvedUrl, url);
	 * ```
	 */
	var Compiler = (function () {
	    /**
	     * @private
	     */
	    function Compiler(_directiveResolver, _pipeResolver, _defaultPipes, _compilerCache, _viewResolver, _componentUrlMapper, _urlResolver, _render, _protoViewFactory, appUrl) {
	        this._directiveResolver = _directiveResolver;
	        this._pipeResolver = _pipeResolver;
	        this._compilerCache = _compilerCache;
	        this._viewResolver = _viewResolver;
	        this._componentUrlMapper = _componentUrlMapper;
	        this._urlResolver = _urlResolver;
	        this._render = _render;
	        this._protoViewFactory = _protoViewFactory;
	        this._compiling = new collection_1.Map();
	        this._defaultPipes = _defaultPipes;
	        this._appUrl = appUrl.value;
	    }
	    Compiler.prototype._bindDirective = function (directiveTypeOrBinding) {
	        if (directiveTypeOrBinding instanceof element_injector_1.DirectiveBinding) {
	            return directiveTypeOrBinding;
	        }
	        else if (directiveTypeOrBinding instanceof di_1.Binding) {
	            var annotation = this._directiveResolver.resolve(directiveTypeOrBinding.token);
	            return element_injector_1.DirectiveBinding.createFromBinding(directiveTypeOrBinding, annotation);
	        }
	        else {
	            var annotation = this._directiveResolver.resolve(directiveTypeOrBinding);
	            return element_injector_1.DirectiveBinding.createFromType(directiveTypeOrBinding, annotation);
	        }
	    };
	    Compiler.prototype._bindPipe = function (typeOrBinding) {
	        var meta = this._pipeResolver.resolve(typeOrBinding);
	        return pipe_binding_1.PipeBinding.createFromType(typeOrBinding, meta);
	    };
	    // Create a hostView as if the compiler encountered <hostcmp></hostcmp>.
	    // Used for bootstrapping.
	    Compiler.prototype.compileInHost = function (componentTypeOrBinding) {
	        var _this = this;
	        var componentType = lang_1.isType(componentTypeOrBinding) ? componentTypeOrBinding :
	            componentTypeOrBinding.token;
	        var r = profile_1.wtfStartTimeRange('Compiler#compile()', lang_1.stringify(componentType));
	        var hostAppProtoView = this._compilerCache.getHost(componentType);
	        var hostPvPromise;
	        if (lang_1.isPresent(hostAppProtoView)) {
	            hostPvPromise = async_1.PromiseWrapper.resolve(hostAppProtoView);
	        }
	        else {
	            var componentBinding = this._bindDirective(componentTypeOrBinding);
	            Compiler._assertTypeIsComponent(componentBinding);
	            var directiveMetadata = componentBinding.metadata;
	            hostPvPromise =
	                this._render.compileHost(directiveMetadata)
	                    .then(function (hostRenderPv) {
	                    var protoViews = _this._protoViewFactory.createAppProtoViews(componentBinding, hostRenderPv, [componentBinding], []);
	                    return _this._compileNestedProtoViews(protoViews, componentType, new collection_1.Map());
	                })
	                    .then(function (appProtoView) {
	                    _this._compilerCache.setHost(componentType, appProtoView);
	                    return appProtoView;
	                });
	        }
	        return hostPvPromise.then(function (hostAppProtoView) {
	            profile_1.wtfEndTimeRange(r);
	            return hostAppProtoView.ref;
	        });
	    };
	    Compiler.prototype._compile = function (componentBinding, componentPath) {
	        var _this = this;
	        var component = componentBinding.key.token;
	        var protoView = this._compilerCache.get(component);
	        if (lang_1.isPresent(protoView)) {
	            // The component has already been compiled into an AppProtoView,
	            // returns a plain AppProtoView, not wrapped inside of a Promise, for performance reasons.
	            return protoView;
	        }
	        var resultPromise = this._compiling.get(component);
	        if (lang_1.isPresent(resultPromise)) {
	            // The component is already being compiled, attach to the existing Promise
	            // instead of re-compiling the component.
	            // It happens when a template references a component multiple times.
	            return resultPromise;
	        }
	        var view = this._viewResolver.resolve(component);
	        var directives = this._flattenDirectives(view);
	        for (var i = 0; i < directives.length; i++) {
	            if (!Compiler._isValidDirective(directives[i])) {
	                throw new exceptions_1.BaseException("Unexpected directive value '" + lang_1.stringify(directives[i]) + "' on the View of component '" + lang_1.stringify(component) + "'");
	            }
	        }
	        var boundDirectives = this._removeDuplicatedDirectives(directives.map(function (directive) { return _this._bindDirective(directive); }));
	        var pipes = this._flattenPipes(view);
	        var boundPipes = pipes.map(function (pipe) { return _this._bindPipe(pipe); });
	        var renderTemplate = this._buildRenderTemplate(component, view, boundDirectives);
	        resultPromise =
	            this._render.compile(renderTemplate)
	                .then(function (renderPv) {
	                var protoViews = _this._protoViewFactory.createAppProtoViews(componentBinding, renderPv, boundDirectives, boundPipes);
	                return _this._compileNestedProtoViews(protoViews, component, componentPath);
	            })
	                .then(function (appProtoView) {
	                _this._compilerCache.set(component, appProtoView);
	                collection_1.MapWrapper.delete(_this._compiling, component);
	                return appProtoView;
	            });
	        this._compiling.set(component, resultPromise);
	        return resultPromise;
	    };
	    Compiler.prototype._removeDuplicatedDirectives = function (directives) {
	        var directivesMap = new collection_1.Map();
	        directives.forEach(function (dirBinding) { directivesMap.set(dirBinding.key.id, dirBinding); });
	        return collection_1.MapWrapper.values(directivesMap);
	    };
	    Compiler.prototype._compileNestedProtoViews = function (appProtoViews, componentType, componentPath) {
	        var _this = this;
	        var nestedPVPromises = [];
	        componentPath = collection_1.MapWrapper.clone(componentPath);
	        if (appProtoViews[0].type === api_1.ViewType.COMPONENT) {
	            componentPath.set(componentType, appProtoViews[0]);
	        }
	        appProtoViews.forEach(function (appProtoView) {
	            _this._collectComponentElementBinders(appProtoView)
	                .forEach(function (elementBinder) {
	                var nestedComponent = elementBinder.componentDirective;
	                var nestedComponentType = nestedComponent.key.token;
	                var elementBinderDone = function (nestedPv) { elementBinder.nestedProtoView = nestedPv; };
	                if (componentPath.has(nestedComponentType)) {
	                    // cycle...
	                    if (appProtoView.isEmbeddedFragment) {
	                        throw new exceptions_1.BaseException("<ng-content> is used within the recursive path of " + lang_1.stringify(nestedComponentType));
	                    }
	                    else if (appProtoView.type === api_1.ViewType.COMPONENT) {
	                        throw new exceptions_1.BaseException("Unconditional component cycle in " + lang_1.stringify(nestedComponentType));
	                    }
	                    else {
	                        elementBinderDone(componentPath.get(nestedComponentType));
	                    }
	                }
	                else {
	                    var nestedCall = _this._compile(nestedComponent, componentPath);
	                    if (lang_1.isPromise(nestedCall)) {
	                        nestedPVPromises.push(nestedCall.then(elementBinderDone));
	                    }
	                    else {
	                        elementBinderDone(nestedCall);
	                    }
	                }
	            });
	        });
	        return async_1.PromiseWrapper.all(nestedPVPromises)
	            .then(function (_) { return async_1.PromiseWrapper.all(appProtoViews.map(function (appProtoView) { return _this._mergeProtoView(appProtoView); })); })
	            .then(function (_) { return appProtoViews[0]; });
	    };
	    Compiler.prototype._mergeProtoView = function (appProtoView) {
	        if (appProtoView.type !== api_1.ViewType.HOST && appProtoView.type !== api_1.ViewType.EMBEDDED) {
	            return null;
	        }
	        return this._render.mergeProtoViewsRecursively(this._collectMergeRenderProtoViews(appProtoView))
	            .then(function (mergeResult) {
	            appProtoView.mergeMapping = new view_1.AppProtoViewMergeMapping(mergeResult);
	        });
	    };
	    Compiler.prototype._collectMergeRenderProtoViews = function (appProtoView) {
	        var result = [appProtoView.render];
	        for (var i = 0; i < appProtoView.elementBinders.length; i++) {
	            var binder = appProtoView.elementBinders[i];
	            if (lang_1.isPresent(binder.nestedProtoView)) {
	                if (binder.hasStaticComponent() ||
	                    (binder.hasEmbeddedProtoView() && binder.nestedProtoView.isEmbeddedFragment)) {
	                    result.push(this._collectMergeRenderProtoViews(binder.nestedProtoView));
	                }
	                else {
	                    result.push(null);
	                }
	            }
	        }
	        return result;
	    };
	    Compiler.prototype._collectComponentElementBinders = function (appProtoView) {
	        var componentElementBinders = [];
	        appProtoView.elementBinders.forEach(function (elementBinder) {
	            if (lang_1.isPresent(elementBinder.componentDirective)) {
	                componentElementBinders.push(elementBinder);
	            }
	        });
	        return componentElementBinders;
	    };
	    Compiler.prototype._buildRenderTemplate = function (component, view, directives) {
	        var _this = this;
	        var componentUrl = this._urlResolver.resolve(this._appUrl, this._componentUrlMapper.getUrl(component));
	        var templateAbsUrl = null;
	        var styleAbsUrls = null;
	        if (lang_1.isPresent(view.templateUrl) && view.templateUrl.trim().length > 0) {
	            templateAbsUrl = this._urlResolver.resolve(componentUrl, view.templateUrl);
	        }
	        else if (lang_1.isPresent(view.template)) {
	            // Note: If we have an inline template, we also need to send
	            // the url for the component to the render so that it
	            // is able to resolve urls in stylesheets.
	            templateAbsUrl = componentUrl;
	        }
	        if (lang_1.isPresent(view.styleUrls)) {
	            styleAbsUrls =
	                collection_1.ListWrapper.map(view.styleUrls, function (url) { return _this._urlResolver.resolve(componentUrl, url); });
	        }
	        return new api_1.ViewDefinition({
	            componentId: lang_1.stringify(component),
	            templateAbsUrl: templateAbsUrl, template: view.template,
	            styleAbsUrls: styleAbsUrls,
	            styles: view.styles,
	            directives: collection_1.ListWrapper.map(directives, function (directiveBinding) { return directiveBinding.metadata; }),
	            encapsulation: view.encapsulation
	        });
	    };
	    Compiler.prototype._flattenPipes = function (view) {
	        if (lang_1.isBlank(view.pipes))
	            return this._defaultPipes;
	        var pipes = collection_1.ListWrapper.clone(this._defaultPipes);
	        this._flattenList(view.pipes, pipes);
	        return pipes;
	    };
	    Compiler.prototype._flattenDirectives = function (view) {
	        if (lang_1.isBlank(view.directives))
	            return [];
	        var directives = [];
	        this._flattenList(view.directives, directives);
	        return directives;
	    };
	    Compiler.prototype._flattenList = function (tree, out) {
	        for (var i = 0; i < tree.length; i++) {
	            var item = di_1.resolveForwardRef(tree[i]);
	            if (lang_1.isArray(item)) {
	                this._flattenList(item, out);
	            }
	            else {
	                out.push(item);
	            }
	        }
	    };
	    Compiler._isValidDirective = function (value) {
	        return lang_1.isPresent(value) && (value instanceof lang_1.Type || value instanceof di_1.Binding);
	    };
	    Compiler._assertTypeIsComponent = function (directiveBinding) {
	        if (directiveBinding.metadata.type !== api_1.RenderDirectiveMetadata.COMPONENT_TYPE) {
	            throw new exceptions_1.BaseException("Could not load '" + lang_1.stringify(directiveBinding.key.token) + "' because it is not a component.");
	        }
	    };
	    Compiler = __decorate([
	        di_1.Injectable(),
	        __param(2, di_1.Inject(pipes_1.DEFAULT_PIPES_TOKEN)), 
	        __metadata('design:paramtypes', [directive_resolver_1.DirectiveResolver, pipe_resolver_1.PipeResolver, Array, CompilerCache, view_resolver_1.ViewResolver, component_url_mapper_1.ComponentUrlMapper, url_resolver_1.UrlResolver, api_1.RenderCompiler, proto_view_factory_1.ProtoViewFactory, app_root_url_1.AppRootUrl])
	    ], Compiler);
	    return Compiler;
	})();
	exports.Compiler = Compiler;
	//# sourceMappingURL=compiler.js.map

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var collection_1 = __webpack_require__(166);
	var change_detection_1 = __webpack_require__(179);
	var interfaces_1 = __webpack_require__(207);
	var element_binder_1 = __webpack_require__(383);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var view_ref_1 = __webpack_require__(384);
	var util_1 = __webpack_require__(385);
	var interfaces_2 = __webpack_require__(207);
	exports.DebugContext = interfaces_2.DebugContext;
	var REFLECT_PREFIX = 'ng-reflect-';
	var AppProtoViewMergeMapping = (function () {
	    function AppProtoViewMergeMapping(renderProtoViewMergeMapping) {
	        this.renderProtoViewRef = renderProtoViewMergeMapping.mergedProtoViewRef;
	        this.renderFragmentCount = renderProtoViewMergeMapping.fragmentCount;
	        this.renderElementIndices = renderProtoViewMergeMapping.mappedElementIndices;
	        this.renderInverseElementIndices = inverseIndexMapping(this.renderElementIndices, renderProtoViewMergeMapping.mappedElementCount);
	        this.renderTextIndices = renderProtoViewMergeMapping.mappedTextIndices;
	        this.hostElementIndicesByViewIndex = renderProtoViewMergeMapping.hostElementIndicesByViewIndex;
	        this.nestedViewIndicesByElementIndex =
	            inverseIndexMapping(this.hostElementIndicesByViewIndex, this.renderElementIndices.length);
	        this.nestedViewCountByViewIndex = renderProtoViewMergeMapping.nestedViewCountByViewIndex;
	    }
	    return AppProtoViewMergeMapping;
	})();
	exports.AppProtoViewMergeMapping = AppProtoViewMergeMapping;
	function inverseIndexMapping(input, resultLength) {
	    var result = collection_1.ListWrapper.createGrowableSize(resultLength);
	    for (var i = 0; i < input.length; i++) {
	        var value = input[i];
	        if (lang_1.isPresent(value)) {
	            result[input[i]] = i;
	        }
	    }
	    return result;
	}
	var AppViewContainer = (function () {
	    function AppViewContainer() {
	        // The order in this list matches the DOM order.
	        this.views = [];
	    }
	    return AppViewContainer;
	})();
	exports.AppViewContainer = AppViewContainer;
	/**
	 * Cost of making objects: http://jsperf.com/instantiate-size-of-object
	 *
	 */
	var AppView = (function () {
	    function AppView(renderer, proto, mainMergeMapping, viewOffset, elementOffset, textOffset, protoLocals, render, renderFragment) {
	        this.renderer = renderer;
	        this.proto = proto;
	        this.mainMergeMapping = mainMergeMapping;
	        this.viewOffset = viewOffset;
	        this.elementOffset = elementOffset;
	        this.textOffset = textOffset;
	        this.render = render;
	        this.renderFragment = renderFragment;
	        // AppViews that have been merged in depth first order.
	        // This list is shared between all merged views. Use this.elementOffset to get the local
	        // entries.
	        this.views = null;
	        // ElementInjectors of all AppViews in views grouped by view.
	        // This list is shared between all merged views. Use this.elementOffset to get the local
	        // entries.
	        this.elementInjectors = null;
	        // ViewContainers of all AppViews in views grouped by view.
	        // This list is shared between all merged views. Use this.elementOffset to get the local
	        // entries.
	        this.viewContainers = null;
	        // PreBuiltObjects of all AppViews in views grouped by view.
	        // This list is shared between all merged views. Use this.elementOffset to get the local
	        // entries.
	        this.preBuiltObjects = null;
	        this.changeDetector = null;
	        /**
	         * The context against which data-binding expressions in this view are evaluated against.
	         * This is always a component instance.
	         */
	        this.context = null;
	        this.ref = new view_ref_1.ViewRef(this);
	        this.locals = new change_detection_1.Locals(null, collection_1.MapWrapper.clone(protoLocals)); // TODO optimize this
	    }
	    AppView.prototype.init = function (changeDetector, elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers) {
	        this.changeDetector = changeDetector;
	        this.elementInjectors = elementInjectors;
	        this.rootElementInjectors = rootElementInjectors;
	        this.preBuiltObjects = preBuiltObjects;
	        this.views = views;
	        this.elementRefs = elementRefs;
	        this.viewContainers = viewContainers;
	    };
	    AppView.prototype.setLocal = function (contextName, value) {
	        if (!this.hydrated())
	            throw new exceptions_1.BaseException('Cannot set locals on dehydrated view.');
	        if (!this.proto.variableBindings.has(contextName)) {
	            return;
	        }
	        var templateName = this.proto.variableBindings.get(contextName);
	        this.locals.set(templateName, value);
	    };
	    AppView.prototype.hydrated = function () { return lang_1.isPresent(this.context); };
	    /**
	     * Triggers the event handlers for the element and the directives.
	     *
	     * This method is intended to be called from directive EventEmitters.
	     *
	     * @param {string} eventName
	     * @param {*} eventObj
	     * @param {number} boundElementIndex
	     */
	    AppView.prototype.triggerEventHandlers = function (eventName, eventObj, boundElementIndex) {
	        var locals = new collection_1.Map();
	        locals.set('$event', eventObj);
	        this.dispatchEvent(boundElementIndex, eventName, locals);
	    };
	    // dispatch to element injector or text nodes based on context
	    AppView.prototype.notifyOnBinding = function (b, currentValue) {
	        if (b.isTextNode()) {
	            this.renderer.setText(this.render, this.mainMergeMapping.renderTextIndices[b.elementIndex + this.textOffset], currentValue);
	        }
	        else {
	            var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
	            if (b.isElementProperty()) {
	                this.renderer.setElementProperty(elementRef, b.name, currentValue);
	            }
	            else if (b.isElementAttribute()) {
	                this.renderer.setElementAttribute(elementRef, b.name, "" + currentValue);
	            }
	            else if (b.isElementClass()) {
	                this.renderer.setElementClass(elementRef, b.name, currentValue);
	            }
	            else if (b.isElementStyle()) {
	                var unit = lang_1.isPresent(b.unit) ? b.unit : '';
	                this.renderer.setElementStyle(elementRef, b.name, "" + currentValue + unit);
	            }
	            else {
	                throw new exceptions_1.BaseException('Unsupported directive record');
	            }
	        }
	    };
	    AppView.prototype.logBindingUpdate = function (b, value) {
	        if (b.isDirective() || b.isElementProperty()) {
	            var elementRef = this.elementRefs[this.elementOffset + b.elementIndex];
	            this.renderer.setElementAttribute(elementRef, "" + REFLECT_PREFIX + util_1.camelCaseToDashCase(b.name), "" + value);
	        }
	    };
	    AppView.prototype.notifyAfterContentChecked = function () {
	        var eiCount = this.proto.elementBinders.length;
	        var ei = this.elementInjectors;
	        for (var i = eiCount - 1; i >= 0; i--) {
	            if (lang_1.isPresent(ei[i + this.elementOffset]))
	                ei[i + this.elementOffset].afterContentChecked();
	        }
	    };
	    AppView.prototype.notifyAfterViewChecked = function () {
	        var eiCount = this.proto.elementBinders.length;
	        var ei = this.elementInjectors;
	        for (var i = eiCount - 1; i >= 0; i--) {
	            if (lang_1.isPresent(ei[i + this.elementOffset]))
	                ei[i + this.elementOffset].afterViewChecked();
	        }
	    };
	    AppView.prototype.getDirectiveFor = function (directive) {
	        var elementInjector = this.elementInjectors[this.elementOffset + directive.elementIndex];
	        return elementInjector.getDirectiveAtIndex(directive.directiveIndex);
	    };
	    AppView.prototype.getNestedView = function (boundElementIndex) {
	        var viewIndex = this.mainMergeMapping.nestedViewIndicesByElementIndex[boundElementIndex];
	        return lang_1.isPresent(viewIndex) ? this.views[viewIndex] : null;
	    };
	    AppView.prototype.getHostElement = function () {
	        var boundElementIndex = this.mainMergeMapping.hostElementIndicesByViewIndex[this.viewOffset];
	        return lang_1.isPresent(boundElementIndex) ? this.elementRefs[boundElementIndex] : null;
	    };
	    AppView.prototype.getDebugContext = function (elementIndex, directiveIndex) {
	        try {
	            var offsettedIndex = this.elementOffset + elementIndex;
	            var hasRefForIndex = offsettedIndex < this.elementRefs.length;
	            var elementRef = hasRefForIndex ? this.elementRefs[this.elementOffset + elementIndex] : null;
	            var host = this.getHostElement();
	            var ei = hasRefForIndex ? this.elementInjectors[this.elementOffset + elementIndex] : null;
	            var element = lang_1.isPresent(elementRef) ? elementRef.nativeElement : null;
	            var componentElement = lang_1.isPresent(host) ? host.nativeElement : null;
	            var directive = lang_1.isPresent(directiveIndex) ? this.getDirectiveFor(directiveIndex) : null;
	            var injector = lang_1.isPresent(ei) ? ei.getInjector() : null;
	            return new interfaces_1.DebugContext(element, componentElement, directive, this.context, _localsToStringMap(this.locals), injector);
	        }
	        catch (e) {
	            // TODO: vsavkin log the exception once we have a good way to log errors and warnings
	            // if an error happens during getting the debug context, we return an empty map.
	            return null;
	        }
	    };
	    AppView.prototype.getDetectorFor = function (directive) {
	        var childView = this.getNestedView(this.elementOffset + directive.elementIndex);
	        return lang_1.isPresent(childView) ? childView.changeDetector : null;
	    };
	    AppView.prototype.invokeElementMethod = function (elementIndex, methodName, args) {
	        this.renderer.invokeElementMethod(this.elementRefs[elementIndex], methodName, args);
	    };
	    // implementation of RenderEventDispatcher#dispatchRenderEvent
	    AppView.prototype.dispatchRenderEvent = function (renderElementIndex, eventName, locals) {
	        var elementRef = this.elementRefs[this.mainMergeMapping.renderInverseElementIndices[renderElementIndex]];
	        var view = view_ref_1.internalView(elementRef.parentView);
	        return view.dispatchEvent(elementRef.boundElementIndex, eventName, locals);
	    };
	    // returns false if preventDefault must be applied to the DOM event
	    AppView.prototype.dispatchEvent = function (boundElementIndex, eventName, locals) {
	        try {
	            if (this.hydrated()) {
	                return !this.changeDetector.handleEvent(eventName, boundElementIndex - this.elementOffset, new change_detection_1.Locals(this.locals, locals));
	            }
	            else {
	                return true;
	            }
	        }
	        catch (e) {
	            var c = this.getDebugContext(boundElementIndex - this.elementOffset, null);
	            var context = lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.context, c.locals, c.injector) :
	                null;
	            throw new EventEvaluationError(eventName, e, e.stack, context);
	        }
	    };
	    Object.defineProperty(AppView.prototype, "ownBindersCount", {
	        get: function () { return this.proto.elementBinders.length; },
	        enumerable: true,
	        configurable: true
	    });
	    return AppView;
	})();
	exports.AppView = AppView;
	function _localsToStringMap(locals) {
	    var res = {};
	    var c = locals;
	    while (lang_1.isPresent(c)) {
	        res = collection_1.StringMapWrapper.merge(res, collection_1.MapWrapper.toStringMap(c.current));
	        c = c.parent;
	    }
	    return res;
	}
	/**
	 * Error context included when an event handler throws an exception.
	 */
	var _Context = (function () {
	    function _Context(element, componentElement, context, locals, injector) {
	        this.element = element;
	        this.componentElement = componentElement;
	        this.context = context;
	        this.locals = locals;
	        this.injector = injector;
	    }
	    return _Context;
	})();
	/**
	 * Wraps an exception thrown by an event handler.
	 */
	var EventEvaluationError = (function (_super) {
	    __extends(EventEvaluationError, _super);
	    function EventEvaluationError(eventName, originalException, originalStack, context) {
	        _super.call(this, "Error during evaluation of \"" + eventName + "\"", originalException, originalStack, context);
	    }
	    return EventEvaluationError;
	})(exceptions_1.WrappedException);
	/**
	 *
	 */
	var AppProtoView = (function () {
	    function AppProtoView(type, isEmbeddedFragment, render, protoChangeDetector, variableBindings, variableLocations, textBindingCount, pipes) {
	        var _this = this;
	        this.type = type;
	        this.isEmbeddedFragment = isEmbeddedFragment;
	        this.render = render;
	        this.protoChangeDetector = protoChangeDetector;
	        this.variableBindings = variableBindings;
	        this.variableLocations = variableLocations;
	        this.textBindingCount = textBindingCount;
	        this.pipes = pipes;
	        this.elementBinders = [];
	        this.protoLocals = new collection_1.Map();
	        this.ref = new view_ref_1.ProtoViewRef(this);
	        if (lang_1.isPresent(variableBindings)) {
	            collection_1.MapWrapper.forEach(variableBindings, function (templateName, _) { _this.protoLocals.set(templateName, null); });
	        }
	    }
	    AppProtoView.prototype.bindElement = function (parent, distanceToParent, protoElementInjector, componentDirective) {
	        if (componentDirective === void 0) { componentDirective = null; }
	        var elBinder = new element_binder_1.ElementBinder(this.elementBinders.length, parent, distanceToParent, protoElementInjector, componentDirective);
	        this.elementBinders.push(elBinder);
	        return elBinder;
	    };
	    return AppProtoView;
	})();
	exports.AppProtoView = AppProtoView;
	//# sourceMappingURL=view.js.map

/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var ElementBinder = (function () {
	    function ElementBinder(index, parent, distanceToParent, protoElementInjector, componentDirective) {
	        this.index = index;
	        this.parent = parent;
	        this.distanceToParent = distanceToParent;
	        this.protoElementInjector = protoElementInjector;
	        this.componentDirective = componentDirective;
	        // updated later, so we are able to resolve cycles
	        this.nestedProtoView = null;
	        if (lang_1.isBlank(index)) {
	            throw new exceptions_1.BaseException('null index not allowed.');
	        }
	    }
	    ElementBinder.prototype.hasStaticComponent = function () {
	        return lang_1.isPresent(this.componentDirective) && lang_1.isPresent(this.nestedProtoView);
	    };
	    ElementBinder.prototype.hasEmbeddedProtoView = function () {
	        return !lang_1.isPresent(this.componentDirective) && lang_1.isPresent(this.nestedProtoView);
	    };
	    return ElementBinder;
	})();
	exports.ElementBinder = ElementBinder;
	//# sourceMappingURL=element_binder.js.map

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	// This is a workaround for privacy in Dart as we don't have library parts
	function internalView(viewRef) {
	    return viewRef._view;
	}
	exports.internalView = internalView;
	// This is a workaround for privacy in Dart as we don't have library parts
	function internalProtoView(protoViewRef) {
	    return lang_1.isPresent(protoViewRef) ? protoViewRef._protoView : null;
	}
	exports.internalProtoView = internalProtoView;
	/**
	 * A reference to an Angular View.
	 *
	 * A View is a fundamental building block of Application UI. A View is the smallest set of
	 * elements which are created and destroyed together. A View can change properties on the elements
	 * within the view, but it can not change the structure of those elements.
	 *
	 * To change structure of the elements, the Views can contain zero or more {@link ViewContainerRef}s
	 * which allow the views to be nested.
	 *
	 * ## Example
	 *
	 * Given this template
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ng-for="var item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * The above example we have two {@link ProtoViewRef}s:
	 *
	 * Outter {@link ProtoViewRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <template ng-for var-item [ng-for-of]="items"></template>
	 * </ul>
	 * ```
	 *
	 * Inner {@link ProtoViewRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.
	 *
	 * The outter/inner {@link ProtoViewRef}s are then assembled into views like so:
	 *
	 * ```
	 * <!-- ViewRef: outer-0 -->
	 * Count: 2
	 * <ul>
	 *   <template view-container-ref></template>
	 *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
	 *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
	 * </ul>
	 * <!-- /ViewRef: outer-0 -->
	 * ```
	 */
	var ViewRef = (function () {
	    /**
	     * @private
	     */
	    function ViewRef(_view) {
	        this._view = _view;
	    }
	    Object.defineProperty(ViewRef.prototype, "render", {
	        /**
	         * Return `RenderViewRef`
	         */
	        get: function () { return this._view.render; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ViewRef.prototype, "renderFragment", {
	        /**
	         * Return `RenderFragmentRef`
	         */
	        get: function () { return this._view.renderFragment; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Set local variable in a view.
	     *
	     * - `contextName` - Name of the local variable in a view.
	     * - `value` - Value for the local variable in a view.
	     */
	    ViewRef.prototype.setLocal = function (contextName, value) { this._view.setLocal(contextName, value); };
	    return ViewRef;
	})();
	exports.ViewRef = ViewRef;
	/**
	 * A reference to an Angular ProtoView.
	 *
	 * A ProtoView is a reference to a template for easy creation of views.
	 * (See {@link AppViewManager#createViewInContainer `AppViewManager#createViewInContainer`} and
	 * {@link AppViewManager#createRootHostView `AppViewManager#createRootHostView`}).
	 *
	 * A `ProtoView` is a factory for creating `View`s.
	 *
	 * ## Example
	 *
	 * Given this template
	 *
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <li *ng-for="var item of items">{{item}}</li>
	 * </ul>
	 * ```
	 *
	 * The above example we have two {@link ProtoViewRef}s:
	 *
	 * Outter {@link ProtoViewRef}:
	 * ```
	 * Count: {{items.length}}
	 * <ul>
	 *   <template ng-for var-item [ng-for-of]="items"></template>
	 * </ul>
	 * ```
	 *
	 * Inner {@link ProtoViewRef}:
	 * ```
	 *   <li>{{item}}</li>
	 * ```
	 *
	 * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.
	 */
	var ProtoViewRef = (function () {
	    /**
	     * @private
	     */
	    function ProtoViewRef(_protoView) {
	        this._protoView = _protoView;
	    }
	    return ProtoViewRef;
	})();
	exports.ProtoViewRef = ProtoViewRef;
	//# sourceMappingURL=view_ref.js.map

/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var dom_adapter_1 = __webpack_require__(386);
	var collection_1 = __webpack_require__(166);
	exports.NG_BINDING_CLASS_SELECTOR = '.ng-binding';
	exports.NG_BINDING_CLASS = 'ng-binding';
	exports.NG_CONTENT_ELEMENT_NAME = 'ng-content';
	exports.NG_SHADOW_ROOT_ELEMENT_NAME = 'shadow-root';
	var MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = 20;
	var CAMEL_CASE_REGEXP = /([A-Z])/g;
	var DASH_CASE_REGEXP = /-([a-z])/g;
	function camelCaseToDashCase(input) {
	    return lang_1.StringWrapper.replaceAllMapped(input, CAMEL_CASE_REGEXP, function (m) { return '-' + m[1].toLowerCase(); });
	}
	exports.camelCaseToDashCase = camelCaseToDashCase;
	function dashCaseToCamelCase(input) {
	    return lang_1.StringWrapper.replaceAllMapped(input, DASH_CASE_REGEXP, function (m) { return m[1].toUpperCase(); });
	}
	exports.dashCaseToCamelCase = dashCaseToCamelCase;
	// Attention: This is on the hot path, so don't use closures or default values!
	function queryBoundElements(templateContent, isSingleElementChild) {
	    var result;
	    var dynamicElementList;
	    var elementIdx = 0;
	    if (isSingleElementChild) {
	        var rootElement = dom_adapter_1.DOM.firstChild(templateContent);
	        var rootHasBinding = dom_adapter_1.DOM.hasClass(rootElement, exports.NG_BINDING_CLASS);
	        dynamicElementList = dom_adapter_1.DOM.getElementsByClassName(rootElement, exports.NG_BINDING_CLASS);
	        result = collection_1.ListWrapper.createFixedSize(dynamicElementList.length + (rootHasBinding ? 1 : 0));
	        if (rootHasBinding) {
	            result[elementIdx++] = rootElement;
	        }
	    }
	    else {
	        dynamicElementList = dom_adapter_1.DOM.querySelectorAll(templateContent, exports.NG_BINDING_CLASS_SELECTOR);
	        result = collection_1.ListWrapper.createFixedSize(dynamicElementList.length);
	    }
	    for (var i = 0; i < dynamicElementList.length; i++) {
	        result[elementIdx++] = dynamicElementList[i];
	    }
	    return result;
	}
	exports.queryBoundElements = queryBoundElements;
	var ClonedProtoView = (function () {
	    function ClonedProtoView(original, fragments, boundElements, boundTextNodes) {
	        this.original = original;
	        this.fragments = fragments;
	        this.boundElements = boundElements;
	        this.boundTextNodes = boundTextNodes;
	    }
	    return ClonedProtoView;
	})();
	exports.ClonedProtoView = ClonedProtoView;
	function cloneAndQueryProtoView(templateCloner, pv, importIntoDocument) {
	    var templateContent = templateCloner.cloneContent(pv.cloneableTemplate, importIntoDocument);
	    var boundElements = queryBoundElements(templateContent, pv.isSingleElementFragment);
	    var boundTextNodes = queryBoundTextNodes(templateContent, pv.rootTextNodeIndices, boundElements, pv.elementBinders, pv.boundTextNodeCount);
	    var fragments = queryFragments(templateContent, pv.fragmentsRootNodeCount);
	    return new ClonedProtoView(pv, fragments, boundElements, boundTextNodes);
	}
	exports.cloneAndQueryProtoView = cloneAndQueryProtoView;
	function queryFragments(templateContent, fragmentsRootNodeCount) {
	    var fragments = collection_1.ListWrapper.createGrowableSize(fragmentsRootNodeCount.length);
	    // Note: An explicit loop is the fastest way to convert a DOM array into a JS array!
	    var childNode = dom_adapter_1.DOM.firstChild(templateContent);
	    for (var fragmentIndex = 0; fragmentIndex < fragments.length; fragmentIndex++) {
	        var fragment = collection_1.ListWrapper.createFixedSize(fragmentsRootNodeCount[fragmentIndex]);
	        fragments[fragmentIndex] = fragment;
	        // Note: the 2nd, 3rd, ... fragments are separated by each other via a '|'
	        if (fragmentIndex >= 1) {
	            childNode = dom_adapter_1.DOM.nextSibling(childNode);
	        }
	        for (var i = 0; i < fragment.length; i++) {
	            fragment[i] = childNode;
	            childNode = dom_adapter_1.DOM.nextSibling(childNode);
	        }
	    }
	    return fragments;
	}
	function queryBoundTextNodes(templateContent, rootTextNodeIndices, boundElements, elementBinders, boundTextNodeCount) {
	    var boundTextNodes = collection_1.ListWrapper.createFixedSize(boundTextNodeCount);
	    var textNodeIndex = 0;
	    if (rootTextNodeIndices.length > 0) {
	        var rootChildNodes = dom_adapter_1.DOM.childNodes(templateContent);
	        for (var i = 0; i < rootTextNodeIndices.length; i++) {
	            boundTextNodes[textNodeIndex++] = rootChildNodes[rootTextNodeIndices[i]];
	        }
	    }
	    for (var i = 0; i < elementBinders.length; i++) {
	        var binder = elementBinders[i];
	        var element = boundElements[i];
	        if (binder.textNodeIndices.length > 0) {
	            var childNodes = dom_adapter_1.DOM.childNodes(element);
	            for (var j = 0; j < binder.textNodeIndices.length; j++) {
	                boundTextNodes[textNodeIndex++] = childNodes[binder.textNodeIndices[j]];
	            }
	        }
	    }
	    return boundTextNodes;
	}
	function isElementWithTag(node, elementName) {
	    return dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.tagName(node).toLowerCase() == elementName.toLowerCase();
	}
	exports.isElementWithTag = isElementWithTag;
	function queryBoundTextNodeIndices(parentNode, boundTextNodes, resultCallback) {
	    var childNodes = dom_adapter_1.DOM.childNodes(parentNode);
	    for (var j = 0; j < childNodes.length; j++) {
	        var node = childNodes[j];
	        if (boundTextNodes.has(node)) {
	            resultCallback(node, j, boundTextNodes.get(node));
	        }
	    }
	}
	exports.queryBoundTextNodeIndices = queryBoundTextNodeIndices;
	function prependAll(parentNode, nodes) {
	    var lastInsertedNode = null;
	    nodes.forEach(function (node) {
	        if (lang_1.isBlank(lastInsertedNode)) {
	            var firstChild = dom_adapter_1.DOM.firstChild(parentNode);
	            if (lang_1.isPresent(firstChild)) {
	                dom_adapter_1.DOM.insertBefore(firstChild, node);
	            }
	            else {
	                dom_adapter_1.DOM.appendChild(parentNode, node);
	            }
	        }
	        else {
	            dom_adapter_1.DOM.insertAfter(lastInsertedNode, node);
	        }
	        lastInsertedNode = node;
	    });
	}
	exports.prependAll = prependAll;
	//# sourceMappingURL=util.js.map

/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	exports.DOM;
	function setRootDomAdapter(adapter) {
	    if (lang_1.isBlank(exports.DOM)) {
	        exports.DOM = adapter;
	    }
	}
	exports.setRootDomAdapter = setRootDomAdapter;
	function _abstract() {
	    return new exceptions_1.BaseException('This method is abstract');
	}
	/* tslint:disable:requireParameterType */
	/**
	 * Provides DOM operations in an environment-agnostic way.
	 */
	var DomAdapter = (function () {
	    function DomAdapter() {
	    }
	    DomAdapter.prototype.hasProperty = function (element, name) { throw _abstract(); };
	    DomAdapter.prototype.setProperty = function (el, name, value) { throw _abstract(); };
	    DomAdapter.prototype.getProperty = function (el, name) { throw _abstract(); };
	    DomAdapter.prototype.invoke = function (el, methodName, args) { throw _abstract(); };
	    DomAdapter.prototype.logError = function (error) { throw _abstract(); };
	    DomAdapter.prototype.log = function (error) { throw _abstract(); };
	    DomAdapter.prototype.logGroup = function (error) { throw _abstract(); };
	    DomAdapter.prototype.logGroupEnd = function () { throw _abstract(); };
	    Object.defineProperty(DomAdapter.prototype, "attrToPropMap", {
	        /**
	         * Maps attribute names to their corresponding property names for cases
	         * where attribute name doesn't match property name.
	         */
	        get: function () { throw _abstract(); },
	        enumerable: true,
	        configurable: true
	    });
	    DomAdapter.prototype.parse = function (templateHtml) { throw _abstract(); };
	    DomAdapter.prototype.query = function (selector) { throw _abstract(); };
	    DomAdapter.prototype.querySelector = function (el, selector) { throw _abstract(); };
	    DomAdapter.prototype.querySelectorAll = function (el, selector) { throw _abstract(); };
	    DomAdapter.prototype.on = function (el, evt, listener) { throw _abstract(); };
	    DomAdapter.prototype.onAndCancel = function (el, evt, listener) { throw _abstract(); };
	    DomAdapter.prototype.dispatchEvent = function (el, evt) { throw _abstract(); };
	    DomAdapter.prototype.createMouseEvent = function (eventType) { throw _abstract(); };
	    DomAdapter.prototype.createEvent = function (eventType) { throw _abstract(); };
	    DomAdapter.prototype.preventDefault = function (evt) { throw _abstract(); };
	    DomAdapter.prototype.isPrevented = function (evt) { throw _abstract(); };
	    DomAdapter.prototype.getInnerHTML = function (el) { throw _abstract(); };
	    DomAdapter.prototype.getOuterHTML = function (el) { throw _abstract(); };
	    DomAdapter.prototype.nodeName = function (node) { throw _abstract(); };
	    DomAdapter.prototype.nodeValue = function (node) { throw _abstract(); };
	    DomAdapter.prototype.type = function (node) { throw _abstract(); };
	    DomAdapter.prototype.content = function (node) { throw _abstract(); };
	    DomAdapter.prototype.firstChild = function (el) { throw _abstract(); };
	    DomAdapter.prototype.nextSibling = function (el) { throw _abstract(); };
	    DomAdapter.prototype.parentElement = function (el) { throw _abstract(); };
	    DomAdapter.prototype.childNodes = function (el) { throw _abstract(); };
	    DomAdapter.prototype.childNodesAsList = function (el) { throw _abstract(); };
	    DomAdapter.prototype.clearNodes = function (el) { throw _abstract(); };
	    DomAdapter.prototype.appendChild = function (el, node) { throw _abstract(); };
	    DomAdapter.prototype.removeChild = function (el, node) { throw _abstract(); };
	    DomAdapter.prototype.replaceChild = function (el, newNode, oldNode) { throw _abstract(); };
	    DomAdapter.prototype.remove = function (el) { throw _abstract(); };
	    DomAdapter.prototype.insertBefore = function (el, node) { throw _abstract(); };
	    DomAdapter.prototype.insertAllBefore = function (el, nodes) { throw _abstract(); };
	    DomAdapter.prototype.insertAfter = function (el, node) { throw _abstract(); };
	    DomAdapter.prototype.setInnerHTML = function (el, value) { throw _abstract(); };
	    DomAdapter.prototype.getText = function (el) { throw _abstract(); };
	    DomAdapter.prototype.setText = function (el, value) { throw _abstract(); };
	    DomAdapter.prototype.getValue = function (el) { throw _abstract(); };
	    DomAdapter.prototype.setValue = function (el, value) { throw _abstract(); };
	    DomAdapter.prototype.getChecked = function (el) { throw _abstract(); };
	    DomAdapter.prototype.setChecked = function (el, value) { throw _abstract(); };
	    DomAdapter.prototype.createComment = function (text) { throw _abstract(); };
	    DomAdapter.prototype.createTemplate = function (html) { throw _abstract(); };
	    DomAdapter.prototype.createElement = function (tagName, doc) {
	        if (doc === void 0) { doc = null; }
	        throw _abstract();
	    };
	    DomAdapter.prototype.createTextNode = function (text, doc) {
	        if (doc === void 0) { doc = null; }
	        throw _abstract();
	    };
	    DomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	        if (doc === void 0) { doc = null; }
	        throw _abstract();
	    };
	    DomAdapter.prototype.createStyleElement = function (css, doc) {
	        if (doc === void 0) { doc = null; }
	        throw _abstract();
	    };
	    DomAdapter.prototype.createShadowRoot = function (el) { throw _abstract(); };
	    DomAdapter.prototype.getShadowRoot = function (el) { throw _abstract(); };
	    DomAdapter.prototype.getHost = function (el) { throw _abstract(); };
	    DomAdapter.prototype.getDistributedNodes = function (el) { throw _abstract(); };
	    DomAdapter.prototype.clone /*<T extends Node>*/ = function (node /*T*/) { throw _abstract(); };
	    DomAdapter.prototype.getElementsByClassName = function (element, name) { throw _abstract(); };
	    DomAdapter.prototype.getElementsByTagName = function (element, name) { throw _abstract(); };
	    DomAdapter.prototype.classList = function (element) { throw _abstract(); };
	    DomAdapter.prototype.addClass = function (element, classname) { throw _abstract(); };
	    DomAdapter.prototype.removeClass = function (element, classname) { throw _abstract(); };
	    DomAdapter.prototype.hasClass = function (element, classname) { throw _abstract(); };
	    DomAdapter.prototype.setStyle = function (element, stylename, stylevalue) { throw _abstract(); };
	    DomAdapter.prototype.removeStyle = function (element, stylename) { throw _abstract(); };
	    DomAdapter.prototype.getStyle = function (element, stylename) { throw _abstract(); };
	    DomAdapter.prototype.tagName = function (element) { throw _abstract(); };
	    DomAdapter.prototype.attributeMap = function (element) { throw _abstract(); };
	    DomAdapter.prototype.hasAttribute = function (element, attribute) { throw _abstract(); };
	    DomAdapter.prototype.getAttribute = function (element, attribute) { throw _abstract(); };
	    DomAdapter.prototype.setAttribute = function (element, name, value) { throw _abstract(); };
	    DomAdapter.prototype.removeAttribute = function (element, attribute) { throw _abstract(); };
	    DomAdapter.prototype.templateAwareRoot = function (el) { throw _abstract(); };
	    DomAdapter.prototype.createHtmlDocument = function () { throw _abstract(); };
	    DomAdapter.prototype.defaultDoc = function () { throw _abstract(); };
	    DomAdapter.prototype.getBoundingClientRect = function (el) { throw _abstract(); };
	    DomAdapter.prototype.getTitle = function () { throw _abstract(); };
	    DomAdapter.prototype.setTitle = function (newTitle) { throw _abstract(); };
	    DomAdapter.prototype.elementMatches = function (n, selector) { throw _abstract(); };
	    DomAdapter.prototype.isTemplateElement = function (el) { throw _abstract(); };
	    DomAdapter.prototype.isTextNode = function (node) { throw _abstract(); };
	    DomAdapter.prototype.isCommentNode = function (node) { throw _abstract(); };
	    DomAdapter.prototype.isElementNode = function (node) { throw _abstract(); };
	    DomAdapter.prototype.hasShadowRoot = function (node) { throw _abstract(); };
	    DomAdapter.prototype.isShadowRoot = function (node) { throw _abstract(); };
	    DomAdapter.prototype.importIntoDoc /*<T extends Node>*/ = function (node /*T*/) { throw _abstract(); };
	    DomAdapter.prototype.adoptNode /*<T extends Node>*/ = function (node /*T*/) { throw _abstract(); };
	    DomAdapter.prototype.isPageRule = function (rule) { throw _abstract(); };
	    DomAdapter.prototype.isStyleRule = function (rule) { throw _abstract(); };
	    DomAdapter.prototype.isMediaRule = function (rule) { throw _abstract(); };
	    DomAdapter.prototype.isKeyframesRule = function (rule) { throw _abstract(); };
	    DomAdapter.prototype.getHref = function (element) { throw _abstract(); };
	    DomAdapter.prototype.getEventKey = function (event) { throw _abstract(); };
	    DomAdapter.prototype.resolveAndSetHref = function (element, baseUrl, href) { throw _abstract(); };
	    DomAdapter.prototype.cssToRules = function (css) { throw _abstract(); };
	    DomAdapter.prototype.supportsDOMEvents = function () { throw _abstract(); };
	    DomAdapter.prototype.supportsNativeShadowDOM = function () { throw _abstract(); };
	    DomAdapter.prototype.getGlobalEventTarget = function (target) { throw _abstract(); };
	    DomAdapter.prototype.getHistory = function () { throw _abstract(); };
	    DomAdapter.prototype.getLocation = function () { throw _abstract(); };
	    DomAdapter.prototype.getBaseHref = function () { throw _abstract(); };
	    DomAdapter.prototype.resetBaseElement = function () { throw _abstract(); };
	    DomAdapter.prototype.getUserAgent = function () { throw _abstract(); };
	    DomAdapter.prototype.setData = function (element, name, value) { throw _abstract(); };
	    DomAdapter.prototype.getData = function (element, name) { throw _abstract(); };
	    DomAdapter.prototype.setGlobalVar = function (name, value) { throw _abstract(); };
	    return DomAdapter;
	})();
	exports.DomAdapter = DomAdapter;
	//# sourceMappingURL=dom_adapter.js.map

/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var async_1 = __webpack_require__(216);
	var collection_1 = __webpack_require__(166);
	var di_1 = __webpack_require__(160);
	var injector_1 = __webpack_require__(165);
	var binding_1 = __webpack_require__(167);
	var di_2 = __webpack_require__(158);
	var avmModule = __webpack_require__(388);
	var view_container_ref_1 = __webpack_require__(394);
	var element_ref_1 = __webpack_require__(390);
	var template_ref_1 = __webpack_require__(391);
	var directives_1 = __webpack_require__(177);
	var directive_lifecycle_reflector_1 = __webpack_require__(395);
	var change_detection_1 = __webpack_require__(179);
	var query_list_1 = __webpack_require__(396);
	var reflection_1 = __webpack_require__(170);
	var api_1 = __webpack_require__(212);
	var event_config_1 = __webpack_require__(397);
	var pipe_binding_1 = __webpack_require__(356);
	var LifecycleHooks = __webpack_require__(378);
	var _staticKeys;
	var StaticKeys = (function () {
	    function StaticKeys() {
	        this.viewManagerId = di_1.Key.get(avmModule.AppViewManager).id;
	        this.templateRefId = di_1.Key.get(template_ref_1.TemplateRef).id;
	        this.viewContainerId = di_1.Key.get(view_container_ref_1.ViewContainerRef).id;
	        this.changeDetectorRefId = di_1.Key.get(change_detection_1.ChangeDetectorRef).id;
	        this.elementRefId = di_1.Key.get(element_ref_1.ElementRef).id;
	    }
	    StaticKeys.instance = function () {
	        if (lang_1.isBlank(_staticKeys))
	            _staticKeys = new StaticKeys();
	        return _staticKeys;
	    };
	    return StaticKeys;
	})();
	exports.StaticKeys = StaticKeys;
	var TreeNode = (function () {
	    function TreeNode(parent) {
	        if (lang_1.isPresent(parent)) {
	            parent.addChild(this);
	        }
	        else {
	            this._parent = null;
	        }
	    }
	    TreeNode.prototype.addChild = function (child) { child._parent = this; };
	    TreeNode.prototype.remove = function () { this._parent = null; };
	    Object.defineProperty(TreeNode.prototype, "parent", {
	        get: function () { return this._parent; },
	        enumerable: true,
	        configurable: true
	    });
	    return TreeNode;
	})();
	exports.TreeNode = TreeNode;
	var DirectiveDependency = (function (_super) {
	    __extends(DirectiveDependency, _super);
	    function DirectiveDependency(key, optional, lowerBoundVisibility, upperBoundVisibility, properties, attributeName, queryDecorator) {
	        _super.call(this, key, optional, lowerBoundVisibility, upperBoundVisibility, properties);
	        this.attributeName = attributeName;
	        this.queryDecorator = queryDecorator;
	        this._verify();
	    }
	    DirectiveDependency.prototype._verify = function () {
	        var count = 0;
	        if (lang_1.isPresent(this.queryDecorator))
	            count++;
	        if (lang_1.isPresent(this.attributeName))
	            count++;
	        if (count > 1)
	            throw new exceptions_1.BaseException('A directive injectable can contain only one of the following @Attribute or @Query.');
	    };
	    DirectiveDependency.createFrom = function (d) {
	        return new DirectiveDependency(d.key, d.optional, d.lowerBoundVisibility, d.upperBoundVisibility, d.properties, DirectiveDependency._attributeName(d.properties), DirectiveDependency._query(d.properties));
	    };
	    DirectiveDependency._attributeName = function (properties) {
	        var p = collection_1.ListWrapper.find(properties, function (p) { return p instanceof di_2.AttributeMetadata; });
	        return lang_1.isPresent(p) ? p.attributeName : null;
	    };
	    DirectiveDependency._query = function (properties) {
	        return collection_1.ListWrapper.find(properties, function (p) { return p instanceof di_2.QueryMetadata; });
	    };
	    return DirectiveDependency;
	})(di_1.Dependency);
	exports.DirectiveDependency = DirectiveDependency;
	var DirectiveBinding = (function (_super) {
	    __extends(DirectiveBinding, _super);
	    function DirectiveBinding(key, factory, deps, metadata, bindings, viewBindings) {
	        _super.call(this, key, [new binding_1.ResolvedFactory(factory, deps)], false);
	        this.metadata = metadata;
	        this.bindings = bindings;
	        this.viewBindings = viewBindings;
	    }
	    Object.defineProperty(DirectiveBinding.prototype, "displayName", {
	        get: function () { return this.key.displayName; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveBinding.prototype, "callOnDestroy", {
	        get: function () { return this.metadata.callOnDestroy; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectiveBinding.prototype, "eventEmitters", {
	        get: function () {
	            return lang_1.isPresent(this.metadata) && lang_1.isPresent(this.metadata.events) ? this.metadata.events : [];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DirectiveBinding.createFromBinding = function (binding, meta) {
	        if (lang_1.isBlank(meta)) {
	            meta = new directives_1.DirectiveMetadata();
	        }
	        var rb = binding_1.resolveBinding(binding);
	        var rf = rb.resolvedFactories[0];
	        var deps = rf.dependencies.map(DirectiveDependency.createFrom);
	        var token = binding.token;
	        var metadata = api_1.RenderDirectiveMetadata.create({
	            id: lang_1.stringify(binding.token),
	            type: meta instanceof directives_1.ComponentMetadata ? api_1.RenderDirectiveMetadata.COMPONENT_TYPE :
	                api_1.RenderDirectiveMetadata.DIRECTIVE_TYPE,
	            selector: meta.selector,
	            compileChildren: meta.compileChildren,
	            events: meta.events,
	            host: lang_1.isPresent(meta.host) ? collection_1.MapWrapper.createFromStringMap(meta.host) : null,
	            properties: meta.properties,
	            readAttributes: DirectiveBinding._readAttributes(deps),
	            callOnDestroy: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.OnDestroy, token),
	            callOnChanges: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.OnChanges, token),
	            callDoCheck: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.DoCheck, token),
	            callOnInit: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.OnInit, token),
	            callAfterContentInit: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.AfterContentInit, token),
	            callAfterContentChecked: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.AfterContentChecked, token),
	            callAfterViewInit: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.AfterViewInit, token),
	            callAfterViewChecked: directive_lifecycle_reflector_1.hasLifecycleHook(LifecycleHooks.AfterViewChecked, token),
	            changeDetection: meta instanceof directives_1.ComponentMetadata ? meta.changeDetection : null,
	            exportAs: meta.exportAs
	        });
	        var bindings = lang_1.isPresent(meta.bindings) ? meta.bindings : [];
	        var viewBindigs = meta instanceof directives_1.ComponentMetadata && lang_1.isPresent(meta.viewBindings) ? meta.viewBindings : [];
	        return new DirectiveBinding(rb.key, rf.factory, deps, metadata, bindings, viewBindigs);
	    };
	    DirectiveBinding._readAttributes = function (deps) {
	        var readAttributes = [];
	        deps.forEach(function (dep) {
	            if (lang_1.isPresent(dep.attributeName)) {
	                readAttributes.push(dep.attributeName);
	            }
	        });
	        return readAttributes;
	    };
	    DirectiveBinding.createFromType = function (type, annotation) {
	        var binding = new di_1.Binding(type, { toClass: type });
	        return DirectiveBinding.createFromBinding(binding, annotation);
	    };
	    return DirectiveBinding;
	})(di_1.ResolvedBinding);
	exports.DirectiveBinding = DirectiveBinding;
	// TODO(rado): benchmark and consider rolling in as ElementInjector fields.
	var PreBuiltObjects = (function () {
	    function PreBuiltObjects(viewManager, view, elementRef, templateRef) {
	        this.viewManager = viewManager;
	        this.view = view;
	        this.elementRef = elementRef;
	        this.templateRef = templateRef;
	    }
	    return PreBuiltObjects;
	})();
	exports.PreBuiltObjects = PreBuiltObjects;
	var EventEmitterAccessor = (function () {
	    function EventEmitterAccessor(eventName, getter) {
	        this.eventName = eventName;
	        this.getter = getter;
	    }
	    EventEmitterAccessor.prototype.subscribe = function (view, boundElementIndex, directive) {
	        var _this = this;
	        var eventEmitter = this.getter(directive);
	        return async_1.ObservableWrapper.subscribe(eventEmitter, function (eventObj) { return view.triggerEventHandlers(_this.eventName, eventObj, boundElementIndex); });
	    };
	    return EventEmitterAccessor;
	})();
	exports.EventEmitterAccessor = EventEmitterAccessor;
	var HostActionAccessor = (function () {
	    function HostActionAccessor(methodName, getter) {
	        this.methodName = methodName;
	        this.getter = getter;
	    }
	    HostActionAccessor.prototype.subscribe = function (view, boundElementIndex, directive) {
	        var _this = this;
	        var eventEmitter = this.getter(directive);
	        return async_1.ObservableWrapper.subscribe(eventEmitter, function (actionArgs) { return view.invokeElementMethod(boundElementIndex, _this.methodName, actionArgs); });
	    };
	    return HostActionAccessor;
	})();
	exports.HostActionAccessor = HostActionAccessor;
	function _createEventEmitterAccessors(bwv) {
	    var binding = bwv.binding;
	    if (!(binding instanceof DirectiveBinding))
	        return [];
	    var db = binding;
	    return collection_1.ListWrapper.map(db.eventEmitters, function (eventConfig) {
	        var parsedEvent = event_config_1.EventConfig.parse(eventConfig);
	        return new EventEmitterAccessor(parsedEvent.eventName, reflection_1.reflector.getter(parsedEvent.fieldName));
	    });
	}
	var ProtoElementInjector = (function () {
	    function ProtoElementInjector(parent, index, bwv, distanceToParent, _firstBindingIsComponent, directiveVariableBindings) {
	        this.parent = parent;
	        this.index = index;
	        this.distanceToParent = distanceToParent;
	        this._firstBindingIsComponent = _firstBindingIsComponent;
	        this.directiveVariableBindings = directiveVariableBindings;
	        var length = bwv.length;
	        this.protoInjector = new di_1.ProtoInjector(bwv);
	        this.eventEmitterAccessors = collection_1.ListWrapper.createFixedSize(length);
	        for (var i = 0; i < length; ++i) {
	            this.eventEmitterAccessors[i] = _createEventEmitterAccessors(bwv[i]);
	        }
	    }
	    ProtoElementInjector.create = function (parent, index, bindings, firstBindingIsComponent, distanceToParent, directiveVariableBindings) {
	        var bd = [];
	        ProtoElementInjector._createDirectiveBindingWithVisibility(bindings, bd, firstBindingIsComponent);
	        if (firstBindingIsComponent) {
	            ProtoElementInjector._createViewBindingsWithVisibility(bindings, bd);
	        }
	        ProtoElementInjector._createBindingsWithVisibility(bindings, bd);
	        return new ProtoElementInjector(parent, index, bd, distanceToParent, firstBindingIsComponent, directiveVariableBindings);
	    };
	    ProtoElementInjector._createDirectiveBindingWithVisibility = function (dirBindings, bd, firstBindingIsComponent) {
	        dirBindings.forEach(function (dirBinding) {
	            bd.push(ProtoElementInjector._createBindingWithVisibility(firstBindingIsComponent, dirBinding, dirBindings, dirBinding));
	        });
	    };
	    ProtoElementInjector._createBindingsWithVisibility = function (dirBindings, bd) {
	        var bindingsFromAllDirectives = [];
	        dirBindings.forEach(function (dirBinding) {
	            bindingsFromAllDirectives =
	                collection_1.ListWrapper.concat(bindingsFromAllDirectives, dirBinding.bindings);
	        });
	        var resolved = di_1.Injector.resolve(bindingsFromAllDirectives);
	        resolved.forEach(function (b) { return bd.push(new injector_1.BindingWithVisibility(b, di_1.Visibility.Public)); });
	    };
	    ProtoElementInjector._createBindingWithVisibility = function (firstBindingIsComponent, dirBinding, dirBindings, binding) {
	        var isComponent = firstBindingIsComponent && dirBindings[0] === dirBinding;
	        return new injector_1.BindingWithVisibility(binding, isComponent ? di_1.Visibility.PublicAndPrivate : di_1.Visibility.Public);
	    };
	    ProtoElementInjector._createViewBindingsWithVisibility = function (dirBindings, bd) {
	        var resolvedViewBindings = di_1.Injector.resolve(dirBindings[0].viewBindings);
	        resolvedViewBindings.forEach(function (b) { return bd.push(new injector_1.BindingWithVisibility(b, di_1.Visibility.Private)); });
	    };
	    ProtoElementInjector.prototype.instantiate = function (parent) {
	        return new ElementInjector(this, parent);
	    };
	    ProtoElementInjector.prototype.directParent = function () { return this.distanceToParent < 2 ? this.parent : null; };
	    Object.defineProperty(ProtoElementInjector.prototype, "hasBindings", {
	        get: function () { return this.eventEmitterAccessors.length > 0; },
	        enumerable: true,
	        configurable: true
	    });
	    ProtoElementInjector.prototype.getBindingAtIndex = function (index) { return this.protoInjector.getBindingAtIndex(index); };
	    return ProtoElementInjector;
	})();
	exports.ProtoElementInjector = ProtoElementInjector;
	var _Context = (function () {
	    function _Context(element, componentElement, injector) {
	        this.element = element;
	        this.componentElement = componentElement;
	        this.injector = injector;
	    }
	    return _Context;
	})();
	var ElementInjector = (function (_super) {
	    __extends(ElementInjector, _super);
	    function ElementInjector(_proto, parent) {
	        var _this = this;
	        _super.call(this, parent);
	        this._proto = _proto;
	        this._preBuiltObjects = null;
	        this._injector =
	            new di_1.Injector(this._proto.protoInjector, null, this, function () { return _this._debugContext(); });
	        // we couple ourselves to the injector strategy to avoid polymoprhic calls
	        var injectorStrategy = this._injector.internalStrategy;
	        this._strategy = injectorStrategy instanceof injector_1.InjectorInlineStrategy ?
	            new ElementInjectorInlineStrategy(injectorStrategy, this) :
	            new ElementInjectorDynamicStrategy(injectorStrategy, this);
	        this.hydrated = false;
	        this._buildQueries();
	    }
	    ElementInjector.prototype.dehydrate = function () {
	        this.hydrated = false;
	        this._host = null;
	        this._preBuiltObjects = null;
	        this._strategy.callOnDestroy();
	        this._strategy.dehydrate();
	        this._clearQueryLists();
	    };
	    ElementInjector.prototype.hydrate = function (imperativelyCreatedInjector, host, preBuiltObjects) {
	        this._host = host;
	        this._preBuiltObjects = preBuiltObjects;
	        this._reattachInjectors(imperativelyCreatedInjector);
	        this._strategy.hydrate();
	        this.hydrated = true;
	    };
	    ElementInjector.prototype.updateLocalQueries = function () {
	        if (lang_1.isPresent(this._query0) && !this._query0.isViewQuery) {
	            this._query0.update();
	            this._query0.list.fireCallbacks();
	        }
	        if (lang_1.isPresent(this._query1) && !this._query1.isViewQuery) {
	            this._query1.update();
	            this._query1.list.fireCallbacks();
	        }
	        if (lang_1.isPresent(this._query2) && !this._query2.isViewQuery) {
	            this._query2.update();
	            this._query2.list.fireCallbacks();
	        }
	    };
	    ElementInjector.prototype.updateLocalViewQueries = function () {
	        if (lang_1.isPresent(this._query0) && this._query0.isViewQuery) {
	            this._query0.update();
	            this._query0.list.fireCallbacks();
	        }
	        if (lang_1.isPresent(this._query1) && this._query1.isViewQuery) {
	            this._query1.update();
	            this._query1.list.fireCallbacks();
	        }
	        if (lang_1.isPresent(this._query2) && this._query2.isViewQuery) {
	            this._query2.update();
	            this._query2.list.fireCallbacks();
	        }
	    };
	    ElementInjector.prototype._debugContext = function () {
	        var p = this._preBuiltObjects;
	        var index = p.elementRef.boundElementIndex - p.view.elementOffset;
	        var c = this._preBuiltObjects.view.getDebugContext(index, null);
	        return lang_1.isPresent(c) ? new _Context(c.element, c.componentElement, c.injector) : null;
	    };
	    ElementInjector.prototype._reattachInjectors = function (imperativelyCreatedInjector) {
	        // Dynamically-loaded component in the template. Not a root ElementInjector.
	        if (lang_1.isPresent(this._parent)) {
	            if (lang_1.isPresent(imperativelyCreatedInjector)) {
	                // The imperative injector is similar to having an element between
	                // the dynamic-loaded component and its parent => no boundaries.
	                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
	                this._reattachInjector(imperativelyCreatedInjector, this._parent._injector, false);
	            }
	            else {
	                this._reattachInjector(this._injector, this._parent._injector, false);
	            }
	        }
	        else if (lang_1.isPresent(this._host)) {
	            // The imperative injector is similar to having an element between
	            // the dynamic-loaded component and its parent => no boundary between
	            // the component and imperativelyCreatedInjector.
	            // But since it is a root ElementInjector, we need to create a boundary
	            // between imperativelyCreatedInjector and _host.
	            if (lang_1.isPresent(imperativelyCreatedInjector)) {
	                this._reattachInjector(this._injector, imperativelyCreatedInjector, false);
	                this._reattachInjector(imperativelyCreatedInjector, this._host._injector, true);
	            }
	            else {
	                this._reattachInjector(this._injector, this._host._injector, true);
	            }
	        }
	        else {
	            if (lang_1.isPresent(imperativelyCreatedInjector)) {
	                this._reattachInjector(this._injector, imperativelyCreatedInjector, true);
	            }
	        }
	    };
	    ElementInjector.prototype._reattachInjector = function (injector, parentInjector, isBoundary) {
	        injector.internalStrategy.attach(parentInjector, isBoundary);
	    };
	    ElementInjector.prototype.hasVariableBinding = function (name) {
	        var vb = this._proto.directiveVariableBindings;
	        return lang_1.isPresent(vb) && vb.has(name);
	    };
	    ElementInjector.prototype.getVariableBinding = function (name) {
	        var index = this._proto.directiveVariableBindings.get(name);
	        return lang_1.isPresent(index) ? this.getDirectiveAtIndex(index) : this.getElementRef();
	    };
	    ElementInjector.prototype.get = function (token) { return this._injector.get(token); };
	    ElementInjector.prototype.hasDirective = function (type) { return lang_1.isPresent(this._injector.getOptional(type)); };
	    ElementInjector.prototype.getEventEmitterAccessors = function () { return this._proto.eventEmitterAccessors; };
	    ElementInjector.prototype.getDirectiveVariableBindings = function () {
	        return this._proto.directiveVariableBindings;
	    };
	    ElementInjector.prototype.getComponent = function () { return this._strategy.getComponent(); };
	    ElementInjector.prototype.getInjector = function () { return this._injector; };
	    ElementInjector.prototype.getElementRef = function () { return this._preBuiltObjects.elementRef; };
	    ElementInjector.prototype.getViewContainerRef = function () {
	        return new view_container_ref_1.ViewContainerRef(this._preBuiltObjects.viewManager, this.getElementRef());
	    };
	    ElementInjector.prototype.getView = function () { return this._preBuiltObjects.view; };
	    ElementInjector.prototype.directParent = function () { return this._proto.distanceToParent < 2 ? this.parent : null; };
	    ElementInjector.prototype.isComponentKey = function (key) { return this._strategy.isComponentKey(key); };
	    ElementInjector.prototype.getDependency = function (injector, binding, dep) {
	        var key = dep.key;
	        if (binding instanceof DirectiveBinding) {
	            var dirDep = dep;
	            var dirBin = binding;
	            var staticKeys = StaticKeys.instance();
	            if (key.id === staticKeys.viewManagerId)
	                return this._preBuiltObjects.viewManager;
	            if (lang_1.isPresent(dirDep.attributeName))
	                return this._buildAttribute(dirDep);
	            if (lang_1.isPresent(dirDep.queryDecorator))
	                return this._findQuery(dirDep.queryDecorator).list;
	            if (dirDep.key.id === StaticKeys.instance().changeDetectorRefId) {
	                // We provide the component's view change detector to components and
	                // the surrounding component's change detector to directives.
	                if (dirBin.metadata.type === api_1.RenderDirectiveMetadata.COMPONENT_TYPE) {
	                    var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
	                    return componentView.changeDetector.ref;
	                }
	                else {
	                    return this._preBuiltObjects.view.changeDetector.ref;
	                }
	            }
	            if (dirDep.key.id === StaticKeys.instance().elementRefId) {
	                return this.getElementRef();
	            }
	            if (dirDep.key.id === StaticKeys.instance().viewContainerId) {
	                return this.getViewContainerRef();
	            }
	            if (dirDep.key.id === StaticKeys.instance().templateRefId) {
	                if (lang_1.isBlank(this._preBuiltObjects.templateRef)) {
	                    if (dirDep.optional) {
	                        return null;
	                    }
	                    throw new di_1.NoBindingError(null, dirDep.key);
	                }
	                return this._preBuiltObjects.templateRef;
	            }
	        }
	        else if (binding instanceof pipe_binding_1.PipeBinding) {
	            if (dep.key.id === StaticKeys.instance().changeDetectorRefId) {
	                var componentView = this._preBuiltObjects.view.getNestedView(this._preBuiltObjects.elementRef.boundElementIndex);
	                return componentView.changeDetector.ref;
	            }
	        }
	        return di_1.UNDEFINED;
	    };
	    ElementInjector.prototype._buildAttribute = function (dep) {
	        var attributes = this._proto.attributes;
	        if (lang_1.isPresent(attributes) && attributes.has(dep.attributeName)) {
	            return attributes.get(dep.attributeName);
	        }
	        else {
	            return null;
	        }
	    };
	    ElementInjector.prototype._buildQueriesForDeps = function (deps) {
	        for (var i = 0; i < deps.length; i++) {
	            var dep = deps[i];
	            if (lang_1.isPresent(dep.queryDecorator)) {
	                this._createQueryRef(dep.queryDecorator);
	            }
	        }
	    };
	    ElementInjector.prototype._createQueryRef = function (query) {
	        var queryList = new query_list_1.QueryList();
	        if (lang_1.isBlank(this._query0)) {
	            this._query0 = new QueryRef(query, queryList, this);
	        }
	        else if (lang_1.isBlank(this._query1)) {
	            this._query1 = new QueryRef(query, queryList, this);
	        }
	        else if (lang_1.isBlank(this._query2)) {
	            this._query2 = new QueryRef(query, queryList, this);
	        }
	        else {
	            throw new QueryError();
	        }
	    };
	    ElementInjector.prototype.addDirectivesMatchingQuery = function (query, list) {
	        var templateRef = lang_1.isBlank(this._preBuiltObjects) ? null : this._preBuiltObjects.templateRef;
	        if (query.selector === template_ref_1.TemplateRef && lang_1.isPresent(templateRef)) {
	            list.push(templateRef);
	        }
	        this._strategy.addDirectivesMatchingQuery(query, list);
	    };
	    ElementInjector.prototype._buildQueries = function () {
	        if (lang_1.isPresent(this._proto)) {
	            this._strategy.buildQueries();
	        }
	    };
	    ElementInjector.prototype._findQuery = function (query) {
	        if (lang_1.isPresent(this._query0) && this._query0.query === query) {
	            return this._query0;
	        }
	        if (lang_1.isPresent(this._query1) && this._query1.query === query) {
	            return this._query1;
	        }
	        if (lang_1.isPresent(this._query2) && this._query2.query === query) {
	            return this._query2;
	        }
	        throw new exceptions_1.BaseException("Cannot find query for directive " + query + ".");
	    };
	    ElementInjector.prototype.link = function (parent) { parent.addChild(this); };
	    ElementInjector.prototype.unlink = function () { this.remove(); };
	    ElementInjector.prototype.getDirectiveAtIndex = function (index) { return this._injector.getAt(index); };
	    ElementInjector.prototype.hasInstances = function () { return this._proto.hasBindings && this.hydrated; };
	    ElementInjector.prototype.getHost = function () { return this._host; };
	    ElementInjector.prototype.getBoundElementIndex = function () { return this._proto.index; };
	    ElementInjector.prototype.getRootViewInjectors = function () {
	        if (!this.hydrated)
	            return [];
	        var view = this._preBuiltObjects.view;
	        var nestedView = view.getNestedView(view.elementOffset + this.getBoundElementIndex());
	        return lang_1.isPresent(nestedView) ? nestedView.rootElementInjectors : [];
	    };
	    ElementInjector.prototype._clearQueryLists = function () {
	        if (lang_1.isPresent(this._query0))
	            this._query0.reset();
	        if (lang_1.isPresent(this._query1))
	            this._query1.reset();
	        if (lang_1.isPresent(this._query2))
	            this._query2.reset();
	    };
	    ElementInjector.prototype.afterViewChecked = function () { this.updateLocalViewQueries(); };
	    ElementInjector.prototype.afterContentChecked = function () { this.updateLocalQueries(); };
	    ElementInjector.prototype.traverseAndSetQueriesAsDirty = function () {
	        var inj = this;
	        while (lang_1.isPresent(inj)) {
	            inj._setQueriesAsDirty();
	            inj = inj.parent;
	        }
	    };
	    ElementInjector.prototype._setQueriesAsDirty = function () {
	        if (lang_1.isPresent(this._query0) && !this._query0.isViewQuery)
	            this._query0.dirty = true;
	        if (lang_1.isPresent(this._query1) && !this._query1.isViewQuery)
	            this._query1.dirty = true;
	        if (lang_1.isPresent(this._query2) && !this._query2.isViewQuery)
	            this._query2.dirty = true;
	        if (lang_1.isPresent(this._host))
	            this._host._setViewQueriesAsDirty();
	    };
	    ElementInjector.prototype._setViewQueriesAsDirty = function () {
	        if (lang_1.isPresent(this._query0) && this._query0.isViewQuery)
	            this._query0.dirty = true;
	        if (lang_1.isPresent(this._query1) && this._query1.isViewQuery)
	            this._query1.dirty = true;
	        if (lang_1.isPresent(this._query2) && this._query2.isViewQuery)
	            this._query2.dirty = true;
	    };
	    return ElementInjector;
	})(TreeNode);
	exports.ElementInjector = ElementInjector;
	/**
	 * Strategy used by the `ElementInjector` when the number of bindings is 10 or less.
	 * In such a case, inlining fields is beneficial for performances.
	 */
	var ElementInjectorInlineStrategy = (function () {
	    function ElementInjectorInlineStrategy(injectorStrategy, _ei) {
	        this.injectorStrategy = injectorStrategy;
	        this._ei = _ei;
	    }
	    ElementInjectorInlineStrategy.prototype.hydrate = function () {
	        var i = this.injectorStrategy;
	        var p = i.protoStrategy;
	        i.resetConstructionCounter();
	        if (p.binding0 instanceof DirectiveBinding && lang_1.isPresent(p.keyId0) && i.obj0 === di_1.UNDEFINED)
	            i.obj0 = i.instantiateBinding(p.binding0, p.visibility0);
	        if (p.binding1 instanceof DirectiveBinding && lang_1.isPresent(p.keyId1) && i.obj1 === di_1.UNDEFINED)
	            i.obj1 = i.instantiateBinding(p.binding1, p.visibility1);
	        if (p.binding2 instanceof DirectiveBinding && lang_1.isPresent(p.keyId2) && i.obj2 === di_1.UNDEFINED)
	            i.obj2 = i.instantiateBinding(p.binding2, p.visibility2);
	        if (p.binding3 instanceof DirectiveBinding && lang_1.isPresent(p.keyId3) && i.obj3 === di_1.UNDEFINED)
	            i.obj3 = i.instantiateBinding(p.binding3, p.visibility3);
	        if (p.binding4 instanceof DirectiveBinding && lang_1.isPresent(p.keyId4) && i.obj4 === di_1.UNDEFINED)
	            i.obj4 = i.instantiateBinding(p.binding4, p.visibility4);
	        if (p.binding5 instanceof DirectiveBinding && lang_1.isPresent(p.keyId5) && i.obj5 === di_1.UNDEFINED)
	            i.obj5 = i.instantiateBinding(p.binding5, p.visibility5);
	        if (p.binding6 instanceof DirectiveBinding && lang_1.isPresent(p.keyId6) && i.obj6 === di_1.UNDEFINED)
	            i.obj6 = i.instantiateBinding(p.binding6, p.visibility6);
	        if (p.binding7 instanceof DirectiveBinding && lang_1.isPresent(p.keyId7) && i.obj7 === di_1.UNDEFINED)
	            i.obj7 = i.instantiateBinding(p.binding7, p.visibility7);
	        if (p.binding8 instanceof DirectiveBinding && lang_1.isPresent(p.keyId8) && i.obj8 === di_1.UNDEFINED)
	            i.obj8 = i.instantiateBinding(p.binding8, p.visibility8);
	        if (p.binding9 instanceof DirectiveBinding && lang_1.isPresent(p.keyId9) && i.obj9 === di_1.UNDEFINED)
	            i.obj9 = i.instantiateBinding(p.binding9, p.visibility9);
	    };
	    ElementInjectorInlineStrategy.prototype.dehydrate = function () {
	        var i = this.injectorStrategy;
	        i.obj0 = di_1.UNDEFINED;
	        i.obj1 = di_1.UNDEFINED;
	        i.obj2 = di_1.UNDEFINED;
	        i.obj3 = di_1.UNDEFINED;
	        i.obj4 = di_1.UNDEFINED;
	        i.obj5 = di_1.UNDEFINED;
	        i.obj6 = di_1.UNDEFINED;
	        i.obj7 = di_1.UNDEFINED;
	        i.obj8 = di_1.UNDEFINED;
	        i.obj9 = di_1.UNDEFINED;
	    };
	    ElementInjectorInlineStrategy.prototype.callOnDestroy = function () {
	        var i = this.injectorStrategy;
	        var p = i.protoStrategy;
	        if (p.binding0 instanceof DirectiveBinding && p.binding0.callOnDestroy) {
	            i.obj0.onDestroy();
	        }
	        if (p.binding1 instanceof DirectiveBinding && p.binding1.callOnDestroy) {
	            i.obj1.onDestroy();
	        }
	        if (p.binding2 instanceof DirectiveBinding && p.binding2.callOnDestroy) {
	            i.obj2.onDestroy();
	        }
	        if (p.binding3 instanceof DirectiveBinding && p.binding3.callOnDestroy) {
	            i.obj3.onDestroy();
	        }
	        if (p.binding4 instanceof DirectiveBinding && p.binding4.callOnDestroy) {
	            i.obj4.onDestroy();
	        }
	        if (p.binding5 instanceof DirectiveBinding && p.binding5.callOnDestroy) {
	            i.obj5.onDestroy();
	        }
	        if (p.binding6 instanceof DirectiveBinding && p.binding6.callOnDestroy) {
	            i.obj6.onDestroy();
	        }
	        if (p.binding7 instanceof DirectiveBinding && p.binding7.callOnDestroy) {
	            i.obj7.onDestroy();
	        }
	        if (p.binding8 instanceof DirectiveBinding && p.binding8.callOnDestroy) {
	            i.obj8.onDestroy();
	        }
	        if (p.binding9 instanceof DirectiveBinding && p.binding9.callOnDestroy) {
	            i.obj9.onDestroy();
	        }
	    };
	    ElementInjectorInlineStrategy.prototype.getComponent = function () { return this.injectorStrategy.obj0; };
	    ElementInjectorInlineStrategy.prototype.isComponentKey = function (key) {
	        return this._ei._proto._firstBindingIsComponent && lang_1.isPresent(key) &&
	            key.id === this.injectorStrategy.protoStrategy.keyId0;
	    };
	    ElementInjectorInlineStrategy.prototype.buildQueries = function () {
	        var p = this.injectorStrategy.protoStrategy;
	        if (p.binding0 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding0.resolvedFactories[0].dependencies);
	        }
	        if (p.binding1 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding1.resolvedFactories[0].dependencies);
	        }
	        if (p.binding2 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding2.resolvedFactories[0].dependencies);
	        }
	        if (p.binding3 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding3.resolvedFactories[0].dependencies);
	        }
	        if (p.binding4 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding4.resolvedFactories[0].dependencies);
	        }
	        if (p.binding5 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding5.resolvedFactories[0].dependencies);
	        }
	        if (p.binding6 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding6.resolvedFactories[0].dependencies);
	        }
	        if (p.binding7 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding7.resolvedFactories[0].dependencies);
	        }
	        if (p.binding8 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding8.resolvedFactories[0].dependencies);
	        }
	        if (p.binding9 instanceof DirectiveBinding) {
	            this._ei._buildQueriesForDeps(p.binding9.resolvedFactories[0].dependencies);
	        }
	    };
	    ElementInjectorInlineStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {
	        var i = this.injectorStrategy;
	        var p = i.protoStrategy;
	        if (lang_1.isPresent(p.binding0) && p.binding0.key.token === query.selector) {
	            if (i.obj0 === di_1.UNDEFINED)
	                i.obj0 = i.instantiateBinding(p.binding0, p.visibility0);
	            list.push(i.obj0);
	        }
	        if (lang_1.isPresent(p.binding1) && p.binding1.key.token === query.selector) {
	            if (i.obj1 === di_1.UNDEFINED)
	                i.obj1 = i.instantiateBinding(p.binding1, p.visibility1);
	            list.push(i.obj1);
	        }
	        if (lang_1.isPresent(p.binding2) && p.binding2.key.token === query.selector) {
	            if (i.obj2 === di_1.UNDEFINED)
	                i.obj2 = i.instantiateBinding(p.binding2, p.visibility2);
	            list.push(i.obj2);
	        }
	        if (lang_1.isPresent(p.binding3) && p.binding3.key.token === query.selector) {
	            if (i.obj3 === di_1.UNDEFINED)
	                i.obj3 = i.instantiateBinding(p.binding3, p.visibility3);
	            list.push(i.obj3);
	        }
	        if (lang_1.isPresent(p.binding4) && p.binding4.key.token === query.selector) {
	            if (i.obj4 === di_1.UNDEFINED)
	                i.obj4 = i.instantiateBinding(p.binding4, p.visibility4);
	            list.push(i.obj4);
	        }
	        if (lang_1.isPresent(p.binding5) && p.binding5.key.token === query.selector) {
	            if (i.obj5 === di_1.UNDEFINED)
	                i.obj5 = i.instantiateBinding(p.binding5, p.visibility5);
	            list.push(i.obj5);
	        }
	        if (lang_1.isPresent(p.binding6) && p.binding6.key.token === query.selector) {
	            if (i.obj6 === di_1.UNDEFINED)
	                i.obj6 = i.instantiateBinding(p.binding6, p.visibility6);
	            list.push(i.obj6);
	        }
	        if (lang_1.isPresent(p.binding7) && p.binding7.key.token === query.selector) {
	            if (i.obj7 === di_1.UNDEFINED)
	                i.obj7 = i.instantiateBinding(p.binding7, p.visibility7);
	            list.push(i.obj7);
	        }
	        if (lang_1.isPresent(p.binding8) && p.binding8.key.token === query.selector) {
	            if (i.obj8 === di_1.UNDEFINED)
	                i.obj8 = i.instantiateBinding(p.binding8, p.visibility8);
	            list.push(i.obj8);
	        }
	        if (lang_1.isPresent(p.binding9) && p.binding9.key.token === query.selector) {
	            if (i.obj9 === di_1.UNDEFINED)
	                i.obj9 = i.instantiateBinding(p.binding9, p.visibility9);
	            list.push(i.obj9);
	        }
	    };
	    return ElementInjectorInlineStrategy;
	})();
	/**
	 * Strategy used by the `ElementInjector` when the number of bindings is 10 or less.
	 * In such a case, inlining fields is benefitial for performances.
	 */
	var ElementInjectorDynamicStrategy = (function () {
	    function ElementInjectorDynamicStrategy(injectorStrategy, _ei) {
	        this.injectorStrategy = injectorStrategy;
	        this._ei = _ei;
	    }
	    ElementInjectorDynamicStrategy.prototype.hydrate = function () {
	        var inj = this.injectorStrategy;
	        var p = inj.protoStrategy;
	        inj.resetConstructionCounter();
	        for (var i = 0; i < p.keyIds.length; i++) {
	            if (p.bindings[i] instanceof DirectiveBinding && lang_1.isPresent(p.keyIds[i]) &&
	                inj.objs[i] === di_1.UNDEFINED) {
	                inj.objs[i] = inj.instantiateBinding(p.bindings[i], p.visibilities[i]);
	            }
	        }
	    };
	    ElementInjectorDynamicStrategy.prototype.dehydrate = function () {
	        var inj = this.injectorStrategy;
	        collection_1.ListWrapper.fill(inj.objs, di_1.UNDEFINED);
	    };
	    ElementInjectorDynamicStrategy.prototype.callOnDestroy = function () {
	        var ist = this.injectorStrategy;
	        var p = ist.protoStrategy;
	        for (var i = 0; i < p.bindings.length; i++) {
	            if (p.bindings[i] instanceof DirectiveBinding &&
	                p.bindings[i].callOnDestroy) {
	                ist.objs[i].onDestroy();
	            }
	        }
	    };
	    ElementInjectorDynamicStrategy.prototype.getComponent = function () { return this.injectorStrategy.objs[0]; };
	    ElementInjectorDynamicStrategy.prototype.isComponentKey = function (key) {
	        var p = this.injectorStrategy.protoStrategy;
	        return this._ei._proto._firstBindingIsComponent && lang_1.isPresent(key) && key.id === p.keyIds[0];
	    };
	    ElementInjectorDynamicStrategy.prototype.buildQueries = function () {
	        var inj = this.injectorStrategy;
	        var p = inj.protoStrategy;
	        for (var i = 0; i < p.bindings.length; i++) {
	            if (p.bindings[i] instanceof DirectiveBinding) {
	                this._ei._buildQueriesForDeps(p.bindings[i].resolvedFactory.dependencies);
	            }
	        }
	    };
	    ElementInjectorDynamicStrategy.prototype.addDirectivesMatchingQuery = function (query, list) {
	        var ist = this.injectorStrategy;
	        var p = ist.protoStrategy;
	        for (var i = 0; i < p.bindings.length; i++) {
	            if (p.bindings[i].key.token === query.selector) {
	                if (ist.objs[i] === di_1.UNDEFINED) {
	                    ist.objs[i] = ist.instantiateBinding(p.bindings[i], p.visibilities[i]);
	                }
	                list.push(ist.objs[i]);
	            }
	        }
	    };
	    return ElementInjectorDynamicStrategy;
	})();
	var QueryError = (function (_super) {
	    __extends(QueryError, _super);
	    // TODO(rado): pass the names of the active directives.
	    function QueryError() {
	        _super.call(this);
	        this.message = 'Only 3 queries can be concurrently active on an element.';
	    }
	    QueryError.prototype.toString = function () { return this.message; };
	    return QueryError;
	})(exceptions_1.BaseException);
	exports.QueryError = QueryError;
	var QueryRef = (function () {
	    function QueryRef(query, list, originator, dirty) {
	        if (dirty === void 0) { dirty = true; }
	        this.query = query;
	        this.list = list;
	        this.originator = originator;
	        this.dirty = dirty;
	    }
	    Object.defineProperty(QueryRef.prototype, "isViewQuery", {
	        get: function () { return this.query.isViewQuery; },
	        enumerable: true,
	        configurable: true
	    });
	    QueryRef.prototype.update = function () {
	        if (!this.dirty)
	            return;
	        this._update();
	        this.dirty = false;
	    };
	    QueryRef.prototype._update = function () {
	        var aggregator = [];
	        if (this.query.isViewQuery) {
	            var view = this.originator.getView();
	            // intentionally skipping originator for view queries.
	            var nestedView = view.getNestedView(view.elementOffset + this.originator.getBoundElementIndex());
	            if (lang_1.isPresent(nestedView))
	                this._visitView(nestedView, aggregator);
	        }
	        else {
	            this._visit(this.originator, aggregator);
	        }
	        this.list.reset(aggregator);
	    };
	    ;
	    QueryRef.prototype._visit = function (inj, aggregator) {
	        var view = inj.getView();
	        var startIdx = view.elementOffset + inj._proto.index;
	        for (var i = startIdx; i < view.elementOffset + view.ownBindersCount; i++) {
	            var curInj = view.elementInjectors[i];
	            if (lang_1.isBlank(curInj))
	                continue;
	            // The first injector after inj, that is outside the subtree rooted at
	            // inj has to have a null parent or a parent that is an ancestor of inj.
	            if (i > startIdx && (lang_1.isBlank(curInj) || lang_1.isBlank(curInj.parent) ||
	                view.elementOffset + curInj.parent._proto.index < startIdx)) {
	                break;
	            }
	            if (!this.query.descendants &&
	                !(curInj.parent == this.originator || curInj == this.originator))
	                continue;
	            // We visit the view container(VC) views right after the injector that contains
	            // the VC. Theoretically, that might not be the right order if there are
	            // child injectors of said injector. Not clear whether if such case can
	            // even be constructed with the current apis.
	            this._visitInjector(curInj, aggregator);
	            var vc = view.viewContainers[i];
	            if (lang_1.isPresent(vc))
	                this._visitViewContainer(vc, aggregator);
	        }
	    };
	    QueryRef.prototype._visitInjector = function (inj, aggregator) {
	        if (this.query.isVarBindingQuery) {
	            this._aggregateVariableBindings(inj, aggregator);
	        }
	        else {
	            this._aggregateDirective(inj, aggregator);
	        }
	    };
	    QueryRef.prototype._visitViewContainer = function (vc, aggregator) {
	        for (var j = 0; j < vc.views.length; j++) {
	            this._visitView(vc.views[j], aggregator);
	        }
	    };
	    QueryRef.prototype._visitView = function (view, aggregator) {
	        for (var i = view.elementOffset; i < view.elementOffset + view.ownBindersCount; i++) {
	            var inj = view.elementInjectors[i];
	            if (lang_1.isBlank(inj))
	                continue;
	            this._visitInjector(inj, aggregator);
	            var vc = view.viewContainers[i];
	            if (lang_1.isPresent(vc))
	                this._visitViewContainer(vc, aggregator);
	        }
	    };
	    QueryRef.prototype._aggregateVariableBindings = function (inj, aggregator) {
	        var vb = this.query.varBindings;
	        for (var i = 0; i < vb.length; ++i) {
	            if (inj.hasVariableBinding(vb[i])) {
	                aggregator.push(inj.getVariableBinding(vb[i]));
	            }
	        }
	    };
	    QueryRef.prototype._aggregateDirective = function (inj, aggregator) {
	        inj.addDirectivesMatchingQuery(this.query, aggregator);
	    };
	    QueryRef.prototype.reset = function () {
	        this.list.reset([]);
	        this.list.removeAllCallbacks();
	        this.dirty = true;
	    };
	    return QueryRef;
	})();
	exports.QueryRef = QueryRef;
	//# sourceMappingURL=element_injector.js.map

/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var view_ref_1 = __webpack_require__(384);
	var api_1 = __webpack_require__(212);
	var view_manager_utils_1 = __webpack_require__(389);
	var view_pool_1 = __webpack_require__(392);
	var view_listener_1 = __webpack_require__(393);
	var profile_1 = __webpack_require__(190);
	/**
	 * Entry point for creating, moving views in the view hierarchy and destroying views.
	 * This manager contains all recursion and delegates to helper methods
	 * in AppViewManagerUtils and the Renderer, so unit tests get simpler.
	 */
	var AppViewManager = (function () {
	    /**
	     * @private
	     */
	    function AppViewManager(_viewPool, _viewListener, _utils, _renderer) {
	        this._viewPool = _viewPool;
	        this._viewListener = _viewListener;
	        this._utils = _utils;
	        this._renderer = _renderer;
	        this._createRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#createRootHostView()');
	        this._destroyRootHostViewScope = profile_1.wtfCreateScope('AppViewManager#destroyRootHostView()');
	        this._createEmbeddedViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createEmbeddedViewInContainer()');
	        this._createHostViewInContainerScope = profile_1.wtfCreateScope('AppViewManager#createHostViewInContainer()');
	        this._destroyViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#destroyViewInContainer()');
	        this._attachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#attachViewInContainer()');
	        this._detachViewInContainerScope = profile_1.wtfCreateScope('AppViewMananger#detachViewInContainer()');
	    }
	    /**
	     * Returns a {@link ViewContainerRef} at the {@link ElementRef} location.
	     */
	    AppViewManager.prototype.getViewContainer = function (location) {
	        var hostView = view_ref_1.internalView(location.parentView);
	        return hostView.elementInjectors[location.boundElementIndex].getViewContainerRef();
	    };
	    /**
	     * Return the first child element of the host element view.
	     */
	    AppViewManager.prototype.getHostElement = function (hostViewRef) {
	        var hostView = view_ref_1.internalView(hostViewRef);
	        if (hostView.proto.type !== api_1.ViewType.HOST) {
	            throw new exceptions_1.BaseException('This operation is only allowed on host views');
	        }
	        return hostView.elementRefs[hostView.elementOffset];
	    };
	    /**
	     * Returns an ElementRef for the element with the given variable name
	     * in the current view.
	     *
	     * - `hostLocation`: {@link ElementRef} of any element in the View which defines the scope of
	     *   search.
	     * - `variableName`: Name of the variable to locate.
	     * - Returns {@link ElementRef} of the found element or null. (Throws if not found.)
	     */
	    AppViewManager.prototype.getNamedElementInComponentView = function (hostLocation, variableName) {
	        var hostView = view_ref_1.internalView(hostLocation.parentView);
	        var boundElementIndex = hostLocation.boundElementIndex;
	        var componentView = hostView.getNestedView(boundElementIndex);
	        if (lang_1.isBlank(componentView)) {
	            throw new exceptions_1.BaseException("There is no component directive at element " + boundElementIndex);
	        }
	        var binderIdx = componentView.proto.variableLocations.get(variableName);
	        if (lang_1.isBlank(binderIdx)) {
	            throw new exceptions_1.BaseException("Could not find variable " + variableName);
	        }
	        return componentView.elementRefs[componentView.elementOffset + binderIdx];
	    };
	    /**
	     * Returns the component instance for a given element.
	     *
	     * The component is the execution context as seen by an expression at that {@link ElementRef}
	     * location.
	     */
	    AppViewManager.prototype.getComponent = function (hostLocation) {
	        var hostView = view_ref_1.internalView(hostLocation.parentView);
	        var boundElementIndex = hostLocation.boundElementIndex;
	        return this._utils.getComponentInstance(hostView, boundElementIndex);
	    };
	    /**
	     * Load component view into existing element.
	     *
	     * Use this if a host element is already in the DOM and it is necessary to upgrade
	     * the element into Angular component by attaching a view but reusing the existing element.
	     *
	     * - `hostProtoViewRef`: {@link ProtoViewRef} Proto view to use in creating a view for this
	     *   component.
	     * - `overrideSelector`: (optional) selector to use in locating the existing element to load
	     *   the view into. If not specified use the selector in the component definition of the
	     *   `hostProtoView`.
	     * - injector: {@link Injector} to use as parent injector for the view.
	     *
	     * See {@link AppViewManager#destroyRootHostView}.
	     *
	     * ## Example
	     *
	     * ```
	     * @ng.Component({
	     *   selector: 'child-component'
	     * })
	     * @ng.View({
	     *   template: 'Child'
	     * })
	     * class ChildComponent {
	     *
	     * }
	     *
	     * @ng.Component({
	     *   selector: 'my-app'
	     * })
	     * @ng.View({
	     *   template: `
	     *     Parent (<some-component></some-component>)
	     *   `
	     * })
	     * class MyApp {
	     *   viewRef: ng.ViewRef;
	     *
	     *   constructor(public appViewManager: ng.AppViewManager, compiler: ng.Compiler) {
	     *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoViewRef) => {
	     *       this.viewRef = appViewManager.createRootHostView(protoView, 'some-component', null);
	     *     })
	     *   }
	     *
	     *   onDestroy() {
	     *     this.appViewManager.destroyRootHostView(this.viewRef);
	     *     this.viewRef = null;
	     *   }
	     * }
	     *
	     * ng.bootstrap(MyApp);
	     * ```
	     */
	    AppViewManager.prototype.createRootHostView = function (hostProtoViewRef, overrideSelector, injector) {
	        var s = this._createRootHostViewScope();
	        var hostProtoView = view_ref_1.internalProtoView(hostProtoViewRef);
	        var hostElementSelector = overrideSelector;
	        if (lang_1.isBlank(hostElementSelector)) {
	            hostElementSelector = hostProtoView.elementBinders[0].componentDirective.metadata.selector;
	        }
	        var renderViewWithFragments = this._renderer.createRootHostView(hostProtoView.mergeMapping.renderProtoViewRef, hostProtoView.mergeMapping.renderFragmentCount, hostElementSelector);
	        var hostView = this._createMainView(hostProtoView, renderViewWithFragments);
	        this._renderer.hydrateView(hostView.render);
	        this._utils.hydrateRootHostView(hostView, injector);
	        return profile_1.wtfLeave(s, hostView.ref);
	    };
	    /**
	     * Remove the View created with {@link AppViewManager#createRootHostView}.
	     */
	    AppViewManager.prototype.destroyRootHostView = function (hostViewRef) {
	        // Note: Don't put the hostView into the view pool
	        // as it is depending on the element for which it was created.
	        var s = this._destroyRootHostViewScope();
	        var hostView = view_ref_1.internalView(hostViewRef);
	        this._renderer.detachFragment(hostView.renderFragment);
	        this._renderer.dehydrateView(hostView.render);
	        this._viewDehydrateRecurse(hostView);
	        this._viewListener.viewDestroyed(hostView);
	        this._renderer.destroyView(hostView.render);
	        profile_1.wtfLeave(s);
	    };
	    /**
	     *
	     * See {@link AppViewManager#destroyViewInContainer}.
	     */
	    AppViewManager.prototype.createEmbeddedViewInContainer = function (viewContainerLocation, atIndex, templateRef) {
	        var s = this._createEmbeddedViewInContainerScope();
	        var protoView = view_ref_1.internalProtoView(templateRef.protoViewRef);
	        if (protoView.type !== api_1.ViewType.EMBEDDED) {
	            throw new exceptions_1.BaseException('This method can only be called with embedded ProtoViews!');
	        }
	        return profile_1.wtfLeave(s, this._createViewInContainer(viewContainerLocation, atIndex, protoView, templateRef.elementRef, null));
	    };
	    /**
	     *
	     * See {@link AppViewManager#destroyViewInContainer}.
	     */
	    AppViewManager.prototype.createHostViewInContainer = function (viewContainerLocation, atIndex, protoViewRef, imperativelyCreatedInjector) {
	        var s = this._createHostViewInContainerScope();
	        var protoView = view_ref_1.internalProtoView(protoViewRef);
	        if (protoView.type !== api_1.ViewType.HOST) {
	            throw new exceptions_1.BaseException('This method can only be called with host ProtoViews!');
	        }
	        return profile_1.wtfLeave(s, this._createViewInContainer(viewContainerLocation, atIndex, protoView, viewContainerLocation, imperativelyCreatedInjector));
	    };
	    /**
	     *
	     * See {@link AppViewManager#destroyViewInContainer}.
	     */
	    AppViewManager.prototype._createViewInContainer = function (viewContainerLocation, atIndex, protoView, context, imperativelyCreatedInjector) {
	        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
	        var boundElementIndex = viewContainerLocation.boundElementIndex;
	        var contextView = view_ref_1.internalView(context.parentView);
	        var contextBoundElementIndex = context.boundElementIndex;
	        var embeddedFragmentView = contextView.getNestedView(contextBoundElementIndex);
	        var view;
	        if (protoView.type === api_1.ViewType.EMBEDDED && lang_1.isPresent(embeddedFragmentView) &&
	            !embeddedFragmentView.hydrated()) {
	            // Case 1: instantiate the first view of a template that has been merged into a parent
	            view = embeddedFragmentView;
	            this._attachRenderView(parentView, boundElementIndex, atIndex, view);
	        }
	        else {
	            // Case 2: instantiate another copy of the template or a host ProtoView.
	            // This is a separate case
	            // as we only inline one copy of the template into the parent view.
	            view = this._createPooledView(protoView);
	            this._attachRenderView(parentView, boundElementIndex, atIndex, view);
	            this._renderer.hydrateView(view.render);
	        }
	        this._utils.attachViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view);
	        this._utils.hydrateViewInContainer(parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, imperativelyCreatedInjector);
	        return view.ref;
	    };
	    AppViewManager.prototype._attachRenderView = function (parentView, boundElementIndex, atIndex, view) {
	        var elementRef = parentView.elementRefs[boundElementIndex];
	        if (atIndex === 0) {
	            this._renderer.attachFragmentAfterElement(elementRef, view.renderFragment);
	        }
	        else {
	            var prevView = parentView.viewContainers[boundElementIndex].views[atIndex - 1];
	            this._renderer.attachFragmentAfterFragment(prevView.renderFragment, view.renderFragment);
	        }
	    };
	    /**
	     *
	     * See {@link AppViewManager#createViewInContainer}.
	     */
	    AppViewManager.prototype.destroyViewInContainer = function (viewContainerLocation, atIndex) {
	        var s = this._destroyViewInContainerScope();
	        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
	        var boundElementIndex = viewContainerLocation.boundElementIndex;
	        this._destroyViewInContainer(parentView, boundElementIndex, atIndex);
	        profile_1.wtfLeave(s);
	    };
	    /**
	     *
	     * See {@link AppViewManager#detachViewInContainer}.
	     */
	    AppViewManager.prototype.attachViewInContainer = function (viewContainerLocation, atIndex, viewRef) {
	        var s = this._attachViewInContainerScope();
	        var view = view_ref_1.internalView(viewRef);
	        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
	        var boundElementIndex = viewContainerLocation.boundElementIndex;
	        // TODO(tbosch): the public methods attachViewInContainer/detachViewInContainer
	        // are used for moving elements without the same container.
	        // We will change this into an atomic `move` operation, which should preserve the
	        // previous parent injector (see https://github.com/angular/angular/issues/1377).
	        // Right now we are destroying any special
	        // context view that might have been used.
	        this._utils.attachViewInContainer(parentView, boundElementIndex, null, null, atIndex, view);
	        this._attachRenderView(parentView, boundElementIndex, atIndex, view);
	        return profile_1.wtfLeave(s, viewRef);
	    };
	    /**
	     *
	     * See {@link AppViewManager#attachViewInContainer}.
	     */
	    AppViewManager.prototype.detachViewInContainer = function (viewContainerLocation, atIndex) {
	        var s = this._detachViewInContainerScope();
	        var parentView = view_ref_1.internalView(viewContainerLocation.parentView);
	        var boundElementIndex = viewContainerLocation.boundElementIndex;
	        var viewContainer = parentView.viewContainers[boundElementIndex];
	        var view = viewContainer.views[atIndex];
	        this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
	        this._renderer.detachFragment(view.renderFragment);
	        return profile_1.wtfLeave(s, view.ref);
	    };
	    AppViewManager.prototype._createMainView = function (protoView, renderViewWithFragments) {
	        var mergedParentView = this._utils.createView(protoView, renderViewWithFragments, this, this._renderer);
	        this._renderer.setEventDispatcher(mergedParentView.render, mergedParentView);
	        this._viewListener.viewCreated(mergedParentView);
	        return mergedParentView;
	    };
	    AppViewManager.prototype._createPooledView = function (protoView) {
	        var view = this._viewPool.getView(protoView);
	        if (lang_1.isBlank(view)) {
	            view = this._createMainView(protoView, this._renderer.createView(protoView.mergeMapping.renderProtoViewRef, protoView.mergeMapping.renderFragmentCount));
	        }
	        return view;
	    };
	    AppViewManager.prototype._destroyPooledView = function (view) {
	        var wasReturned = this._viewPool.returnView(view);
	        if (!wasReturned) {
	            this._viewListener.viewDestroyed(view);
	            this._renderer.destroyView(view.render);
	        }
	    };
	    AppViewManager.prototype._destroyViewInContainer = function (parentView, boundElementIndex, atIndex) {
	        var viewContainer = parentView.viewContainers[boundElementIndex];
	        var view = viewContainer.views[atIndex];
	        this._viewDehydrateRecurse(view);
	        this._utils.detachViewInContainer(parentView, boundElementIndex, atIndex);
	        if (view.viewOffset > 0) {
	            // Case 1: a view that is part of another view.
	            // Just detach the fragment
	            this._renderer.detachFragment(view.renderFragment);
	        }
	        else {
	            // Case 2: a view that is not part of another view.
	            // dehydrate and destroy it.
	            this._renderer.dehydrateView(view.render);
	            this._renderer.detachFragment(view.renderFragment);
	            this._destroyPooledView(view);
	        }
	    };
	    AppViewManager.prototype._viewDehydrateRecurse = function (view) {
	        if (view.hydrated()) {
	            this._utils.dehydrateView(view);
	        }
	        var viewContainers = view.viewContainers;
	        var startViewOffset = view.viewOffset;
	        var endViewOffset = view.viewOffset + view.mainMergeMapping.nestedViewCountByViewIndex[view.viewOffset];
	        var elementOffset = view.elementOffset;
	        for (var viewIdx = startViewOffset; viewIdx <= endViewOffset; viewIdx++) {
	            var currView = view.views[viewIdx];
	            for (var binderIdx = 0; binderIdx < currView.proto.elementBinders.length; binderIdx++, elementOffset++) {
	                var vc = viewContainers[elementOffset];
	                if (lang_1.isPresent(vc)) {
	                    for (var j = vc.views.length - 1; j >= 0; j--) {
	                        this._destroyViewInContainer(currView, elementOffset, j);
	                    }
	                }
	            }
	        }
	    };
	    AppViewManager = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [view_pool_1.AppViewPool, view_listener_1.AppViewListener, view_manager_utils_1.AppViewManagerUtils, api_1.Renderer])
	    ], AppViewManager);
	    return AppViewManager;
	})();
	exports.AppViewManager = AppViewManager;
	//# sourceMappingURL=view_manager.js.map

/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var collection_1 = __webpack_require__(166);
	var eli = __webpack_require__(387);
	var lang_1 = __webpack_require__(159);
	var viewModule = __webpack_require__(382);
	var view_ref_1 = __webpack_require__(384);
	var element_ref_1 = __webpack_require__(390);
	var template_ref_1 = __webpack_require__(391);
	var pipes_1 = __webpack_require__(354);
	var api_1 = __webpack_require__(212);
	var AppViewManagerUtils = (function () {
	    function AppViewManagerUtils() {
	    }
	    AppViewManagerUtils.prototype.getComponentInstance = function (parentView, boundElementIndex) {
	        var eli = parentView.elementInjectors[boundElementIndex];
	        return eli.getComponent();
	    };
	    AppViewManagerUtils.prototype.createView = function (mergedParentViewProto, renderViewWithFragments, viewManager, renderer) {
	        var renderFragments = renderViewWithFragments.fragmentRefs;
	        var renderView = renderViewWithFragments.viewRef;
	        var elementCount = mergedParentViewProto.mergeMapping.renderElementIndices.length;
	        var viewCount = mergedParentViewProto.mergeMapping.nestedViewCountByViewIndex[0] + 1;
	        var elementRefs = collection_1.ListWrapper.createFixedSize(elementCount);
	        var viewContainers = collection_1.ListWrapper.createFixedSize(elementCount);
	        var preBuiltObjects = collection_1.ListWrapper.createFixedSize(elementCount);
	        var elementInjectors = collection_1.ListWrapper.createFixedSize(elementCount);
	        var views = collection_1.ListWrapper.createFixedSize(viewCount);
	        var elementOffset = 0;
	        var textOffset = 0;
	        var fragmentIdx = 0;
	        for (var viewOffset = 0; viewOffset < viewCount; viewOffset++) {
	            var hostElementIndex = mergedParentViewProto.mergeMapping.hostElementIndicesByViewIndex[viewOffset];
	            var parentView = lang_1.isPresent(hostElementIndex) ?
	                view_ref_1.internalView(elementRefs[hostElementIndex].parentView) :
	                null;
	            var protoView = lang_1.isPresent(hostElementIndex) ?
	                parentView.proto.elementBinders[hostElementIndex - parentView.elementOffset]
	                    .nestedProtoView :
	                mergedParentViewProto;
	            var renderFragment = null;
	            if (viewOffset === 0 || protoView.type === api_1.ViewType.EMBEDDED) {
	                renderFragment = renderFragments[fragmentIdx++];
	            }
	            var currentView = new viewModule.AppView(renderer, protoView, mergedParentViewProto.mergeMapping, viewOffset, elementOffset, textOffset, protoView.protoLocals, renderView, renderFragment);
	            views[viewOffset] = currentView;
	            var rootElementInjectors = [];
	            for (var binderIdx = 0; binderIdx < protoView.elementBinders.length; binderIdx++) {
	                var binder = protoView.elementBinders[binderIdx];
	                var boundElementIndex = elementOffset + binderIdx;
	                var elementInjector = null;
	                // elementInjectors and rootElementInjectors
	                var protoElementInjector = binder.protoElementInjector;
	                if (lang_1.isPresent(protoElementInjector)) {
	                    if (lang_1.isPresent(protoElementInjector.parent)) {
	                        var parentElementInjector = elementInjectors[elementOffset + protoElementInjector.parent.index];
	                        elementInjector = protoElementInjector.instantiate(parentElementInjector);
	                    }
	                    else {
	                        elementInjector = protoElementInjector.instantiate(null);
	                        rootElementInjectors.push(elementInjector);
	                    }
	                }
	                elementInjectors[boundElementIndex] = elementInjector;
	                // elementRefs
	                var el = new element_ref_1.ElementRef(currentView.ref, boundElementIndex, mergedParentViewProto.mergeMapping.renderElementIndices[boundElementIndex], renderer);
	                elementRefs[el.boundElementIndex] = el;
	                // preBuiltObjects
	                if (lang_1.isPresent(elementInjector)) {
	                    var templateRef = binder.hasEmbeddedProtoView() ? new template_ref_1.TemplateRef(el) : null;
	                    preBuiltObjects[boundElementIndex] =
	                        new eli.PreBuiltObjects(viewManager, currentView, el, templateRef);
	                }
	            }
	            currentView.init(protoView.protoChangeDetector.instantiate(currentView), elementInjectors, rootElementInjectors, preBuiltObjects, views, elementRefs, viewContainers);
	            if (lang_1.isPresent(parentView) && protoView.type === api_1.ViewType.COMPONENT) {
	                parentView.changeDetector.addShadowDomChild(currentView.changeDetector);
	            }
	            elementOffset += protoView.elementBinders.length;
	            textOffset += protoView.textBindingCount;
	        }
	        return views[0];
	    };
	    AppViewManagerUtils.prototype.hydrateRootHostView = function (hostView, injector) {
	        this._hydrateView(hostView, injector, null, new Object(), null);
	    };
	    // Misnomer: this method is attaching next to the view container.
	    AppViewManagerUtils.prototype.attachViewInContainer = function (parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, view) {
	        if (lang_1.isBlank(contextView)) {
	            contextView = parentView;
	            contextBoundElementIndex = boundElementIndex;
	        }
	        parentView.changeDetector.addChild(view.changeDetector);
	        var viewContainer = parentView.viewContainers[boundElementIndex];
	        if (lang_1.isBlank(viewContainer)) {
	            viewContainer = new viewModule.AppViewContainer();
	            parentView.viewContainers[boundElementIndex] = viewContainer;
	        }
	        collection_1.ListWrapper.insert(viewContainer.views, atIndex, view);
	        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
	        for (var i = view.rootElementInjectors.length - 1; i >= 0; i--) {
	            if (lang_1.isPresent(elementInjector.parent)) {
	                view.rootElementInjectors[i].link(elementInjector.parent);
	            }
	        }
	        elementInjector.traverseAndSetQueriesAsDirty();
	    };
	    AppViewManagerUtils.prototype.detachViewInContainer = function (parentView, boundElementIndex, atIndex) {
	        var viewContainer = parentView.viewContainers[boundElementIndex];
	        var view = viewContainer.views[atIndex];
	        parentView.elementInjectors[boundElementIndex].traverseAndSetQueriesAsDirty();
	        view.changeDetector.remove();
	        collection_1.ListWrapper.removeAt(viewContainer.views, atIndex);
	        for (var i = 0; i < view.rootElementInjectors.length; ++i) {
	            var inj = view.rootElementInjectors[i];
	            inj.unlink();
	        }
	    };
	    AppViewManagerUtils.prototype.hydrateViewInContainer = function (parentView, boundElementIndex, contextView, contextBoundElementIndex, atIndex, imperativelyCreatedBindings) {
	        if (lang_1.isBlank(contextView)) {
	            contextView = parentView;
	            contextBoundElementIndex = boundElementIndex;
	        }
	        var viewContainer = parentView.viewContainers[boundElementIndex];
	        var view = viewContainer.views[atIndex];
	        var elementInjector = contextView.elementInjectors[contextBoundElementIndex];
	        var injector = lang_1.isPresent(imperativelyCreatedBindings) ?
	            di_1.Injector.fromResolvedBindings(imperativelyCreatedBindings) :
	            null;
	        this._hydrateView(view, injector, elementInjector.getHost(), contextView.context, contextView.locals);
	    };
	    AppViewManagerUtils.prototype._hydrateView = function (initView, imperativelyCreatedInjector, hostElementInjector, context, parentLocals) {
	        var viewIdx = initView.viewOffset;
	        var endViewOffset = viewIdx + initView.mainMergeMapping.nestedViewCountByViewIndex[viewIdx];
	        while (viewIdx <= endViewOffset) {
	            var currView = initView.views[viewIdx];
	            var currProtoView = currView.proto;
	            if (currView !== initView && currView.proto.type === api_1.ViewType.EMBEDDED) {
	                // Don't hydrate components of embedded fragment views.
	                viewIdx += initView.mainMergeMapping.nestedViewCountByViewIndex[viewIdx] + 1;
	            }
	            else {
	                if (currView !== initView) {
	                    // hydrate a nested component view
	                    imperativelyCreatedInjector = null;
	                    parentLocals = null;
	                    var hostElementIndex = initView.mainMergeMapping.hostElementIndicesByViewIndex[viewIdx];
	                    hostElementInjector = initView.elementInjectors[hostElementIndex];
	                    context = hostElementInjector.getComponent();
	                }
	                currView.context = context;
	                currView.locals.parent = parentLocals;
	                var binders = currProtoView.elementBinders;
	                for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
	                    var boundElementIndex = binderIdx + currView.elementOffset;
	                    var elementInjector = initView.elementInjectors[boundElementIndex];
	                    if (lang_1.isPresent(elementInjector)) {
	                        elementInjector.hydrate(imperativelyCreatedInjector, hostElementInjector, currView.preBuiltObjects[boundElementIndex]);
	                        this._populateViewLocals(currView, elementInjector, boundElementIndex);
	                        this._setUpEventEmitters(currView, elementInjector, boundElementIndex);
	                    }
	                }
	                var pipes = lang_1.isPresent(hostElementInjector) ?
	                    new pipes_1.Pipes(currView.proto.pipes, hostElementInjector.getInjector()) :
	                    null;
	                currView.changeDetector.hydrate(currView.context, currView.locals, currView, pipes);
	                viewIdx++;
	            }
	        }
	    };
	    AppViewManagerUtils.prototype._populateViewLocals = function (view, elementInjector, boundElementIdx) {
	        if (lang_1.isPresent(elementInjector.getDirectiveVariableBindings())) {
	            collection_1.MapWrapper.forEach(elementInjector.getDirectiveVariableBindings(), function (directiveIndex, name) {
	                if (lang_1.isBlank(directiveIndex)) {
	                    view.locals.set(name, view.elementRefs[boundElementIdx].nativeElement);
	                }
	                else {
	                    view.locals.set(name, elementInjector.getDirectiveAtIndex(directiveIndex));
	                }
	            });
	        }
	    };
	    AppViewManagerUtils.prototype._setUpEventEmitters = function (view, elementInjector, boundElementIndex) {
	        var emitters = elementInjector.getEventEmitterAccessors();
	        for (var directiveIndex = 0; directiveIndex < emitters.length; ++directiveIndex) {
	            var directiveEmitters = emitters[directiveIndex];
	            var directive = elementInjector.getDirectiveAtIndex(directiveIndex);
	            for (var eventIndex = 0; eventIndex < directiveEmitters.length; ++eventIndex) {
	                var eventEmitterAccessor = directiveEmitters[eventIndex];
	                eventEmitterAccessor.subscribe(view, boundElementIndex, directive);
	            }
	        }
	    };
	    AppViewManagerUtils.prototype.dehydrateView = function (initView) {
	        var endViewOffset = initView.viewOffset +
	            initView.mainMergeMapping.nestedViewCountByViewIndex[initView.viewOffset];
	        for (var viewIdx = initView.viewOffset; viewIdx <= endViewOffset; viewIdx++) {
	            var currView = initView.views[viewIdx];
	            if (currView.hydrated()) {
	                if (lang_1.isPresent(currView.locals)) {
	                    currView.locals.clearValues();
	                }
	                currView.context = null;
	                currView.changeDetector.dehydrate();
	                var binders = currView.proto.elementBinders;
	                for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
	                    var eli = initView.elementInjectors[currView.elementOffset + binderIdx];
	                    if (lang_1.isPresent(eli)) {
	                        eli.dehydrate();
	                    }
	                }
	            }
	        }
	    };
	    AppViewManagerUtils = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], AppViewManagerUtils);
	    return AppViewManagerUtils;
	})();
	exports.AppViewManagerUtils = AppViewManagerUtils;
	//# sourceMappingURL=view_manager_utils.js.map

/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	var exceptions_1 = __webpack_require__(168);
	/**
	 * An opaque reference to the underlying element.
	 *
	 * The underlying native element is a DOM Element in a browser context, but may represent other
	 * types on other rendering platforms. In the browser the `ElementRef` can be sent to the Web
	 * Worker. Web Workers can not have references to the DOM Elements.
	 */
	var ElementRef = (function () {
	    function ElementRef(parentView, boundElementIndex, renderBoundElementIndex, _renderer) {
	        this._renderer = _renderer;
	        this.parentView = parentView;
	        this.boundElementIndex = boundElementIndex;
	        this.renderBoundElementIndex = renderBoundElementIndex;
	    }
	    Object.defineProperty(ElementRef.prototype, "renderView", {
	        /**
	         *
	         */
	        get: function () { return this.parentView.render; },
	        // TODO(tbosch): remove this once Typescript supports declaring interfaces
	        // that contain getters
	        // https://github.com/Microsoft/TypeScript/issues/3745
	        set: function (viewRef) { throw new exceptions_1.BaseException('Abstract setter'); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ElementRef.prototype, "nativeElement", {
	        /**
	         * Returns the native Element implementation.
	         *
	         * In the browser this represents the DOM element.
	         *
	         * The `nativeElement` can be used as an escape hatch when direct DOM manipulation is needed. Use
	         * this with caution, as it creates tight coupling between your application and the browser, which
	         * will not work in Web Workers.
	         *
	         * NOTE: This method will return null in the webworker scenario!
	         */
	        get: function () { return this._renderer.getNativeElementSync(this); },
	        enumerable: true,
	        configurable: true
	    });
	    return ElementRef;
	})();
	exports.ElementRef = ElementRef;
	//# sourceMappingURL=element_ref.js.map

/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	var view_ref_1 = __webpack_require__(384);
	/**
	 * Reference to a template within a component.
	 *
	 * Represents an opaque reference to the underlying template that can
	 * be instantiated using the {@link ViewContainerRef}.
	 */
	var TemplateRef = (function () {
	    function TemplateRef(elementRef) {
	        this.elementRef = elementRef;
	    }
	    TemplateRef.prototype._getProtoView = function () {
	        var parentView = view_ref_1.internalView(this.elementRef.parentView);
	        return parentView.proto
	            .elementBinders[this.elementRef.boundElementIndex - parentView.elementOffset]
	            .nestedProtoView;
	    };
	    Object.defineProperty(TemplateRef.prototype, "protoViewRef", {
	        get: function () { return this._getProtoView().ref; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Whether this template has a local variable with the given name
	     */
	    TemplateRef.prototype.hasLocal = function (name) { return this._getProtoView().variableBindings.has(name); };
	    return TemplateRef;
	})();
	exports.TemplateRef = TemplateRef;
	//# sourceMappingURL=template_ref.js.map

/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var di_1 = __webpack_require__(160);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	exports.APP_VIEW_POOL_CAPACITY = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppViewPool.viewPoolCapacity'));
	var AppViewPool = (function () {
	    function AppViewPool(poolCapacityPerProtoView) {
	        this._pooledViewsPerProtoView = new collection_1.Map();
	        this._poolCapacityPerProtoView = poolCapacityPerProtoView;
	    }
	    AppViewPool.prototype.getView = function (protoView) {
	        var pooledViews = this._pooledViewsPerProtoView.get(protoView);
	        if (lang_1.isPresent(pooledViews) && pooledViews.length > 0) {
	            return collection_1.ListWrapper.removeLast(pooledViews);
	        }
	        return null;
	    };
	    AppViewPool.prototype.returnView = function (view) {
	        var protoView = view.proto;
	        var pooledViews = this._pooledViewsPerProtoView.get(protoView);
	        if (lang_1.isBlank(pooledViews)) {
	            pooledViews = [];
	            this._pooledViewsPerProtoView.set(protoView, pooledViews);
	        }
	        var haveRemainingCapacity = pooledViews.length < this._poolCapacityPerProtoView;
	        if (haveRemainingCapacity) {
	            pooledViews.push(view);
	        }
	        return haveRemainingCapacity;
	    };
	    AppViewPool = __decorate([
	        di_1.Injectable(),
	        __param(0, di_1.Inject(exports.APP_VIEW_POOL_CAPACITY)), 
	        __metadata('design:paramtypes', [Object])
	    ], AppViewPool);
	    return AppViewPool;
	})();
	exports.AppViewPool = AppViewPool;
	//# sourceMappingURL=view_pool.js.map

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	/**
	 * Listener for view creation / destruction.
	 */
	var AppViewListener = (function () {
	    function AppViewListener() {
	    }
	    AppViewListener.prototype.viewCreated = function (view) { };
	    AppViewListener.prototype.viewDestroyed = function (view) { };
	    AppViewListener = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], AppViewListener);
	    return AppViewListener;
	})();
	exports.AppViewListener = AppViewListener;
	//# sourceMappingURL=view_listener.js.map

/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var view_ref_1 = __webpack_require__(384);
	/**
	 * A location where {@link ViewRef}s can be attached.
	 *
	 * A `ViewContainerRef` represents a location in a {@link ViewRef} where other child
	 * {@link ViewRef}s can be inserted. Adding and removing views is the only way of structurally
	 * changing the rendered DOM of the application.
	 */
	var ViewContainerRef = (function () {
	    /**
	     * @private
	     */
	    function ViewContainerRef(viewManager, element) {
	        this.viewManager = viewManager;
	        this.element = element;
	    }
	    ViewContainerRef.prototype._getViews = function () {
	        var vc = view_ref_1.internalView(this.element.parentView).viewContainers[this.element.boundElementIndex];
	        return lang_1.isPresent(vc) ? vc.views : [];
	    };
	    /**
	     * Remove all {@link ViewRef}s at current location.
	     */
	    ViewContainerRef.prototype.clear = function () {
	        for (var i = this.length - 1; i >= 0; i--) {
	            this.remove(i);
	        }
	    };
	    /**
	     * Return a {@link ViewRef} at specific index.
	     */
	    ViewContainerRef.prototype.get = function (index) { return this._getViews()[index].ref; };
	    Object.defineProperty(ViewContainerRef.prototype, "length", {
	        /**
	         * Returns number of {@link ViewRef}s currently attached at this location.
	         */
	        get: function () { return this._getViews().length; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create and insert a {@link ViewRef} into the view-container.
	     *
	     * - `protoViewRef` (optional) {@link ProtoViewRef} - The `ProtoView` to use for creating
	     *   `View` to be inserted at this location. If `ViewContainer` is created at a location
	     *   of inline template, then `protoViewRef` is the `ProtoView` of the template.
	     * - `atIndex` (optional) `number` - location of insertion point. (Or at the end if unspecified.)
	     * - `context` (optional) {@link ElementRef} - Context (for expression evaluation) from the
	     *   {@link ElementRef} location. (Or current context if unspecified.)
	     * - `bindings` (optional) Array of {@link ResolvedBinding} - Used for configuring
	     *   `ElementInjector`.
	     *
	     * Returns newly created {@link ViewRef}.
	     */
	    // TODO(rado): profile and decide whether bounds checks should be added
	    // to the methods below.
	    ViewContainerRef.prototype.createEmbeddedView = function (templateRef, atIndex) {
	        if (atIndex === void 0) { atIndex = -1; }
	        if (atIndex == -1)
	            atIndex = this.length;
	        return this.viewManager.createEmbeddedViewInContainer(this.element, atIndex, templateRef);
	    };
	    ViewContainerRef.prototype.createHostView = function (protoViewRef, atIndex, dynamicallyCreatedBindings) {
	        if (protoViewRef === void 0) { protoViewRef = null; }
	        if (atIndex === void 0) { atIndex = -1; }
	        if (dynamicallyCreatedBindings === void 0) { dynamicallyCreatedBindings = null; }
	        if (atIndex == -1)
	            atIndex = this.length;
	        return this.viewManager.createHostViewInContainer(this.element, atIndex, protoViewRef, dynamicallyCreatedBindings);
	    };
	    /**
	     * Insert a {@link ViewRef} at specefic index.
	     *
	     * The index is location at which the {@link ViewRef} should be attached. If omitted it is
	     * inserted at the end.
	     *
	     * Returns the inserted {@link ViewRef}.
	     */
	    ViewContainerRef.prototype.insert = function (viewRef, atIndex) {
	        if (atIndex === void 0) { atIndex = -1; }
	        if (atIndex == -1)
	            atIndex = this.length;
	        return this.viewManager.attachViewInContainer(this.element, atIndex, viewRef);
	    };
	    /**
	     * Return the index of already inserted {@link ViewRef}.
	     */
	    ViewContainerRef.prototype.indexOf = function (viewRef) {
	        return collection_1.ListWrapper.indexOf(this._getViews(), view_ref_1.internalView(viewRef));
	    };
	    /**
	     * Remove a {@link ViewRef} at specific index.
	     *
	     * If the index is omitted last {@link ViewRef} is removed.
	     */
	    ViewContainerRef.prototype.remove = function (atIndex) {
	        if (atIndex === void 0) { atIndex = -1; }
	        if (atIndex == -1)
	            atIndex = this.length - 1;
	        this.viewManager.destroyViewInContainer(this.element, atIndex);
	        // view is intentionally not returned to the client.
	    };
	    /**
	     * The method can be used together with insert to implement a view move, i.e.
	     * moving the dom nodes while the directives in the view stay intact.
	     */
	    ViewContainerRef.prototype.detach = function (atIndex) {
	        if (atIndex === void 0) { atIndex = -1; }
	        if (atIndex == -1)
	            atIndex = this.length - 1;
	        return this.viewManager.detachViewInContainer(this.element, atIndex);
	    };
	    return ViewContainerRef;
	})();
	exports.ViewContainerRef = ViewContainerRef;
	//# sourceMappingURL=view_container_ref.js.map

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var Interfaces = __webpack_require__(378);
	function hasLifecycleHook(lcInterface, type) {
	    if (!(type instanceof lang_1.Type))
	        return false;
	    var proto = type.prototype;
	    switch (lcInterface) {
	        case Interfaces.AfterContentInit:
	            return !!proto.afterContentInit;
	        case Interfaces.AfterContentChecked:
	            return !!proto.afterContentChecked;
	        case Interfaces.AfterViewInit:
	            return !!proto.afterViewInit;
	        case Interfaces.AfterViewChecked:
	            return !!proto.afterViewChecked;
	        case Interfaces.OnChanges:
	            return !!proto.onChanges;
	        case Interfaces.DoCheck:
	            return !!proto.doCheck;
	        case Interfaces.OnDestroy:
	            return !!proto.onDestroy;
	        case Interfaces.OnInit:
	            return !!proto.onInit;
	        default:
	            return false;
	    }
	}
	exports.hasLifecycleHook = hasLifecycleHook;
	//# sourceMappingURL=directive_lifecycle_reflector.js.map

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	/**
	 * An iterable and observable live list of components in the DOM.
	 *
	 * A QueryList contains a live list of child directives in the DOM of a directive.
	 * The directives are kept in depth-first pre-order traversal of the DOM.
	 *
	 * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop
	 * as well as in template with `*ng-for="of"` directive.
	 *
	 * QueryList is updated as part of the change-detection cycle of a directive. Since change detection
	 * happens after construction of a directive, QueryList will always be empty when observed in the
	 * constructor.
	 *
	 *
	 * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain
	 * list of observable callbacks.
	 *
	 * # Example:
	 *
	 * Assume that `<tabs>` component would like to get a list its children which are `<pane>`
	 * components as shown in this example:
	 *
	 * ```html
	 * <tabs>
	 *   <pane title="Overview">...</pane>
	 *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
	 * </tabs>
	 * ```
	 *
	 * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so
	 * that it could render tabs with the correct titles and in the correct order.
	 *
	 * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself
	 * with `<tabs>` component's on `hydrate` and deregister on `dehydrate` event. While a reasonable
	 * approach, this would only work partially since `*ng-for` could rearrange the list of `<pane>`
	 * components which would not be reported to `<tabs>` component and thus the list of `<pane>`
	 * components would be out of sync with respect to the list of `<pane>` elements.
	 *
	 * A preferred solution is to inject a `QueryList` which is a live list of directives in the
	 * component`s light DOM.
	 *
	 * ```javascript
	 * @Component({
	 *   selector: 'tabs'
	 * })
	 * @View({
	 *  template: `
	 *    <ul>
	 *      <li *ng-for="#pane of panes">{{pane.title}}</li>
	 *    </ul>
	 *    <content></content>
	 *  `
	 * })
	 * class Tabs {
	 *   panes: QueryList<Pane>
	 *
	 *   constructor(@Query(Pane) panes:QueryList<Pane>) {
	 *     this.panes = panes;
	 *   }
	 * }
	 *
	 * @Component({
	 *   selector: 'pane',
	 *   properties: ['title']
	 * })
	 * @View(...)
	 * class Pane {
	 *   title:string;
	 * }
	 * ```
	 */
	var QueryList = (function () {
	    function QueryList() {
	        this._results = [];
	        this._callbacks = [];
	        this._dirty = false;
	    }
	    QueryList.prototype.reset = function (newList) {
	        this._results = newList;
	        this._dirty = true;
	    };
	    QueryList.prototype.add = function (obj) {
	        this._results.push(obj);
	        this._dirty = true;
	    };
	    QueryList.prototype.onChange = function (callback) { this._callbacks.push(callback); };
	    QueryList.prototype.removeCallback = function (callback) { collection_1.ListWrapper.remove(this._callbacks, callback); };
	    QueryList.prototype.removeAllCallbacks = function () { this._callbacks = []; };
	    QueryList.prototype.toString = function () { return this._results.toString(); };
	    Object.defineProperty(QueryList.prototype, "length", {
	        get: function () { return this._results.length; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "first", {
	        get: function () { return collection_1.ListWrapper.first(this._results); },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(QueryList.prototype, "last", {
	        get: function () { return collection_1.ListWrapper.last(this._results); },
	        enumerable: true,
	        configurable: true
	    });
	    QueryList.prototype.map = function (fn) { return this._results.map(fn); };
	    QueryList.prototype[Symbol.iterator] = function () { return this._results[Symbol.iterator](); };
	    // Internal to the framework.
	    QueryList.prototype.fireCallbacks = function () {
	        if (this._dirty) {
	            collection_1.ListWrapper.forEach(this._callbacks, function (c) { return c(); });
	            this._dirty = false;
	        }
	    };
	    return QueryList;
	})();
	exports.QueryList = QueryList;
	//# sourceMappingURL=query_list.js.map

/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	exports.EVENT_TARGET_SEPARATOR = ':';
	var EventConfig = (function () {
	    function EventConfig(fieldName, eventName, isLongForm) {
	        this.fieldName = fieldName;
	        this.eventName = eventName;
	        this.isLongForm = isLongForm;
	    }
	    EventConfig.parse = function (eventConfig) {
	        var fieldName = eventConfig, eventName = eventConfig, isLongForm = false;
	        var separatorIdx = eventConfig.indexOf(exports.EVENT_TARGET_SEPARATOR);
	        if (separatorIdx > -1) {
	            // long format: 'fieldName: eventName'
	            fieldName = lang_1.StringWrapper.substring(eventConfig, 0, separatorIdx).trim();
	            eventName = lang_1.StringWrapper.substring(eventConfig, separatorIdx + 1).trim();
	            isLongForm = true;
	        }
	        return new EventConfig(fieldName, eventName, isLongForm);
	    };
	    EventConfig.prototype.getFullName = function () {
	        return this.isLongForm ? "" + this.fieldName + exports.EVENT_TARGET_SEPARATOR + this.eventName :
	            this.eventName;
	    };
	    return EventConfig;
	})();
	exports.EventConfig = EventConfig;
	//# sourceMappingURL=event_config.js.map

/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var view_1 = __webpack_require__(211);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var reflection_1 = __webpack_require__(170);
	var ViewResolver = (function () {
	    function ViewResolver() {
	        this._cache = new collection_1.Map();
	    }
	    ViewResolver.prototype.resolve = function (component) {
	        var view = this._cache.get(component);
	        if (lang_1.isBlank(view)) {
	            view = this._resolve(component);
	            this._cache.set(component, view);
	        }
	        return view;
	    };
	    ViewResolver.prototype._resolve = function (component) {
	        var annotations = reflection_1.reflector.annotations(component);
	        for (var i = 0; i < annotations.length; i++) {
	            var annotation = annotations[i];
	            if (annotation instanceof view_1.ViewMetadata) {
	                return annotation;
	            }
	        }
	        throw new exceptions_1.BaseException("No View annotation found on component " + lang_1.stringify(component));
	    };
	    ViewResolver = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], ViewResolver);
	    return ViewResolver;
	})();
	exports.ViewResolver = ViewResolver;
	//# sourceMappingURL=view_resolver.js.map

/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var metadata_1 = __webpack_require__(157);
	var reflection_1 = __webpack_require__(170);
	/**
	 * Resolve a `Type` for {@link PipeMetadata}.
	 *
	 * This interface can be overridden by the application developer to create custom behavior.
	 *
	 * See {@link Compiler}
	 */
	var PipeResolver = (function () {
	    function PipeResolver() {
	    }
	    /**
	     * Return {@link PipeMetadata} for a given `Type`.
	     */
	    PipeResolver.prototype.resolve = function (type) {
	        var metas = reflection_1.reflector.annotations(di_1.resolveForwardRef(type));
	        if (lang_1.isPresent(metas)) {
	            for (var i = 0; i < metas.length; i++) {
	                var annotation = metas[i];
	                if (annotation instanceof metadata_1.PipeMetadata) {
	                    return annotation;
	                }
	            }
	        }
	        throw new exceptions_1.BaseException("No Pipe decorator found on " + lang_1.stringify(type));
	    };
	    PipeResolver = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], PipeResolver);
	    return PipeResolver;
	})();
	exports.PipeResolver = PipeResolver;
	//# sourceMappingURL=pipe_resolver.js.map

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var reflection_1 = __webpack_require__(170);
	var change_detection_1 = __webpack_require__(179);
	var pipes_1 = __webpack_require__(354);
	var api_1 = __webpack_require__(212);
	var view_1 = __webpack_require__(382);
	var element_injector_1 = __webpack_require__(387);
	var BindingRecordsCreator = (function () {
	    function BindingRecordsCreator() {
	        this._directiveRecordsMap = new Map();
	    }
	    BindingRecordsCreator.prototype.getEventBindingRecords = function (elementBinders, allDirectiveMetadatas) {
	        var res = [];
	        for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
	            var renderElementBinder = elementBinders[boundElementIndex];
	            this._createTemplateEventRecords(res, renderElementBinder, boundElementIndex);
	            this._createHostEventRecords(res, renderElementBinder, allDirectiveMetadatas, boundElementIndex);
	        }
	        return res;
	    };
	    BindingRecordsCreator.prototype._createTemplateEventRecords = function (res, renderElementBinder, boundElementIndex) {
	        renderElementBinder.eventBindings.forEach(function (eb) {
	            res.push(change_detection_1.BindingRecord.createForEvent(eb.source, eb.fullName, boundElementIndex));
	        });
	    };
	    BindingRecordsCreator.prototype._createHostEventRecords = function (res, renderElementBinder, allDirectiveMetadatas, boundElementIndex) {
	        for (var i = 0; i < renderElementBinder.directives.length; ++i) {
	            var dir = renderElementBinder.directives[i];
	            var directiveMetadata = allDirectiveMetadatas[dir.directiveIndex];
	            var dirRecord = this._getDirectiveRecord(boundElementIndex, i, directiveMetadata);
	            dir.eventBindings.forEach(function (heb) {
	                res.push(change_detection_1.BindingRecord.createForHostEvent(heb.source, heb.fullName, dirRecord));
	            });
	        }
	    };
	    BindingRecordsCreator.prototype.getPropertyBindingRecords = function (textBindings, elementBinders, allDirectiveMetadatas) {
	        var bindings = [];
	        this._createTextNodeRecords(bindings, textBindings);
	        for (var boundElementIndex = 0; boundElementIndex < elementBinders.length; boundElementIndex++) {
	            var renderElementBinder = elementBinders[boundElementIndex];
	            this._createElementPropertyRecords(bindings, boundElementIndex, renderElementBinder);
	            this._createDirectiveRecords(bindings, boundElementIndex, renderElementBinder.directives, allDirectiveMetadatas);
	        }
	        return bindings;
	    };
	    BindingRecordsCreator.prototype.getDirectiveRecords = function (elementBinders, allDirectiveMetadatas) {
	        var directiveRecords = [];
	        for (var elementIndex = 0; elementIndex < elementBinders.length; ++elementIndex) {
	            var dirs = elementBinders[elementIndex].directives;
	            for (var dirIndex = 0; dirIndex < dirs.length; ++dirIndex) {
	                directiveRecords.push(this._getDirectiveRecord(elementIndex, dirIndex, allDirectiveMetadatas[dirs[dirIndex].directiveIndex]));
	            }
	        }
	        return directiveRecords;
	    };
	    BindingRecordsCreator.prototype._createTextNodeRecords = function (bindings, textBindings) {
	        for (var i = 0; i < textBindings.length; i++) {
	            bindings.push(change_detection_1.BindingRecord.createForTextNode(textBindings[i], i));
	        }
	    };
	    BindingRecordsCreator.prototype._createElementPropertyRecords = function (bindings, boundElementIndex, renderElementBinder) {
	        collection_1.ListWrapper.forEach(renderElementBinder.propertyBindings, function (binding) {
	            if (binding.type === api_1.PropertyBindingType.PROPERTY) {
	                bindings.push(change_detection_1.BindingRecord.createForElementProperty(binding.astWithSource, boundElementIndex, binding.property));
	            }
	            else if (binding.type === api_1.PropertyBindingType.ATTRIBUTE) {
	                bindings.push(change_detection_1.BindingRecord.createForElementAttribute(binding.astWithSource, boundElementIndex, binding.property));
	            }
	            else if (binding.type === api_1.PropertyBindingType.CLASS) {
	                bindings.push(change_detection_1.BindingRecord.createForElementClass(binding.astWithSource, boundElementIndex, binding.property));
	            }
	            else if (binding.type === api_1.PropertyBindingType.STYLE) {
	                bindings.push(change_detection_1.BindingRecord.createForElementStyle(binding.astWithSource, boundElementIndex, binding.property, binding.unit));
	            }
	        });
	    };
	    BindingRecordsCreator.prototype._createDirectiveRecords = function (bindings, boundElementIndex, directiveBinders, allDirectiveMetadatas) {
	        for (var i = 0; i < directiveBinders.length; i++) {
	            var directiveBinder = directiveBinders[i];
	            var directiveMetadata = allDirectiveMetadatas[directiveBinder.directiveIndex];
	            var directiveRecord = this._getDirectiveRecord(boundElementIndex, i, directiveMetadata);
	            // directive properties
	            collection_1.MapWrapper.forEach(directiveBinder.propertyBindings, function (astWithSource, propertyName) {
	                // TODO: these setters should eventually be created by change detection, to make
	                // it monomorphic!
	                var setter = reflection_1.reflector.setter(propertyName);
	                bindings.push(change_detection_1.BindingRecord.createForDirective(astWithSource, propertyName, setter, directiveRecord));
	            });
	            if (directiveRecord.callOnChanges) {
	                bindings.push(change_detection_1.BindingRecord.createDirectiveOnChanges(directiveRecord));
	            }
	            if (directiveRecord.callOnInit) {
	                bindings.push(change_detection_1.BindingRecord.createDirectiveOnInit(directiveRecord));
	            }
	            if (directiveRecord.callDoCheck) {
	                bindings.push(change_detection_1.BindingRecord.createDirectiveDoCheck(directiveRecord));
	            }
	        }
	        for (var i = 0; i < directiveBinders.length; i++) {
	            var directiveBinder = directiveBinders[i];
	            // host properties
	            collection_1.ListWrapper.forEach(directiveBinder.hostPropertyBindings, function (binding) {
	                var dirIndex = new change_detection_1.DirectiveIndex(boundElementIndex, i);
	                if (binding.type === api_1.PropertyBindingType.PROPERTY) {
	                    bindings.push(change_detection_1.BindingRecord.createForHostProperty(dirIndex, binding.astWithSource, binding.property));
	                }
	                else if (binding.type === api_1.PropertyBindingType.ATTRIBUTE) {
	                    bindings.push(change_detection_1.BindingRecord.createForHostAttribute(dirIndex, binding.astWithSource, binding.property));
	                }
	                else if (binding.type === api_1.PropertyBindingType.CLASS) {
	                    bindings.push(change_detection_1.BindingRecord.createForHostClass(dirIndex, binding.astWithSource, binding.property));
	                }
	                else if (binding.type === api_1.PropertyBindingType.STYLE) {
	                    bindings.push(change_detection_1.BindingRecord.createForHostStyle(dirIndex, binding.astWithSource, binding.property, binding.unit));
	                }
	            });
	        }
	    };
	    BindingRecordsCreator.prototype._getDirectiveRecord = function (boundElementIndex, directiveIndex, directiveMetadata) {
	        var id = boundElementIndex * 100 + directiveIndex;
	        if (!this._directiveRecordsMap.has(id)) {
	            this._directiveRecordsMap.set(id, new change_detection_1.DirectiveRecord({
	                directiveIndex: new change_detection_1.DirectiveIndex(boundElementIndex, directiveIndex),
	                callAfterContentInit: directiveMetadata.callAfterContentInit,
	                callAfterContentChecked: directiveMetadata.callAfterContentChecked,
	                callAfterViewInit: directiveMetadata.callAfterViewInit,
	                callAfterViewChecked: directiveMetadata.callAfterViewChecked,
	                callOnChanges: directiveMetadata.callOnChanges,
	                callDoCheck: directiveMetadata.callDoCheck,
	                callOnInit: directiveMetadata.callOnInit,
	                changeDetection: directiveMetadata.changeDetection
	            }));
	        }
	        return this._directiveRecordsMap.get(id);
	    };
	    return BindingRecordsCreator;
	})();
	exports.BindingRecordsCreator = BindingRecordsCreator;
	var ProtoViewFactory = (function () {
	    /**
	     * @private
	     */
	    function ProtoViewFactory(_changeDetection) {
	        this._changeDetection = _changeDetection;
	    }
	    ProtoViewFactory.prototype.createAppProtoViews = function (hostComponentBinding, rootRenderProtoView, allDirectives, pipes) {
	        var allRenderDirectiveMetadata = collection_1.ListWrapper.map(allDirectives, function (directiveBinding) { return directiveBinding.metadata; });
	        var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
	        var nestedPvVariableBindings = _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex);
	        var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex);
	        var protoChangeDetectors = this._getProtoChangeDetectors(hostComponentBinding, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata);
	        var appProtoViews = collection_1.ListWrapper.createFixedSize(nestedPvsWithIndex.length);
	        collection_1.ListWrapper.forEach(nestedPvsWithIndex, function (pvWithIndex) {
	            var appProtoView = _createAppProtoView(pvWithIndex.renderProtoView, protoChangeDetectors[pvWithIndex.index], nestedPvVariableBindings[pvWithIndex.index], allDirectives, pipes);
	            if (lang_1.isPresent(pvWithIndex.parentIndex)) {
	                var parentView = appProtoViews[pvWithIndex.parentIndex];
	                parentView.elementBinders[pvWithIndex.boundElementIndex].nestedProtoView = appProtoView;
	            }
	            appProtoViews[pvWithIndex.index] = appProtoView;
	        });
	        return appProtoViews;
	    };
	    ProtoViewFactory.prototype._getProtoChangeDetectors = function (hostComponentBinding, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata) {
	        var _this = this;
	        if (this._changeDetection.generateDetectors) {
	            var changeDetectorDefs = _getChangeDetectorDefinitions(hostComponentBinding.metadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata, this._changeDetection.genConfig);
	            return changeDetectorDefs.map(function (changeDetectorDef) {
	                return _this._changeDetection.getProtoChangeDetector(changeDetectorDef.id, changeDetectorDef);
	            });
	        }
	        else {
	            var changeDetectorIds = _getChangeDetectorDefinitionIds(hostComponentBinding.metadata, nestedPvsWithIndex);
	            return changeDetectorIds.map(function (id) { return _this._changeDetection.getProtoChangeDetector(id, null); });
	        }
	    };
	    ProtoViewFactory = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [change_detection_1.ChangeDetection])
	    ], ProtoViewFactory);
	    return ProtoViewFactory;
	})();
	exports.ProtoViewFactory = ProtoViewFactory;
	/**
	 * Returns the data needed to create ChangeDetectors
	 * for the given ProtoView and all nested ProtoViews.
	 */
	function getChangeDetectorDefinitions(hostComponentMetadata, rootRenderProtoView, allRenderDirectiveMetadata, genConfig) {
	    var nestedPvsWithIndex = _collectNestedProtoViews(rootRenderProtoView);
	    var nestedPvVariableNames = _collectNestedProtoViewsVariableNames(nestedPvsWithIndex);
	    return _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata, genConfig);
	}
	exports.getChangeDetectorDefinitions = getChangeDetectorDefinitions;
	function _collectNestedProtoViews(renderProtoView, parentIndex, boundElementIndex, result) {
	    if (parentIndex === void 0) { parentIndex = null; }
	    if (boundElementIndex === void 0) { boundElementIndex = null; }
	    if (result === void 0) { result = null; }
	    if (lang_1.isBlank(result)) {
	        result = [];
	    }
	    // reserve the place in the array
	    result.push(new RenderProtoViewWithIndex(renderProtoView, result.length, parentIndex, boundElementIndex));
	    var currentIndex = result.length - 1;
	    var childBoundElementIndex = 0;
	    collection_1.ListWrapper.forEach(renderProtoView.elementBinders, function (elementBinder) {
	        if (lang_1.isPresent(elementBinder.nestedProtoView)) {
	            _collectNestedProtoViews(elementBinder.nestedProtoView, currentIndex, childBoundElementIndex, result);
	        }
	        childBoundElementIndex++;
	    });
	    return result;
	}
	function _getChangeDetectorDefinitions(hostComponentMetadata, nestedPvsWithIndex, nestedPvVariableNames, allRenderDirectiveMetadata, genConfig) {
	    return collection_1.ListWrapper.map(nestedPvsWithIndex, function (pvWithIndex) {
	        var elementBinders = pvWithIndex.renderProtoView.elementBinders;
	        var bindingRecordsCreator = new BindingRecordsCreator();
	        var propBindingRecords = bindingRecordsCreator.getPropertyBindingRecords(pvWithIndex.renderProtoView.textBindings, elementBinders, allRenderDirectiveMetadata);
	        var eventBindingRecords = bindingRecordsCreator.getEventBindingRecords(elementBinders, allRenderDirectiveMetadata);
	        var directiveRecords = bindingRecordsCreator.getDirectiveRecords(elementBinders, allRenderDirectiveMetadata);
	        var strategyName = change_detection_1.ChangeDetectionStrategy.Default;
	        if (pvWithIndex.renderProtoView.type === api_1.ViewType.COMPONENT) {
	            strategyName = hostComponentMetadata.changeDetection;
	        }
	        var id = _protoViewId(hostComponentMetadata, pvWithIndex);
	        var variableNames = nestedPvVariableNames[pvWithIndex.index];
	        return new change_detection_1.ChangeDetectorDefinition(id, strategyName, variableNames, propBindingRecords, eventBindingRecords, directiveRecords, genConfig);
	    });
	}
	function _getChangeDetectorDefinitionIds(hostComponentMetadata, nestedPvsWithIndex) {
	    return nestedPvsWithIndex.map(function (pvWithIndex) { return _protoViewId(hostComponentMetadata, pvWithIndex); });
	}
	function _protoViewId(hostComponentMetadata, pvWithIndex) {
	    var typeString;
	    if (pvWithIndex.renderProtoView.type === api_1.ViewType.COMPONENT) {
	        typeString = 'comp';
	    }
	    else if (pvWithIndex.renderProtoView.type === api_1.ViewType.HOST) {
	        typeString = 'host';
	    }
	    else {
	        typeString = 'embedded';
	    }
	    return hostComponentMetadata.id + "_" + typeString + "_" + pvWithIndex.index;
	}
	function _createAppProtoView(renderProtoView, protoChangeDetector, variableBindings, allDirectives, pipes) {
	    var elementBinders = renderProtoView.elementBinders;
	    // Embedded ProtoViews that contain `<ng-content>` will be merged into their parents and use
	    // a RenderFragmentRef. I.e. renderProtoView.transitiveNgContentCount > 0.
	    var protoPipes = new pipes_1.ProtoPipes(pipes);
	    var protoView = new view_1.AppProtoView(renderProtoView.type, renderProtoView.transitiveNgContentCount > 0, renderProtoView.render, protoChangeDetector, variableBindings, createVariableLocations(elementBinders), renderProtoView.textBindings.length, protoPipes);
	    _createElementBinders(protoView, elementBinders, allDirectives);
	    return protoView;
	}
	function _collectNestedProtoViewsVariableBindings(nestedPvsWithIndex) {
	    return collection_1.ListWrapper.map(nestedPvsWithIndex, function (pvWithIndex) {
	        return _createVariableBindings(pvWithIndex.renderProtoView);
	    });
	}
	function _createVariableBindings(renderProtoView) {
	    var variableBindings = new Map();
	    collection_1.MapWrapper.forEach(renderProtoView.variableBindings, function (mappedName, varName) { variableBindings.set(varName, mappedName); });
	    return variableBindings;
	}
	function _collectNestedProtoViewsVariableNames(nestedPvsWithIndex) {
	    var nestedPvVariableNames = collection_1.ListWrapper.createFixedSize(nestedPvsWithIndex.length);
	    collection_1.ListWrapper.forEach(nestedPvsWithIndex, function (pvWithIndex) {
	        var parentVariableNames = lang_1.isPresent(pvWithIndex.parentIndex) ? nestedPvVariableNames[pvWithIndex.parentIndex] : null;
	        nestedPvVariableNames[pvWithIndex.index] =
	            _createVariableNames(parentVariableNames, pvWithIndex.renderProtoView);
	    });
	    return nestedPvVariableNames;
	}
	function _createVariableNames(parentVariableNames, renderProtoView) {
	    var res = lang_1.isBlank(parentVariableNames) ? [] : collection_1.ListWrapper.clone(parentVariableNames);
	    collection_1.MapWrapper.forEach(renderProtoView.variableBindings, function (mappedName, varName) { res.push(mappedName); });
	    collection_1.ListWrapper.forEach(renderProtoView.elementBinders, function (binder) {
	        collection_1.MapWrapper.forEach(binder.variableBindings, function (mappedName, varName) { res.push(mappedName); });
	    });
	    return res;
	}
	function createVariableLocations(elementBinders) {
	    var variableLocations = new Map();
	    for (var i = 0; i < elementBinders.length; i++) {
	        var binder = elementBinders[i];
	        collection_1.MapWrapper.forEach(binder.variableBindings, function (mappedName, varName) { variableLocations.set(mappedName, i); });
	    }
	    return variableLocations;
	}
	exports.createVariableLocations = createVariableLocations;
	function _createElementBinders(protoView, elementBinders, allDirectiveBindings) {
	    for (var i = 0; i < elementBinders.length; i++) {
	        var renderElementBinder = elementBinders[i];
	        var dirs = elementBinders[i].directives;
	        var parentPeiWithDistance = _findParentProtoElementInjectorWithDistance(i, protoView.elementBinders, elementBinders);
	        var directiveBindings = collection_1.ListWrapper.map(dirs, function (dir) { return allDirectiveBindings[dir.directiveIndex]; });
	        var componentDirectiveBinding = null;
	        if (directiveBindings.length > 0) {
	            if (directiveBindings[0].metadata.type === api_1.RenderDirectiveMetadata.COMPONENT_TYPE) {
	                componentDirectiveBinding = directiveBindings[0];
	            }
	        }
	        var protoElementInjector = _createProtoElementInjector(i, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings);
	        _createElementBinder(protoView, i, renderElementBinder, protoElementInjector, componentDirectiveBinding, directiveBindings);
	    }
	}
	function _findParentProtoElementInjectorWithDistance(binderIndex, elementBinders, renderElementBinders) {
	    var distance = 0;
	    do {
	        var renderElementBinder = renderElementBinders[binderIndex];
	        binderIndex = renderElementBinder.parentIndex;
	        if (binderIndex !== -1) {
	            distance += renderElementBinder.distanceToParent;
	            var elementBinder = elementBinders[binderIndex];
	            if (lang_1.isPresent(elementBinder.protoElementInjector)) {
	                return new ParentProtoElementInjectorWithDistance(elementBinder.protoElementInjector, distance);
	            }
	        }
	    } while (binderIndex !== -1);
	    return new ParentProtoElementInjectorWithDistance(null, 0);
	}
	function _createProtoElementInjector(binderIndex, parentPeiWithDistance, renderElementBinder, componentDirectiveBinding, directiveBindings) {
	    var protoElementInjector = null;
	    // Create a protoElementInjector for any element that either has bindings *or* has one
	    // or more var- defined *or* for <template> elements:
	    // - Elements with a var- defined need a their own element injector
	    //   so that, when hydrating, $implicit can be set to the element.
	    // - <template> elements need their own ElementInjector so that we can query their TemplateRef
	    var hasVariables = collection_1.MapWrapper.size(renderElementBinder.variableBindings) > 0;
	    if (directiveBindings.length > 0 || hasVariables ||
	        lang_1.isPresent(renderElementBinder.nestedProtoView)) {
	        var directiveVariableBindings = createDirectiveVariableBindings(renderElementBinder, directiveBindings);
	        protoElementInjector =
	            element_injector_1.ProtoElementInjector.create(parentPeiWithDistance.protoElementInjector, binderIndex, directiveBindings, lang_1.isPresent(componentDirectiveBinding), parentPeiWithDistance.distance, directiveVariableBindings);
	        protoElementInjector.attributes = renderElementBinder.readAttributes;
	    }
	    return protoElementInjector;
	}
	function _createElementBinder(protoView, boundElementIndex, renderElementBinder, protoElementInjector, componentDirectiveBinding, directiveBindings) {
	    var parent = null;
	    if (renderElementBinder.parentIndex !== -1) {
	        parent = protoView.elementBinders[renderElementBinder.parentIndex];
	    }
	    var elBinder = protoView.bindElement(parent, renderElementBinder.distanceToParent, protoElementInjector, componentDirectiveBinding);
	    // The view's locals needs to have a full set of variable names at construction time
	    // in order to prevent new variables from being set later in the lifecycle. Since we don't want
	    // to actually create variable bindings for the $implicit bindings, add to the
	    // protoLocals manually.
	    collection_1.MapWrapper.forEach(renderElementBinder.variableBindings, function (mappedName, varName) { protoView.protoLocals.set(mappedName, null); });
	    return elBinder;
	}
	function createDirectiveVariableBindings(renderElementBinder, directiveBindings) {
	    var directiveVariableBindings = new Map();
	    collection_1.MapWrapper.forEach(renderElementBinder.variableBindings, function (templateName, exportAs) {
	        var dirIndex = _findDirectiveIndexByExportAs(renderElementBinder, directiveBindings, exportAs);
	        directiveVariableBindings.set(templateName, dirIndex);
	    });
	    return directiveVariableBindings;
	}
	exports.createDirectiveVariableBindings = createDirectiveVariableBindings;
	function _findDirectiveIndexByExportAs(renderElementBinder, directiveBindings, exportAs) {
	    var matchedDirectiveIndex = null;
	    var matchedDirective;
	    for (var i = 0; i < directiveBindings.length; ++i) {
	        var directive = directiveBindings[i];
	        if (_directiveExportAs(directive) == exportAs) {
	            if (lang_1.isPresent(matchedDirective)) {
	                throw new exceptions_1.BaseException("More than one directive have exportAs = '" + exportAs + "'. Directives: [" + matchedDirective.displayName + ", " + directive.displayName + "]");
	            }
	            matchedDirectiveIndex = i;
	            matchedDirective = directive;
	        }
	    }
	    if (lang_1.isBlank(matchedDirective) && !lang_1.StringWrapper.equals(exportAs, "$implicit")) {
	        throw new exceptions_1.BaseException("Cannot find directive with exportAs = '" + exportAs + "'");
	    }
	    return matchedDirectiveIndex;
	}
	function _directiveExportAs(directive) {
	    var directiveExportAs = directive.metadata.exportAs;
	    if (lang_1.isBlank(directiveExportAs) &&
	        directive.metadata.type === api_1.RenderDirectiveMetadata.COMPONENT_TYPE) {
	        return "$implicit";
	    }
	    else {
	        return directiveExportAs;
	    }
	}
	var RenderProtoViewWithIndex = (function () {
	    function RenderProtoViewWithIndex(renderProtoView, index, parentIndex, boundElementIndex) {
	        this.renderProtoView = renderProtoView;
	        this.index = index;
	        this.parentIndex = parentIndex;
	        this.boundElementIndex = boundElementIndex;
	    }
	    return RenderProtoViewWithIndex;
	})();
	var ParentProtoElementInjectorWithDistance = (function () {
	    function ParentProtoElementInjectorWithDistance(protoElementInjector, distance) {
	        this.protoElementInjector = protoElementInjector;
	        this.distance = distance;
	    }
	    return ParentProtoElementInjectorWithDistance;
	})();
	//# sourceMappingURL=proto_view_factory.js.map

/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	/**
	 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
	 *
	 * This interface can be overridden by the application developer to create custom behavior.
	 *
	 * See {@link Compiler}
	 */
	var UrlResolver = (function () {
	    function UrlResolver() {
	    }
	    /**
	     * Resolves the `url` given the `baseUrl`:
	     * - when the `url` is null, the `baseUrl` is returned,
	     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
	     * `baseUrl` and `url`,
	     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
	     * returned as is (ignoring the `baseUrl`)
	     *
	     * @param {string} baseUrl
	     * @param {string} url
	     * @returns {string} the resolved URL
	     */
	    UrlResolver.prototype.resolve = function (baseUrl, url) { return _resolveUrl(baseUrl, url); };
	    UrlResolver = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], UrlResolver);
	    return UrlResolver;
	})();
	exports.UrlResolver = UrlResolver;
	// The code below is adapted from Traceur:
	// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js
	/**
	 * Builds a URI string from already-encoded parts.
	 *
	 * No encoding is performed.  Any component may be omitted as either null or
	 * undefined.
	 *
	 * @param {?string=} opt_scheme The scheme such as 'http'.
	 * @param {?string=} opt_userInfo The user name before the '@'.
	 * @param {?string=} opt_domain The domain such as 'www.google.com', already
	 *     URI-encoded.
	 * @param {(string|null)=} opt_port The port number.
	 * @param {?string=} opt_path The path, already URI-encoded.  If it is not
	 *     empty, it must begin with a slash.
	 * @param {?string=} opt_queryData The URI-encoded query data.
	 * @param {?string=} opt_fragment The URI-encoded fragment identifier.
	 * @return {string} The fully combined URI.
	 */
	function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {
	    var out = [];
	    if (lang_1.isPresent(opt_scheme)) {
	        out.push(opt_scheme + ':');
	    }
	    if (lang_1.isPresent(opt_domain)) {
	        out.push('//');
	        if (lang_1.isPresent(opt_userInfo)) {
	            out.push(opt_userInfo + '@');
	        }
	        out.push(opt_domain);
	        if (lang_1.isPresent(opt_port)) {
	            out.push(':' + opt_port);
	        }
	    }
	    if (lang_1.isPresent(opt_path)) {
	        out.push(opt_path);
	    }
	    if (lang_1.isPresent(opt_queryData)) {
	        out.push('?' + opt_queryData);
	    }
	    if (lang_1.isPresent(opt_fragment)) {
	        out.push('#' + opt_fragment);
	    }
	    return out.join('');
	}
	/**
	 * A regular expression for breaking a URI into its component parts.
	 *
	 * {@link http://www.gbiv.com/protocols/uri/rfc/rfc3986.html#RFC2234} says
	 * As the "first-match-wins" algorithm is identical to the "greedy"
	 * disambiguation method used by POSIX regular expressions, it is natural and
	 * commonplace to use a regular expression for parsing the potential five
	 * components of a URI reference.
	 *
	 * The following line is the regular expression for breaking-down a
	 * well-formed URI reference into its components.
	 *
	 * <pre>
	 * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?
	 *  12            3  4          5       6  7        8 9
	 * </pre>
	 *
	 * The numbers in the second line above are only to assist readability; they
	 * indicate the reference points for each subexpression (i.e., each paired
	 * parenthesis). We refer to the value matched for subexpression <n> as $<n>.
	 * For example, matching the above expression to
	 * <pre>
	 *     http://www.ics.uci.edu/pub/ietf/uri/#Related
	 * </pre>
	 * results in the following subexpression matches:
	 * <pre>
	 *    $1 = http:
	 *    $2 = http
	 *    $3 = //www.ics.uci.edu
	 *    $4 = www.ics.uci.edu
	 *    $5 = /pub/ietf/uri/
	 *    $6 = <undefined>
	 *    $7 = <undefined>
	 *    $8 = #Related
	 *    $9 = Related
	 * </pre>
	 * where <undefined> indicates that the component is not present, as is the
	 * case for the query component in the above example. Therefore, we can
	 * determine the value of the five components as
	 * <pre>
	 *    scheme    = $2
	 *    authority = $4
	 *    path      = $5
	 *    query     = $7
	 *    fragment  = $9
	 * </pre>
	 *
	 * The regular expression has been modified slightly to expose the
	 * userInfo, domain, and port separately from the authority.
	 * The modified version yields
	 * <pre>
	 *    $1 = http              scheme
	 *    $2 = <undefined>       userInfo -\
	 *    $3 = www.ics.uci.edu   domain     | authority
	 *    $4 = <undefined>       port     -/
	 *    $5 = /pub/ietf/uri/    path
	 *    $6 = <undefined>       query without ?
	 *    $7 = Related           fragment without #
	 * </pre>
	 * @type {!RegExp}
	 * @private
	 */
	var _splitRe = lang_1.RegExpWrapper.create('^' +
	    '(?:' +
	    '([^:/?#.]+)' +
	    // used by other URL parts such as :,
	    // ?, /, #, and .
	    ':)?' +
	    '(?://' +
	    '(?:([^/?#]*)@)?' +
	    '([\\w\\d\\-\\u0100-\\uffff.%]*)' +
	    // digits, dashes, dots, percent
	    // escapes, and unicode characters.
	    '(?::([0-9]+))?' +
	    ')?' +
	    '([^?#]+)?' +
	    '(?:\\?([^#]*))?' +
	    '(?:#(.*))?' +
	    '$');
	/**
	 * The index of each URI component in the return value of goog.uri.utils.split.
	 * @enum {number}
	 */
	var _ComponentIndex;
	(function (_ComponentIndex) {
	    _ComponentIndex[_ComponentIndex["Scheme"] = 1] = "Scheme";
	    _ComponentIndex[_ComponentIndex["UserInfo"] = 2] = "UserInfo";
	    _ComponentIndex[_ComponentIndex["Domain"] = 3] = "Domain";
	    _ComponentIndex[_ComponentIndex["Port"] = 4] = "Port";
	    _ComponentIndex[_ComponentIndex["Path"] = 5] = "Path";
	    _ComponentIndex[_ComponentIndex["QueryData"] = 6] = "QueryData";
	    _ComponentIndex[_ComponentIndex["Fragment"] = 7] = "Fragment";
	})(_ComponentIndex || (_ComponentIndex = {}));
	/**
	 * Splits a URI into its component parts.
	 *
	 * Each component can be accessed via the component indices; for example:
	 * <pre>
	 * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];
	 * </pre>
	 *
	 * @param {string} uri The URI string to examine.
	 * @return {!Array.<string|undefined>} Each component still URI-encoded.
	 *     Each component that is present will contain the encoded value, whereas
	 *     components that are not present will be undefined or empty, depending
	 *     on the browser's regular expression implementation.  Never null, since
	 *     arbitrary strings may still look like path names.
	 */
	function _split(uri) {
	    return lang_1.RegExpWrapper.firstMatch(_splitRe, uri);
	}
	/**
	  * Removes dot segments in given path component, as described in
	  * RFC 3986, section 5.2.4.
	  *
	  * @param {string} path A non-empty path component.
	  * @return {string} Path component with removed dot segments.
	  */
	function _removeDotSegments(path) {
	    if (path == '/')
	        return '/';
	    var leadingSlash = path[0] == '/' ? '/' : '';
	    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';
	    var segments = path.split('/');
	    var out = [];
	    var up = 0;
	    for (var pos = 0; pos < segments.length; pos++) {
	        var segment = segments[pos];
	        switch (segment) {
	            case '':
	            case '.':
	                break;
	            case '..':
	                if (out.length > 0) {
	                    collection_1.ListWrapper.removeAt(out, out.length - 1);
	                }
	                else {
	                    up++;
	                }
	                break;
	            default:
	                out.push(segment);
	        }
	    }
	    if (leadingSlash == '') {
	        while (up-- > 0) {
	            collection_1.ListWrapper.insert(out, 0, '..');
	        }
	        if (out.length === 0)
	            out.push('.');
	    }
	    return leadingSlash + out.join('/') + trailingSlash;
	}
	/**
	 * Takes an array of the parts from split and canonicalizes the path part
	 * and then joins all the parts.
	 * @param {Array.<string?>} parts
	 * @return {string}
	 */
	function _joinAndCanonicalizePath(parts) {
	    var path = parts[_ComponentIndex.Path];
	    path = lang_1.isBlank(path) ? '' : _removeDotSegments(path);
	    parts[_ComponentIndex.Path] = path;
	    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);
	}
	/**
	 * Resolves a URL.
	 * @param {string} base The URL acting as the base URL.
	 * @param {string} to The URL to resolve.
	 * @return {string}
	 */
	function _resolveUrl(base, url) {
	    var parts = _split(encodeURI(url));
	    var baseParts = _split(base);
	    if (lang_1.isPresent(parts[_ComponentIndex.Scheme])) {
	        return _joinAndCanonicalizePath(parts);
	    }
	    else {
	        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];
	    }
	    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {
	        if (lang_1.isBlank(parts[i])) {
	            parts[i] = baseParts[i];
	        }
	    }
	    if (parts[_ComponentIndex.Path][0] == '/') {
	        return _joinAndCanonicalizePath(parts);
	    }
	    var path = baseParts[_ComponentIndex.Path];
	    if (lang_1.isBlank(path))
	        path = '/';
	    var index = path.lastIndexOf('/');
	    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];
	    parts[_ComponentIndex.Path] = path;
	    return _joinAndCanonicalizePath(parts);
	}
	//# sourceMappingURL=url_resolver.js.map

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	/**
	 * Specifies app root url for the application.
	 *
	 * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
	 *
	 * This interface can be overridden by the application developer to create custom behavior.
	 *
	 * See {@link Compiler}
	 */
	var AppRootUrl = (function () {
	    function AppRootUrl(value) {
	        this._value = value;
	    }
	    Object.defineProperty(AppRootUrl.prototype, "value", {
	        /**
	         * Returns the base URL of the currently running application.
	         */
	        get: function () { return this._value; },
	        set: function (value) { this._value = value; },
	        enumerable: true,
	        configurable: true
	    });
	    AppRootUrl = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [String])
	    ], AppRootUrl);
	    return AppRootUrl;
	})();
	exports.AppRootUrl = AppRootUrl;
	//# sourceMappingURL=app_root_url.js.map

/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var compiler_1 = __webpack_require__(381);
	var view_manager_1 = __webpack_require__(388);
	/**
	 * Angular's reference to a component instance.
	 *
	 * `ComponentRef` represents a component instance lifecycle and meta information.
	 */
	var ComponentRef = (function () {
	    /**
	     * @private
	     */
	    function ComponentRef(location, instance, _dispose) {
	        this._dispose = _dispose;
	        this.location = location;
	        this.instance = instance;
	    }
	    Object.defineProperty(ComponentRef.prototype, "hostView", {
	        /**
	         * Returns the host {@link ViewRef}.
	         */
	        get: function () { return this.location.parentView; },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Dispose of the component instance.
	     */
	    ComponentRef.prototype.dispose = function () { this._dispose(); };
	    return ComponentRef;
	})();
	exports.ComponentRef = ComponentRef;
	/**
	 * Service for dynamically loading a Component into an arbitrary position in the internal Angular
	 * application tree.
	 */
	var DynamicComponentLoader = (function () {
	    function DynamicComponentLoader(_compiler, _viewManager) {
	        this._compiler = _compiler;
	        this._viewManager = _viewManager;
	    }
	    /**
	     * Loads a root component that is placed at the first element that matches the component's
	     * selector.
	     *
	     * - `typeOrBinding` `Type` \ {@link Binding} - representing the component to load.
	     * - `overrideSelector` (optional) selector to load the component at (or use
	     *   `@Component.selector`) The selector can be anywhere (i.e. outside the current component.)
	     * - `injector` {@link Injector} - optional injector to use for the component.
	     *
	     * The loaded component receives injection normally as a hosted view.
	     *
	     *
	     * ## Example
	     *
	     * ```
	     * @ng.Component({
	     *   selector: 'child-component'
	     * })
	     * @ng.View({
	     *   template: 'Child'
	     * })
	     * class ChildComponent {
	     * }
	     *
	     *
	     *
	     * @ng.Component({
	     *   selector: 'my-app'
	     * })
	     * @ng.View({
	     *   template: `
	     *     Parent (<child id="child"></child>)
	     *   `
	     * })
	     * class MyApp {
	     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, injector: ng.Injector) {
	     *     dynamicComponentLoader.loadAsRoot(ChildComponent, '#child', injector);
	     *   }
	     * }
	     *
	     * ng.bootstrap(MyApp);
	     * ```
	     *
	     * Resulting DOM:
	     *
	     * ```
	     * <my-app>
	     *   Parent (
	     *     <child id="child">
	     *        Child
	     *     </child>
	     *   )
	     * </my-app>
	     * ```
	     */
	    DynamicComponentLoader.prototype.loadAsRoot = function (typeOrBinding, overrideSelector, injector) {
	        var _this = this;
	        return this._compiler.compileInHost(typeOrBinding)
	            .then(function (hostProtoViewRef) {
	            var hostViewRef = _this._viewManager.createRootHostView(hostProtoViewRef, overrideSelector, injector);
	            var newLocation = _this._viewManager.getHostElement(hostViewRef);
	            var component = _this._viewManager.getComponent(newLocation);
	            var dispose = function () { _this._viewManager.destroyRootHostView(hostViewRef); };
	            return new ComponentRef(newLocation, component, dispose);
	        });
	    };
	    /**
	     * Loads a component into the component view of the provided ElementRef next to the element
	     * with the given name.
	     *
	     * The loaded component receives injection normally as a hosted view.
	     *
	     * ## Example
	     *
	     * ```
	     * @ng.Component({
	     *   selector: 'child-component'
	     * })
	     * @ng.View({
	     *   template: 'Child'
	     * })
	     * class ChildComponent {
	     * }
	     *
	     *
	     * @ng.Component({
	     *   selector: 'my-app'
	     * })
	     * @ng.View({
	     *   template: `
	     *     Parent (<div #child></div>)
	     *   `
	     * })
	     * class MyApp {
	     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, elementRef: ng.ElementRef) {
	     *     dynamicComponentLoader.loadIntoLocation(ChildComponent, elementRef, 'child');
	     *   }
	     * }
	     *
	     * ng.bootstrap(MyApp);
	     * ```
	     *
	     * Resulting DOM:
	     *
	     * ```
	     * <my-app>
	     *    Parent (
	     *      <div #child="" class="ng-binding"></div>
	     *      <child-component class="ng-binding">Child</child-component>
	     *    )
	     * </my-app>
	     * ```
	     */
	    DynamicComponentLoader.prototype.loadIntoLocation = function (typeOrBinding, hostLocation, anchorName, bindings) {
	        if (bindings === void 0) { bindings = null; }
	        return this.loadNextToLocation(typeOrBinding, this._viewManager.getNamedElementInComponentView(hostLocation, anchorName), bindings);
	    };
	    /**
	     * Loads a component next to the provided ElementRef.
	     *
	     * The loaded component receives injection normally as a hosted view.
	     *
	     *
	     * ## Example
	     *
	     * ```
	     * @ng.Component({
	     *   selector: 'child-component'
	     * })
	     * @ng.View({
	     *   template: 'Child'
	     * })
	     * class ChildComponent {
	     * }
	     *
	     *
	     * @ng.Component({
	     *   selector: 'my-app'
	     * })
	     * @ng.View({
	     *   template: `Parent`
	     * })
	     * class MyApp {
	     *   constructor(dynamicComponentLoader: ng.DynamicComponentLoader, elementRef: ng.ElementRef) {
	     *     dynamicComponentLoader.loadIntoLocation(ChildComponent, elementRef, 'child');
	     *   }
	     * }
	     *
	     * ng.bootstrap(MyApp);
	     * ```
	     *
	     * Resulting DOM:
	     *
	     * ```
	     * <my-app>Parent</my-app>
	     * <child-component>Child</child-component>
	     * ```
	     */
	    DynamicComponentLoader.prototype.loadNextToLocation = function (typeOrBinding, location, bindings) {
	        var _this = this;
	        if (bindings === void 0) { bindings = null; }
	        return this._compiler.compileInHost(typeOrBinding)
	            .then(function (hostProtoViewRef) {
	            var viewContainer = _this._viewManager.getViewContainer(location);
	            var hostViewRef = viewContainer.createHostView(hostProtoViewRef, viewContainer.length, bindings);
	            var newLocation = _this._viewManager.getHostElement(hostViewRef);
	            var component = _this._viewManager.getComponent(newLocation);
	            var dispose = function () {
	                var index = viewContainer.indexOf(hostViewRef);
	                if (index !== -1) {
	                    viewContainer.remove(index);
	                }
	            };
	            return new ComponentRef(newLocation, component, dispose);
	        });
	    };
	    DynamicComponentLoader = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [compiler_1.Compiler, view_manager_1.AppViewManager])
	    ], DynamicComponentLoader);
	    return DynamicComponentLoader;
	})();
	exports.DynamicComponentLoader = DynamicComponentLoader;
	//# sourceMappingURL=dynamic_component_loader.js.map

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for render
	var render_1 = __webpack_require__(405);
	exports.RenderDirectiveMetadata = render_1.RenderDirectiveMetadata;
	exports.DomRenderer = render_1.DomRenderer;
	exports.Renderer = render_1.Renderer;
	exports.RenderViewRef = render_1.RenderViewRef;
	exports.RenderProtoViewRef = render_1.RenderProtoViewRef;
	exports.RenderFragmentRef = render_1.RenderFragmentRef;
	exports.RenderViewWithFragments = render_1.RenderViewWithFragments;
	exports.ViewDefinition = render_1.ViewDefinition;
	exports.DOCUMENT = render_1.DOCUMENT;
	exports.APP_ID = render_1.APP_ID;
	exports.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = render_1.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE;
	exports.EventManager = render_1.EventManager;
	exports.SharedStylesHost = render_1.SharedStylesHost;
	exports.DomSharedStylesHost = render_1.DomSharedStylesHost;
	exports.TemplateCloner = render_1.TemplateCloner;
	exports.ViewType = render_1.ViewType;
	exports.RenderProtoViewMergeMapping = render_1.RenderProtoViewMergeMapping;
	exports.EventManagerPlugin = render_1.EventManagerPlugin;
	//# sourceMappingURL=render.js.map

/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * This module provides advanced support for extending dom strategy.
	 */
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(406));
	__export(__webpack_require__(410));
	__export(__webpack_require__(412));
	__export(__webpack_require__(430));
	__export(__webpack_require__(411));
	__export(__webpack_require__(429));
	__export(__webpack_require__(431));
	__export(__webpack_require__(410));
	__export(__webpack_require__(429));
	__export(__webpack_require__(212));
	//# sourceMappingURL=render.js.map

/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var async_1 = __webpack_require__(216);
	var dom_adapter_1 = __webpack_require__(386);
	var xhr_1 = __webpack_require__(407);
	var style_inliner_1 = __webpack_require__(408);
	var style_url_resolver_1 = __webpack_require__(409);
	var profile_1 = __webpack_require__(190);
	var TemplateAndStyles = (function () {
	    function TemplateAndStyles(template, styles) {
	        this.template = template;
	        this.styles = styles;
	    }
	    return TemplateAndStyles;
	})();
	exports.TemplateAndStyles = TemplateAndStyles;
	/**
	 * Strategy to load component views.
	 * TODO: Make public API once we are more confident in this approach.
	 */
	var ViewLoader = (function () {
	    function ViewLoader(_xhr, _styleInliner, _styleUrlResolver) {
	        this._xhr = _xhr;
	        this._styleInliner = _styleInliner;
	        this._styleUrlResolver = _styleUrlResolver;
	        this._cache = new collection_1.Map();
	    }
	    ViewLoader.prototype.load = function (viewDef) {
	        var _this = this;
	        var r = profile_1.wtfStartTimeRange('ViewLoader#load()', lang_1.stringify(viewDef.componentId));
	        var tplAndStyles = [this._loadHtml(viewDef.template, viewDef.templateAbsUrl, viewDef.componentId)];
	        if (lang_1.isPresent(viewDef.styles)) {
	            viewDef.styles.forEach(function (cssText) {
	                var textOrPromise = _this._resolveAndInlineCssText(cssText, viewDef.templateAbsUrl);
	                tplAndStyles.push(textOrPromise);
	            });
	        }
	        if (lang_1.isPresent(viewDef.styleAbsUrls)) {
	            viewDef.styleAbsUrls.forEach(function (url) {
	                var promise = _this._loadText(url).then(function (cssText) { return _this._resolveAndInlineCssText(cssText, viewDef.templateAbsUrl); });
	                tplAndStyles.push(promise);
	            });
	        }
	        // Inline the styles from the @View annotation
	        return async_1.PromiseWrapper.all(tplAndStyles)
	            .then(function (res) {
	            var loadedTplAndStyles = res[0];
	            var styles = collection_1.ListWrapper.slice(res, 1);
	            var templateAndStyles = new TemplateAndStyles(loadedTplAndStyles.template, loadedTplAndStyles.styles.concat(styles));
	            profile_1.wtfEndTimeRange(r);
	            return templateAndStyles;
	        });
	    };
	    ViewLoader.prototype._loadText = function (url) {
	        var response = this._cache.get(url);
	        if (lang_1.isBlank(response)) {
	            // TODO(vicb): change error when TS gets fixed
	            // https://github.com/angular/angular/issues/2280
	            // throw new BaseException(`Failed to fetch url "${url}"`);
	            response = async_1.PromiseWrapper.catchError(this._xhr.get(url), function (_) { return async_1.PromiseWrapper.reject(new exceptions_1.BaseException("Failed to fetch url \"" + url + "\""), null); });
	            this._cache.set(url, response);
	        }
	        return response;
	    };
	    // Load the html and inline any style tags
	    ViewLoader.prototype._loadHtml = function (template, templateAbsUrl, componentId) {
	        var _this = this;
	        var html;
	        // Load the HTML
	        if (lang_1.isPresent(template)) {
	            html = async_1.PromiseWrapper.resolve(template);
	        }
	        else if (lang_1.isPresent(templateAbsUrl)) {
	            html = this._loadText(templateAbsUrl);
	        }
	        else {
	            throw new exceptions_1.BaseException("View should have either the templateUrl or template property set but none was found for the '" + componentId + "' component");
	        }
	        return html.then(function (html) {
	            var tplEl = dom_adapter_1.DOM.createTemplate(html);
	            // Replace $baseUrl with the base url for the template
	            if (lang_1.isPresent(templateAbsUrl) && templateAbsUrl.indexOf("/") >= 0) {
	                var baseUrl = templateAbsUrl.substring(0, templateAbsUrl.lastIndexOf("/"));
	                _this._substituteBaseUrl(dom_adapter_1.DOM.content(tplEl), baseUrl);
	            }
	            var styleEls = dom_adapter_1.DOM.querySelectorAll(dom_adapter_1.DOM.content(tplEl), 'STYLE');
	            var unresolvedStyles = [];
	            for (var i = 0; i < styleEls.length; i++) {
	                var styleEl = styleEls[i];
	                unresolvedStyles.push(dom_adapter_1.DOM.getText(styleEl));
	                dom_adapter_1.DOM.remove(styleEl);
	            }
	            var syncStyles = [];
	            var asyncStyles = [];
	            // Inline the style tags from the html
	            for (var i = 0; i < styleEls.length; i++) {
	                var styleEl_1 = styleEls[i];
	                var resolvedStyled = _this._resolveAndInlineCssText(dom_adapter_1.DOM.getText(styleEl_1), templateAbsUrl);
	                if (lang_1.isPromise(resolvedStyled)) {
	                    asyncStyles.push(resolvedStyled);
	                }
	                else {
	                    syncStyles.push(resolvedStyled);
	                }
	            }
	            if (asyncStyles.length === 0) {
	                return async_1.PromiseWrapper.resolve(new TemplateAndStyles(dom_adapter_1.DOM.getInnerHTML(tplEl), syncStyles));
	            }
	            else {
	                return async_1.PromiseWrapper.all(asyncStyles)
	                    .then(function (loadedStyles) { return new TemplateAndStyles(dom_adapter_1.DOM.getInnerHTML(tplEl), syncStyles.concat(loadedStyles)); });
	            }
	        });
	    };
	    /**
	     * Replace all occurrences of $baseUrl in the attributes of an element and its
	     * children with the base URL of the template.
	     *
	     * @param element The element to process
	     * @param baseUrl The base URL of the template.
	     * @private
	     */
	    ViewLoader.prototype._substituteBaseUrl = function (element, baseUrl) {
	        if (dom_adapter_1.DOM.isElementNode(element)) {
	            var attrs = dom_adapter_1.DOM.attributeMap(element);
	            collection_1.MapWrapper.forEach(attrs, function (v, k) {
	                if (lang_1.isPresent(v) && v.indexOf('$baseUrl') >= 0) {
	                    dom_adapter_1.DOM.setAttribute(element, k, lang_1.StringWrapper.replaceAll(v, /\$baseUrl/g, baseUrl));
	                }
	            });
	        }
	        var children = dom_adapter_1.DOM.childNodes(element);
	        for (var i = 0; i < children.length; i++) {
	            if (dom_adapter_1.DOM.isElementNode(children[i])) {
	                this._substituteBaseUrl(children[i], baseUrl);
	            }
	        }
	    };
	    ViewLoader.prototype._resolveAndInlineCssText = function (cssText, baseUrl) {
	        cssText = this._styleUrlResolver.resolveUrls(cssText, baseUrl);
	        return this._styleInliner.inlineImports(cssText, baseUrl);
	    };
	    ViewLoader = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [xhr_1.XHR, style_inliner_1.StyleInliner, style_url_resolver_1.StyleUrlResolver])
	    ], ViewLoader);
	    return ViewLoader;
	})();
	exports.ViewLoader = ViewLoader;
	//# sourceMappingURL=view_loader.js.map

/***/ },
/* 407 */
/***/ function(module, exports) {

	var XHR = (function () {
	    function XHR() {
	    }
	    XHR.prototype.get = function (url) { return null; };
	    return XHR;
	})();
	exports.XHR = XHR;
	//# sourceMappingURL=xhr.js.map

/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var xhr_1 = __webpack_require__(407);
	var collection_1 = __webpack_require__(166);
	var url_resolver_1 = __webpack_require__(401);
	var style_url_resolver_1 = __webpack_require__(409);
	var lang_1 = __webpack_require__(159);
	var async_1 = __webpack_require__(216);
	/**
	 * Inline @import rules in the given CSS.
	 *
	 * When an @import rules is inlined, it's url are rewritten.
	 */
	var StyleInliner = (function () {
	    function StyleInliner(_xhr, _styleUrlResolver, _urlResolver) {
	        this._xhr = _xhr;
	        this._styleUrlResolver = _styleUrlResolver;
	        this._urlResolver = _urlResolver;
	    }
	    /**
	     * Inline the @imports rules in the given CSS text.
	     *
	     * The baseUrl is required to rewrite URLs in the inlined content.
	     *
	     * @param {string} cssText
	     * @param {string} baseUrl
	     * @returns {*} a Promise<string> when @import rules are present, a string otherwise
	     */
	    StyleInliner.prototype.inlineImports = function (cssText, baseUrl) {
	        return this._inlineImports(cssText, baseUrl, []);
	    };
	    StyleInliner.prototype._inlineImports = function (cssText, baseUrl, inlinedUrls) {
	        var _this = this;
	        var partIndex = 0;
	        var parts = lang_1.StringWrapper.split(cssText, _importRe);
	        if (parts.length === 1) {
	            // no @import rule found, return the original css
	            return cssText;
	        }
	        var promises = [];
	        while (partIndex < parts.length - 1) {
	            // prefix is the content before the @import rule
	            var prefix = parts[partIndex];
	            // rule is the parameter of the @import rule
	            var rule = parts[partIndex + 1];
	            var url = _extractUrl(rule);
	            if (lang_1.isPresent(url)) {
	                url = this._urlResolver.resolve(baseUrl, url);
	            }
	            var mediaQuery = _extractMediaQuery(rule);
	            var promise;
	            if (lang_1.isBlank(url)) {
	                promise = async_1.PromiseWrapper.resolve("/* Invalid import rule: \"@import " + rule + ";\" */");
	            }
	            else if (collection_1.ListWrapper.contains(inlinedUrls, url)) {
	                // The current import rule has already been inlined, return the prefix only
	                // Importing again might cause a circular dependency
	                promise = async_1.PromiseWrapper.resolve(prefix);
	            }
	            else {
	                inlinedUrls.push(url);
	                promise = async_1.PromiseWrapper.then(this._xhr.get(url), function (rawCss) {
	                    // resolve nested @import rules
	                    var inlinedCss = _this._inlineImports(rawCss, url, inlinedUrls);
	                    if (lang_1.isPromise(inlinedCss)) {
	                        // wait until nested @import are inlined
	                        return inlinedCss
	                            .then(function (css) { return prefix + _this._transformImportedCss(css, mediaQuery, url) + '\n'; });
	                    }
	                    else {
	                        // there are no nested @import, return the css
	                        return prefix + _this._transformImportedCss(inlinedCss, mediaQuery, url) + '\n';
	                    }
	                }, function (error) { return ("/* failed to import " + url + " */\n"); });
	            }
	            promises.push(promise);
	            partIndex += 2;
	        }
	        return async_1.PromiseWrapper.all(promises).then(function (cssParts) {
	            var cssText = cssParts.join('');
	            if (partIndex < parts.length) {
	                // append then content located after the last @import rule
	                cssText += parts[partIndex];
	            }
	            return cssText;
	        });
	    };
	    StyleInliner.prototype._transformImportedCss = function (css, mediaQuery, url) {
	        css = this._styleUrlResolver.resolveUrls(css, url);
	        return _wrapInMediaRule(css, mediaQuery);
	    };
	    StyleInliner = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [xhr_1.XHR, style_url_resolver_1.StyleUrlResolver, url_resolver_1.UrlResolver])
	    ], StyleInliner);
	    return StyleInliner;
	})();
	exports.StyleInliner = StyleInliner;
	// Extracts the url from an import rule, supported formats:
	// - 'url' / "url",
	// - url(url) / url('url') / url("url")
	function _extractUrl(importRule) {
	    var match = lang_1.RegExpWrapper.firstMatch(_urlRe, importRule);
	    if (lang_1.isBlank(match))
	        return null;
	    return lang_1.isPresent(match[1]) ? match[1] : match[2];
	}
	// Extracts the media query from an import rule.
	// Returns null when there is no media query.
	function _extractMediaQuery(importRule) {
	    var match = lang_1.RegExpWrapper.firstMatch(_mediaQueryRe, importRule);
	    if (lang_1.isBlank(match))
	        return null;
	    var mediaQuery = match[1].trim();
	    return (mediaQuery.length > 0) ? mediaQuery : null;
	}
	// Wraps the css in a media rule when the media query is not null
	function _wrapInMediaRule(css, query) {
	    return (lang_1.isBlank(query)) ? css : "@media " + query + " {\n" + css + "\n}";
	}
	var _importRe = /@import\s+([^;]+);/g;
	var _urlRe = lang_1.RegExpWrapper.create('url\\(\\s*?[\'"]?([^\'")]+)[\'"]?|' +
	    '[\'"]([^\'")]+)[\'"]' // "url" or 'url'
	);
	var _mediaQueryRe = /['"][^'"]+['"]\s*\)?\s*(.*)/g;
	//# sourceMappingURL=style_inliner.js.map

/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	// Some of the code comes from WebComponents.JS
	// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var url_resolver_1 = __webpack_require__(401);
	/**
	 * Rewrites URLs by resolving '@import' and 'url()' URLs from the given base URL.
	 */
	var StyleUrlResolver = (function () {
	    function StyleUrlResolver(_resolver) {
	        this._resolver = _resolver;
	    }
	    StyleUrlResolver.prototype.resolveUrls = function (cssText, baseUrl) {
	        cssText = this._replaceUrls(cssText, _cssUrlRe, baseUrl);
	        cssText = this._replaceUrls(cssText, _cssImportRe, baseUrl);
	        return cssText;
	    };
	    StyleUrlResolver.prototype._replaceUrls = function (cssText, re, baseUrl) {
	        var _this = this;
	        return lang_1.StringWrapper.replaceAllMapped(cssText, re, function (m) {
	            var pre = m[1];
	            var originalUrl = m[2];
	            if (lang_1.RegExpWrapper.test(_dataUrlRe, originalUrl)) {
	                // Do not attempt to resolve data: URLs
	                return m[0];
	            }
	            var url = lang_1.StringWrapper.replaceAll(originalUrl, _quoteRe, '');
	            var post = m[3];
	            var resolvedUrl = _this._resolver.resolve(baseUrl, url);
	            return pre + "'" + resolvedUrl + "'" + post;
	        });
	    };
	    StyleUrlResolver = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [url_resolver_1.UrlResolver])
	    ], StyleUrlResolver);
	    return StyleUrlResolver;
	})();
	exports.StyleUrlResolver = StyleUrlResolver;
	var _cssUrlRe = /(url\()([^)]*)(\))/g;
	var _cssImportRe = /(@import[\s]+(?!url\())['"]([^'"]*)['"](.*;)/g;
	var _quoteRe = /['"]/g;
	var _dataUrlRe = /^['"]?data:/g;
	//# sourceMappingURL=style_url_resolver.js.map

/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var dom_adapter_1 = __webpack_require__(386);
	var di_1 = __webpack_require__(160);
	var collection_1 = __webpack_require__(166);
	var dom_tokens_1 = __webpack_require__(411);
	var SharedStylesHost = (function () {
	    function SharedStylesHost() {
	        this._styles = [];
	        this._stylesSet = new Set();
	    }
	    SharedStylesHost.prototype.addStyles = function (styles) {
	        var _this = this;
	        var additions = [];
	        styles.forEach(function (style) {
	            if (!collection_1.SetWrapper.has(_this._stylesSet, style)) {
	                _this._stylesSet.add(style);
	                _this._styles.push(style);
	                additions.push(style);
	            }
	        });
	        this.onStylesAdded(additions);
	    };
	    SharedStylesHost.prototype.onStylesAdded = function (additions) { };
	    SharedStylesHost.prototype.getAllStyles = function () { return this._styles; };
	    SharedStylesHost = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], SharedStylesHost);
	    return SharedStylesHost;
	})();
	exports.SharedStylesHost = SharedStylesHost;
	var DomSharedStylesHost = (function (_super) {
	    __extends(DomSharedStylesHost, _super);
	    function DomSharedStylesHost(doc) {
	        _super.call(this);
	        this._hostNodes = new Set();
	        this._hostNodes.add(doc.head);
	    }
	    DomSharedStylesHost.prototype._addStylesToHost = function (styles, host) {
	        for (var i = 0; i < styles.length; i++) {
	            var style = styles[i];
	            dom_adapter_1.DOM.appendChild(host, dom_adapter_1.DOM.createStyleElement(style));
	        }
	    };
	    DomSharedStylesHost.prototype.addHost = function (hostNode) {
	        this._addStylesToHost(this._styles, hostNode);
	        this._hostNodes.add(hostNode);
	    };
	    DomSharedStylesHost.prototype.removeHost = function (hostNode) { collection_1.SetWrapper.delete(this._hostNodes, hostNode); };
	    DomSharedStylesHost.prototype.onStylesAdded = function (additions) {
	        var _this = this;
	        this._hostNodes.forEach(function (hostNode) { _this._addStylesToHost(additions, hostNode); });
	    };
	    DomSharedStylesHost = __decorate([
	        di_1.Injectable(),
	        __param(0, di_1.Inject(dom_tokens_1.DOCUMENT)), 
	        __metadata('design:paramtypes', [Object])
	    ], DomSharedStylesHost);
	    return DomSharedStylesHost;
	})(SharedStylesHost);
	exports.DomSharedStylesHost = DomSharedStylesHost;
	//# sourceMappingURL=shared_styles_host.js.map

/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	exports.DOCUMENT = lang_1.CONST_EXPR(new di_1.OpaqueToken('DocumentToken'));
	/**
	 * A unique id (string) for an angular application.
	 */
	exports.APP_ID = lang_1.CONST_EXPR(new di_1.OpaqueToken('AppId'));
	function _appIdRandomBindingFactory() {
	    return "" + randomChar() + randomChar() + randomChar();
	}
	/**
	 * Bindings that will generate a random APP_ID_TOKEN.
	 */
	exports.APP_ID_RANDOM_BINDING = lang_1.CONST_EXPR(new di_1.Binding(exports.APP_ID, { toFactory: _appIdRandomBindingFactory, deps: [] }));
	/**
	 * Defines when a compiled template should be stored as a string
	 * rather than keeping its Nodes to preserve memory.
	 */
	exports.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE = lang_1.CONST_EXPR(new di_1.OpaqueToken('MaxInMemoryElementsPerTemplate'));
	function randomChar() {
	    return lang_1.StringWrapper.fromCharCode(97 + lang_1.Math.floor(lang_1.Math.random() * 25));
	}
	//# sourceMappingURL=dom_tokens.js.map

/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var di_1 = __webpack_require__(160);
	var async_1 = __webpack_require__(216);
	var dom_adapter_1 = __webpack_require__(386);
	var api_1 = __webpack_require__(212);
	var compile_pipeline_1 = __webpack_require__(413);
	var exceptions_1 = __webpack_require__(168);
	var view_loader_1 = __webpack_require__(406);
	var compile_step_factory_1 = __webpack_require__(419);
	var element_schema_registry_1 = __webpack_require__(427);
	var change_detection_1 = __webpack_require__(179);
	var pvm = __webpack_require__(428);
	var selector_1 = __webpack_require__(423);
	var dom_tokens_1 = __webpack_require__(411);
	var shared_styles_host_1 = __webpack_require__(410);
	var util_1 = __webpack_require__(385);
	var template_cloner_1 = __webpack_require__(429);
	/**
	 * The compiler loads and translates the html templates of components into
	 * nested ProtoViews. To decompose its functionality it uses
	 * the CompilePipeline and the CompileSteps.
	 */
	var DomCompiler = (function (_super) {
	    __extends(DomCompiler, _super);
	    function DomCompiler(_schemaRegistry, _templateCloner, _stepFactory, _viewLoader, _sharedStylesHost) {
	        _super.call(this);
	        this._schemaRegistry = _schemaRegistry;
	        this._templateCloner = _templateCloner;
	        this._stepFactory = _stepFactory;
	        this._viewLoader = _viewLoader;
	        this._sharedStylesHost = _sharedStylesHost;
	    }
	    DomCompiler.prototype.compile = function (view) {
	        var _this = this;
	        var tplPromise = this._viewLoader.load(view);
	        return async_1.PromiseWrapper.then(tplPromise, function (tplAndStyles) {
	            return _this._compileView(view, tplAndStyles, api_1.ViewType.COMPONENT);
	        }, function (e) {
	            throw new exceptions_1.BaseException("Failed to load the template for \"" + view.componentId + "\" : " + e);
	            return null;
	        });
	    };
	    DomCompiler.prototype.compileHost = function (directiveMetadata) {
	        var hostViewDef = new api_1.ViewDefinition({
	            componentId: directiveMetadata.id,
	            templateAbsUrl: null, template: null,
	            styles: null,
	            styleAbsUrls: null,
	            directives: [directiveMetadata],
	            encapsulation: api_1.ViewEncapsulation.None
	        });
	        var selector = selector_1.CssSelector.parse(directiveMetadata.selector)[0];
	        var hostTemplate = selector.getMatchingElementTemplate();
	        var templateAndStyles = new view_loader_1.TemplateAndStyles(hostTemplate, []);
	        return this._compileView(hostViewDef, templateAndStyles, api_1.ViewType.HOST);
	    };
	    DomCompiler.prototype.mergeProtoViewsRecursively = function (protoViewRefs) {
	        return async_1.PromiseWrapper.resolve(pvm.mergeProtoViewsRecursively(this._templateCloner, protoViewRefs));
	    };
	    DomCompiler.prototype._compileView = function (viewDef, templateAndStyles, protoViewType) {
	        if (viewDef.encapsulation === api_1.ViewEncapsulation.Emulated &&
	            templateAndStyles.styles.length === 0) {
	            viewDef = this._normalizeViewEncapsulationIfThereAreNoStyles(viewDef);
	        }
	        var pipeline = new compile_pipeline_1.CompilePipeline(this._stepFactory.createSteps(viewDef));
	        var compiledStyles = pipeline.processStyles(templateAndStyles.styles);
	        var compileElements = pipeline.processElements(this._createTemplateElm(templateAndStyles.template), protoViewType, viewDef);
	        if (viewDef.encapsulation === api_1.ViewEncapsulation.Native) {
	            util_1.prependAll(dom_adapter_1.DOM.content(compileElements[0].element), compiledStyles.map(function (style) { return dom_adapter_1.DOM.createStyleElement(style); }));
	        }
	        else {
	            this._sharedStylesHost.addStyles(compiledStyles);
	        }
	        return async_1.PromiseWrapper.resolve(compileElements[0].inheritedProtoView.build(this._schemaRegistry, this._templateCloner));
	    };
	    DomCompiler.prototype._createTemplateElm = function (template) {
	        var templateElm = dom_adapter_1.DOM.createTemplate(template);
	        var scriptTags = dom_adapter_1.DOM.querySelectorAll(dom_adapter_1.DOM.templateAwareRoot(templateElm), 'script');
	        for (var i = 0; i < scriptTags.length; i++) {
	            dom_adapter_1.DOM.remove(scriptTags[i]);
	        }
	        return templateElm;
	    };
	    DomCompiler.prototype._normalizeViewEncapsulationIfThereAreNoStyles = function (viewDef) {
	        if (viewDef.encapsulation === api_1.ViewEncapsulation.Emulated) {
	            return new api_1.ViewDefinition({
	                componentId: viewDef.componentId,
	                templateAbsUrl: viewDef.templateAbsUrl, template: viewDef.template,
	                styleAbsUrls: viewDef.styleAbsUrls,
	                styles: viewDef.styles,
	                directives: viewDef.directives,
	                encapsulation: api_1.ViewEncapsulation.None
	            });
	        }
	        else {
	            return viewDef;
	        }
	    };
	    return DomCompiler;
	})(api_1.RenderCompiler);
	exports.DomCompiler = DomCompiler;
	var DefaultDomCompiler = (function (_super) {
	    __extends(DefaultDomCompiler, _super);
	    function DefaultDomCompiler(schemaRegistry, templateCloner, parser, viewLoader, sharedStylesHost, appId) {
	        _super.call(this, schemaRegistry, templateCloner, new compile_step_factory_1.DefaultStepFactory(parser, appId), viewLoader, sharedStylesHost);
	    }
	    DefaultDomCompiler = __decorate([
	        di_1.Injectable(),
	        __param(5, di_1.Inject(dom_tokens_1.APP_ID)), 
	        __metadata('design:paramtypes', [element_schema_registry_1.ElementSchemaRegistry, template_cloner_1.TemplateCloner, change_detection_1.Parser, view_loader_1.ViewLoader, shared_styles_host_1.SharedStylesHost, Object])
	    ], DefaultDomCompiler);
	    return DefaultDomCompiler;
	})(DomCompiler);
	exports.DefaultDomCompiler = DefaultDomCompiler;
	//# sourceMappingURL=compiler.js.map

/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var dom_adapter_1 = __webpack_require__(386);
	var compile_element_1 = __webpack_require__(414);
	var compile_control_1 = __webpack_require__(415);
	var proto_view_builder_1 = __webpack_require__(416);
	/**
	 * CompilePipeline for executing CompileSteps recursively for
	 * all elements in a template.
	 */
	var CompilePipeline = (function () {
	    function CompilePipeline(steps) {
	        this.steps = steps;
	        this._control = new compile_control_1.CompileControl(steps);
	    }
	    CompilePipeline.prototype.processStyles = function (styles) {
	        var _this = this;
	        return styles.map(function (style) {
	            _this.steps.forEach(function (step) { style = step.processStyle(style); });
	            return style;
	        });
	    };
	    CompilePipeline.prototype.processElements = function (rootElement, protoViewType, viewDef) {
	        var results = [];
	        var compilationCtxtDescription = viewDef.componentId;
	        var rootCompileElement = new compile_element_1.CompileElement(rootElement, compilationCtxtDescription);
	        rootCompileElement.inheritedProtoView =
	            new proto_view_builder_1.ProtoViewBuilder(rootElement, protoViewType, viewDef.encapsulation);
	        rootCompileElement.isViewRoot = true;
	        this._processElement(results, null, rootCompileElement, compilationCtxtDescription);
	        return results;
	    };
	    CompilePipeline.prototype._processElement = function (results, parent, current, compilationCtxtDescription) {
	        if (compilationCtxtDescription === void 0) { compilationCtxtDescription = ''; }
	        var additionalChildren = this._control.internalProcess(results, 0, parent, current);
	        if (current.compileChildren) {
	            var node = dom_adapter_1.DOM.firstChild(dom_adapter_1.DOM.templateAwareRoot(current.element));
	            while (lang_1.isPresent(node)) {
	                // compilation can potentially move the node, so we need to store the
	                // next sibling before recursing.
	                var nextNode = dom_adapter_1.DOM.nextSibling(node);
	                if (dom_adapter_1.DOM.isElementNode(node)) {
	                    var childCompileElement = new compile_element_1.CompileElement(node, compilationCtxtDescription);
	                    childCompileElement.inheritedProtoView = current.inheritedProtoView;
	                    childCompileElement.inheritedElementBinder = current.inheritedElementBinder;
	                    childCompileElement.distanceToInheritedBinder = current.distanceToInheritedBinder + 1;
	                    this._processElement(results, current, childCompileElement);
	                }
	                node = nextNode;
	            }
	        }
	        if (lang_1.isPresent(additionalChildren)) {
	            for (var i = 0; i < additionalChildren.length; i++) {
	                this._processElement(results, current, additionalChildren[i]);
	            }
	        }
	    };
	    return CompilePipeline;
	})();
	exports.CompilePipeline = CompilePipeline;
	//# sourceMappingURL=compile_pipeline.js.map

/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var dom_adapter_1 = __webpack_require__(386);
	var lang_1 = __webpack_require__(159);
	/**
	 * Collects all data that is needed to process an element
	 * in the compile process. Fields are filled
	 * by the CompileSteps starting out with the pure HTMLElement.
	 */
	var CompileElement = (function () {
	    // error
	    function CompileElement(element, compilationUnit) {
	        if (compilationUnit === void 0) { compilationUnit = ''; }
	        this.element = element;
	        this._attrs = null;
	        this._classList = null;
	        this.isViewRoot = false;
	        // inherited down to children if they don't have an own protoView
	        this.inheritedProtoView = null;
	        this.distanceToInheritedBinder = 0;
	        // inherited down to children if they don't have an own elementBinder
	        this.inheritedElementBinder = null;
	        this.compileChildren = true;
	        // description is calculated here as compilation steps may change the element
	        var tplDesc = lang_1.assertionsEnabled() ? getElementDescription(element) : null;
	        if (compilationUnit !== '') {
	            this.elementDescription = compilationUnit;
	            if (lang_1.isPresent(tplDesc))
	                this.elementDescription += ": " + tplDesc;
	        }
	        else {
	            this.elementDescription = tplDesc;
	        }
	    }
	    CompileElement.prototype.isBound = function () {
	        return lang_1.isPresent(this.inheritedElementBinder) && this.distanceToInheritedBinder === 0;
	    };
	    CompileElement.prototype.bindElement = function () {
	        if (!this.isBound()) {
	            var parentBinder = this.inheritedElementBinder;
	            this.inheritedElementBinder =
	                this.inheritedProtoView.bindElement(this.element, this.elementDescription);
	            if (lang_1.isPresent(parentBinder)) {
	                this.inheritedElementBinder.setParent(parentBinder, this.distanceToInheritedBinder);
	            }
	            this.distanceToInheritedBinder = 0;
	        }
	        return this.inheritedElementBinder;
	    };
	    CompileElement.prototype.attrs = function () {
	        if (lang_1.isBlank(this._attrs)) {
	            this._attrs = dom_adapter_1.DOM.attributeMap(this.element);
	        }
	        return this._attrs;
	    };
	    CompileElement.prototype.classList = function () {
	        if (lang_1.isBlank(this._classList)) {
	            this._classList = [];
	            var elClassList = dom_adapter_1.DOM.classList(this.element);
	            for (var i = 0; i < elClassList.length; i++) {
	                this._classList.push(elClassList[i]);
	            }
	        }
	        return this._classList;
	    };
	    return CompileElement;
	})();
	exports.CompileElement = CompileElement;
	// return an HTML representation of an element start tag - without its content
	// this is used to give contextual information in case of errors
	function getElementDescription(domElement) {
	    var buf = new lang_1.StringJoiner();
	    var atts = dom_adapter_1.DOM.attributeMap(domElement);
	    buf.add("<");
	    buf.add(dom_adapter_1.DOM.tagName(domElement).toLowerCase());
	    // show id and class first to ease element identification
	    addDescriptionAttribute(buf, "id", atts.get("id"));
	    addDescriptionAttribute(buf, "class", atts.get("class"));
	    collection_1.MapWrapper.forEach(atts, function (attValue, attName) {
	        if (attName !== "id" && attName !== "class") {
	            addDescriptionAttribute(buf, attName, attValue);
	        }
	    });
	    buf.add(">");
	    return buf.toString();
	}
	function addDescriptionAttribute(buffer, attName, attValue) {
	    if (lang_1.isPresent(attValue)) {
	        if (attValue.length === 0) {
	            buffer.add(' ' + attName);
	        }
	        else {
	            buffer.add(' ' + attName + '="' + attValue + '"');
	        }
	    }
	}
	//# sourceMappingURL=compile_element.js.map

/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	/**
	 * Controls the processing order of elements.
	 * Right now it only allows to add a parent element.
	 */
	var CompileControl = (function () {
	    function CompileControl(_steps) {
	        this._steps = _steps;
	        this._currentStepIndex = 0;
	        this._parent = null;
	        this._results = null;
	        this._additionalChildren = null;
	    }
	    // only public so that it can be used by compile_pipeline
	    CompileControl.prototype.internalProcess = function (results, startStepIndex, parent, current) {
	        this._results = results;
	        var previousStepIndex = this._currentStepIndex;
	        var previousParent = this._parent;
	        this._ignoreCurrentElement = false;
	        for (var i = startStepIndex; i < this._steps.length && !this._ignoreCurrentElement; i++) {
	            var step = this._steps[i];
	            this._parent = parent;
	            this._currentStepIndex = i;
	            step.processElement(parent, current, this);
	            parent = this._parent;
	        }
	        if (!this._ignoreCurrentElement) {
	            results.push(current);
	        }
	        this._currentStepIndex = previousStepIndex;
	        this._parent = previousParent;
	        var localAdditionalChildren = this._additionalChildren;
	        this._additionalChildren = null;
	        return localAdditionalChildren;
	    };
	    CompileControl.prototype.addParent = function (newElement) {
	        this.internalProcess(this._results, this._currentStepIndex + 1, this._parent, newElement);
	        this._parent = newElement;
	    };
	    CompileControl.prototype.addChild = function (element) {
	        if (lang_1.isBlank(this._additionalChildren)) {
	            this._additionalChildren = [];
	        }
	        this._additionalChildren.push(element);
	    };
	    /**
	     * Ignores the current element.
	     *
	     * When a step calls `ignoreCurrentElement`, no further steps are executed on the current
	     * element and no `CompileElement` is added to the result list.
	     */
	    CompileControl.prototype.ignoreCurrentElement = function () { this._ignoreCurrentElement = true; };
	    return CompileControl;
	})();
	exports.CompileControl = CompileControl;
	//# sourceMappingURL=compile_control.js.map

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var dom_adapter_1 = __webpack_require__(386);
	var change_detection_1 = __webpack_require__(179);
	var proto_view_1 = __webpack_require__(417);
	var element_binder_1 = __webpack_require__(418);
	var api_1 = __webpack_require__(212);
	var util_1 = __webpack_require__(385);
	var event_config_1 = __webpack_require__(397);
	var ProtoViewBuilder = (function () {
	    function ProtoViewBuilder(rootElement, type, viewEncapsulation) {
	        this.rootElement = rootElement;
	        this.type = type;
	        this.viewEncapsulation = viewEncapsulation;
	        this.variableBindings = new Map();
	        this.elements = [];
	        this.rootTextBindings = new Map();
	        this.ngContentCount = 0;
	        this.hostAttributes = new Map();
	    }
	    ProtoViewBuilder.prototype.bindElement = function (element, description) {
	        if (description === void 0) { description = null; }
	        var builder = new ElementBinderBuilder(this.elements.length, element, description);
	        this.elements.push(builder);
	        dom_adapter_1.DOM.addClass(element, util_1.NG_BINDING_CLASS);
	        return builder;
	    };
	    ProtoViewBuilder.prototype.bindVariable = function (name, value) {
	        // Store the variable map from value to variable, reflecting how it will be used later by
	        // DomView. When a local is set to the view, a lookup for the variable name will take place
	        // keyed
	        // by the "value", or exported identifier. For example, ng-for sets a view local of "index".
	        // When this occurs, a lookup keyed by "index" must occur to find if there is a var referencing
	        // it.
	        this.variableBindings.set(value, name);
	    };
	    // Note: We don't store the node index until the compilation is complete,
	    // as the compiler might change the order of elements.
	    ProtoViewBuilder.prototype.bindRootText = function (textNode, expression) {
	        this.rootTextBindings.set(textNode, expression);
	    };
	    ProtoViewBuilder.prototype.bindNgContent = function () { this.ngContentCount++; };
	    ProtoViewBuilder.prototype.setHostAttribute = function (name, value) { this.hostAttributes.set(name, value); };
	    ProtoViewBuilder.prototype.build = function (schemaRegistry, templateCloner) {
	        var domElementBinders = [];
	        var apiElementBinders = [];
	        var textNodeExpressions = [];
	        var rootTextNodeIndices = [];
	        var transitiveNgContentCount = this.ngContentCount;
	        util_1.queryBoundTextNodeIndices(dom_adapter_1.DOM.content(this.rootElement), this.rootTextBindings, function (node, nodeIndex, expression) {
	            textNodeExpressions.push(expression);
	            rootTextNodeIndices.push(nodeIndex);
	        });
	        collection_1.ListWrapper.forEach(this.elements, function (ebb) {
	            var directiveTemplatePropertyNames = new collection_1.Set();
	            var apiDirectiveBinders = collection_1.ListWrapper.map(ebb.directives, function (dbb) {
	                ebb.eventBuilder.merge(dbb.eventBuilder);
	                collection_1.ListWrapper.forEach(dbb.templatePropertyNames, function (name) { return directiveTemplatePropertyNames.add(name); });
	                return new api_1.DirectiveBinder({
	                    directiveIndex: dbb.directiveIndex,
	                    propertyBindings: dbb.propertyBindings,
	                    eventBindings: dbb.eventBindings,
	                    hostPropertyBindings: buildElementPropertyBindings(schemaRegistry, ebb.element, true, dbb.hostPropertyBindings, null)
	                });
	            });
	            var nestedProtoView = lang_1.isPresent(ebb.nestedProtoView) ?
	                ebb.nestedProtoView.build(schemaRegistry, templateCloner) :
	                null;
	            if (lang_1.isPresent(nestedProtoView)) {
	                transitiveNgContentCount += nestedProtoView.transitiveNgContentCount;
	            }
	            var parentIndex = lang_1.isPresent(ebb.parent) ? ebb.parent.index : -1;
	            var textNodeIndices = [];
	            util_1.queryBoundTextNodeIndices(ebb.element, ebb.textBindings, function (node, nodeIndex, expression) {
	                textNodeExpressions.push(expression);
	                textNodeIndices.push(nodeIndex);
	            });
	            apiElementBinders.push(new api_1.RenderElementBinder({
	                index: ebb.index,
	                parentIndex: parentIndex,
	                distanceToParent: ebb.distanceToParent,
	                directives: apiDirectiveBinders,
	                nestedProtoView: nestedProtoView,
	                propertyBindings: buildElementPropertyBindings(schemaRegistry, ebb.element, lang_1.isPresent(ebb.componentId), ebb.propertyBindings, directiveTemplatePropertyNames),
	                variableBindings: ebb.variableBindings,
	                eventBindings: ebb.eventBindings,
	                readAttributes: ebb.readAttributes
	            }));
	            domElementBinders.push(new element_binder_1.DomElementBinder({
	                textNodeIndices: textNodeIndices,
	                hasNestedProtoView: lang_1.isPresent(nestedProtoView) || lang_1.isPresent(ebb.componentId),
	                hasNativeShadowRoot: false,
	                eventLocals: new change_detection_1.LiteralArray(ebb.eventBuilder.buildEventLocals()),
	                localEvents: ebb.eventBuilder.buildLocalEvents(),
	                globalEvents: ebb.eventBuilder.buildGlobalEvents()
	            }));
	        });
	        var rootNodeCount = dom_adapter_1.DOM.childNodes(dom_adapter_1.DOM.content(this.rootElement)).length;
	        return new api_1.ProtoViewDto({
	            render: new proto_view_1.DomProtoViewRef(proto_view_1.DomProtoView.create(templateCloner, this.type, this.rootElement, this.viewEncapsulation, [rootNodeCount], rootTextNodeIndices, domElementBinders, this.hostAttributes)),
	            type: this.type,
	            elementBinders: apiElementBinders,
	            variableBindings: this.variableBindings,
	            textBindings: textNodeExpressions,
	            transitiveNgContentCount: transitiveNgContentCount
	        });
	    };
	    return ProtoViewBuilder;
	})();
	exports.ProtoViewBuilder = ProtoViewBuilder;
	var ElementBinderBuilder = (function () {
	    function ElementBinderBuilder(index, element, description) {
	        this.index = index;
	        this.element = element;
	        this.parent = null;
	        this.distanceToParent = 0;
	        this.directives = [];
	        this.nestedProtoView = null;
	        this.propertyBindings = new Map();
	        this.variableBindings = new Map();
	        this.eventBindings = [];
	        this.eventBuilder = new EventBuilder();
	        this.textBindings = new Map();
	        this.readAttributes = new Map();
	        this.componentId = null;
	    }
	    ElementBinderBuilder.prototype.setParent = function (parent, distanceToParent) {
	        this.parent = parent;
	        if (lang_1.isPresent(parent)) {
	            this.distanceToParent = distanceToParent;
	        }
	        return this;
	    };
	    ElementBinderBuilder.prototype.readAttribute = function (attrName) {
	        if (lang_1.isBlank(this.readAttributes.get(attrName))) {
	            this.readAttributes.set(attrName, dom_adapter_1.DOM.getAttribute(this.element, attrName));
	        }
	    };
	    ElementBinderBuilder.prototype.bindDirective = function (directiveIndex) {
	        var directive = new DirectiveBuilder(directiveIndex);
	        this.directives.push(directive);
	        return directive;
	    };
	    ElementBinderBuilder.prototype.bindNestedProtoView = function (rootElement) {
	        if (lang_1.isPresent(this.nestedProtoView)) {
	            throw new exceptions_1.BaseException('Only one nested view per element is allowed');
	        }
	        this.nestedProtoView =
	            new ProtoViewBuilder(rootElement, api_1.ViewType.EMBEDDED, api_1.ViewEncapsulation.None);
	        return this.nestedProtoView;
	    };
	    ElementBinderBuilder.prototype.bindProperty = function (name, expression) {
	        this.propertyBindings.set(name, expression);
	    };
	    ElementBinderBuilder.prototype.bindVariable = function (name, value) {
	        // When current is a view root, the variable bindings are set to the *nested* proto view.
	        // The root view conceptually signifies a new "block scope" (the nested view), to which
	        // the variables are bound.
	        if (lang_1.isPresent(this.nestedProtoView)) {
	            this.nestedProtoView.bindVariable(name, value);
	        }
	        else {
	            // Store the variable map from value to variable, reflecting how it will be used later by
	            // DomView. When a local is set to the view, a lookup for the variable name will take place
	            // keyed
	            // by the "value", or exported identifier. For example, ng-for sets a view local of "index".
	            // When this occurs, a lookup keyed by "index" must occur to find if there is a var
	            // referencing
	            // it.
	            this.variableBindings.set(value, name);
	        }
	    };
	    ElementBinderBuilder.prototype.bindEvent = function (name, expression, target) {
	        if (target === void 0) { target = null; }
	        this.eventBindings.push(this.eventBuilder.add(name, expression, target));
	    };
	    // Note: We don't store the node index until the compilation is complete,
	    // as the compiler might change the order of elements.
	    ElementBinderBuilder.prototype.bindText = function (textNode, expression) {
	        this.textBindings.set(textNode, expression);
	    };
	    ElementBinderBuilder.prototype.setComponentId = function (componentId) { this.componentId = componentId; };
	    return ElementBinderBuilder;
	})();
	exports.ElementBinderBuilder = ElementBinderBuilder;
	var DirectiveBuilder = (function () {
	    function DirectiveBuilder(directiveIndex) {
	        this.directiveIndex = directiveIndex;
	        // mapping from directive property name to AST for that directive
	        this.propertyBindings = new Map();
	        // property names used in the template
	        this.templatePropertyNames = [];
	        this.hostPropertyBindings = new Map();
	        this.eventBindings = [];
	        this.eventBuilder = new EventBuilder();
	    }
	    DirectiveBuilder.prototype.bindProperty = function (name, expression, elProp) {
	        this.propertyBindings.set(name, expression);
	        if (lang_1.isPresent(elProp)) {
	            // we are filling in a set of property names that are bound to a property
	            // of at least one directive. This allows us to report "dangling" bindings.
	            this.templatePropertyNames.push(elProp);
	        }
	    };
	    DirectiveBuilder.prototype.bindHostProperty = function (name, expression) {
	        this.hostPropertyBindings.set(name, expression);
	    };
	    DirectiveBuilder.prototype.bindEvent = function (name, expression, target) {
	        if (target === void 0) { target = null; }
	        this.eventBindings.push(this.eventBuilder.add(name, expression, target));
	    };
	    return DirectiveBuilder;
	})();
	exports.DirectiveBuilder = DirectiveBuilder;
	var EventBuilder = (function (_super) {
	    __extends(EventBuilder, _super);
	    function EventBuilder() {
	        _super.call(this);
	        this.locals = [];
	        this.localEvents = [];
	        this.globalEvents = [];
	        this._implicitReceiver = new change_detection_1.ImplicitReceiver();
	    }
	    EventBuilder.prototype.add = function (name, source, target) {
	        // TODO(tbosch): reenable this when we are parsing element properties
	        // out of action expressions
	        // var adjustedAst = astWithSource.ast.visit(this);
	        var adjustedAst = source.ast;
	        var fullName = lang_1.isPresent(target) ? target + event_config_1.EVENT_TARGET_SEPARATOR + name : name;
	        var result = new api_1.EventBinding(fullName, new change_detection_1.ASTWithSource(adjustedAst, source.source, source.location));
	        var event = new element_binder_1.Event(name, target, fullName);
	        if (lang_1.isBlank(target)) {
	            this.localEvents.push(event);
	        }
	        else {
	            this.globalEvents.push(event);
	        }
	        return result;
	    };
	    EventBuilder.prototype.visitPropertyRead = function (ast) {
	        var isEventAccess = false;
	        var current = ast;
	        while (!isEventAccess && (current instanceof change_detection_1.PropertyRead)) {
	            var am = current;
	            if (am.name == '$event') {
	                isEventAccess = true;
	            }
	            current = am.receiver;
	        }
	        if (isEventAccess) {
	            this.locals.push(ast);
	            var index = this.locals.length - 1;
	            return new change_detection_1.PropertyRead(this._implicitReceiver, "" + index, function (arr) { return arr[index]; });
	        }
	        else {
	            return ast;
	        }
	    };
	    EventBuilder.prototype.buildEventLocals = function () { return this.locals; };
	    EventBuilder.prototype.buildLocalEvents = function () { return this.localEvents; };
	    EventBuilder.prototype.buildGlobalEvents = function () { return this.globalEvents; };
	    EventBuilder.prototype.merge = function (eventBuilder) {
	        this._merge(this.localEvents, eventBuilder.localEvents);
	        this._merge(this.globalEvents, eventBuilder.globalEvents);
	        this.locals.concat(eventBuilder.locals);
	    };
	    EventBuilder.prototype._merge = function (host, tobeAdded) {
	        var names = [];
	        for (var i = 0; i < host.length; i++) {
	            names.push(host[i].fullName);
	        }
	        for (var j = 0; j < tobeAdded.length; j++) {
	            if (!collection_1.ListWrapper.contains(names, tobeAdded[j].fullName)) {
	                host.push(tobeAdded[j]);
	            }
	        }
	    };
	    return EventBuilder;
	})(change_detection_1.AstTransformer);
	var ATTRIBUTE_PREFIX = 'attr';
	var CLASS_PREFIX = 'class';
	var STYLE_PREFIX = 'style';
	function buildElementPropertyBindings(schemaRegistry, protoElement, isNgComponent, bindingsInTemplate, directiveTemplatePropertyNames) {
	    var propertyBindings = [];
	    collection_1.MapWrapper.forEach(bindingsInTemplate, function (ast, propertyNameInTemplate) {
	        var propertyBinding = createElementPropertyBinding(schemaRegistry, ast, propertyNameInTemplate);
	        if (lang_1.isPresent(directiveTemplatePropertyNames) &&
	            collection_1.SetWrapper.has(directiveTemplatePropertyNames, propertyNameInTemplate)) {
	        }
	        else if (isValidElementPropertyBinding(schemaRegistry, protoElement, isNgComponent, propertyBinding)) {
	            propertyBindings.push(propertyBinding);
	        }
	        else {
	            var exMsg = "Can't bind to '" + propertyNameInTemplate + "' since it isn't a known property of the '<" + dom_adapter_1.DOM.tagName(protoElement).toLowerCase() + ">' element";
	            // directiveTemplatePropertyNames is null for host property bindings
	            if (lang_1.isPresent(directiveTemplatePropertyNames)) {
	                exMsg += ' and there are no matching directives with a corresponding property';
	            }
	            throw new exceptions_1.BaseException(exMsg);
	        }
	    });
	    return propertyBindings;
	}
	function isValidElementPropertyBinding(schemaRegistry, protoElement, isNgComponent, binding) {
	    if (binding.type === api_1.PropertyBindingType.PROPERTY) {
	        if (!isNgComponent) {
	            return schemaRegistry.hasProperty(dom_adapter_1.DOM.tagName(protoElement), binding.property);
	        }
	        else {
	            // TODO(pk): change this logic as soon as we can properly detect custom elements
	            return dom_adapter_1.DOM.hasProperty(protoElement, binding.property);
	        }
	    }
	    return true;
	}
	function createElementPropertyBinding(schemaRegistry, ast, propertyNameInTemplate) {
	    var parts = propertyNameInTemplate.split('.');
	    if (parts.length === 1) {
	        var propName = schemaRegistry.getMappedPropName(parts[0]);
	        return new api_1.ElementPropertyBinding(api_1.PropertyBindingType.PROPERTY, ast, propName);
	    }
	    else if (parts[0] == ATTRIBUTE_PREFIX) {
	        return new api_1.ElementPropertyBinding(api_1.PropertyBindingType.ATTRIBUTE, ast, parts[1]);
	    }
	    else if (parts[0] == CLASS_PREFIX) {
	        return new api_1.ElementPropertyBinding(api_1.PropertyBindingType.CLASS, ast, util_1.camelCaseToDashCase(parts[1]));
	    }
	    else if (parts[0] == STYLE_PREFIX) {
	        var unit = parts.length > 2 ? parts[2] : null;
	        return new api_1.ElementPropertyBinding(api_1.PropertyBindingType.STYLE, ast, parts[1], unit);
	    }
	    else {
	        throw new exceptions_1.BaseException("Invalid property name " + propertyNameInTemplate);
	    }
	}
	//# sourceMappingURL=proto_view_builder.js.map

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var api_1 = __webpack_require__(212);
	var dom_adapter_1 = __webpack_require__(386);
	function resolveInternalDomProtoView(protoViewRef) {
	    return protoViewRef._protoView;
	}
	exports.resolveInternalDomProtoView = resolveInternalDomProtoView;
	var DomProtoViewRef = (function (_super) {
	    __extends(DomProtoViewRef, _super);
	    function DomProtoViewRef(_protoView) {
	        _super.call(this);
	        this._protoView = _protoView;
	    }
	    return DomProtoViewRef;
	})(api_1.RenderProtoViewRef);
	exports.DomProtoViewRef = DomProtoViewRef;
	var DomProtoView = (function () {
	    // Note: fragments are separated by a comment node that is not counted in fragmentsRootNodeCount!
	    function DomProtoView(type, cloneableTemplate, encapsulation, elementBinders, hostAttributes, rootTextNodeIndices, boundTextNodeCount, fragmentsRootNodeCount, isSingleElementFragment) {
	        this.type = type;
	        this.cloneableTemplate = cloneableTemplate;
	        this.encapsulation = encapsulation;
	        this.elementBinders = elementBinders;
	        this.hostAttributes = hostAttributes;
	        this.rootTextNodeIndices = rootTextNodeIndices;
	        this.boundTextNodeCount = boundTextNodeCount;
	        this.fragmentsRootNodeCount = fragmentsRootNodeCount;
	        this.isSingleElementFragment = isSingleElementFragment;
	    }
	    DomProtoView.create = function (templateCloner, type, rootElement, viewEncapsulation, fragmentsRootNodeCount, rootTextNodeIndices, elementBinders, hostAttributes) {
	        var boundTextNodeCount = rootTextNodeIndices.length;
	        for (var i = 0; i < elementBinders.length; i++) {
	            boundTextNodeCount += elementBinders[i].textNodeIndices.length;
	        }
	        var isSingleElementFragment = fragmentsRootNodeCount.length === 1 &&
	            fragmentsRootNodeCount[0] === 1 &&
	            dom_adapter_1.DOM.isElementNode(dom_adapter_1.DOM.firstChild(dom_adapter_1.DOM.content(rootElement)));
	        return new DomProtoView(type, templateCloner.prepareForClone(rootElement), viewEncapsulation, elementBinders, hostAttributes, rootTextNodeIndices, boundTextNodeCount, fragmentsRootNodeCount, isSingleElementFragment);
	    };
	    return DomProtoView;
	})();
	exports.DomProtoView = DomProtoView;
	//# sourceMappingURL=proto_view.js.map

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var DomElementBinder = (function () {
	    function DomElementBinder(_a) {
	        var _b = _a === void 0 ? {} : _a, textNodeIndices = _b.textNodeIndices, hasNestedProtoView = _b.hasNestedProtoView, eventLocals = _b.eventLocals, localEvents = _b.localEvents, globalEvents = _b.globalEvents, hasNativeShadowRoot = _b.hasNativeShadowRoot;
	        this.textNodeIndices = textNodeIndices;
	        this.hasNestedProtoView = hasNestedProtoView;
	        this.eventLocals = eventLocals;
	        this.localEvents = localEvents;
	        this.globalEvents = globalEvents;
	        this.hasNativeShadowRoot = lang_1.isPresent(hasNativeShadowRoot) ? hasNativeShadowRoot : false;
	    }
	    return DomElementBinder;
	})();
	exports.DomElementBinder = DomElementBinder;
	var Event = (function () {
	    function Event(name, target, fullName) {
	        this.name = name;
	        this.target = target;
	        this.fullName = fullName;
	    }
	    return Event;
	})();
	exports.Event = Event;
	var HostAction = (function () {
	    function HostAction(actionName, actionExpression, expression) {
	        this.actionName = actionName;
	        this.actionExpression = actionExpression;
	        this.expression = expression;
	    }
	    return HostAction;
	})();
	exports.HostAction = HostAction;
	//# sourceMappingURL=element_binder.js.map

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var property_binding_parser_1 = __webpack_require__(420);
	var text_interpolation_parser_1 = __webpack_require__(421);
	var directive_parser_1 = __webpack_require__(422);
	var view_splitter_1 = __webpack_require__(424);
	var style_encapsulator_1 = __webpack_require__(425);
	var CompileStepFactory = (function () {
	    function CompileStepFactory() {
	    }
	    CompileStepFactory.prototype.createSteps = function (view) { return null; };
	    return CompileStepFactory;
	})();
	exports.CompileStepFactory = CompileStepFactory;
	var DefaultStepFactory = (function (_super) {
	    __extends(DefaultStepFactory, _super);
	    function DefaultStepFactory(_parser, _appId) {
	        _super.call(this);
	        this._parser = _parser;
	        this._appId = _appId;
	        this._componentUIDsCache = new Map();
	    }
	    DefaultStepFactory.prototype.createSteps = function (view) {
	        return [
	            new view_splitter_1.ViewSplitter(this._parser),
	            new property_binding_parser_1.PropertyBindingParser(this._parser),
	            new directive_parser_1.DirectiveParser(this._parser, view.directives),
	            new text_interpolation_parser_1.TextInterpolationParser(this._parser),
	            new style_encapsulator_1.StyleEncapsulator(this._appId, view, this._componentUIDsCache)
	        ];
	    };
	    return DefaultStepFactory;
	})(CompileStepFactory);
	exports.DefaultStepFactory = DefaultStepFactory;
	//# sourceMappingURL=compile_step_factory.js.map

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var util_1 = __webpack_require__(385);
	// Group 1 = "bind-"
	// Group 2 = "var-" or "#"
	// Group 3 = "on-"
	// Group 4 = "bindon-"
	// Group 5 = the identifier after "bind-", "var-/#", or "on-"
	// Group 6 = identifier inside [()]
	// Group 7 = identifier inside []
	// Group 8 = identifier inside ()
	var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(var-|#)|(on-)|(bindon-))(.+))|\[\(([^\)]+)\)\]|\[([^\]]+)\]|\(([^\)]+)\))$/g;
	/**
	 * Parses the property bindings on a single element.
	 */
	var PropertyBindingParser = (function () {
	    function PropertyBindingParser(_parser) {
	        this._parser = _parser;
	    }
	    PropertyBindingParser.prototype.processStyle = function (style) { return style; };
	    PropertyBindingParser.prototype.processElement = function (parent, current, control) {
	        var _this = this;
	        var attrs = current.attrs();
	        var newAttrs = new Map();
	        collection_1.MapWrapper.forEach(attrs, function (attrValue, attrName) {
	            attrName = _this._normalizeAttributeName(attrName);
	            var bindParts = lang_1.RegExpWrapper.firstMatch(BIND_NAME_REGEXP, attrName);
	            if (lang_1.isPresent(bindParts)) {
	                if (lang_1.isPresent(bindParts[1])) {
	                    _this._bindProperty(bindParts[5], attrValue, current, newAttrs);
	                }
	                else if (lang_1.isPresent(bindParts[2])) {
	                    var identifier = bindParts[5];
	                    var value = attrValue == '' ? '\$implicit' : attrValue;
	                    _this._bindVariable(identifier, value, current, newAttrs);
	                }
	                else if (lang_1.isPresent(bindParts[3])) {
	                    _this._bindEvent(bindParts[5], attrValue, current, newAttrs);
	                }
	                else if (lang_1.isPresent(bindParts[4])) {
	                    _this._bindProperty(bindParts[5], attrValue, current, newAttrs);
	                    _this._bindAssignmentEvent(bindParts[5], attrValue, current, newAttrs);
	                }
	                else if (lang_1.isPresent(bindParts[6])) {
	                    _this._bindProperty(bindParts[6], attrValue, current, newAttrs);
	                    _this._bindAssignmentEvent(bindParts[6], attrValue, current, newAttrs);
	                }
	                else if (lang_1.isPresent(bindParts[7])) {
	                    _this._bindProperty(bindParts[7], attrValue, current, newAttrs);
	                }
	                else if (lang_1.isPresent(bindParts[8])) {
	                    _this._bindEvent(bindParts[8], attrValue, current, newAttrs);
	                }
	            }
	            else {
	                var expr = _this._parser.parseInterpolation(attrValue, current.elementDescription);
	                if (lang_1.isPresent(expr)) {
	                    _this._bindPropertyAst(attrName, expr, current, newAttrs);
	                }
	            }
	        });
	        collection_1.MapWrapper.forEach(newAttrs, function (attrValue, attrName) { attrs.set(attrName, attrValue); });
	    };
	    PropertyBindingParser.prototype._normalizeAttributeName = function (attrName) {
	        return lang_1.StringWrapper.startsWith(attrName, 'data-') ? lang_1.StringWrapper.substring(attrName, 5) :
	            attrName;
	    };
	    PropertyBindingParser.prototype._bindVariable = function (identifier, value, current, newAttrs) {
	        current.bindElement().bindVariable(util_1.dashCaseToCamelCase(identifier), value);
	        newAttrs.set(identifier, value);
	    };
	    PropertyBindingParser.prototype._bindProperty = function (name, expression, current, newAttrs) {
	        this._bindPropertyAst(name, this._parser.parseBinding(expression, current.elementDescription), current, newAttrs);
	    };
	    PropertyBindingParser.prototype._bindPropertyAst = function (name, ast, current, newAttrs) {
	        var binder = current.bindElement();
	        binder.bindProperty(util_1.dashCaseToCamelCase(name), ast);
	        newAttrs.set(name, ast.source);
	    };
	    PropertyBindingParser.prototype._bindAssignmentEvent = function (name, expression, current, newAttrs) {
	        this._bindEvent(name, expression + "=$event", current, newAttrs);
	    };
	    PropertyBindingParser.prototype._bindEvent = function (name, expression, current, newAttrs) {
	        current.bindElement().bindEvent(util_1.dashCaseToCamelCase(name), this._parser.parseAction(expression, current.elementDescription));
	        // Don't detect directives for event names for now,
	        // so don't add the event name to the CompileElement.attrs
	    };
	    return PropertyBindingParser;
	})();
	exports.PropertyBindingParser = PropertyBindingParser;
	//# sourceMappingURL=property_binding_parser.js.map

/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var dom_adapter_1 = __webpack_require__(386);
	/**
	 * Parses interpolations in direct text child nodes of the current element.
	 */
	var TextInterpolationParser = (function () {
	    function TextInterpolationParser(_parser) {
	        this._parser = _parser;
	    }
	    TextInterpolationParser.prototype.processStyle = function (style) { return style; };
	    TextInterpolationParser.prototype.processElement = function (parent, current, control) {
	        if (!current.compileChildren) {
	            return;
	        }
	        var element = current.element;
	        var childNodes = dom_adapter_1.DOM.childNodes(dom_adapter_1.DOM.templateAwareRoot(element));
	        for (var i = 0; i < childNodes.length; i++) {
	            var node = childNodes[i];
	            if (dom_adapter_1.DOM.isTextNode(node)) {
	                var textNode = node;
	                var text = dom_adapter_1.DOM.nodeValue(textNode);
	                var expr = this._parser.parseInterpolation(text, current.elementDescription);
	                if (lang_1.isPresent(expr)) {
	                    dom_adapter_1.DOM.setText(textNode, ' ');
	                    if (current.element === current.inheritedProtoView.rootElement) {
	                        current.inheritedProtoView.bindRootText(textNode, expr);
	                    }
	                    else {
	                        current.bindElement().bindText(textNode, expr);
	                    }
	                }
	            }
	        }
	    };
	    return TextInterpolationParser;
	})();
	exports.TextInterpolationParser = TextInterpolationParser;
	//# sourceMappingURL=text_interpolation_parser.js.map

/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var dom_adapter_1 = __webpack_require__(386);
	var selector_1 = __webpack_require__(423);
	var api_1 = __webpack_require__(212);
	var util_1 = __webpack_require__(385);
	var event_config_1 = __webpack_require__(397);
	/**
	 * Parses the directives on a single element. Assumes ViewSplitter has already created
	 * <template> elements for template directives.
	 */
	var DirectiveParser = (function () {
	    function DirectiveParser(_parser, _directives) {
	        this._parser = _parser;
	        this._directives = _directives;
	        this._selectorMatcher = new selector_1.SelectorMatcher();
	        for (var i = 0; i < _directives.length; i++) {
	            var directive = _directives[i];
	            var selector = selector_1.CssSelector.parse(directive.selector);
	            this._selectorMatcher.addSelectables(selector, i);
	        }
	    }
	    DirectiveParser.prototype.processStyle = function (style) { return style; };
	    DirectiveParser.prototype.processElement = function (parent, current, control) {
	        var _this = this;
	        var attrs = current.attrs();
	        var classList = current.classList();
	        var cssSelector = new selector_1.CssSelector();
	        var foundDirectiveIndices = [];
	        var elementBinder = null;
	        cssSelector.setElement(dom_adapter_1.DOM.nodeName(current.element));
	        for (var i = 0; i < classList.length; i++) {
	            cssSelector.addClassName(classList[i]);
	        }
	        collection_1.MapWrapper.forEach(attrs, function (attrValue, attrName) { cssSelector.addAttribute(attrName, attrValue); });
	        this._selectorMatcher.match(cssSelector, function (selector, directiveIndex) {
	            var directive = _this._directives[directiveIndex];
	            elementBinder = current.bindElement();
	            if (directive.type === api_1.RenderDirectiveMetadata.COMPONENT_TYPE) {
	                _this._ensureHasOnlyOneComponent(elementBinder, current.elementDescription);
	                // components need to go first, so it is easier to locate them in the result.
	                collection_1.ListWrapper.insert(foundDirectiveIndices, 0, directiveIndex);
	                elementBinder.setComponentId(directive.id);
	            }
	            else {
	                foundDirectiveIndices.push(directiveIndex);
	            }
	        });
	        collection_1.ListWrapper.forEach(foundDirectiveIndices, function (directiveIndex) {
	            var dirMetadata = _this._directives[directiveIndex];
	            var directiveBinderBuilder = elementBinder.bindDirective(directiveIndex);
	            current.compileChildren = current.compileChildren && dirMetadata.compileChildren;
	            if (lang_1.isPresent(dirMetadata.properties)) {
	                collection_1.ListWrapper.forEach(dirMetadata.properties, function (bindConfig) {
	                    _this._bindDirectiveProperty(bindConfig, current, directiveBinderBuilder);
	                });
	            }
	            if (lang_1.isPresent(dirMetadata.hostListeners)) {
	                _this._sortedKeysForEach(dirMetadata.hostListeners, function (action, eventName) {
	                    _this._bindDirectiveEvent(eventName, action, current, directiveBinderBuilder);
	                });
	            }
	            if (lang_1.isPresent(dirMetadata.hostProperties)) {
	                _this._sortedKeysForEach(dirMetadata.hostProperties, function (expression, hostPropertyName) {
	                    _this._bindHostProperty(hostPropertyName, expression, current, directiveBinderBuilder);
	                });
	            }
	            if (lang_1.isPresent(dirMetadata.hostAttributes)) {
	                _this._sortedKeysForEach(dirMetadata.hostAttributes, function (hostAttrValue, hostAttrName) {
	                    _this._addHostAttribute(hostAttrName, hostAttrValue, current);
	                });
	            }
	            if (lang_1.isPresent(dirMetadata.readAttributes)) {
	                collection_1.ListWrapper.forEach(dirMetadata.readAttributes, function (attrName) { elementBinder.readAttribute(attrName); });
	            }
	        });
	    };
	    DirectiveParser.prototype._sortedKeysForEach = function (map, fn) {
	        var keys = collection_1.MapWrapper.keys(map);
	        collection_1.ListWrapper.sort(keys, function (a, b) {
	            // Ensure a stable sort.
	            var compareVal = lang_1.StringWrapper.compare(a, b);
	            return compareVal == 0 ? -1 : compareVal;
	        });
	        collection_1.ListWrapper.forEach(keys, function (key) { fn(collection_1.MapWrapper.get(map, key), key); });
	    };
	    DirectiveParser.prototype._ensureHasOnlyOneComponent = function (elementBinder, elDescription) {
	        if (lang_1.isPresent(elementBinder.componentId)) {
	            throw new exceptions_1.BaseException("Only one component directive is allowed per element - check " + elDescription);
	        }
	    };
	    DirectiveParser.prototype._bindDirectiveProperty = function (bindConfig, compileElement, directiveBinderBuilder) {
	        // Name of the property on the directive
	        var dirProperty;
	        // Name of the property on the element
	        var elProp;
	        var pipes;
	        var assignIndex = bindConfig.indexOf(':');
	        if (assignIndex > -1) {
	            // canonical syntax: `dirProp: elProp | pipe0 | ... | pipeN`
	            dirProperty = lang_1.StringWrapper.substring(bindConfig, 0, assignIndex).trim();
	            pipes = this._splitBindConfig(lang_1.StringWrapper.substring(bindConfig, assignIndex + 1));
	            elProp = collection_1.ListWrapper.removeAt(pipes, 0);
	        }
	        else {
	            // shorthand syntax when the name of the property on the directive and on the element is the
	            // same, ie `property`
	            dirProperty = bindConfig;
	            elProp = bindConfig;
	            pipes = [];
	        }
	        elProp = util_1.dashCaseToCamelCase(elProp);
	        var bindingAst = compileElement.bindElement().propertyBindings.get(elProp);
	        if (lang_1.isBlank(bindingAst)) {
	            var attributeValue = compileElement.attrs().get(util_1.camelCaseToDashCase(elProp));
	            if (lang_1.isPresent(attributeValue)) {
	                bindingAst =
	                    this._parser.wrapLiteralPrimitive(attributeValue, compileElement.elementDescription);
	            }
	        }
	        // Bindings are optional, so this binding only needs to be set up if an expression is given.
	        if (lang_1.isPresent(bindingAst)) {
	            directiveBinderBuilder.bindProperty(dirProperty, bindingAst, elProp);
	        }
	    };
	    DirectiveParser.prototype._bindDirectiveEvent = function (eventName, action, compileElement, directiveBinderBuilder) {
	        var ast = this._parser.parseAction(action, compileElement.elementDescription);
	        var parsedEvent = event_config_1.EventConfig.parse(eventName);
	        var targetName = parsedEvent.isLongForm ? parsedEvent.fieldName : null;
	        directiveBinderBuilder.bindEvent(parsedEvent.eventName, ast, targetName);
	    };
	    DirectiveParser.prototype._bindHostProperty = function (hostPropertyName, expression, compileElement, directiveBinderBuilder) {
	        var ast = this._parser.parseSimpleBinding(expression, "hostProperties of " + compileElement.elementDescription);
	        directiveBinderBuilder.bindHostProperty(hostPropertyName, ast);
	    };
	    DirectiveParser.prototype._addHostAttribute = function (attrName, attrValue, compileElement) {
	        if (lang_1.StringWrapper.equals(attrName, 'class')) {
	            collection_1.ListWrapper.forEach(attrValue.split(' '), function (className) { dom_adapter_1.DOM.addClass(compileElement.element, className); });
	        }
	        else if (!dom_adapter_1.DOM.hasAttribute(compileElement.element, attrName)) {
	            dom_adapter_1.DOM.setAttribute(compileElement.element, attrName, attrValue);
	        }
	    };
	    DirectiveParser.prototype._splitBindConfig = function (bindConfig) {
	        return collection_1.ListWrapper.map(bindConfig.split('|'), function (s) { return s.trim(); });
	    };
	    return DirectiveParser;
	})();
	exports.DirectiveParser = DirectiveParser;
	//# sourceMappingURL=directive_parser.js.map

/***/ },
/* 423 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var _EMPTY_ATTR_VALUE = '';
	// TODO: Can't use `const` here as
	// in Dart this is not transpiled into `final` yet...
	var _SELECTOR_REGEXP = lang_1.RegExpWrapper.create('(\\:not\\()|' +
	    '([-\\w]+)|' +
	    '(?:\\.([-\\w]+))|' +
	    '(?:\\[([-\\w*]+)(?:=([^\\]]*))?\\])|' +
	    '(\\))|' +
	    '(\\s*,\\s*)'); // ","
	/**
	 * A css selector contains an element name,
	 * css classes and attribute/value pairs with the purpose
	 * of selecting subsets out of them.
	 */
	var CssSelector = (function () {
	    function CssSelector() {
	        this.element = null;
	        this.classNames = [];
	        this.attrs = [];
	        this.notSelectors = [];
	    }
	    CssSelector.parse = function (selector) {
	        var results = [];
	        var _addResult = function (res, cssSel) {
	            if (cssSel.notSelectors.length > 0 && lang_1.isBlank(cssSel.element) &&
	                collection_1.ListWrapper.isEmpty(cssSel.classNames) && collection_1.ListWrapper.isEmpty(cssSel.attrs)) {
	                cssSel.element = "*";
	            }
	            res.push(cssSel);
	        };
	        var cssSelector = new CssSelector();
	        var matcher = lang_1.RegExpWrapper.matcher(_SELECTOR_REGEXP, selector);
	        var match;
	        var current = cssSelector;
	        var inNot = false;
	        while (lang_1.isPresent(match = lang_1.RegExpMatcherWrapper.next(matcher))) {
	            if (lang_1.isPresent(match[1])) {
	                if (inNot) {
	                    throw new exceptions_1.BaseException('Nesting :not is not allowed in a selector');
	                }
	                inNot = true;
	                current = new CssSelector();
	                cssSelector.notSelectors.push(current);
	            }
	            if (lang_1.isPresent(match[2])) {
	                current.setElement(match[2]);
	            }
	            if (lang_1.isPresent(match[3])) {
	                current.addClassName(match[3]);
	            }
	            if (lang_1.isPresent(match[4])) {
	                current.addAttribute(match[4], match[5]);
	            }
	            if (lang_1.isPresent(match[6])) {
	                inNot = false;
	                current = cssSelector;
	            }
	            if (lang_1.isPresent(match[7])) {
	                if (inNot) {
	                    throw new exceptions_1.BaseException('Multiple selectors in :not are not supported');
	                }
	                _addResult(results, cssSelector);
	                cssSelector = current = new CssSelector();
	            }
	        }
	        _addResult(results, cssSelector);
	        return results;
	    };
	    CssSelector.prototype.isElementSelector = function () {
	        return lang_1.isPresent(this.element) && collection_1.ListWrapper.isEmpty(this.classNames) &&
	            collection_1.ListWrapper.isEmpty(this.attrs) && this.notSelectors.length === 0;
	    };
	    CssSelector.prototype.setElement = function (element) {
	        if (element === void 0) { element = null; }
	        if (lang_1.isPresent(element)) {
	            element = element.toLowerCase();
	        }
	        this.element = element;
	    };
	    /** Gets a template string for an element that matches the selector. */
	    CssSelector.prototype.getMatchingElementTemplate = function () {
	        var tagName = lang_1.isPresent(this.element) ? this.element : 'div';
	        var classAttr = this.classNames.length > 0 ? " class=\"" + this.classNames.join(' ') + "\"" : '';
	        var attrs = '';
	        for (var i = 0; i < this.attrs.length; i += 2) {
	            var attrName = this.attrs[i];
	            var attrValue = this.attrs[i + 1] !== '' ? "=\"" + this.attrs[i + 1] + "\"" : '';
	            attrs += " " + attrName + attrValue;
	        }
	        return "<" + tagName + classAttr + attrs + "></" + tagName + ">";
	    };
	    CssSelector.prototype.addAttribute = function (name, value) {
	        if (value === void 0) { value = _EMPTY_ATTR_VALUE; }
	        this.attrs.push(name.toLowerCase());
	        if (lang_1.isPresent(value)) {
	            value = value.toLowerCase();
	        }
	        else {
	            value = _EMPTY_ATTR_VALUE;
	        }
	        this.attrs.push(value);
	    };
	    CssSelector.prototype.addClassName = function (name) { this.classNames.push(name.toLowerCase()); };
	    CssSelector.prototype.toString = function () {
	        var res = '';
	        if (lang_1.isPresent(this.element)) {
	            res += this.element;
	        }
	        if (lang_1.isPresent(this.classNames)) {
	            for (var i = 0; i < this.classNames.length; i++) {
	                res += '.' + this.classNames[i];
	            }
	        }
	        if (lang_1.isPresent(this.attrs)) {
	            for (var i = 0; i < this.attrs.length;) {
	                var attrName = this.attrs[i++];
	                var attrValue = this.attrs[i++];
	                res += '[' + attrName;
	                if (attrValue.length > 0) {
	                    res += '=' + attrValue;
	                }
	                res += ']';
	            }
	        }
	        collection_1.ListWrapper.forEach(this.notSelectors, function (notSelector) { res += ":not(" + notSelector.toString() + ")"; });
	        return res;
	    };
	    return CssSelector;
	})();
	exports.CssSelector = CssSelector;
	/**
	 * Reads a list of CssSelectors and allows to calculate which ones
	 * are contained in a given CssSelector.
	 */
	var SelectorMatcher = (function () {
	    function SelectorMatcher() {
	        this._elementMap = new collection_1.Map();
	        this._elementPartialMap = new collection_1.Map();
	        this._classMap = new collection_1.Map();
	        this._classPartialMap = new collection_1.Map();
	        this._attrValueMap = new collection_1.Map();
	        this._attrValuePartialMap = new collection_1.Map();
	        this._listContexts = [];
	    }
	    SelectorMatcher.createNotMatcher = function (notSelectors) {
	        var notMatcher = new SelectorMatcher();
	        notMatcher.addSelectables(notSelectors, null);
	        return notMatcher;
	    };
	    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {
	        var listContext = null;
	        if (cssSelectors.length > 1) {
	            listContext = new SelectorListContext(cssSelectors);
	            this._listContexts.push(listContext);
	        }
	        for (var i = 0; i < cssSelectors.length; i++) {
	            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);
	        }
	    };
	    /**
	     * Add an object that can be found later on by calling `match`.
	     * @param cssSelector A css selector
	     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function
	     */
	    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {
	        var matcher = this;
	        var element = cssSelector.element;
	        var classNames = cssSelector.classNames;
	        var attrs = cssSelector.attrs;
	        var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);
	        if (lang_1.isPresent(element)) {
	            var isTerminal = attrs.length === 0 && classNames.length === 0;
	            if (isTerminal) {
	                this._addTerminal(matcher._elementMap, element, selectable);
	            }
	            else {
	                matcher = this._addPartial(matcher._elementPartialMap, element);
	            }
	        }
	        if (lang_1.isPresent(classNames)) {
	            for (var index = 0; index < classNames.length; index++) {
	                var isTerminal = attrs.length === 0 && index === classNames.length - 1;
	                var className = classNames[index];
	                if (isTerminal) {
	                    this._addTerminal(matcher._classMap, className, selectable);
	                }
	                else {
	                    matcher = this._addPartial(matcher._classPartialMap, className);
	                }
	            }
	        }
	        if (lang_1.isPresent(attrs)) {
	            for (var index = 0; index < attrs.length;) {
	                var isTerminal = index === attrs.length - 2;
	                var attrName = attrs[index++];
	                var attrValue = attrs[index++];
	                if (isTerminal) {
	                    var terminalMap = matcher._attrValueMap;
	                    var terminalValuesMap = terminalMap.get(attrName);
	                    if (lang_1.isBlank(terminalValuesMap)) {
	                        terminalValuesMap = new collection_1.Map();
	                        terminalMap.set(attrName, terminalValuesMap);
	                    }
	                    this._addTerminal(terminalValuesMap, attrValue, selectable);
	                }
	                else {
	                    var parttialMap = matcher._attrValuePartialMap;
	                    var partialValuesMap = parttialMap.get(attrName);
	                    if (lang_1.isBlank(partialValuesMap)) {
	                        partialValuesMap = new collection_1.Map();
	                        parttialMap.set(attrName, partialValuesMap);
	                    }
	                    matcher = this._addPartial(partialValuesMap, attrValue);
	                }
	            }
	        }
	    };
	    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {
	        var terminalList = map.get(name);
	        if (lang_1.isBlank(terminalList)) {
	            terminalList = [];
	            map.set(name, terminalList);
	        }
	        terminalList.push(selectable);
	    };
	    SelectorMatcher.prototype._addPartial = function (map, name) {
	        var matcher = map.get(name);
	        if (lang_1.isBlank(matcher)) {
	            matcher = new SelectorMatcher();
	            map.set(name, matcher);
	        }
	        return matcher;
	    };
	    /**
	     * Find the objects that have been added via `addSelectable`
	     * whose css selector is contained in the given css selector.
	     * @param cssSelector A css selector
	     * @param matchedCallback This callback will be called with the object handed into `addSelectable`
	     * @return boolean true if a match was found
	    */
	    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {
	        var result = false;
	        var element = cssSelector.element;
	        var classNames = cssSelector.classNames;
	        var attrs = cssSelector.attrs;
	        for (var i = 0; i < this._listContexts.length; i++) {
	            this._listContexts[i].alreadyMatched = false;
	        }
	        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;
	        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||
	            result;
	        if (lang_1.isPresent(classNames)) {
	            for (var index = 0; index < classNames.length; index++) {
	                var className = classNames[index];
	                result =
	                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;
	                result =
	                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||
	                        result;
	            }
	        }
	        if (lang_1.isPresent(attrs)) {
	            for (var index = 0; index < attrs.length;) {
	                var attrName = attrs[index++];
	                var attrValue = attrs[index++];
	                var terminalValuesMap = this._attrValueMap.get(attrName);
	                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
	                    result = this._matchTerminal(terminalValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
	                        result;
	                }
	                result = this._matchTerminal(terminalValuesMap, attrValue, cssSelector, matchedCallback) ||
	                    result;
	                var partialValuesMap = this._attrValuePartialMap.get(attrName);
	                if (!lang_1.StringWrapper.equals(attrValue, _EMPTY_ATTR_VALUE)) {
	                    result = this._matchPartial(partialValuesMap, _EMPTY_ATTR_VALUE, cssSelector, matchedCallback) ||
	                        result;
	                }
	                result =
	                    this._matchPartial(partialValuesMap, attrValue, cssSelector, matchedCallback) || result;
	            }
	        }
	        return result;
	    };
	    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {
	        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
	            return false;
	        }
	        var selectables = map.get(name);
	        var starSelectables = map.get("*");
	        if (lang_1.isPresent(starSelectables)) {
	            selectables = selectables.concat(starSelectables);
	        }
	        if (lang_1.isBlank(selectables)) {
	            return false;
	        }
	        var selectable;
	        var result = false;
	        for (var index = 0; index < selectables.length; index++) {
	            selectable = selectables[index];
	            result = selectable.finalize(cssSelector, matchedCallback) || result;
	        }
	        return result;
	    };
	    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback /*: (CssSelector, any) => void*/) {
	        if (lang_1.isBlank(map) || lang_1.isBlank(name)) {
	            return false;
	        }
	        var nestedSelector = map.get(name);
	        if (lang_1.isBlank(nestedSelector)) {
	            return false;
	        }
	        // TODO(perf): get rid of recursion and measure again
	        // TODO(perf): don't pass the whole selector into the recursion,
	        // but only the not processed parts
	        return nestedSelector.match(cssSelector, matchedCallback);
	    };
	    return SelectorMatcher;
	})();
	exports.SelectorMatcher = SelectorMatcher;
	var SelectorListContext = (function () {
	    function SelectorListContext(selectors) {
	        this.selectors = selectors;
	        this.alreadyMatched = false;
	    }
	    return SelectorListContext;
	})();
	exports.SelectorListContext = SelectorListContext;
	// Store context to pass back selector and context when a selector is matched
	var SelectorContext = (function () {
	    function SelectorContext(selector, cbContext, listContext) {
	        this.selector = selector;
	        this.cbContext = cbContext;
	        this.listContext = listContext;
	        this.notSelectors = selector.notSelectors;
	    }
	    SelectorContext.prototype.finalize = function (cssSelector, callback) {
	        var result = true;
	        if (this.notSelectors.length > 0 &&
	            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
	            var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);
	            result = !notMatcher.match(cssSelector, null);
	        }
	        if (result && lang_1.isPresent(callback) &&
	            (lang_1.isBlank(this.listContext) || !this.listContext.alreadyMatched)) {
	            if (lang_1.isPresent(this.listContext)) {
	                this.listContext.alreadyMatched = true;
	            }
	            callback(this.selector, this.cbContext);
	        }
	        return result;
	    };
	    return SelectorContext;
	})();
	exports.SelectorContext = SelectorContext;
	//# sourceMappingURL=selector.js.map

/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var dom_adapter_1 = __webpack_require__(386);
	var collection_1 = __webpack_require__(166);
	var compile_element_1 = __webpack_require__(414);
	var util_1 = __webpack_require__(385);
	/**
	 * Splits views at `<template>` elements or elements with `template` attribute:
	 * For `<template>` elements:
	 * - moves the content into a new and disconnected `<template>` element
	 *   that is marked as view root.
	 *
	 * For elements with a `template` attribute:
	 * - replaces the element with an empty `<template>` element,
	 *   parses the content of the `template` attribute and adds the information to that
	 *   `<template>` element. Marks the elements as view root.
	 *
	 * Note: In both cases the root of the nested view is disconnected from its parent element.
	 * This is needed for browsers that don't support the `<template>` element
	 * as we want to do locate elements with bindings using `getElementsByClassName` later on,
	 * which should not descend into the nested view.
	 */
	var ViewSplitter = (function () {
	    function ViewSplitter(_parser) {
	        this._parser = _parser;
	    }
	    ViewSplitter.prototype.processStyle = function (style) { return style; };
	    ViewSplitter.prototype.processElement = function (parent, current, control) {
	        var attrs = current.attrs();
	        var templateBindings = attrs.get('template');
	        var hasTemplateBinding = lang_1.isPresent(templateBindings);
	        // look for template shortcuts such as *ng-if="condition" and treat them as template="if
	        // condition"
	        collection_1.MapWrapper.forEach(attrs, function (attrValue, attrName) {
	            if (lang_1.StringWrapper.startsWith(attrName, '*')) {
	                var key = lang_1.StringWrapper.substring(attrName, 1); // remove the star
	                if (hasTemplateBinding) {
	                    // 2nd template binding detected
	                    throw new exceptions_1.BaseException("Only one template directive per element is allowed: " +
	                        (templateBindings + " and " + key + " cannot be used simultaneously ") +
	                        ("in " + current.elementDescription));
	                }
	                else {
	                    templateBindings = (attrValue.length == 0) ? key : key + ' ' + attrValue;
	                    hasTemplateBinding = true;
	                }
	            }
	        });
	        if (lang_1.isPresent(parent)) {
	            if (dom_adapter_1.DOM.isTemplateElement(current.element)) {
	                if (!current.isViewRoot) {
	                    var viewRoot = new compile_element_1.CompileElement(dom_adapter_1.DOM.createTemplate(''));
	                    viewRoot.inheritedProtoView = current.bindElement().bindNestedProtoView(viewRoot.element);
	                    // viewRoot doesn't appear in the original template, so we associate
	                    // the current element description to get a more meaningful message in case of error
	                    viewRoot.elementDescription = current.elementDescription;
	                    viewRoot.isViewRoot = true;
	                    this._moveChildNodes(dom_adapter_1.DOM.content(current.element), dom_adapter_1.DOM.content(viewRoot.element));
	                    control.addChild(viewRoot);
	                }
	            }
	            if (hasTemplateBinding) {
	                var anchor = new compile_element_1.CompileElement(dom_adapter_1.DOM.createTemplate(''));
	                anchor.inheritedProtoView = current.inheritedProtoView;
	                anchor.inheritedElementBinder = current.inheritedElementBinder;
	                anchor.distanceToInheritedBinder = current.distanceToInheritedBinder;
	                // newParent doesn't appear in the original template, so we associate
	                // the current element description to get a more meaningful message in case of error
	                anchor.elementDescription = current.elementDescription;
	                var viewRoot = new compile_element_1.CompileElement(dom_adapter_1.DOM.createTemplate(''));
	                viewRoot.inheritedProtoView = anchor.bindElement().bindNestedProtoView(viewRoot.element);
	                // viewRoot doesn't appear in the original template, so we associate
	                // the current element description to get a more meaningful message in case of error
	                viewRoot.elementDescription = current.elementDescription;
	                viewRoot.isViewRoot = true;
	                current.inheritedProtoView = viewRoot.inheritedProtoView;
	                current.inheritedElementBinder = null;
	                current.distanceToInheritedBinder = 0;
	                this._parseTemplateBindings(templateBindings, anchor);
	                dom_adapter_1.DOM.insertBefore(current.element, anchor.element);
	                control.addParent(anchor);
	                dom_adapter_1.DOM.appendChild(dom_adapter_1.DOM.content(viewRoot.element), current.element);
	                control.addParent(viewRoot);
	            }
	        }
	    };
	    ViewSplitter.prototype._moveChildNodes = function (source, target) {
	        var next = dom_adapter_1.DOM.firstChild(source);
	        while (lang_1.isPresent(next)) {
	            dom_adapter_1.DOM.appendChild(target, next);
	            next = dom_adapter_1.DOM.firstChild(source);
	        }
	    };
	    ViewSplitter.prototype._parseTemplateBindings = function (templateBindings, compileElement) {
	        var bindings = this._parser.parseTemplateBindings(templateBindings, compileElement.elementDescription);
	        for (var i = 0; i < bindings.length; i++) {
	            var binding = bindings[i];
	            if (binding.keyIsVar) {
	                compileElement.bindElement().bindVariable(util_1.dashCaseToCamelCase(binding.key), binding.name);
	                compileElement.attrs().set(binding.key, binding.name);
	            }
	            else if (lang_1.isPresent(binding.expression)) {
	                compileElement.bindElement().bindProperty(util_1.dashCaseToCamelCase(binding.key), binding.expression);
	                compileElement.attrs().set(binding.key, binding.expression.source);
	            }
	            else {
	                dom_adapter_1.DOM.setAttribute(compileElement.element, binding.key, '');
	            }
	        }
	    };
	    return ViewSplitter;
	})();
	exports.ViewSplitter = ViewSplitter;
	//# sourceMappingURL=view_splitter.js.map

/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	var api_1 = __webpack_require__(212);
	var util_1 = __webpack_require__(385);
	var dom_adapter_1 = __webpack_require__(386);
	var lang_1 = __webpack_require__(159);
	var shadow_css_1 = __webpack_require__(426);
	var StyleEncapsulator = (function () {
	    function StyleEncapsulator(_appId, _view, _componentUIDsCache) {
	        this._appId = _appId;
	        this._view = _view;
	        this._componentUIDsCache = _componentUIDsCache;
	    }
	    StyleEncapsulator.prototype.processElement = function (parent, current, control) {
	        if (util_1.isElementWithTag(current.element, util_1.NG_CONTENT_ELEMENT_NAME)) {
	            current.inheritedProtoView.bindNgContent();
	        }
	        else {
	            if (this._view.encapsulation === api_1.ViewEncapsulation.Emulated) {
	                this._processEmulatedScopedElement(current, parent);
	            }
	        }
	    };
	    StyleEncapsulator.prototype.processStyle = function (style) {
	        var encapsulation = this._view.encapsulation;
	        if (encapsulation === api_1.ViewEncapsulation.Emulated) {
	            return this._shimCssForComponent(style, this._view.componentId);
	        }
	        else {
	            return style;
	        }
	    };
	    StyleEncapsulator.prototype._processEmulatedScopedElement = function (current, parent) {
	        var element = current.element;
	        var hostComponentId = this._view.componentId;
	        var viewType = current.inheritedProtoView.type;
	        // Shim the element as a child of the compiled component
	        if (viewType !== api_1.ViewType.HOST && lang_1.isPresent(hostComponentId)) {
	            var contentAttribute = getContentAttribute(this._getComponentId(hostComponentId));
	            dom_adapter_1.DOM.setAttribute(element, contentAttribute, '');
	            // also shim the host
	            if (lang_1.isBlank(parent) && viewType == api_1.ViewType.COMPONENT) {
	                var hostAttribute = getHostAttribute(this._getComponentId(hostComponentId));
	                current.inheritedProtoView.setHostAttribute(hostAttribute, '');
	            }
	        }
	    };
	    StyleEncapsulator.prototype._shimCssForComponent = function (cssText, componentId) {
	        var id = this._getComponentId(componentId);
	        var shadowCss = new shadow_css_1.ShadowCss();
	        return shadowCss.shimCssText(cssText, getContentAttribute(id), getHostAttribute(id));
	    };
	    StyleEncapsulator.prototype._getComponentId = function (componentStringId) {
	        var id = this._componentUIDsCache.get(componentStringId);
	        if (lang_1.isBlank(id)) {
	            id = this._appId + "-" + this._componentUIDsCache.size;
	            this._componentUIDsCache.set(componentStringId, id);
	        }
	        return id;
	    };
	    return StyleEncapsulator;
	})();
	exports.StyleEncapsulator = StyleEncapsulator;
	// Return the attribute to be added to the component
	function getHostAttribute(compId) {
	    return "_nghost-" + compId;
	}
	// Returns the attribute to be added on every single element nodes in the component
	function getContentAttribute(compId) {
	    return "_ngcontent-" + compId;
	}
	//# sourceMappingURL=style_encapsulator.js.map

/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	var dom_adapter_1 = __webpack_require__(386);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	/**
	 * This file is a port of shadowCSS from webcomponents.js to TypeScript.
	 *
	 * Please make sure to keep to edits in sync with the source file.
	 *
	 * Source:
	 * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js
	 *
	 * The original file level comment is reproduced below
	 */
	/*
	  This is a limited shim for ShadowDOM css styling.
	  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles

	  The intention here is to support only the styling features which can be
	  relatively simply implemented. The goal is to allow users to avoid the
	  most obvious pitfalls and do so without compromising performance significantly.
	  For ShadowDOM styling that's not covered here, a set of best practices
	  can be provided that should allow users to accomplish more complex styling.

	  The following is a list of specific ShadowDOM styling features and a brief
	  discussion of the approach used to shim.

	  Shimmed features:

	  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host
	  element using the :host rule. To shim this feature, the :host styles are
	  reformatted and prefixed with a given scope name and promoted to a
	  document level stylesheet.
	  For example, given a scope name of .foo, a rule like this:

	    :host {
	        background: red;
	      }
	    }

	  becomes:

	    .foo {
	      background: red;
	    }

	  * encapsultion: Styles defined within ShadowDOM, apply only to
	  dom inside the ShadowDOM. Polymer uses one of two techniques to imlement
	  this feature.

	  By default, rules are prefixed with the host element tag name
	  as a descendant selector. This ensures styling does not leak out of the 'top'
	  of the element's ShadowDOM. For example,

	  div {
	      font-weight: bold;
	    }

	  becomes:

	  x-foo div {
	      font-weight: bold;
	    }

	  becomes:


	  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then
	  selectors are scoped by adding an attribute selector suffix to each
	  simple selector that contains the host element tag name. Each element
	  in the element's ShadowDOM template is also given the scope attribute.
	  Thus, these rules match only elements that have the scope attribute.
	  For example, given a scope name of x-foo, a rule like this:

	    div {
	      font-weight: bold;
	    }

	  becomes:

	    div[x-foo] {
	      font-weight: bold;
	    }

	  Note that elements that are dynamically added to a scope must have the scope
	  selector added to them manually.

	  * upper/lower bound encapsulation: Styles which are defined outside a
	  shadowRoot should not cross the ShadowDOM boundary and should not apply
	  inside a shadowRoot.

	  This styling behavior is not emulated. Some possible ways to do this that
	  were rejected due to complexity and/or performance concerns include: (1) reset
	  every possible property for every possible selector for a given scope name;
	  (2) re-implement css in javascript.

	  As an alternative, users should make sure to use selectors
	  specific to the scope in which they are working.

	  * ::distributed: This behavior is not emulated. It's often not necessary
	  to style the contents of a specific insertion point and instead, descendants
	  of the host element can be styled selectively. Users can also create an
	  extra node around an insertion point and style that node's contents
	  via descendent selectors. For example, with a shadowRoot like this:

	    <style>
	      ::content(div) {
	        background: red;
	      }
	    </style>
	    <content></content>

	  could become:

	    <style>
	      / *@polyfill .content-container div * /
	      ::content(div) {
	        background: red;
	      }
	    </style>
	    <div class="content-container">
	      <content></content>
	    </div>

	  Note the use of @polyfill in the comment above a ShadowDOM specific style
	  declaration. This is a directive to the styling shim to use the selector
	  in comments in lieu of the next selector when running under polyfill.
	*/
	var ShadowCss = (function () {
	    function ShadowCss() {
	        this.strictStyling = true;
	    }
	    /*
	    * Shim a style element with the given selector. Returns cssText that can
	    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
	    */
	    ShadowCss.prototype.shimStyle = function (style, selector, hostSelector) {
	        if (hostSelector === void 0) { hostSelector = ''; }
	        var cssText = dom_adapter_1.DOM.getText(style);
	        return this.shimCssText(cssText, selector, hostSelector);
	    };
	    /*
	    * Shim some cssText with the given selector. Returns cssText that can
	    * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).
	    *
	    * When strictStyling is true:
	    * - selector is the attribute added to all elements inside the host,
	    * - hostSelector is the attribute added to the host itself.
	    */
	    ShadowCss.prototype.shimCssText = function (cssText, selector, hostSelector) {
	        if (hostSelector === void 0) { hostSelector = ''; }
	        cssText = this._insertDirectives(cssText);
	        return this._scopeCssText(cssText, selector, hostSelector);
	    };
	    ShadowCss.prototype._insertDirectives = function (cssText) {
	        cssText = this._insertPolyfillDirectivesInCssText(cssText);
	        return this._insertPolyfillRulesInCssText(cssText);
	    };
	    /*
	     * Process styles to convert native ShadowDOM rules that will trip
	     * up the css parser; we rely on decorating the stylesheet with inert rules.
	     *
	     * For example, we convert this rule:
	     *
	     * polyfill-next-selector { content: ':host menu-item'; }
	     * ::content menu-item {
	     *
	     * to this:
	     *
	     * scopeName menu-item {
	     *
	    **/
	    ShadowCss.prototype._insertPolyfillDirectivesInCssText = function (cssText) {
	        // Difference with webcomponents.js: does not handle comments
	        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentNextSelectorRe, function (m) { return m[1] + '{'; });
	    };
	    /*
	     * Process styles to add rules which will only apply under the polyfill
	     *
	     * For example, we convert this rule:
	     *
	     * polyfill-rule {
	     *   content: ':host menu-item';
	     * ...
	     * }
	     *
	     * to this:
	     *
	     * scopeName menu-item {...}
	     *
	    **/
	    ShadowCss.prototype._insertPolyfillRulesInCssText = function (cssText) {
	        // Difference with webcomponents.js: does not handle comments
	        return lang_1.StringWrapper.replaceAllMapped(cssText, _cssContentRuleRe, function (m) {
	            var rule = m[0];
	            rule = lang_1.StringWrapper.replace(rule, m[1], '');
	            rule = lang_1.StringWrapper.replace(rule, m[2], '');
	            return m[3] + rule;
	        });
	    };
	    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:
	     *
	     *  .foo {... }
	     *
	     *  and converts this to
	     *
	     *  scopeName .foo { ... }
	    */
	    ShadowCss.prototype._scopeCssText = function (cssText, scopeSelector, hostSelector) {
	        var _this = this;
	        var unscoped = this._extractUnscopedRulesFromCssText(cssText);
	        cssText = this._insertPolyfillHostInCssText(cssText);
	        cssText = this._convertColonHost(cssText);
	        cssText = this._convertColonHostContext(cssText);
	        cssText = this._convertShadowDOMSelectors(cssText);
	        if (lang_1.isPresent(scopeSelector)) {
	            _withCssRules(cssText, function (rules) { cssText = _this._scopeRules(rules, scopeSelector, hostSelector); });
	        }
	        cssText = cssText + '\n' + unscoped;
	        return cssText.trim();
	    };
	    /*
	     * Process styles to add rules which will only apply under the polyfill
	     * and do not process via CSSOM. (CSSOM is destructive to rules on rare
	     * occasions, e.g. -webkit-calc on Safari.)
	     * For example, we convert this rule:
	     *
	     * @polyfill-unscoped-rule {
	     *   content: 'menu-item';
	     * ... }
	     *
	     * to this:
	     *
	     * menu-item {...}
	     *
	    **/
	    ShadowCss.prototype._extractUnscopedRulesFromCssText = function (cssText) {
	        // Difference with webcomponents.js: does not handle comments
	        var r = '', m;
	        var matcher = lang_1.RegExpWrapper.matcher(_cssContentUnscopedRuleRe, cssText);
	        while (lang_1.isPresent(m = lang_1.RegExpMatcherWrapper.next(matcher))) {
	            var rule = m[0];
	            rule = lang_1.StringWrapper.replace(rule, m[2], '');
	            rule = lang_1.StringWrapper.replace(rule, m[1], m[3]);
	            r += rule + '\n\n';
	        }
	        return r;
	    };
	    /*
	     * convert a rule like :host(.foo) > .bar { }
	     *
	     * to
	     *
	     * scopeName.foo > .bar
	    */
	    ShadowCss.prototype._convertColonHost = function (cssText) {
	        return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);
	    };
	    /*
	     * convert a rule like :host-context(.foo) > .bar { }
	     *
	     * to
	     *
	     * scopeName.foo > .bar, .foo scopeName > .bar { }
	     *
	     * and
	     *
	     * :host-context(.foo:host) .bar { ... }
	     *
	     * to
	     *
	     * scopeName.foo .bar { ... }
	    */
	    ShadowCss.prototype._convertColonHostContext = function (cssText) {
	        return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);
	    };
	    ShadowCss.prototype._convertColonRule = function (cssText, regExp, partReplacer) {
	        // p1 = :host, p2 = contents of (), p3 rest of rule
	        return lang_1.StringWrapper.replaceAllMapped(cssText, regExp, function (m) {
	            if (lang_1.isPresent(m[2])) {
	                var parts = m[2].split(','), r = [];
	                for (var i = 0; i < parts.length; i++) {
	                    var p = parts[i];
	                    if (lang_1.isBlank(p))
	                        break;
	                    p = p.trim();
	                    r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));
	                }
	                return r.join(',');
	            }
	            else {
	                return _polyfillHostNoCombinator + m[3];
	            }
	        });
	    };
	    ShadowCss.prototype._colonHostContextPartReplacer = function (host, part, suffix) {
	        if (lang_1.StringWrapper.contains(part, _polyfillHost)) {
	            return this._colonHostPartReplacer(host, part, suffix);
	        }
	        else {
	            return host + part + suffix + ', ' + part + ' ' + host + suffix;
	        }
	    };
	    ShadowCss.prototype._colonHostPartReplacer = function (host, part, suffix) {
	        return host + lang_1.StringWrapper.replace(part, _polyfillHost, '') + suffix;
	    };
	    /*
	     * Convert combinators like ::shadow and pseudo-elements like ::content
	     * by replacing with space.
	    */
	    ShadowCss.prototype._convertShadowDOMSelectors = function (cssText) {
	        for (var i = 0; i < _shadowDOMSelectorsRe.length; i++) {
	            cssText = lang_1.StringWrapper.replaceAll(cssText, _shadowDOMSelectorsRe[i], ' ');
	        }
	        return cssText;
	    };
	    // change a selector like 'div' to 'name div'
	    ShadowCss.prototype._scopeRules = function (cssRules, scopeSelector, hostSelector) {
	        var cssText = '';
	        if (lang_1.isPresent(cssRules)) {
	            for (var i = 0; i < cssRules.length; i++) {
	                var rule = cssRules[i];
	                if (dom_adapter_1.DOM.isStyleRule(rule) || dom_adapter_1.DOM.isPageRule(rule)) {
	                    cssText += this._scopeSelector(rule.selectorText, scopeSelector, hostSelector, this.strictStyling) +
	                        ' {\n';
	                    cssText += this._propertiesFromRule(rule) + '\n}\n\n';
	                }
	                else if (dom_adapter_1.DOM.isMediaRule(rule)) {
	                    cssText += '@media ' + rule.media.mediaText + ' {\n';
	                    cssText += this._scopeRules(rule.cssRules, scopeSelector, hostSelector);
	                    cssText += '\n}\n\n';
	                }
	                else {
	                    // KEYFRAMES_RULE in IE throws when we query cssText
	                    // when it contains a -webkit- property.
	                    // if this happens, we fallback to constructing the rule
	                    // from the CSSRuleSet
	                    // https://connect.microsoft.com/IE/feedbackdetail/view/955703/accessing-csstext-of-a-keyframe-rule-that-contains-a-webkit-property-via-cssom-generates-exception
	                    try {
	                        if (lang_1.isPresent(rule.cssText)) {
	                            cssText += rule.cssText + '\n\n';
	                        }
	                    }
	                    catch (x) {
	                        if (dom_adapter_1.DOM.isKeyframesRule(rule) && lang_1.isPresent(rule.cssRules)) {
	                            cssText += this._ieSafeCssTextFromKeyFrameRule(rule);
	                        }
	                    }
	                }
	            }
	        }
	        return cssText;
	    };
	    ShadowCss.prototype._ieSafeCssTextFromKeyFrameRule = function (rule) {
	        var cssText = '@keyframes ' + rule.name + ' {';
	        for (var i = 0; i < rule.cssRules.length; i++) {
	            var r = rule.cssRules[i];
	            cssText += ' ' + r.keyText + ' {' + r.style.cssText + '}';
	        }
	        cssText += ' }';
	        return cssText;
	    };
	    ShadowCss.prototype._scopeSelector = function (selector, scopeSelector, hostSelector, strict) {
	        var r = [], parts = selector.split(',');
	        for (var i = 0; i < parts.length; i++) {
	            var p = parts[i];
	            p = p.trim();
	            if (this._selectorNeedsScoping(p, scopeSelector)) {
	                p = strict && !lang_1.StringWrapper.contains(p, _polyfillHostNoCombinator) ?
	                    this._applyStrictSelectorScope(p, scopeSelector) :
	                    this._applySelectorScope(p, scopeSelector, hostSelector);
	            }
	            r.push(p);
	        }
	        return r.join(', ');
	    };
	    ShadowCss.prototype._selectorNeedsScoping = function (selector, scopeSelector) {
	        var re = this._makeScopeMatcher(scopeSelector);
	        return !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(re, selector));
	    };
	    ShadowCss.prototype._makeScopeMatcher = function (scopeSelector) {
	        var lre = /\[/g;
	        var rre = /\]/g;
	        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, lre, '\\[');
	        scopeSelector = lang_1.StringWrapper.replaceAll(scopeSelector, rre, '\\]');
	        return lang_1.RegExpWrapper.create('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');
	    };
	    ShadowCss.prototype._applySelectorScope = function (selector, scopeSelector, hostSelector) {
	        // Difference from webcomponentsjs: scopeSelector could not be an array
	        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);
	    };
	    // scope via name and [is=name]
	    ShadowCss.prototype._applySimpleSelectorScope = function (selector, scopeSelector, hostSelector) {
	        if (lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(_polyfillHostRe, selector))) {
	            var replaceBy = this.strictStyling ? "[" + hostSelector + "]" : scopeSelector;
	            selector = lang_1.StringWrapper.replace(selector, _polyfillHostNoCombinator, replaceBy);
	            return lang_1.StringWrapper.replaceAll(selector, _polyfillHostRe, replaceBy + ' ');
	        }
	        else {
	            return scopeSelector + ' ' + selector;
	        }
	    };
	    // return a selector with [name] suffix on each simple selector
	    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]
	    ShadowCss.prototype._applyStrictSelectorScope = function (selector, scopeSelector) {
	        var isRe = /\[is=([^\]]*)\]/g;
	        scopeSelector = lang_1.StringWrapper.replaceAllMapped(scopeSelector, isRe, function (m) { return m[1]; });
	        var splits = [' ', '>', '+', '~'], scoped = selector, attrName = '[' + scopeSelector + ']';
	        for (var i = 0; i < splits.length; i++) {
	            var sep = splits[i];
	            var parts = scoped.split(sep);
	            scoped = collection_1.ListWrapper.map(parts, function (p) {
	                // remove :host since it should be unnecessary
	                var t = lang_1.StringWrapper.replaceAll(p.trim(), _polyfillHostRe, '');
	                if (t.length > 0 && !collection_1.ListWrapper.contains(splits, t) &&
	                    !lang_1.StringWrapper.contains(t, attrName)) {
	                    var re = /([^:]*)(:*)(.*)/g;
	                    var m = lang_1.RegExpWrapper.firstMatch(re, t);
	                    if (lang_1.isPresent(m)) {
	                        p = m[1] + attrName + m[2] + m[3];
	                    }
	                }
	                return p;
	            }).join(sep);
	        }
	        return scoped;
	    };
	    ShadowCss.prototype._insertPolyfillHostInCssText = function (selector) {
	        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostContextRe, _polyfillHostContext);
	        selector = lang_1.StringWrapper.replaceAll(selector, _colonHostRe, _polyfillHost);
	        return selector;
	    };
	    ShadowCss.prototype._propertiesFromRule = function (rule) {
	        var cssText = rule.style.cssText;
	        // TODO(sorvell): Safari cssom incorrectly removes quotes from the content
	        // property. (https://bugs.webkit.org/show_bug.cgi?id=118045)
	        // don't replace attr rules
	        var attrRe = /['"]+|attr/g;
	        if (rule.style.content.length > 0 &&
	            !lang_1.isPresent(lang_1.RegExpWrapper.firstMatch(attrRe, rule.style.content))) {
	            var contentRe = /content:[^;]*;/g;
	            cssText =
	                lang_1.StringWrapper.replaceAll(cssText, contentRe, 'content: \'' + rule.style.content + '\';');
	        }
	        // TODO(sorvell): we can workaround this issue here, but we need a list
	        // of troublesome properties to fix https://github.com/Polymer/platform/issues/53
	        //
	        // inherit rules can be omitted from cssText
	        // TODO(sorvell): remove when Blink bug is fixed:
	        // https://code.google.com/p/chromium/issues/detail?id=358273
	        // var style = rule.style;
	        // for (var i = 0; i < style.length; i++) {
	        //  var name = style.item(i);
	        //  var value = style.getPropertyValue(name);
	        //  if (value == 'initial') {
	        //    cssText += name + ': initial; ';
	        //  }
	        //}
	        return cssText;
	    };
	    return ShadowCss;
	})();
	exports.ShadowCss = ShadowCss;
	var _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\s]*?['"](.*?)['"][;\s]*}([^{]*?){/gim;
	var _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
	var _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\s]*['"](.*?)['"])[;\s]*[^}]*}/gim;
	var _polyfillHost = '-shadowcsshost';
	// note: :host-context pre-processed to -shadowcsshostcontext.
	var _polyfillHostContext = '-shadowcsscontext';
	var _parenSuffix = ')(?:\\((' +
	    '(?:\\([^)(]*\\)|[^)(]*)+?' +
	    ')\\))?([^,{]*)';
	var _cssColonHostRe = lang_1.RegExpWrapper.create('(' + _polyfillHost + _parenSuffix, 'im');
	var _cssColonHostContextRe = lang_1.RegExpWrapper.create('(' + _polyfillHostContext + _parenSuffix, 'im');
	var _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';
	var _shadowDOMSelectorsRe = [
	    />>>/g,
	    /::shadow/g,
	    /::content/g,
	    // Deprecated selectors
	    // TODO(vicb): see https://github.com/angular/clang-format/issues/16
	    // clang-format off
	    /\/deep\//g,
	    /\/shadow-deep\//g,
	    /\/shadow\//g,
	];
	var _selectorReSuffix = '([>\\s~+\[.,{:][\\s\\S]*)?$';
	var _polyfillHostRe = lang_1.RegExpWrapper.create(_polyfillHost, 'im');
	var _colonHostRe = /:host/gim;
	var _colonHostContextRe = /:host-context/gim;
	function _cssToRules(cssText) {
	    return dom_adapter_1.DOM.cssToRules(cssText);
	}
	function _withCssRules(cssText, callback) {
	    // Difference from webcomponentjs: remove the workaround for an old bug in Chrome
	    if (lang_1.isBlank(callback))
	        return;
	    var rules = _cssToRules(cssText);
	    callback(rules);
	}
	//# sourceMappingURL=shadow_css.js.map

/***/ },
/* 427 */
/***/ function(module, exports) {

	var ElementSchemaRegistry = (function () {
	    function ElementSchemaRegistry() {
	    }
	    ElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) { return true; };
	    ElementSchemaRegistry.prototype.getMappedPropName = function (propName) { return propName; };
	    return ElementSchemaRegistry;
	})();
	exports.ElementSchemaRegistry = ElementSchemaRegistry;
	//# sourceMappingURL=element_schema_registry.js.map

/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	var dom_adapter_1 = __webpack_require__(386);
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var proto_view_1 = __webpack_require__(417);
	var element_binder_1 = __webpack_require__(418);
	var api_1 = __webpack_require__(212);
	var util_1 = __webpack_require__(385);
	function mergeProtoViewsRecursively(templateCloner, protoViewRefs) {
	    // clone
	    var clonedProtoViews = [];
	    var hostViewAndBinderIndices = [];
	    cloneProtoViews(templateCloner, protoViewRefs, clonedProtoViews, hostViewAndBinderIndices);
	    var mainProtoView = clonedProtoViews[0];
	    // modify the DOM
	    mergeEmbeddedPvsIntoComponentOrRootPv(clonedProtoViews, hostViewAndBinderIndices);
	    var fragments = [];
	    var elementsWithNativeShadowRoot = new Set();
	    mergeComponents(clonedProtoViews, hostViewAndBinderIndices, fragments, elementsWithNativeShadowRoot);
	    // Note: Need to remark parent elements of bound text nodes
	    // so that we can find them later via queryBoundElements!
	    markBoundTextNodeParentsAsBoundElements(clonedProtoViews);
	    // create a new root element with the changed fragments and elements
	    var fragmentsRootNodeCount = fragments.map(function (fragment) { return fragment.length; });
	    var rootElement = createRootElementFromFragments(fragments);
	    var rootNode = dom_adapter_1.DOM.content(rootElement);
	    // read out the new element / text node / ElementBinder order
	    var mergedBoundElements = util_1.queryBoundElements(rootNode, false);
	    var mergedBoundTextIndices = new Map();
	    var boundTextNodeMap = indexBoundTextNodes(clonedProtoViews);
	    var rootTextNodeIndices = calcRootTextNodeIndices(rootNode, boundTextNodeMap, mergedBoundTextIndices);
	    var mergedElementBinders = calcElementBinders(clonedProtoViews, mergedBoundElements, elementsWithNativeShadowRoot, boundTextNodeMap, mergedBoundTextIndices);
	    // create element / text index mappings
	    var mappedElementIndices = calcMappedElementIndices(clonedProtoViews, mergedBoundElements);
	    var mappedTextIndices = calcMappedTextIndices(clonedProtoViews, mergedBoundTextIndices);
	    // create result
	    var hostElementIndicesByViewIndex = calcHostElementIndicesByViewIndex(clonedProtoViews, hostViewAndBinderIndices);
	    var nestedViewCounts = calcNestedViewCounts(hostViewAndBinderIndices);
	    var mergedProtoView = proto_view_1.DomProtoView.create(templateCloner, mainProtoView.original.type, rootElement, mainProtoView.original.encapsulation, fragmentsRootNodeCount, rootTextNodeIndices, mergedElementBinders, new Map());
	    return new api_1.RenderProtoViewMergeMapping(new proto_view_1.DomProtoViewRef(mergedProtoView), fragmentsRootNodeCount.length, mappedElementIndices, mergedBoundElements.length, mappedTextIndices, hostElementIndicesByViewIndex, nestedViewCounts);
	}
	exports.mergeProtoViewsRecursively = mergeProtoViewsRecursively;
	function cloneProtoViews(templateCloner, protoViewRefs, targetClonedProtoViews, targetHostViewAndBinderIndices) {
	    var hostProtoView = proto_view_1.resolveInternalDomProtoView(protoViewRefs[0]);
	    var hostPvIdx = targetClonedProtoViews.length;
	    targetClonedProtoViews.push(util_1.cloneAndQueryProtoView(templateCloner, hostProtoView, false));
	    if (targetHostViewAndBinderIndices.length === 0) {
	        targetHostViewAndBinderIndices.push([null, null]);
	    }
	    var protoViewIdx = 1;
	    for (var i = 0; i < hostProtoView.elementBinders.length; i++) {
	        var binder = hostProtoView.elementBinders[i];
	        if (binder.hasNestedProtoView) {
	            var nestedEntry = protoViewRefs[protoViewIdx++];
	            if (lang_1.isPresent(nestedEntry)) {
	                targetHostViewAndBinderIndices.push([hostPvIdx, i]);
	                if (lang_1.isArray(nestedEntry)) {
	                    cloneProtoViews(templateCloner, nestedEntry, targetClonedProtoViews, targetHostViewAndBinderIndices);
	                }
	                else {
	                    targetClonedProtoViews.push(util_1.cloneAndQueryProtoView(templateCloner, proto_view_1.resolveInternalDomProtoView(nestedEntry), false));
	                }
	            }
	        }
	    }
	}
	function markBoundTextNodeParentsAsBoundElements(mergableProtoViews) {
	    mergableProtoViews.forEach(function (mergableProtoView) {
	        mergableProtoView.boundTextNodes.forEach(function (textNode) {
	            var parentNode = textNode.parentNode;
	            if (lang_1.isPresent(parentNode) && dom_adapter_1.DOM.isElementNode(parentNode)) {
	                dom_adapter_1.DOM.addClass(parentNode, util_1.NG_BINDING_CLASS);
	            }
	        });
	    });
	}
	function indexBoundTextNodes(mergableProtoViews) {
	    var boundTextNodeMap = new Map();
	    for (var pvIndex = 0; pvIndex < mergableProtoViews.length; pvIndex++) {
	        var mergableProtoView = mergableProtoViews[pvIndex];
	        mergableProtoView.boundTextNodes.forEach(function (textNode) { boundTextNodeMap.set(textNode, null); });
	    }
	    return boundTextNodeMap;
	}
	function mergeEmbeddedPvsIntoComponentOrRootPv(clonedProtoViews, hostViewAndBinderIndices) {
	    var nearestHostComponentOrRootPvIndices = calcNearestHostComponentOrRootPvIndices(clonedProtoViews, hostViewAndBinderIndices);
	    for (var viewIdx = 1; viewIdx < clonedProtoViews.length; viewIdx++) {
	        var clonedProtoView = clonedProtoViews[viewIdx];
	        if (clonedProtoView.original.type === api_1.ViewType.EMBEDDED) {
	            var hostComponentIdx = nearestHostComponentOrRootPvIndices[viewIdx];
	            var hostPv = clonedProtoViews[hostComponentIdx];
	            clonedProtoView.fragments.forEach(function (fragment) { return hostPv.fragments.push(fragment); });
	        }
	    }
	}
	function calcNearestHostComponentOrRootPvIndices(clonedProtoViews, hostViewAndBinderIndices) {
	    var nearestHostComponentOrRootPvIndices = collection_1.ListWrapper.createFixedSize(clonedProtoViews.length);
	    nearestHostComponentOrRootPvIndices[0] = null;
	    for (var viewIdx = 1; viewIdx < hostViewAndBinderIndices.length; viewIdx++) {
	        var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
	        var hostProtoView = clonedProtoViews[hostViewIdx];
	        if (hostViewIdx === 0 || hostProtoView.original.type === api_1.ViewType.COMPONENT) {
	            nearestHostComponentOrRootPvIndices[viewIdx] = hostViewIdx;
	        }
	        else {
	            nearestHostComponentOrRootPvIndices[viewIdx] =
	                nearestHostComponentOrRootPvIndices[hostViewIdx];
	        }
	    }
	    return nearestHostComponentOrRootPvIndices;
	}
	function mergeComponents(clonedProtoViews, hostViewAndBinderIndices, targetFragments, targetElementsWithNativeShadowRoot) {
	    var hostProtoView = clonedProtoViews[0];
	    hostProtoView.fragments.forEach(function (fragment) { return targetFragments.push(fragment); });
	    for (var viewIdx = 1; viewIdx < clonedProtoViews.length; viewIdx++) {
	        var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
	        var hostBinderIdx = hostViewAndBinderIndices[viewIdx][1];
	        var hostProtoView = clonedProtoViews[hostViewIdx];
	        var clonedProtoView = clonedProtoViews[viewIdx];
	        if (clonedProtoView.original.type === api_1.ViewType.COMPONENT) {
	            mergeComponent(hostProtoView, hostBinderIdx, clonedProtoView, targetFragments, targetElementsWithNativeShadowRoot);
	        }
	    }
	}
	function mergeComponent(hostProtoView, binderIdx, nestedProtoView, targetFragments, targetElementsWithNativeShadowRoot) {
	    var hostElement = hostProtoView.boundElements[binderIdx];
	    // We wrap the fragments into elements so that we can expand <ng-content>
	    // even for root nodes in the fragment without special casing them.
	    var fragmentElements = mapFragmentsIntoElements(nestedProtoView.fragments);
	    var contentElements = findContentElements(fragmentElements);
	    var projectableNodes = dom_adapter_1.DOM.childNodesAsList(hostElement);
	    for (var i = 0; i < contentElements.length; i++) {
	        var contentElement = contentElements[i];
	        var select = dom_adapter_1.DOM.getAttribute(contentElement, 'select');
	        projectableNodes = projectMatchingNodes(select, contentElement, projectableNodes);
	    }
	    // unwrap the fragment elements into arrays of nodes after projecting
	    var fragments = extractFragmentNodesFromElements(fragmentElements);
	    var useNativeShadowRoot = nestedProtoView.original.encapsulation === api_1.ViewEncapsulation.Native;
	    if (useNativeShadowRoot) {
	        targetElementsWithNativeShadowRoot.add(hostElement);
	    }
	    collection_1.MapWrapper.forEach(nestedProtoView.original.hostAttributes, function (attrValue, attrName) {
	        dom_adapter_1.DOM.setAttribute(hostElement, attrName, attrValue);
	    });
	    appendComponentNodesToHost(hostProtoView, binderIdx, fragments[0], useNativeShadowRoot);
	    for (var i = 1; i < fragments.length; i++) {
	        targetFragments.push(fragments[i]);
	    }
	}
	function mapFragmentsIntoElements(fragments) {
	    return fragments.map(function (fragment) {
	        var fragmentElement = dom_adapter_1.DOM.createTemplate('');
	        fragment.forEach(function (node) { return dom_adapter_1.DOM.appendChild(dom_adapter_1.DOM.content(fragmentElement), node); });
	        return fragmentElement;
	    });
	}
	function extractFragmentNodesFromElements(fragmentElements) {
	    return fragmentElements.map(function (fragmentElement) { return dom_adapter_1.DOM.childNodesAsList(dom_adapter_1.DOM.content(fragmentElement)); });
	}
	function findContentElements(fragmentElements) {
	    var contentElements = [];
	    fragmentElements.forEach(function (fragmentElement) {
	        var fragmentContentElements = dom_adapter_1.DOM.querySelectorAll(dom_adapter_1.DOM.content(fragmentElement), util_1.NG_CONTENT_ELEMENT_NAME);
	        for (var i = 0; i < fragmentContentElements.length; i++) {
	            contentElements.push(fragmentContentElements[i]);
	        }
	    });
	    return sortContentElements(contentElements);
	}
	function appendComponentNodesToHost(hostProtoView, binderIdx, componentRootNodes, useNativeShadowRoot) {
	    var hostElement = hostProtoView.boundElements[binderIdx];
	    if (useNativeShadowRoot) {
	        var shadowRootWrapper = dom_adapter_1.DOM.createElement(util_1.NG_SHADOW_ROOT_ELEMENT_NAME);
	        for (var i = 0; i < componentRootNodes.length; i++) {
	            dom_adapter_1.DOM.appendChild(shadowRootWrapper, componentRootNodes[i]);
	        }
	        var firstChild = dom_adapter_1.DOM.firstChild(hostElement);
	        if (lang_1.isPresent(firstChild)) {
	            dom_adapter_1.DOM.insertBefore(firstChild, shadowRootWrapper);
	        }
	        else {
	            dom_adapter_1.DOM.appendChild(hostElement, shadowRootWrapper);
	        }
	    }
	    else {
	        dom_adapter_1.DOM.clearNodes(hostElement);
	        for (var i = 0; i < componentRootNodes.length; i++) {
	            dom_adapter_1.DOM.appendChild(hostElement, componentRootNodes[i]);
	        }
	    }
	}
	function projectMatchingNodes(selector, contentElement, nodes) {
	    var remaining = [];
	    dom_adapter_1.DOM.insertBefore(contentElement, dom_adapter_1.DOM.createComment('['));
	    for (var i = 0; i < nodes.length; i++) {
	        var node = nodes[i];
	        var matches = false;
	        if (isWildcard(selector)) {
	            matches = true;
	        }
	        else if (dom_adapter_1.DOM.isElementNode(node) && dom_adapter_1.DOM.elementMatches(node, selector)) {
	            matches = true;
	        }
	        if (matches) {
	            dom_adapter_1.DOM.insertBefore(contentElement, node);
	        }
	        else {
	            remaining.push(node);
	        }
	    }
	    dom_adapter_1.DOM.insertBefore(contentElement, dom_adapter_1.DOM.createComment(']'));
	    dom_adapter_1.DOM.remove(contentElement);
	    return remaining;
	}
	function isWildcard(selector) {
	    return lang_1.isBlank(selector) || selector.length === 0 || selector == '*';
	}
	// we need to sort content elements as they can originate from
	// different sub views
	function sortContentElements(contentElements) {
	    // for now, only move the wildcard selector to the end.
	    // TODO(tbosch): think about sorting by selector specificity...
	    var firstWildcard = null;
	    var sorted = [];
	    contentElements.forEach(function (contentElement) {
	        var select = dom_adapter_1.DOM.getAttribute(contentElement, 'select');
	        if (isWildcard(select)) {
	            if (lang_1.isBlank(firstWildcard)) {
	                firstWildcard = contentElement;
	            }
	        }
	        else {
	            sorted.push(contentElement);
	        }
	    });
	    if (lang_1.isPresent(firstWildcard)) {
	        sorted.push(firstWildcard);
	    }
	    return sorted;
	}
	function createRootElementFromFragments(fragments) {
	    var rootElement = dom_adapter_1.DOM.createTemplate('');
	    var rootNode = dom_adapter_1.DOM.content(rootElement);
	    for (var i = 0; i < fragments.length; i++) {
	        var fragment = fragments[i];
	        if (i >= 1) {
	            // Note: We need to separate fragments by a comment so that sibling
	            // text nodes don't get merged when we serialize the DomProtoView into a string
	            // and parse it back again.
	            dom_adapter_1.DOM.appendChild(rootNode, dom_adapter_1.DOM.createComment('|'));
	        }
	        fragment.forEach(function (node) { dom_adapter_1.DOM.appendChild(rootNode, node); });
	    }
	    return rootElement;
	}
	function calcRootTextNodeIndices(rootNode, boundTextNodes, targetBoundTextIndices) {
	    var rootTextNodeIndices = [];
	    util_1.queryBoundTextNodeIndices(rootNode, boundTextNodes, function (textNode, nodeIndex, _) {
	        rootTextNodeIndices.push(nodeIndex);
	        targetBoundTextIndices.set(textNode, targetBoundTextIndices.size);
	    });
	    return rootTextNodeIndices;
	}
	function calcElementBinders(clonedProtoViews, mergedBoundElements, elementsWithNativeShadowRoot, boundTextNodes, targetBoundTextIndices) {
	    var elementBinderByElement = indexElementBindersByElement(clonedProtoViews);
	    var mergedElementBinders = [];
	    for (var i = 0; i < mergedBoundElements.length; i++) {
	        var element = mergedBoundElements[i];
	        var textNodeIndices = [];
	        util_1.queryBoundTextNodeIndices(element, boundTextNodes, function (textNode, nodeIndex, _) {
	            textNodeIndices.push(nodeIndex);
	            targetBoundTextIndices.set(textNode, targetBoundTextIndices.size);
	        });
	        mergedElementBinders.push(updateElementBinders(elementBinderByElement.get(element), textNodeIndices, collection_1.SetWrapper.has(elementsWithNativeShadowRoot, element)));
	    }
	    return mergedElementBinders;
	}
	function indexElementBindersByElement(mergableProtoViews) {
	    var elementBinderByElement = new Map();
	    mergableProtoViews.forEach(function (mergableProtoView) {
	        for (var i = 0; i < mergableProtoView.boundElements.length; i++) {
	            var el = mergableProtoView.boundElements[i];
	            if (lang_1.isPresent(el)) {
	                elementBinderByElement.set(el, mergableProtoView.original.elementBinders[i]);
	            }
	        }
	    });
	    return elementBinderByElement;
	}
	function updateElementBinders(elementBinder, textNodeIndices, hasNativeShadowRoot) {
	    var result;
	    if (lang_1.isBlank(elementBinder)) {
	        result = new element_binder_1.DomElementBinder({
	            textNodeIndices: textNodeIndices,
	            hasNestedProtoView: false,
	            eventLocals: null,
	            localEvents: [],
	            globalEvents: [],
	            hasNativeShadowRoot: false
	        });
	    }
	    else {
	        result = new element_binder_1.DomElementBinder({
	            textNodeIndices: textNodeIndices,
	            hasNestedProtoView: false,
	            eventLocals: elementBinder.eventLocals,
	            localEvents: elementBinder.localEvents,
	            globalEvents: elementBinder.globalEvents,
	            hasNativeShadowRoot: hasNativeShadowRoot
	        });
	    }
	    return result;
	}
	function calcMappedElementIndices(clonedProtoViews, mergedBoundElements) {
	    var mergedBoundElementIndices = indexArray(mergedBoundElements);
	    var mappedElementIndices = [];
	    clonedProtoViews.forEach(function (clonedProtoView) {
	        clonedProtoView.boundElements.forEach(function (boundElement) {
	            var mappedElementIndex = mergedBoundElementIndices.get(boundElement);
	            mappedElementIndices.push(mappedElementIndex);
	        });
	    });
	    return mappedElementIndices;
	}
	function calcMappedTextIndices(clonedProtoViews, mergedBoundTextIndices) {
	    var mappedTextIndices = [];
	    clonedProtoViews.forEach(function (clonedProtoView) {
	        clonedProtoView.boundTextNodes.forEach(function (textNode) {
	            var mappedTextIndex = mergedBoundTextIndices.get(textNode);
	            mappedTextIndices.push(mappedTextIndex);
	        });
	    });
	    return mappedTextIndices;
	}
	function calcHostElementIndicesByViewIndex(clonedProtoViews, hostViewAndBinderIndices) {
	    var hostElementIndices = [null];
	    var viewElementOffsets = [0];
	    var elementIndex = clonedProtoViews[0].original.elementBinders.length;
	    for (var viewIdx = 1; viewIdx < hostViewAndBinderIndices.length; viewIdx++) {
	        viewElementOffsets.push(elementIndex);
	        elementIndex += clonedProtoViews[viewIdx].original.elementBinders.length;
	        var hostViewIdx = hostViewAndBinderIndices[viewIdx][0];
	        var hostBinderIdx = hostViewAndBinderIndices[viewIdx][1];
	        hostElementIndices.push(viewElementOffsets[hostViewIdx] + hostBinderIdx);
	    }
	    return hostElementIndices;
	}
	function calcNestedViewCounts(hostViewAndBinderIndices) {
	    var nestedViewCounts = collection_1.ListWrapper.createFixedSize(hostViewAndBinderIndices.length);
	    collection_1.ListWrapper.fill(nestedViewCounts, 0);
	    for (var viewIdx = hostViewAndBinderIndices.length - 1; viewIdx >= 1; viewIdx--) {
	        var hostViewAndElementIdx = hostViewAndBinderIndices[viewIdx];
	        if (lang_1.isPresent(hostViewAndElementIdx)) {
	            nestedViewCounts[hostViewAndElementIdx[0]] += nestedViewCounts[viewIdx] + 1;
	        }
	    }
	    return nestedViewCounts;
	}
	function indexArray(arr) {
	    var map = new Map();
	    for (var i = 0; i < arr.length; i++) {
	        map.set(arr[i], i);
	    }
	    return map;
	}
	//# sourceMappingURL=proto_view_merger.js.map

/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var lang_1 = __webpack_require__(159);
	var di_1 = __webpack_require__(160);
	var dom_adapter_1 = __webpack_require__(386);
	var dom_tokens_1 = __webpack_require__(411);
	var TemplateCloner = (function () {
	    function TemplateCloner(maxInMemoryElementsPerTemplate) {
	        this.maxInMemoryElementsPerTemplate = maxInMemoryElementsPerTemplate;
	    }
	    TemplateCloner.prototype.prepareForClone = function (templateRoot) {
	        var elementCount = dom_adapter_1.DOM.querySelectorAll(dom_adapter_1.DOM.content(templateRoot), '*').length;
	        if (this.maxInMemoryElementsPerTemplate >= 0 &&
	            elementCount >= this.maxInMemoryElementsPerTemplate) {
	            return dom_adapter_1.DOM.getInnerHTML(templateRoot);
	        }
	        else {
	            return templateRoot;
	        }
	    };
	    TemplateCloner.prototype.cloneContent = function (preparedTemplateRoot, importNode) {
	        var templateContent;
	        if (lang_1.isString(preparedTemplateRoot)) {
	            templateContent = dom_adapter_1.DOM.content(dom_adapter_1.DOM.createTemplate(preparedTemplateRoot));
	            if (importNode) {
	                // Attention: We can't use document.adoptNode here
	                // as this does NOT wake up custom elements in Chrome 43
	                // TODO: Use div.innerHTML instead of template.innerHTML when we
	                // have code to support the various special cases and
	                // don't use importNode additionally (e.g. for <tr>, svg elements, ...)
	                // see https://github.com/angular/angular/issues/3364
	                templateContent = dom_adapter_1.DOM.importIntoDoc(templateContent);
	            }
	        }
	        else {
	            templateContent = dom_adapter_1.DOM.content(preparedTemplateRoot);
	            if (importNode) {
	                templateContent = dom_adapter_1.DOM.importIntoDoc(templateContent);
	            }
	            else {
	                templateContent = dom_adapter_1.DOM.clone(templateContent);
	            }
	        }
	        return templateContent;
	    };
	    TemplateCloner = __decorate([
	        di_1.Injectable(),
	        __param(0, di_1.Inject(dom_tokens_1.MAX_IN_MEMORY_ELEMENTS_PER_TEMPLATE)), 
	        __metadata('design:paramtypes', [Object])
	    ], TemplateCloner);
	    return TemplateCloner;
	})();
	exports.TemplateCloner = TemplateCloner;
	//# sourceMappingURL=template_cloner.js.map

/***/ },
/* 430 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var dom_adapter_1 = __webpack_require__(386);
	var event_manager_1 = __webpack_require__(431);
	var proto_view_1 = __webpack_require__(417);
	var view_1 = __webpack_require__(433);
	var fragment_1 = __webpack_require__(434);
	var shared_styles_host_1 = __webpack_require__(410);
	var util_1 = __webpack_require__(385);
	var profile_1 = __webpack_require__(190);
	var api_1 = __webpack_require__(212);
	var template_cloner_1 = __webpack_require__(429);
	var dom_tokens_1 = __webpack_require__(411);
	var REFLECT_PREFIX = 'ng-reflect-';
	var DomRenderer = (function (_super) {
	    __extends(DomRenderer, _super);
	    function DomRenderer(_eventManager, _domSharedStylesHost, _templateCloner, document) {
	        _super.call(this);
	        this._eventManager = _eventManager;
	        this._domSharedStylesHost = _domSharedStylesHost;
	        this._templateCloner = _templateCloner;
	        this._createRootHostViewScope = profile_1.wtfCreateScope('DomRenderer#createRootHostView()');
	        this._createViewScope = profile_1.wtfCreateScope('DomRenderer#createView()');
	        this._detachFragmentScope = profile_1.wtfCreateScope('DomRenderer#detachFragment()');
	        this._setEventDispatcherScope = profile_1.wtfCreateScope('DomRenderer#setEventDispatcher()');
	        this._document = document;
	    }
	    DomRenderer.prototype.createRootHostView = function (hostProtoViewRef, fragmentCount, hostElementSelector) {
	        var s = this._createRootHostViewScope();
	        var hostProtoView = proto_view_1.resolveInternalDomProtoView(hostProtoViewRef);
	        var element = dom_adapter_1.DOM.querySelector(this._document, hostElementSelector);
	        if (lang_1.isBlank(element)) {
	            profile_1.wtfLeave(s);
	            throw new exceptions_1.BaseException("The selector \"" + hostElementSelector + "\" did not match any elements");
	        }
	        return profile_1.wtfLeave(s, this._createView(hostProtoView, element));
	    };
	    DomRenderer.prototype.createView = function (protoViewRef, fragmentCount) {
	        var s = this._createViewScope();
	        var protoView = proto_view_1.resolveInternalDomProtoView(protoViewRef);
	        return profile_1.wtfLeave(s, this._createView(protoView, null));
	    };
	    DomRenderer.prototype.destroyView = function (viewRef) {
	        var view = view_1.resolveInternalDomView(viewRef);
	        var elementBinders = view.proto.elementBinders;
	        for (var i = 0; i < elementBinders.length; i++) {
	            var binder = elementBinders[i];
	            if (binder.hasNativeShadowRoot) {
	                this._domSharedStylesHost.removeHost(dom_adapter_1.DOM.getShadowRoot(view.boundElements[i]));
	            }
	        }
	    };
	    DomRenderer.prototype.getNativeElementSync = function (location) {
	        if (lang_1.isBlank(location.renderBoundElementIndex)) {
	            return null;
	        }
	        return view_1.resolveInternalDomView(location.renderView)
	            .boundElements[location.renderBoundElementIndex];
	    };
	    DomRenderer.prototype.getRootNodes = function (fragment) { return fragment_1.resolveInternalDomFragment(fragment); };
	    DomRenderer.prototype.attachFragmentAfterFragment = function (previousFragmentRef, fragmentRef) {
	        var previousFragmentNodes = fragment_1.resolveInternalDomFragment(previousFragmentRef);
	        if (previousFragmentNodes.length > 0) {
	            var sibling = previousFragmentNodes[previousFragmentNodes.length - 1];
	            moveNodesAfterSibling(sibling, fragment_1.resolveInternalDomFragment(fragmentRef));
	        }
	    };
	    DomRenderer.prototype.attachFragmentAfterElement = function (elementRef, fragmentRef) {
	        if (lang_1.isBlank(elementRef.renderBoundElementIndex)) {
	            return;
	        }
	        var parentView = view_1.resolveInternalDomView(elementRef.renderView);
	        var element = parentView.boundElements[elementRef.renderBoundElementIndex];
	        moveNodesAfterSibling(element, fragment_1.resolveInternalDomFragment(fragmentRef));
	    };
	    DomRenderer.prototype.detachFragment = function (fragmentRef) {
	        var s = this._detachFragmentScope();
	        var fragmentNodes = fragment_1.resolveInternalDomFragment(fragmentRef);
	        for (var i = 0; i < fragmentNodes.length; i++) {
	            dom_adapter_1.DOM.remove(fragmentNodes[i]);
	        }
	        profile_1.wtfLeave(s);
	    };
	    DomRenderer.prototype.hydrateView = function (viewRef) {
	        var view = view_1.resolveInternalDomView(viewRef);
	        if (view.hydrated)
	            throw new exceptions_1.BaseException('The view is already hydrated.');
	        view.hydrated = true;
	        // add global events
	        view.eventHandlerRemovers = [];
	        var binders = view.proto.elementBinders;
	        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
	            var binder = binders[binderIdx];
	            if (lang_1.isPresent(binder.globalEvents)) {
	                for (var i = 0; i < binder.globalEvents.length; i++) {
	                    var globalEvent = binder.globalEvents[i];
	                    var remover = this._createGlobalEventListener(view, binderIdx, globalEvent.name, globalEvent.target, globalEvent.fullName);
	                    view.eventHandlerRemovers.push(remover);
	                }
	            }
	        }
	    };
	    DomRenderer.prototype.dehydrateView = function (viewRef) {
	        var view = view_1.resolveInternalDomView(viewRef);
	        // remove global events
	        for (var i = 0; i < view.eventHandlerRemovers.length; i++) {
	            view.eventHandlerRemovers[i]();
	        }
	        view.eventHandlerRemovers = null;
	        view.hydrated = false;
	    };
	    DomRenderer.prototype.setElementProperty = function (location, propertyName, propertyValue) {
	        if (lang_1.isBlank(location.renderBoundElementIndex)) {
	            return;
	        }
	        var view = view_1.resolveInternalDomView(location.renderView);
	        view.setElementProperty(location.renderBoundElementIndex, propertyName, propertyValue);
	    };
	    DomRenderer.prototype.setElementAttribute = function (location, attributeName, attributeValue) {
	        if (lang_1.isBlank(location.renderBoundElementIndex)) {
	            return;
	        }
	        var view = view_1.resolveInternalDomView(location.renderView);
	        view.setElementAttribute(location.renderBoundElementIndex, attributeName, attributeValue);
	    };
	    DomRenderer.prototype.setElementClass = function (location, className, isAdd) {
	        if (lang_1.isBlank(location.renderBoundElementIndex)) {
	            return;
	        }
	        var view = view_1.resolveInternalDomView(location.renderView);
	        view.setElementClass(location.renderBoundElementIndex, className, isAdd);
	    };
	    DomRenderer.prototype.setElementStyle = function (location, styleName, styleValue) {
	        if (lang_1.isBlank(location.renderBoundElementIndex)) {
	            return;
	        }
	        var view = view_1.resolveInternalDomView(location.renderView);
	        view.setElementStyle(location.renderBoundElementIndex, styleName, styleValue);
	    };
	    DomRenderer.prototype.invokeElementMethod = function (location, methodName, args) {
	        if (lang_1.isBlank(location.renderBoundElementIndex)) {
	            return;
	        }
	        var view = view_1.resolveInternalDomView(location.renderView);
	        view.invokeElementMethod(location.renderBoundElementIndex, methodName, args);
	    };
	    DomRenderer.prototype.setText = function (viewRef, textNodeIndex, text) {
	        if (lang_1.isBlank(textNodeIndex)) {
	            return;
	        }
	        var view = view_1.resolveInternalDomView(viewRef);
	        dom_adapter_1.DOM.setText(view.boundTextNodes[textNodeIndex], text);
	    };
	    DomRenderer.prototype.setEventDispatcher = function (viewRef, dispatcher /*api.EventDispatcher*/) {
	        var s = this._setEventDispatcherScope();
	        var view = view_1.resolveInternalDomView(viewRef);
	        view.eventDispatcher = dispatcher;
	        profile_1.wtfLeave(s);
	    };
	    DomRenderer.prototype._createView = function (protoView, inplaceElement) {
	        var clonedProtoView = util_1.cloneAndQueryProtoView(this._templateCloner, protoView, true);
	        var boundElements = clonedProtoView.boundElements;
	        // adopt inplaceElement
	        if (lang_1.isPresent(inplaceElement)) {
	            if (protoView.fragmentsRootNodeCount[0] !== 1) {
	                throw new exceptions_1.BaseException('Root proto views can only contain one element!');
	            }
	            dom_adapter_1.DOM.clearNodes(inplaceElement);
	            var tempRoot = clonedProtoView.fragments[0][0];
	            moveChildNodes(tempRoot, inplaceElement);
	            if (boundElements.length > 0 && boundElements[0] === tempRoot) {
	                boundElements[0] = inplaceElement;
	            }
	            clonedProtoView.fragments[0][0] = inplaceElement;
	        }
	        var view = new view_1.DomView(protoView, clonedProtoView.boundTextNodes, boundElements);
	        var binders = protoView.elementBinders;
	        for (var binderIdx = 0; binderIdx < binders.length; binderIdx++) {
	            var binder = binders[binderIdx];
	            var element = boundElements[binderIdx];
	            // native shadow DOM
	            if (binder.hasNativeShadowRoot) {
	                var shadowRootWrapper = dom_adapter_1.DOM.firstChild(element);
	                var shadowRoot = dom_adapter_1.DOM.createShadowRoot(element);
	                this._domSharedStylesHost.addHost(shadowRoot);
	                moveChildNodes(shadowRootWrapper, shadowRoot);
	                dom_adapter_1.DOM.remove(shadowRootWrapper);
	            }
	            // events
	            if (lang_1.isPresent(binder.eventLocals) && lang_1.isPresent(binder.localEvents)) {
	                for (var i = 0; i < binder.localEvents.length; i++) {
	                    this._createEventListener(view, element, binderIdx, binder.localEvents[i].name, binder.eventLocals);
	                }
	            }
	        }
	        return new api_1.RenderViewWithFragments(new view_1.DomViewRef(view), clonedProtoView.fragments.map(function (nodes) { return new fragment_1.DomFragmentRef(nodes); }));
	    };
	    DomRenderer.prototype._createEventListener = function (view, element, elementIndex, eventName, eventLocals) {
	        this._eventManager.addEventListener(element, eventName, function (event) { view.dispatchEvent(elementIndex, eventName, event); });
	    };
	    DomRenderer.prototype._createGlobalEventListener = function (view, elementIndex, eventName, eventTarget, fullName) {
	        return this._eventManager.addGlobalEventListener(eventTarget, eventName, function (event) { view.dispatchEvent(elementIndex, fullName, event); });
	    };
	    DomRenderer = __decorate([
	        di_1.Injectable(),
	        __param(3, di_1.Inject(dom_tokens_1.DOCUMENT)), 
	        __metadata('design:paramtypes', [event_manager_1.EventManager, shared_styles_host_1.DomSharedStylesHost, template_cloner_1.TemplateCloner, Object])
	    ], DomRenderer);
	    return DomRenderer;
	})(api_1.Renderer);
	exports.DomRenderer = DomRenderer;
	function moveNodesAfterSibling(sibling, nodes) {
	    if (nodes.length > 0 && lang_1.isPresent(dom_adapter_1.DOM.parentElement(sibling))) {
	        for (var i = 0; i < nodes.length; i++) {
	            dom_adapter_1.DOM.insertBefore(sibling, nodes[i]);
	        }
	        dom_adapter_1.DOM.insertBefore(nodes[nodes.length - 1], sibling);
	    }
	}
	function moveChildNodes(source, target) {
	    var currChild = dom_adapter_1.DOM.firstChild(source);
	    while (lang_1.isPresent(currChild)) {
	        var nextChild = dom_adapter_1.DOM.nextSibling(currChild);
	        dom_adapter_1.DOM.appendChild(target, currChild);
	        currChild = nextChild;
	    }
	}
	//# sourceMappingURL=dom_renderer.js.map

/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var collection_1 = __webpack_require__(166);
	var dom_adapter_1 = __webpack_require__(386);
	var ng_zone_1 = __webpack_require__(432);
	var di_1 = __webpack_require__(160);
	exports.EVENT_MANAGER_PLUGINS = lang_1.CONST_EXPR(new di_1.OpaqueToken("EventManagerPlugins"));
	var EventManager = (function () {
	    function EventManager(plugins, _zone) {
	        var _this = this;
	        this._zone = _zone;
	        plugins.forEach(function (p) { return p.manager = _this; });
	        this._plugins = collection_1.ListWrapper.reversed(plugins);
	    }
	    EventManager.prototype.addEventListener = function (element, eventName, handler) {
	        var plugin = this._findPluginFor(eventName);
	        plugin.addEventListener(element, eventName, handler);
	    };
	    EventManager.prototype.addGlobalEventListener = function (target, eventName, handler) {
	        var plugin = this._findPluginFor(eventName);
	        return plugin.addGlobalEventListener(target, eventName, handler);
	    };
	    EventManager.prototype.getZone = function () { return this._zone; };
	    EventManager.prototype._findPluginFor = function (eventName) {
	        var plugins = this._plugins;
	        for (var i = 0; i < plugins.length; i++) {
	            var plugin = plugins[i];
	            if (plugin.supports(eventName)) {
	                return plugin;
	            }
	        }
	        throw new exceptions_1.BaseException("No event manager plugin found for event " + eventName);
	    };
	    EventManager = __decorate([
	        di_1.Injectable(),
	        __param(0, di_1.Inject(exports.EVENT_MANAGER_PLUGINS)), 
	        __metadata('design:paramtypes', [Array, ng_zone_1.NgZone])
	    ], EventManager);
	    return EventManager;
	})();
	exports.EventManager = EventManager;
	var EventManagerPlugin = (function () {
	    function EventManagerPlugin() {
	    }
	    // That is equivalent to having supporting $event.target
	    EventManagerPlugin.prototype.supports = function (eventName) { return false; };
	    EventManagerPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        throw "not implemented";
	    };
	    EventManagerPlugin.prototype.addGlobalEventListener = function (element, eventName, handler) {
	        throw "not implemented";
	    };
	    return EventManagerPlugin;
	})();
	exports.EventManagerPlugin = EventManagerPlugin;
	var DomEventsPlugin = (function (_super) {
	    __extends(DomEventsPlugin, _super);
	    function DomEventsPlugin() {
	        _super.apply(this, arguments);
	    }
	    // This plugin should come last in the list of plugins, because it accepts all
	    // events.
	    DomEventsPlugin.prototype.supports = function (eventName) { return true; };
	    DomEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var zone = this.manager.getZone();
	        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };
	        this.manager.getZone().runOutsideAngular(function () { dom_adapter_1.DOM.on(element, eventName, outsideHandler); });
	    };
	    DomEventsPlugin.prototype.addGlobalEventListener = function (target, eventName, handler) {
	        var element = dom_adapter_1.DOM.getGlobalEventTarget(target);
	        var zone = this.manager.getZone();
	        var outsideHandler = function (event) { return zone.run(function () { return handler(event); }); };
	        return this.manager.getZone().runOutsideAngular(function () { return dom_adapter_1.DOM.onAndCancel(element, eventName, outsideHandler); });
	    };
	    DomEventsPlugin = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], DomEventsPlugin);
	    return DomEventsPlugin;
	})(EventManagerPlugin);
	exports.DomEventsPlugin = DomEventsPlugin;
	//# sourceMappingURL=event_manager.js.map

/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var profile_1 = __webpack_require__(190);
	/**
	 * A wrapper around zones that lets you schedule tasks after it has executed a task.
	 *
	 * The wrapper maintains an "inner" and an "mount" `Zone`. The application code will executes
	 * in the "inner" zone unless `runOutsideAngular` is explicitly called.
	 *
	 * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root
	 * `Zone`. The default `onTurnDone` runs the Angular change detection.
	 */
	var NgZone = (function () {
	    /**
	     * Associates with this
	     *
	     * - a "root" zone, which the one that instantiated this.
	     * - an "inner" zone, which is a child of the root zone.
	     *
	     * @param {bool} enableLongStackTrace whether to enable long stack trace. They should only be
	     *               enabled in development mode as they significantly impact perf.
	     */
	    function NgZone(_a) {
	        var enableLongStackTrace = _a.enableLongStackTrace;
	        this._runScope = profile_1.wtfCreateScope("NgZone#run()");
	        this._microtaskScope = profile_1.wtfCreateScope("NgZone#microtask()");
	        this._inVmTurnDone = false;
	        this._pendingTimeouts = [];
	        this._onTurnStart = null;
	        this._onTurnDone = null;
	        this._onEventDone = null;
	        this._onErrorHandler = null;
	        this._pendingMicrotasks = 0;
	        this._hasExecutedCodeInInnerZone = false;
	        this._nestedRun = 0;
	        if (lang_1.global.zone) {
	            this._disabled = false;
	            this._mountZone = lang_1.global.zone;
	            this._innerZone = this._createInnerZone(this._mountZone, enableLongStackTrace);
	        }
	        else {
	            this._disabled = true;
	            this._mountZone = null;
	        }
	    }
	    /**
	     * Sets the zone hook that is called just before Angular event turn starts.
	     * It is called once per browser event.
	     */
	    NgZone.prototype.overrideOnTurnStart = function (onTurnStartFn) {
	        this._onTurnStart = lang_1.normalizeBlank(onTurnStartFn);
	    };
	    /**
	     * Sets the zone hook that is called immediately after Angular processes
	     * all pending microtasks.
	     */
	    NgZone.prototype.overrideOnTurnDone = function (onTurnDoneFn) {
	        this._onTurnDone = lang_1.normalizeBlank(onTurnDoneFn);
	    };
	    /**
	     * Sets the zone hook that is called immediately after the last turn in
	     * an event completes. At this point Angular will no longer attempt to
	     * sync the UI. Any changes to the data model will not be reflected in the
	     * DOM. `onEventDoneFn` is executed outside Angular zone.
	     *
	     * This hook is useful for validating application state (e.g. in a test).
	     */
	    NgZone.prototype.overrideOnEventDone = function (onEventDoneFn, opt_waitForAsync) {
	        var _this = this;
	        if (opt_waitForAsync === void 0) { opt_waitForAsync = false; }
	        var normalizedOnEventDone = lang_1.normalizeBlank(onEventDoneFn);
	        if (opt_waitForAsync) {
	            this._onEventDone = function () {
	                if (!_this._pendingTimeouts.length) {
	                    normalizedOnEventDone();
	                }
	            };
	        }
	        else {
	            this._onEventDone = normalizedOnEventDone;
	        }
	    };
	    /**
	     * Sets the zone hook that is called when an error is uncaught in the
	     * Angular zone. The first argument is the error. The second argument is
	     * the stack trace.
	     */
	    NgZone.prototype.overrideOnErrorHandler = function (errorHandlingFn) {
	        this._onErrorHandler = lang_1.normalizeBlank(errorHandlingFn);
	    };
	    /**
	     * Runs `fn` in the inner zone and returns whatever it returns.
	     *
	     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the
	     * Angular's auto digest mechanism.
	     *
	     * ```
	     * var zone: NgZone = [ref to the application zone];
	     *
	     * zone.run(() => {
	     *   // the change detection will run after this function and the microtasks it enqueues have
	     * executed.
	     * });
	     * ```
	     */
	    NgZone.prototype.run = function (fn) {
	        if (this._disabled) {
	            return fn();
	        }
	        else {
	            var s = this._runScope();
	            try {
	                return this._innerZone.run(fn);
	            }
	            finally {
	                profile_1.wtfLeave(s);
	            }
	        }
	    };
	    /**
	     * Runs `fn` in the outer zone and returns whatever it returns.
	     *
	     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's
	     * auto-digest mechanism.
	     *
	     * ```
	     * var zone: NgZone = [ref to the application zone];
	     *
	     * zone.runOutsideAngular(() => {
	     *   element.onClick(() => {
	     *     // Clicking on the element would not trigger the change detection
	     *   });
	     * });
	     * ```
	     */
	    NgZone.prototype.runOutsideAngular = function (fn) {
	        if (this._disabled) {
	            return fn();
	        }
	        else {
	            return this._mountZone.run(fn);
	        }
	    };
	    NgZone.prototype._createInnerZone = function (zone, enableLongStackTrace) {
	        var microtaskScope = this._microtaskScope;
	        var ngZone = this;
	        var errorHandling;
	        if (enableLongStackTrace) {
	            errorHandling = collection_1.StringMapWrapper.merge(Zone.longStackTraceZone, { onError: function (e) { ngZone._onError(this, e); } });
	        }
	        else {
	            errorHandling = { onError: function (e) { ngZone._onError(this, e); } };
	        }
	        return zone.fork(errorHandling)
	            .fork({
	            '$run': function (parentRun) {
	                return function () {
	                    try {
	                        ngZone._nestedRun++;
	                        if (!ngZone._hasExecutedCodeInInnerZone) {
	                            ngZone._hasExecutedCodeInInnerZone = true;
	                            if (ngZone._onTurnStart) {
	                                parentRun.call(ngZone._innerZone, ngZone._onTurnStart);
	                            }
	                        }
	                        return parentRun.apply(this, arguments);
	                    }
	                    finally {
	                        ngZone._nestedRun--;
	                        // If there are no more pending microtasks, we are at the end of a VM turn (or in
	                        // onTurnStart)
	                        // _nestedRun will be 0 at the end of a macrotasks (it could be > 0 when there are
	                        // nested calls
	                        // to run()).
	                        if (ngZone._pendingMicrotasks == 0 && ngZone._nestedRun == 0 &&
	                            !this._inVmTurnDone) {
	                            if (ngZone._onTurnDone && ngZone._hasExecutedCodeInInnerZone) {
	                                try {
	                                    this._inVmTurnDone = true;
	                                    parentRun.call(ngZone._innerZone, ngZone._onTurnDone);
	                                }
	                                finally {
	                                    this._inVmTurnDone = false;
	                                    ngZone._hasExecutedCodeInInnerZone = false;
	                                }
	                            }
	                            if (ngZone._pendingMicrotasks === 0 && lang_1.isPresent(ngZone._onEventDone)) {
	                                ngZone.runOutsideAngular(ngZone._onEventDone);
	                            }
	                        }
	                    }
	                };
	            },
	            '$scheduleMicrotask': function (parentScheduleMicrotask) {
	                return function (fn) {
	                    ngZone._pendingMicrotasks++;
	                    var microtask = function () {
	                        var s = microtaskScope();
	                        try {
	                            fn();
	                        }
	                        finally {
	                            ngZone._pendingMicrotasks--;
	                            profile_1.wtfLeave(s);
	                        }
	                    };
	                    parentScheduleMicrotask.call(this, microtask);
	                };
	            },
	            '$setTimeout': function (parentSetTimeout) {
	                return function (fn, delay) {
	                    var args = [];
	                    for (var _i = 2; _i < arguments.length; _i++) {
	                        args[_i - 2] = arguments[_i];
	                    }
	                    var id;
	                    var cb = function () {
	                        fn();
	                        collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);
	                    };
	                    id = parentSetTimeout(cb, delay, args);
	                    ngZone._pendingTimeouts.push(id);
	                    return id;
	                };
	            },
	            '$clearTimeout': function (parentClearTimeout) {
	                return function (id) {
	                    parentClearTimeout(id);
	                    collection_1.ListWrapper.remove(ngZone._pendingTimeouts, id);
	                };
	            },
	            _innerZone: true
	        });
	    };
	    NgZone.prototype._onError = function (zone, e) {
	        if (lang_1.isPresent(this._onErrorHandler)) {
	            var trace = [lang_1.normalizeBlank(e.stack)];
	            while (zone && zone.constructedAtException) {
	                trace.push(zone.constructedAtException.get());
	                zone = zone.parent;
	            }
	            this._onErrorHandler(e, trace);
	        }
	        else {
	            console.log('## _onError ##');
	            console.log(e.stack);
	            throw e;
	        }
	    };
	    return NgZone;
	})();
	exports.NgZone = NgZone;
	//# sourceMappingURL=ng_zone.js.map

/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var dom_adapter_1 = __webpack_require__(386);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var api_1 = __webpack_require__(212);
	var util_1 = __webpack_require__(385);
	function resolveInternalDomView(viewRef) {
	    return viewRef._view;
	}
	exports.resolveInternalDomView = resolveInternalDomView;
	var DomViewRef = (function (_super) {
	    __extends(DomViewRef, _super);
	    function DomViewRef(_view) {
	        _super.call(this);
	        this._view = _view;
	    }
	    return DomViewRef;
	})(api_1.RenderViewRef);
	exports.DomViewRef = DomViewRef;
	/**
	 * Const of making objects: http://jsperf.com/instantiate-size-of-object
	 */
	var DomView = (function () {
	    function DomView(proto, boundTextNodes, boundElements) {
	        this.proto = proto;
	        this.boundTextNodes = boundTextNodes;
	        this.boundElements = boundElements;
	        this.hydrated = false;
	        this.eventDispatcher = null;
	        this.eventHandlerRemovers = [];
	    }
	    DomView.prototype.setElementProperty = function (elementIndex, propertyName, value) {
	        dom_adapter_1.DOM.setProperty(this.boundElements[elementIndex], propertyName, value);
	    };
	    DomView.prototype.setElementAttribute = function (elementIndex, attributeName, value) {
	        var element = this.boundElements[elementIndex];
	        var dashCasedAttributeName = util_1.camelCaseToDashCase(attributeName);
	        if (lang_1.isPresent(value)) {
	            dom_adapter_1.DOM.setAttribute(element, dashCasedAttributeName, lang_1.stringify(value));
	        }
	        else {
	            dom_adapter_1.DOM.removeAttribute(element, dashCasedAttributeName);
	        }
	    };
	    DomView.prototype.setElementClass = function (elementIndex, className, isAdd) {
	        var element = this.boundElements[elementIndex];
	        if (isAdd) {
	            dom_adapter_1.DOM.addClass(element, className);
	        }
	        else {
	            dom_adapter_1.DOM.removeClass(element, className);
	        }
	    };
	    DomView.prototype.setElementStyle = function (elementIndex, styleName, value) {
	        var element = this.boundElements[elementIndex];
	        var dashCasedStyleName = util_1.camelCaseToDashCase(styleName);
	        if (lang_1.isPresent(value)) {
	            dom_adapter_1.DOM.setStyle(element, dashCasedStyleName, lang_1.stringify(value));
	        }
	        else {
	            dom_adapter_1.DOM.removeStyle(element, dashCasedStyleName);
	        }
	    };
	    DomView.prototype.invokeElementMethod = function (elementIndex, methodName, args) {
	        var element = this.boundElements[elementIndex];
	        dom_adapter_1.DOM.invoke(element, methodName, args);
	    };
	    DomView.prototype.setText = function (textIndex, value) { dom_adapter_1.DOM.setText(this.boundTextNodes[textIndex], value); };
	    DomView.prototype.dispatchEvent = function (elementIndex, eventName, event) {
	        var allowDefaultBehavior = true;
	        if (lang_1.isPresent(this.eventDispatcher)) {
	            var evalLocals = new collection_1.Map();
	            evalLocals.set('$event', event);
	            // TODO(tbosch): reenable this when we are parsing element properties
	            // out of action expressions
	            // var localValues = this.proto.elementBinders[elementIndex].eventLocals.eval(null, new
	            // Locals(null, evalLocals));
	            // this.eventDispatcher.dispatchEvent(elementIndex, eventName, localValues);
	            allowDefaultBehavior =
	                this.eventDispatcher.dispatchRenderEvent(elementIndex, eventName, evalLocals);
	            if (!allowDefaultBehavior) {
	                dom_adapter_1.DOM.preventDefault(event);
	            }
	        }
	        return allowDefaultBehavior;
	    };
	    return DomView;
	})();
	exports.DomView = DomView;
	//# sourceMappingURL=view.js.map

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var api_1 = __webpack_require__(212);
	function resolveInternalDomFragment(fragmentRef) {
	    return fragmentRef._nodes;
	}
	exports.resolveInternalDomFragment = resolveInternalDomFragment;
	var DomFragmentRef = (function (_super) {
	    __extends(DomFragmentRef, _super);
	    function DomFragmentRef(_nodes) {
	        _super.call(this);
	        this._nodes = _nodes;
	    }
	    return DomFragmentRef;
	})(api_1.RenderFragmentRef);
	exports.DomFragmentRef = DomFragmentRef;
	//# sourceMappingURL=fragment.js.map

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var metadata_1 = __webpack_require__(157);
	var render_1 = __webpack_require__(404);
	var compiler_1 = __webpack_require__(377);
	var di_1 = __webpack_require__(160);
	var ng_control_1 = __webpack_require__(369);
	var lang_1 = __webpack_require__(159);
	var shared_1 = __webpack_require__(370);
	/**
	 * The accessor for writing a value and listening to changes on a checkbox input element.
	 *
	 *  # Example
	 *  ```
	 *  <input type="checkbox" [ng-control]="rememberLogin">
	 *  ```
	 */
	var CheckboxControlValueAccessor = (function () {
	    function CheckboxControlValueAccessor(cd, _renderer, _elementRef) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	        this._cd = cd;
	        cd.valueAccessor = this;
	    }
	    CheckboxControlValueAccessor.prototype.writeValue = function (value) { shared_1.setProperty(this._renderer, this._elementRef, "checked", value); };
	    Object.defineProperty(CheckboxControlValueAccessor.prototype, "ngClassUntouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CheckboxControlValueAccessor.prototype, "ngClassTouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CheckboxControlValueAccessor.prototype, "ngClassPristine", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CheckboxControlValueAccessor.prototype, "ngClassDirty", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CheckboxControlValueAccessor.prototype, "ngClassValid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CheckboxControlValueAccessor.prototype, "ngClassInvalid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    CheckboxControlValueAccessor = __decorate([
	        metadata_1.Directive({
	            selector: 'input[type=checkbox][ng-control],input[type=checkbox][ng-form-control],input[type=checkbox][ng-model]',
	            host: {
	                '(change)': 'onChange($event.target.checked)',
	                '(blur)': 'onTouched()',
	                '[class.ng-untouched]': 'ngClassUntouched',
	                '[class.ng-touched]': 'ngClassTouched',
	                '[class.ng-pristine]': 'ngClassPristine',
	                '[class.ng-dirty]': 'ngClassDirty',
	                '[class.ng-valid]': 'ngClassValid',
	                '[class.ng-invalid]': 'ngClassInvalid'
	            }
	        }),
	        __param(0, di_1.Self()), 
	        __metadata('design:paramtypes', [ng_control_1.NgControl, render_1.Renderer, compiler_1.ElementRef])
	    ], CheckboxControlValueAccessor);
	    return CheckboxControlValueAccessor;
	})();
	exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;
	//# sourceMappingURL=checkbox_value_accessor.js.map

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var di_1 = __webpack_require__(160);
	var render_1 = __webpack_require__(404);
	var compiler_1 = __webpack_require__(377);
	var metadata_1 = __webpack_require__(157);
	var ng_control_1 = __webpack_require__(369);
	var lang_1 = __webpack_require__(159);
	var shared_1 = __webpack_require__(370);
	/**
	 * Marks <option> as dynamic, so Angular can be notified when options change.
	 *
	 * #Example:
	 *
	 * ```
	 * <select ng-control="city">
	 *   <option *ng-for="#c of cities" [value]="c"></option>
	 * </select>
	 * ```
	 */
	var NgSelectOption = (function () {
	    function NgSelectOption() {
	    }
	    NgSelectOption = __decorate([
	        metadata_1.Directive({ selector: 'option' }), 
	        __metadata('design:paramtypes', [])
	    ], NgSelectOption);
	    return NgSelectOption;
	})();
	exports.NgSelectOption = NgSelectOption;
	/**
	 * The accessor for writing a value and listening to changes on a select element.
	 */
	var SelectControlValueAccessor = (function () {
	    function SelectControlValueAccessor(cd, _renderer, _elementRef, query) {
	        this._renderer = _renderer;
	        this._elementRef = _elementRef;
	        this.onChange = function (_) { };
	        this.onTouched = function () { };
	        this._cd = cd;
	        cd.valueAccessor = this;
	        this._updateValueWhenListOfOptionsChanges(query);
	    }
	    SelectControlValueAccessor.prototype.writeValue = function (value) {
	        this.value = value;
	        shared_1.setProperty(this._renderer, this._elementRef, "value", value);
	    };
	    Object.defineProperty(SelectControlValueAccessor.prototype, "ngClassUntouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.untouched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SelectControlValueAccessor.prototype, "ngClassTouched", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.touched : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SelectControlValueAccessor.prototype, "ngClassPristine", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.pristine : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SelectControlValueAccessor.prototype, "ngClassDirty", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.dirty : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SelectControlValueAccessor.prototype, "ngClassValid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SelectControlValueAccessor.prototype, "ngClassInvalid", {
	        get: function () {
	            return lang_1.isPresent(this._cd.control) ? !this._cd.control.valid : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SelectControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };
	    SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };
	    SelectControlValueAccessor.prototype._updateValueWhenListOfOptionsChanges = function (query) {
	        var _this = this;
	        query.onChange(function () { return _this.writeValue(_this.value); });
	    };
	    SelectControlValueAccessor = __decorate([
	        metadata_1.Directive({
	            selector: 'select[ng-control],select[ng-form-control],select[ng-model]',
	            host: {
	                '(change)': 'onChange($event.target.value)',
	                '(input)': 'onChange($event.target.value)',
	                '(blur)': 'onTouched()',
	                '[class.ng-untouched]': 'ngClassUntouched',
	                '[class.ng-touched]': 'ngClassTouched',
	                '[class.ng-pristine]': 'ngClassPristine',
	                '[class.ng-dirty]': 'ngClassDirty',
	                '[class.ng-valid]': 'ngClassValid',
	                '[class.ng-invalid]': 'ngClassInvalid'
	            }
	        }),
	        __param(0, di_1.Self()),
	        __param(3, metadata_1.Query(NgSelectOption, { descendants: true })), 
	        __metadata('design:paramtypes', [ng_control_1.NgControl, render_1.Renderer, compiler_1.ElementRef, compiler_1.QueryList])
	    ], SelectControlValueAccessor);
	    return SelectControlValueAccessor;
	})();
	exports.SelectControlValueAccessor = SelectControlValueAccessor;
	//# sourceMappingURL=select_control_value_accessor.js.map

/***/ },
/* 437 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var ng_control_name_1 = __webpack_require__(368);
	var ng_form_control_1 = __webpack_require__(371);
	var ng_model_1 = __webpack_require__(372);
	var ng_control_group_1 = __webpack_require__(373);
	var ng_form_model_1 = __webpack_require__(374);
	var ng_form_1 = __webpack_require__(375);
	var default_value_accessor_1 = __webpack_require__(376);
	var checkbox_value_accessor_1 = __webpack_require__(435);
	var select_control_value_accessor_1 = __webpack_require__(436);
	var validators_1 = __webpack_require__(438);
	var ng_control_name_2 = __webpack_require__(368);
	exports.NgControlName = ng_control_name_2.NgControlName;
	var ng_form_control_2 = __webpack_require__(371);
	exports.NgFormControl = ng_form_control_2.NgFormControl;
	var ng_model_2 = __webpack_require__(372);
	exports.NgModel = ng_model_2.NgModel;
	var ng_control_1 = __webpack_require__(369);
	exports.NgControl = ng_control_1.NgControl;
	var ng_control_group_2 = __webpack_require__(373);
	exports.NgControlGroup = ng_control_group_2.NgControlGroup;
	var ng_form_model_2 = __webpack_require__(374);
	exports.NgFormModel = ng_form_model_2.NgFormModel;
	var ng_form_2 = __webpack_require__(375);
	exports.NgForm = ng_form_2.NgForm;
	var default_value_accessor_2 = __webpack_require__(376);
	exports.DefaultValueAccessor = default_value_accessor_2.DefaultValueAccessor;
	var checkbox_value_accessor_2 = __webpack_require__(435);
	exports.CheckboxControlValueAccessor = checkbox_value_accessor_2.CheckboxControlValueAccessor;
	var select_control_value_accessor_2 = __webpack_require__(436);
	exports.SelectControlValueAccessor = select_control_value_accessor_2.SelectControlValueAccessor;
	exports.NgSelectOption = select_control_value_accessor_2.NgSelectOption;
	var validators_2 = __webpack_require__(438);
	exports.DefaultValidators = validators_2.DefaultValidators;
	/**
	 *
	 * A list of all the form directives used as part of a `@View` annotation.
	 *
	 *  This is a shorthand for importing them each individually.
	 */
	exports.FORM_DIRECTIVES = lang_1.CONST_EXPR([
	    ng_control_name_1.NgControlName,
	    ng_control_group_1.NgControlGroup,
	    ng_form_control_1.NgFormControl,
	    ng_model_1.NgModel,
	    ng_form_model_1.NgFormModel,
	    ng_form_1.NgForm,
	    select_control_value_accessor_1.NgSelectOption,
	    default_value_accessor_1.DefaultValueAccessor,
	    checkbox_value_accessor_1.CheckboxControlValueAccessor,
	    select_control_value_accessor_1.SelectControlValueAccessor,
	    validators_1.DefaultValidators
	]);
	//# sourceMappingURL=directives.js.map

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var metadata_1 = __webpack_require__(157);
	var validators_1 = __webpack_require__(365);
	var DEFAULT_VALIDATORS = lang_1.CONST_EXPR(new di_1.Binding(validators_1.NG_VALIDATORS, { toValue: validators_1.Validators.required, multi: true }));
	var DefaultValidators = (function () {
	    function DefaultValidators() {
	    }
	    DefaultValidators = __decorate([
	        metadata_1.Directive({
	            selector: '[required][ng-control],[required][ng-form-control],[required][ng-model]',
	            bindings: [DEFAULT_VALIDATORS]
	        }), 
	        __metadata('design:paramtypes', [])
	    ], DefaultValidators);
	    return DefaultValidators;
	})();
	exports.DefaultValidators = DefaultValidators;
	//# sourceMappingURL=validators.js.map

/***/ },
/* 439 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var modelModule = __webpack_require__(364);
	/**
	 * Creates a form object from a user-specified configuration.
	 *
	 * # Example
	 *
	 * ```
	 * import {Component, View, bootstrap} from 'angular2/angular2';
	 * import {FormBuilder, Validators, FORM_DIRECTIVES, ControlGroup} from 'angular2/core';
	 *
	 * @Component({
	 *   selector: 'login-comp',
	 *   viewBindings: [
	 *     FormBuilder
	 *   ]
	 * })
	 * @View({
	 *   template: `
	 *     <form [control-group]="loginForm">
	 *       Login <input control="login">
	 *
	 *       <div control-group="passwordRetry">
	 *         Password <input type="password" control="password">
	 *         Confirm password <input type="password" control="passwordConfirmation">
	 *       </div>
	 *     </form>
	 *   `,
	 *   directives: [
	 *     FORM_DIRECTIVES
	 *   ]
	 * })
	 * class LoginComp {
	 *   loginForm: ControlGroup;
	 *
	 *   constructor(builder: FormBuilder) {
	 *     this.loginForm = builder.group({
	 *       login: ["", Validators.required],
	 *
	 *       passwordRetry: builder.group({
	 *         password: ["", Validators.required],
	 *         passwordConfirmation: ["", Validators.required]
	 *       })
	 *     });
	 *   }
	 * }
	 *
	 * bootstrap(LoginComp)
	 * ```
	 *
	 * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a
	 * nested
	 * {@link ControlGroup} that defines a `password` and a `passwordConfirmation` {@link Control}:
	 *
	 * ```
	 *  var loginForm = builder.group({
	 *    login: ["", Validators.required],
	 *
	 *    passwordRetry: builder.group({
	 *      password: ["", Validators.required],
	 *      passwordConfirmation: ["", Validators.required]
	 *    })
	 *  });
	 *
	 *  ```
	 */
	var FormBuilder = (function () {
	    function FormBuilder() {
	    }
	    FormBuilder.prototype.group = function (controlsConfig, extra) {
	        if (extra === void 0) { extra = null; }
	        var controls = this._reduceControls(controlsConfig);
	        var optionals = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "optionals") : null;
	        var validator = lang_1.isPresent(extra) ? collection_1.StringMapWrapper.get(extra, "validator") : null;
	        if (lang_1.isPresent(validator)) {
	            return new modelModule.ControlGroup(controls, optionals, validator);
	        }
	        else {
	            return new modelModule.ControlGroup(controls, optionals);
	        }
	    };
	    FormBuilder.prototype.control = function (value, validator) {
	        if (validator === void 0) { validator = null; }
	        if (lang_1.isPresent(validator)) {
	            return new modelModule.Control(value, validator);
	        }
	        else {
	            return new modelModule.Control(value);
	        }
	    };
	    FormBuilder.prototype.array = function (controlsConfig, validator) {
	        var _this = this;
	        if (validator === void 0) { validator = null; }
	        var controls = collection_1.ListWrapper.map(controlsConfig, function (c) { return _this._createControl(c); });
	        if (lang_1.isPresent(validator)) {
	            return new modelModule.ControlArray(controls, validator);
	        }
	        else {
	            return new modelModule.ControlArray(controls);
	        }
	    };
	    FormBuilder.prototype._reduceControls = function (controlsConfig) {
	        var _this = this;
	        var controls = {};
	        collection_1.StringMapWrapper.forEach(controlsConfig, function (controlConfig, controlName) {
	            controls[controlName] = _this._createControl(controlConfig);
	        });
	        return controls;
	    };
	    FormBuilder.prototype._createControl = function (controlConfig) {
	        if (controlConfig instanceof modelModule.Control ||
	            controlConfig instanceof modelModule.ControlGroup ||
	            controlConfig instanceof modelModule.ControlArray) {
	            return controlConfig;
	        }
	        else if (lang_1.isArray(controlConfig)) {
	            var value = controlConfig[0];
	            var validator = controlConfig.length > 1 ? controlConfig[1] : null;
	            return this.control(value, validator);
	        }
	        else {
	            return this.control(controlConfig);
	        }
	    };
	    FormBuilder = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], FormBuilder);
	    return FormBuilder;
	})();
	exports.FormBuilder = FormBuilder;
	//# sourceMappingURL=form_builder.js.map

/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var dom_adapter_1 = __webpack_require__(386);
	var generic_browser_adapter_1 = __webpack_require__(441);
	var _attrToPropMap = {
	    'class': 'className',
	    'innerHtml': 'innerHTML',
	    'readonly': 'readOnly',
	    'tabindex': 'tabIndex'
	};
	var DOM_KEY_LOCATION_NUMPAD = 3;
	// Map to convert some key or keyIdentifier values to what will be returned by getEventKey
	var _keyMap = {
	    // The following values are here for cross-browser compatibility and to match the W3C standard
	    // cf http://www.w3.org/TR/DOM-Level-3-Events-key/
	    '\b': 'Backspace',
	    '\t': 'Tab',
	    '\x7F': 'Delete',
	    '\x1B': 'Escape',
	    'Del': 'Delete',
	    'Esc': 'Escape',
	    'Left': 'ArrowLeft',
	    'Right': 'ArrowRight',
	    'Up': 'ArrowUp',
	    'Down': 'ArrowDown',
	    'Menu': 'ContextMenu',
	    'Scroll': 'ScrollLock',
	    'Win': 'OS'
	};
	// There is a bug in Chrome for numeric keypad keys:
	// https://code.google.com/p/chromium/issues/detail?id=155654
	// 1, 2, 3 ... are reported as A, B, C ...
	var _chromeNumKeyPadMap = {
	    'A': '1',
	    'B': '2',
	    'C': '3',
	    'D': '4',
	    'E': '5',
	    'F': '6',
	    'G': '7',
	    'H': '8',
	    'I': '9',
	    'J': '*',
	    'K': '+',
	    'M': '-',
	    'N': '.',
	    'O': '/',
	    '\x60': '0',
	    '\x90': 'NumLock'
	};
	/* tslint:disable:requireParameterType */
	var BrowserDomAdapter = (function (_super) {
	    __extends(BrowserDomAdapter, _super);
	    function BrowserDomAdapter() {
	        _super.apply(this, arguments);
	    }
	    BrowserDomAdapter.makeCurrent = function () { dom_adapter_1.setRootDomAdapter(new BrowserDomAdapter()); };
	    BrowserDomAdapter.prototype.hasProperty = function (element, name) { return name in element; };
	    BrowserDomAdapter.prototype.setProperty = function (el, name, value) { el[name] = value; };
	    BrowserDomAdapter.prototype.getProperty = function (el, name) { return el[name]; };
	    BrowserDomAdapter.prototype.invoke = function (el, methodName, args) {
	        el[methodName].apply(el, args);
	    };
	    // TODO(tbosch): move this into a separate environment class once we have it
	    BrowserDomAdapter.prototype.logError = function (error) {
	        if (window.console.error) {
	            window.console.error(error);
	        }
	        else {
	            window.console.log(error);
	        }
	    };
	    BrowserDomAdapter.prototype.log = function (error) { window.console.log(error); };
	    BrowserDomAdapter.prototype.logGroup = function (error) {
	        if (window.console.group) {
	            window.console.group(error);
	            this.logError(error);
	        }
	        else {
	            window.console.log(error);
	        }
	    };
	    BrowserDomAdapter.prototype.logGroupEnd = function () {
	        if (window.console.groupEnd) {
	            window.console.groupEnd();
	        }
	    };
	    Object.defineProperty(BrowserDomAdapter.prototype, "attrToPropMap", {
	        get: function () { return _attrToPropMap; },
	        enumerable: true,
	        configurable: true
	    });
	    BrowserDomAdapter.prototype.query = function (selector) { return document.querySelector(selector); };
	    BrowserDomAdapter.prototype.querySelector = function (el, selector) { return el.querySelector(selector); };
	    BrowserDomAdapter.prototype.querySelectorAll = function (el, selector) { return el.querySelectorAll(selector); };
	    BrowserDomAdapter.prototype.on = function (el, evt, listener) { el.addEventListener(evt, listener, false); };
	    BrowserDomAdapter.prototype.onAndCancel = function (el, evt, listener) {
	        el.addEventListener(evt, listener, false);
	        // Needed to follow Dart's subscription semantic, until fix of
	        // https://code.google.com/p/dart/issues/detail?id=17406
	        return function () { el.removeEventListener(evt, listener, false); };
	    };
	    BrowserDomAdapter.prototype.dispatchEvent = function (el, evt) { el.dispatchEvent(evt); };
	    BrowserDomAdapter.prototype.createMouseEvent = function (eventType) {
	        var evt = document.createEvent('MouseEvent');
	        evt.initEvent(eventType, true, true);
	        return evt;
	    };
	    BrowserDomAdapter.prototype.createEvent = function (eventType) {
	        var evt = document.createEvent('Event');
	        evt.initEvent(eventType, true, true);
	        return evt;
	    };
	    BrowserDomAdapter.prototype.preventDefault = function (evt) {
	        evt.preventDefault();
	        evt.returnValue = false;
	    };
	    BrowserDomAdapter.prototype.isPrevented = function (evt) {
	        return evt.defaultPrevented || lang_1.isPresent(evt.returnValue) && !evt.returnValue;
	    };
	    BrowserDomAdapter.prototype.getInnerHTML = function (el) { return el.innerHTML; };
	    BrowserDomAdapter.prototype.getOuterHTML = function (el) { return el.outerHTML; };
	    BrowserDomAdapter.prototype.nodeName = function (node) { return node.nodeName; };
	    BrowserDomAdapter.prototype.nodeValue = function (node) { return node.nodeValue; };
	    BrowserDomAdapter.prototype.type = function (node) { return node.type; };
	    BrowserDomAdapter.prototype.content = function (node) {
	        if (this.hasProperty(node, "content")) {
	            return node.content;
	        }
	        else {
	            return node;
	        }
	    };
	    BrowserDomAdapter.prototype.firstChild = function (el) { return el.firstChild; };
	    BrowserDomAdapter.prototype.nextSibling = function (el) { return el.nextSibling; };
	    BrowserDomAdapter.prototype.parentElement = function (el) { return el.parentNode; };
	    BrowserDomAdapter.prototype.childNodes = function (el) { return el.childNodes; };
	    BrowserDomAdapter.prototype.childNodesAsList = function (el) {
	        var childNodes = el.childNodes;
	        var res = collection_1.ListWrapper.createFixedSize(childNodes.length);
	        for (var i = 0; i < childNodes.length; i++) {
	            res[i] = childNodes[i];
	        }
	        return res;
	    };
	    BrowserDomAdapter.prototype.clearNodes = function (el) {
	        while (el.firstChild) {
	            el.removeChild(el.firstChild);
	        }
	    };
	    BrowserDomAdapter.prototype.appendChild = function (el, node) { el.appendChild(node); };
	    BrowserDomAdapter.prototype.removeChild = function (el, node) { el.removeChild(node); };
	    BrowserDomAdapter.prototype.replaceChild = function (el, newChild, oldChild) { el.replaceChild(newChild, oldChild); };
	    BrowserDomAdapter.prototype.remove = function (node) {
	        node.parentNode.removeChild(node);
	        return node;
	    };
	    BrowserDomAdapter.prototype.insertBefore = function (el, node) { el.parentNode.insertBefore(node, el); };
	    BrowserDomAdapter.prototype.insertAllBefore = function (el, nodes) {
	        collection_1.ListWrapper.forEach(nodes, function (n) { el.parentNode.insertBefore(n, el); });
	    };
	    BrowserDomAdapter.prototype.insertAfter = function (el, node) { el.parentNode.insertBefore(node, el.nextSibling); };
	    BrowserDomAdapter.prototype.setInnerHTML = function (el, value) { el.innerHTML = value; };
	    BrowserDomAdapter.prototype.getText = function (el) { return el.textContent; };
	    // TODO(vicb): removed Element type because it does not support StyleElement
	    BrowserDomAdapter.prototype.setText = function (el, value) { el.textContent = value; };
	    BrowserDomAdapter.prototype.getValue = function (el) { return el.value; };
	    BrowserDomAdapter.prototype.setValue = function (el, value) { el.value = value; };
	    BrowserDomAdapter.prototype.getChecked = function (el) { return el.checked; };
	    BrowserDomAdapter.prototype.setChecked = function (el, value) { el.checked = value; };
	    BrowserDomAdapter.prototype.createComment = function (text) { return document.createComment(text); };
	    BrowserDomAdapter.prototype.createTemplate = function (html) {
	        var t = document.createElement('template');
	        t.innerHTML = html;
	        return t;
	    };
	    BrowserDomAdapter.prototype.createElement = function (tagName, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createElement(tagName);
	    };
	    BrowserDomAdapter.prototype.createTextNode = function (text, doc) {
	        if (doc === void 0) { doc = document; }
	        return doc.createTextNode(text);
	    };
	    BrowserDomAdapter.prototype.createScriptTag = function (attrName, attrValue, doc) {
	        if (doc === void 0) { doc = document; }
	        var el = doc.createElement('SCRIPT');
	        el.setAttribute(attrName, attrValue);
	        return el;
	    };
	    BrowserDomAdapter.prototype.createStyleElement = function (css, doc) {
	        if (doc === void 0) { doc = document; }
	        var style = doc.createElement('style');
	        this.appendChild(style, this.createTextNode(css));
	        return style;
	    };
	    BrowserDomAdapter.prototype.createShadowRoot = function (el) { return el.createShadowRoot(); };
	    BrowserDomAdapter.prototype.getShadowRoot = function (el) { return el.shadowRoot; };
	    BrowserDomAdapter.prototype.getHost = function (el) { return el.host; };
	    BrowserDomAdapter.prototype.clone = function (node) { return node.cloneNode(true); };
	    BrowserDomAdapter.prototype.getElementsByClassName = function (element, name) {
	        return element.getElementsByClassName(name);
	    };
	    BrowserDomAdapter.prototype.getElementsByTagName = function (element, name) {
	        return element.getElementsByTagName(name);
	    };
	    BrowserDomAdapter.prototype.classList = function (element) { return Array.prototype.slice.call(element.classList, 0); };
	    BrowserDomAdapter.prototype.addClass = function (element, classname) { element.classList.add(classname); };
	    BrowserDomAdapter.prototype.removeClass = function (element, classname) { element.classList.remove(classname); };
	    BrowserDomAdapter.prototype.hasClass = function (element, classname) { return element.classList.contains(classname); };
	    BrowserDomAdapter.prototype.setStyle = function (element, stylename, stylevalue) {
	        element.style[stylename] = stylevalue;
	    };
	    BrowserDomAdapter.prototype.removeStyle = function (element, stylename) { element.style[stylename] = null; };
	    BrowserDomAdapter.prototype.getStyle = function (element, stylename) { return element.style[stylename]; };
	    BrowserDomAdapter.prototype.tagName = function (element) { return element.tagName; };
	    BrowserDomAdapter.prototype.attributeMap = function (element) {
	        var res = new Map();
	        var elAttrs = element.attributes;
	        for (var i = 0; i < elAttrs.length; i++) {
	            var attrib = elAttrs[i];
	            res.set(attrib.name, attrib.value);
	        }
	        return res;
	    };
	    BrowserDomAdapter.prototype.hasAttribute = function (element, attribute) { return element.hasAttribute(attribute); };
	    BrowserDomAdapter.prototype.getAttribute = function (element, attribute) { return element.getAttribute(attribute); };
	    BrowserDomAdapter.prototype.setAttribute = function (element, name, value) { element.setAttribute(name, value); };
	    BrowserDomAdapter.prototype.removeAttribute = function (element, attribute) { element.removeAttribute(attribute); };
	    BrowserDomAdapter.prototype.templateAwareRoot = function (el) { return this.isTemplateElement(el) ? this.content(el) : el; };
	    BrowserDomAdapter.prototype.createHtmlDocument = function () {
	        return document.implementation.createHTMLDocument('fakeTitle');
	    };
	    BrowserDomAdapter.prototype.defaultDoc = function () { return document; };
	    BrowserDomAdapter.prototype.getBoundingClientRect = function (el) {
	        try {
	            return el.getBoundingClientRect();
	        }
	        catch (e) {
	            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
	        }
	    };
	    BrowserDomAdapter.prototype.getTitle = function () { return document.title; };
	    BrowserDomAdapter.prototype.setTitle = function (newTitle) { document.title = newTitle || ''; };
	    BrowserDomAdapter.prototype.elementMatches = function (n, selector) {
	        var matches = false;
	        if (n instanceof HTMLElement) {
	            if (n.matches) {
	                matches = n.matches(selector);
	            }
	            else if (n.msMatchesSelector) {
	                matches = n.msMatchesSelector(selector);
	            }
	            else if (n.webkitMatchesSelector) {
	                matches = n.webkitMatchesSelector(selector);
	            }
	        }
	        return matches;
	    };
	    BrowserDomAdapter.prototype.isTemplateElement = function (el) {
	        return el instanceof HTMLElement && el.nodeName == "TEMPLATE";
	    };
	    BrowserDomAdapter.prototype.isTextNode = function (node) { return node.nodeType === Node.TEXT_NODE; };
	    BrowserDomAdapter.prototype.isCommentNode = function (node) { return node.nodeType === Node.COMMENT_NODE; };
	    BrowserDomAdapter.prototype.isElementNode = function (node) { return node.nodeType === Node.ELEMENT_NODE; };
	    BrowserDomAdapter.prototype.hasShadowRoot = function (node) { return node instanceof HTMLElement && lang_1.isPresent(node.shadowRoot); };
	    BrowserDomAdapter.prototype.isShadowRoot = function (node) { return node instanceof DocumentFragment; };
	    BrowserDomAdapter.prototype.importIntoDoc = function (node) {
	        var toImport = node;
	        if (this.isTemplateElement(node)) {
	            toImport = this.content(node);
	        }
	        return document.importNode(toImport, true);
	    };
	    BrowserDomAdapter.prototype.adoptNode = function (node) { return document.adoptNode(node); };
	    BrowserDomAdapter.prototype.isPageRule = function (rule) { return rule.type === CSSRule.PAGE_RULE; };
	    BrowserDomAdapter.prototype.isStyleRule = function (rule) { return rule.type === CSSRule.STYLE_RULE; };
	    BrowserDomAdapter.prototype.isMediaRule = function (rule) { return rule.type === CSSRule.MEDIA_RULE; };
	    BrowserDomAdapter.prototype.isKeyframesRule = function (rule) { return rule.type === CSSRule.KEYFRAMES_RULE; };
	    BrowserDomAdapter.prototype.getHref = function (el) { return el.href; };
	    BrowserDomAdapter.prototype.getEventKey = function (event) {
	        var key = event.key;
	        if (lang_1.isBlank(key)) {
	            key = event.keyIdentifier;
	            // keyIdentifier is defined in the old draft of DOM Level 3 Events implemented by Chrome and
	            // Safari
	            // cf
	            // http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/events.html#Events-KeyboardEvents-Interfaces
	            if (lang_1.isBlank(key)) {
	                return 'Unidentified';
	            }
	            if (key.startsWith('U+')) {
	                key = String.fromCharCode(parseInt(key.substring(2), 16));
	                if (event.location === DOM_KEY_LOCATION_NUMPAD && _chromeNumKeyPadMap.hasOwnProperty(key)) {
	                    // There is a bug in Chrome for numeric keypad keys:
	                    // https://code.google.com/p/chromium/issues/detail?id=155654
	                    // 1, 2, 3 ... are reported as A, B, C ...
	                    key = _chromeNumKeyPadMap[key];
	                }
	            }
	        }
	        if (_keyMap.hasOwnProperty(key)) {
	            key = _keyMap[key];
	        }
	        return key;
	    };
	    BrowserDomAdapter.prototype.getGlobalEventTarget = function (target) {
	        if (target == "window") {
	            return window;
	        }
	        else if (target == "document") {
	            return document;
	        }
	        else if (target == "body") {
	            return document.body;
	        }
	    };
	    BrowserDomAdapter.prototype.getHistory = function () { return window.history; };
	    BrowserDomAdapter.prototype.getLocation = function () { return window.location; };
	    BrowserDomAdapter.prototype.getBaseHref = function () {
	        var href = getBaseElementHref();
	        if (lang_1.isBlank(href)) {
	            return null;
	        }
	        return relativePath(href);
	    };
	    BrowserDomAdapter.prototype.resetBaseElement = function () { baseElement = null; };
	    BrowserDomAdapter.prototype.getUserAgent = function () { return window.navigator.userAgent; };
	    BrowserDomAdapter.prototype.setData = function (element, name, value) {
	        this.setAttribute(element, 'data-' + name, value);
	    };
	    BrowserDomAdapter.prototype.getData = function (element, name) { return this.getAttribute(element, 'data-' + name); };
	    // TODO(tbosch): move this into a separate environment class once we have it
	    BrowserDomAdapter.prototype.setGlobalVar = function (path, value) { lang_1.setValueOnPath(lang_1.global, path, value); };
	    return BrowserDomAdapter;
	})(generic_browser_adapter_1.GenericBrowserDomAdapter);
	exports.BrowserDomAdapter = BrowserDomAdapter;
	var baseElement = null;
	function getBaseElementHref() {
	    if (lang_1.isBlank(baseElement)) {
	        baseElement = document.querySelector('base');
	        if (lang_1.isBlank(baseElement)) {
	            return null;
	        }
	    }
	    return baseElement.getAttribute('href');
	}
	// based on urlUtils.js in AngularJS 1
	var urlParsingNode = null;
	function relativePath(url) {
	    if (lang_1.isBlank(urlParsingNode)) {
	        urlParsingNode = document.createElement("a");
	    }
	    urlParsingNode.setAttribute('href', url);
	    return (urlParsingNode.pathname.charAt(0) === '/') ? urlParsingNode.pathname :
	        '/' + urlParsingNode.pathname;
	}
	//# sourceMappingURL=browser_adapter.js.map

/***/ },
/* 441 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var collection_1 = __webpack_require__(166);
	var lang_1 = __webpack_require__(159);
	var dom_adapter_1 = __webpack_require__(386);
	/**
	 * Provides DOM operations in any browser environment.
	 */
	var GenericBrowserDomAdapter = (function (_super) {
	    __extends(GenericBrowserDomAdapter, _super);
	    function GenericBrowserDomAdapter() {
	        _super.apply(this, arguments);
	    }
	    GenericBrowserDomAdapter.prototype.getDistributedNodes = function (el) { return el.getDistributedNodes(); };
	    GenericBrowserDomAdapter.prototype.resolveAndSetHref = function (el, baseUrl, href) {
	        el.href = href == null ? baseUrl : baseUrl + '/../' + href;
	    };
	    GenericBrowserDomAdapter.prototype.cssToRules = function (css) {
	        var style = this.createStyleElement(css);
	        this.appendChild(this.defaultDoc().head, style);
	        var rules = [];
	        if (lang_1.isPresent(style.sheet)) {
	            // TODO(sorvell): Firefox throws when accessing the rules of a stylesheet
	            // with an @import
	            // https://bugzilla.mozilla.org/show_bug.cgi?id=625013
	            try {
	                var rawRules = style.sheet.cssRules;
	                rules = collection_1.ListWrapper.createFixedSize(rawRules.length);
	                for (var i = 0; i < rawRules.length; i++) {
	                    rules[i] = rawRules[i];
	                }
	            }
	            catch (e) {
	            }
	        }
	        else {
	        }
	        this.remove(style);
	        return rules;
	    };
	    GenericBrowserDomAdapter.prototype.supportsDOMEvents = function () { return true; };
	    GenericBrowserDomAdapter.prototype.supportsNativeShadowDOM = function () {
	        return lang_1.isFunction(this.defaultDoc().body.createShadowRoot);
	    };
	    return GenericBrowserDomAdapter;
	})(dom_adapter_1.DomAdapter);
	exports.GenericBrowserDomAdapter = GenericBrowserDomAdapter;
	//# sourceMappingURL=generic_browser_adapter.js.map

/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var profile_1 = __webpack_require__(190);
	/**
	 * Provides access to explicitly trigger change detection in an application.
	 *
	 * By default, `Zone` triggers change detection in Angular on each virtual machine (VM) turn. When
	 * testing, or in some
	 * limited application use cases, a developer can also trigger change detection with the
	 * `lifecycle.tick()` method.
	 *
	 * Each Angular application has a single `LifeCycle` instance.
	 *
	 * # Example
	 *
	 * This is a contrived example, since the bootstrap automatically runs inside of the `Zone`, which
	 * invokes
	 * `lifecycle.tick()` on your behalf.
	 *
	 * ```javascript
	 * bootstrap(MyApp).then((ref:ComponentRef) => {
	 *   var lifeCycle = ref.injector.get(LifeCycle);
	 *   var myApp = ref.instance;
	 *
	 *   ref.doSomething();
	 *   lifecycle.tick();
	 * });
	 * ```
	 */
	var LifeCycle = (function () {
	    function LifeCycle(changeDetector, enforceNoNewChanges) {
	        if (changeDetector === void 0) { changeDetector = null; }
	        if (enforceNoNewChanges === void 0) { enforceNoNewChanges = false; }
	        this._runningTick = false;
	        this._changeDetector =
	            changeDetector; // may be null when instantiated from application bootstrap
	        this._enforceNoNewChanges = enforceNoNewChanges;
	    }
	    /**
	     * @private
	     */
	    LifeCycle.prototype.registerWith = function (zone, changeDetector) {
	        var _this = this;
	        if (changeDetector === void 0) { changeDetector = null; }
	        if (lang_1.isPresent(changeDetector)) {
	            this._changeDetector = changeDetector;
	        }
	        zone.overrideOnTurnDone(function () { return _this.tick(); });
	    };
	    /**
	     *  Invoke this method to explicitly process change detection and its side-effects.
	     *
	     *  In development mode, `tick()` also performs a second change detection cycle to ensure that no
	     * further
	     *  changes are detected. If additional changes are picked up during this second cycle, bindings
	     * in
	     * the app have
	     *  side-effects that cannot be resolved in a single change detection pass. In this case, Angular
	     * throws an error,
	     *  since an Angular application can only have one change detection pass during which all change
	     * detection must
	     *  complete.
	     *
	     */
	    LifeCycle.prototype.tick = function () {
	        if (this._runningTick) {
	            throw new exceptions_1.BaseException("LifeCycle.tick is called recursively");
	        }
	        var s = LifeCycle._tickScope();
	        try {
	            this._runningTick = true;
	            this._changeDetector.detectChanges();
	            if (this._enforceNoNewChanges) {
	                this._changeDetector.checkNoChanges();
	            }
	        }
	        finally {
	            this._runningTick = false;
	            profile_1.wtfLeave(s);
	        }
	    };
	    LifeCycle._tickScope = profile_1.wtfCreateScope('LifeCycle#tick()');
	    LifeCycle = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [Object, Boolean])
	    ], LifeCycle);
	    return LifeCycle;
	})();
	exports.LifeCycle = LifeCycle;
	//# sourceMappingURL=life_cycle.js.map

/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var async_1 = __webpack_require__(216);
	var lang_1 = __webpack_require__(159);
	var xhr_1 = __webpack_require__(407);
	var XHRImpl = (function (_super) {
	    __extends(XHRImpl, _super);
	    function XHRImpl() {
	        _super.apply(this, arguments);
	    }
	    XHRImpl.prototype.get = function (url) {
	        var completer = async_1.PromiseWrapper.completer();
	        var xhr = new XMLHttpRequest();
	        xhr.open('GET', url, true);
	        xhr.responseType = 'text';
	        xhr.onload = function () {
	            // responseText is the old-school way of retrieving response (supported by IE8 & 9)
	            // response/responseType properties were introduced in XHR Level2 spec (supported by IE10)
	            var response = lang_1.isPresent(xhr.response) ? xhr.response : xhr.responseText;
	            // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	            var status = xhr.status === 1223 ? 204 : xhr.status;
	            // fix status code when it is 0 (0 status is undocumented).
	            // Occurs when accessing file resources or on Android 4.1 stock browser
	            // while retrieving files from application cache.
	            if (status === 0) {
	                status = response ? 200 : 0;
	            }
	            if (200 <= status && status <= 300) {
	                completer.resolve(response);
	            }
	            else {
	                completer.reject("Failed to load " + url, null);
	            }
	        };
	        xhr.onerror = function () { completer.reject("Failed to load " + url, null); };
	        xhr.send();
	        return completer.promise;
	    };
	    XHRImpl = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], XHRImpl);
	    return XHRImpl;
	})(xhr_1.XHR);
	exports.XHRImpl = XHRImpl;
	//# sourceMappingURL=xhr_impl.js.map

/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var dom_adapter_1 = __webpack_require__(386);
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var event_manager_1 = __webpack_require__(431);
	var di_1 = __webpack_require__(160);
	var modifierKeys = ['alt', 'control', 'meta', 'shift'];
	var modifierKeyGetters = {
	    'alt': function (event) { return event.altKey; },
	    'control': function (event) { return event.ctrlKey; },
	    'meta': function (event) { return event.metaKey; },
	    'shift': function (event) { return event.shiftKey; }
	};
	var KeyEventsPlugin = (function (_super) {
	    __extends(KeyEventsPlugin, _super);
	    function KeyEventsPlugin() {
	        _super.call(this);
	    }
	    KeyEventsPlugin.prototype.supports = function (eventName) {
	        return lang_1.isPresent(KeyEventsPlugin.parseEventName(eventName));
	    };
	    KeyEventsPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var parsedEvent = KeyEventsPlugin.parseEventName(eventName);
	        var outsideHandler = KeyEventsPlugin.eventCallback(element, collection_1.StringMapWrapper.get(parsedEvent, 'fullKey'), handler, this.manager.getZone());
	        this.manager.getZone().runOutsideAngular(function () {
	            dom_adapter_1.DOM.on(element, collection_1.StringMapWrapper.get(parsedEvent, 'domEventName'), outsideHandler);
	        });
	    };
	    KeyEventsPlugin.parseEventName = function (eventName) {
	        var parts = eventName.toLowerCase().split('.');
	        var domEventName = collection_1.ListWrapper.removeAt(parts, 0);
	        if ((parts.length === 0) ||
	            !(lang_1.StringWrapper.equals(domEventName, 'keydown') ||
	                lang_1.StringWrapper.equals(domEventName, 'keyup'))) {
	            return null;
	        }
	        var key = KeyEventsPlugin._normalizeKey(collection_1.ListWrapper.removeLast(parts));
	        var fullKey = '';
	        collection_1.ListWrapper.forEach(modifierKeys, function (modifierName) {
	            if (collection_1.ListWrapper.contains(parts, modifierName)) {
	                collection_1.ListWrapper.remove(parts, modifierName);
	                fullKey += modifierName + '.';
	            }
	        });
	        fullKey += key;
	        if (parts.length != 0 || key.length === 0) {
	            // returning null instead of throwing to let another plugin process the event
	            return null;
	        }
	        var result = collection_1.StringMapWrapper.create();
	        collection_1.StringMapWrapper.set(result, 'domEventName', domEventName);
	        collection_1.StringMapWrapper.set(result, 'fullKey', fullKey);
	        return result;
	    };
	    KeyEventsPlugin.getEventFullKey = function (event) {
	        var fullKey = '';
	        var key = dom_adapter_1.DOM.getEventKey(event);
	        key = key.toLowerCase();
	        if (lang_1.StringWrapper.equals(key, ' ')) {
	            key = 'space'; // for readability
	        }
	        else if (lang_1.StringWrapper.equals(key, '.')) {
	            key = 'dot'; // because '.' is used as a separator in event names
	        }
	        collection_1.ListWrapper.forEach(modifierKeys, function (modifierName) {
	            if (modifierName != key) {
	                var modifierGetter = collection_1.StringMapWrapper.get(modifierKeyGetters, modifierName);
	                if (modifierGetter(event)) {
	                    fullKey += modifierName + '.';
	                }
	            }
	        });
	        fullKey += key;
	        return fullKey;
	    };
	    KeyEventsPlugin.eventCallback = function (element, fullKey, handler, zone) {
	        return function (event) {
	            if (lang_1.StringWrapper.equals(KeyEventsPlugin.getEventFullKey(event), fullKey)) {
	                zone.run(function () { return handler(event); });
	            }
	        };
	    };
	    KeyEventsPlugin._normalizeKey = function (keyName) {
	        // TODO: switch to a StringMap if the mapping grows too much
	        switch (keyName) {
	            case 'esc':
	                return 'escape';
	            default:
	                return keyName;
	        }
	    };
	    KeyEventsPlugin = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], KeyEventsPlugin);
	    return KeyEventsPlugin;
	})(event_manager_1.EventManagerPlugin);
	exports.KeyEventsPlugin = KeyEventsPlugin;
	//# sourceMappingURL=key_events.js.map

/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	/// <reference path="../../../../../typings/hammerjs/hammerjs.d.ts"/>
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var hammer_common_1 = __webpack_require__(446);
	var lang_1 = __webpack_require__(159);
	var exceptions_1 = __webpack_require__(168);
	var di_1 = __webpack_require__(160);
	var HammerGesturesPlugin = (function (_super) {
	    __extends(HammerGesturesPlugin, _super);
	    function HammerGesturesPlugin() {
	        _super.apply(this, arguments);
	    }
	    HammerGesturesPlugin.prototype.supports = function (eventName) {
	        if (!_super.prototype.supports.call(this, eventName))
	            return false;
	        if (!lang_1.isPresent(window['Hammer'])) {
	            throw new exceptions_1.BaseException("Hammer.js is not loaded, can not bind " + eventName + " event");
	        }
	        return true;
	    };
	    HammerGesturesPlugin.prototype.addEventListener = function (element, eventName, handler) {
	        var zone = this.manager.getZone();
	        eventName = eventName.toLowerCase();
	        zone.runOutsideAngular(function () {
	            // Creating the manager bind events, must be done outside of angular
	            var mc = new Hammer(element);
	            mc.get('pinch').set({ enable: true });
	            mc.get('rotate').set({ enable: true });
	            mc.on(eventName, function (eventObj) { zone.run(function () { handler(eventObj); }); });
	        });
	    };
	    HammerGesturesPlugin = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], HammerGesturesPlugin);
	    return HammerGesturesPlugin;
	})(hammer_common_1.HammerGesturesPluginCommon);
	exports.HammerGesturesPlugin = HammerGesturesPlugin;
	//# sourceMappingURL=hammer_gestures.js.map

/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var event_manager_1 = __webpack_require__(431);
	var collection_1 = __webpack_require__(166);
	var _eventNames = {
	    // pan
	    'pan': true,
	    'panstart': true,
	    'panmove': true,
	    'panend': true,
	    'pancancel': true,
	    'panleft': true,
	    'panright': true,
	    'panup': true,
	    'pandown': true,
	    // pinch
	    'pinch': true,
	    'pinchstart': true,
	    'pinchmove': true,
	    'pinchend': true,
	    'pinchcancel': true,
	    'pinchin': true,
	    'pinchout': true,
	    // press
	    'press': true,
	    'pressup': true,
	    // rotate
	    'rotate': true,
	    'rotatestart': true,
	    'rotatemove': true,
	    'rotateend': true,
	    'rotatecancel': true,
	    // swipe
	    'swipe': true,
	    'swipeleft': true,
	    'swiperight': true,
	    'swipeup': true,
	    'swipedown': true,
	    // tap
	    'tap': true,
	};
	var HammerGesturesPluginCommon = (function (_super) {
	    __extends(HammerGesturesPluginCommon, _super);
	    function HammerGesturesPluginCommon() {
	        _super.call(this);
	    }
	    HammerGesturesPluginCommon.prototype.supports = function (eventName) {
	        eventName = eventName.toLowerCase();
	        return collection_1.StringMapWrapper.contains(_eventNames, eventName);
	    };
	    return HammerGesturesPluginCommon;
	})(event_manager_1.EventManagerPlugin);
	exports.HammerGesturesPluginCommon = HammerGesturesPluginCommon;
	//# sourceMappingURL=hammer_common.js.map

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var app_root_url_1 = __webpack_require__(402);
	var dom_adapter_1 = __webpack_require__(386);
	var di_1 = __webpack_require__(160);
	/**
	 * Extension of {@link AppRootUrl} that uses a DOM anchor tag to set the root url to
	 * the current page's url.
	 */
	var AnchorBasedAppRootUrl = (function (_super) {
	    __extends(AnchorBasedAppRootUrl, _super);
	    function AnchorBasedAppRootUrl() {
	        _super.call(this, "");
	        // compute the root url to pass to AppRootUrl
	        var rootUrl;
	        var a = dom_adapter_1.DOM.createElement('a');
	        dom_adapter_1.DOM.resolveAndSetHref(a, './', null);
	        rootUrl = dom_adapter_1.DOM.getHref(a);
	        this.value = rootUrl;
	    }
	    AnchorBasedAppRootUrl = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], AnchorBasedAppRootUrl);
	    return AnchorBasedAppRootUrl;
	})(app_root_url_1.AppRootUrl);
	exports.AnchorBasedAppRootUrl = AnchorBasedAppRootUrl;
	//# sourceMappingURL=anchor_based_app_root_url.js.map

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var di_1 = __webpack_require__(160);
	var dom_adapter_1 = __webpack_require__(386);
	var collection_1 = __webpack_require__(166);
	var exceptions_1 = __webpack_require__(168);
	var getTestabilityModule = __webpack_require__(449);
	var ng_zone_1 = __webpack_require__(432);
	var async_1 = __webpack_require__(216);
	/**
	 * The Testability service provides testing hooks that can be accessed from
	 * the browser and by services such as Protractor. Each bootstrapped Angular
	 * application on the page will have an instance of Testability.
	 */
	var Testability = (function () {
	    function Testability(_ngZone) {
	        this._ngZone = _ngZone;
	        this._pendingCount = 0;
	        this._callbacks = [];
	        this._isAngularEventPending = false;
	        this._watchAngularEvents(_ngZone);
	    }
	    Testability.prototype._watchAngularEvents = function (_ngZone) {
	        var _this = this;
	        _ngZone.overrideOnTurnStart(function () { _this._isAngularEventPending = true; });
	        _ngZone.overrideOnEventDone(function () {
	            _this._isAngularEventPending = false;
	            _this._runCallbacksIfReady();
	        }, true);
	    };
	    Testability.prototype.increasePendingRequestCount = function () {
	        this._pendingCount += 1;
	        return this._pendingCount;
	    };
	    Testability.prototype.decreasePendingRequestCount = function () {
	        this._pendingCount -= 1;
	        if (this._pendingCount < 0) {
	            throw new exceptions_1.BaseException('pending async requests below zero');
	        }
	        this._runCallbacksIfReady();
	        return this._pendingCount;
	    };
	    Testability.prototype._runCallbacksIfReady = function () {
	        var _this = this;
	        if (this._pendingCount != 0 || this._isAngularEventPending) {
	            return; // Not ready
	        }
	        // Schedules the call backs in a new frame so that it is always async.
	        async_1.PromiseWrapper.resolve(null).then(function (_) {
	            while (_this._callbacks.length !== 0) {
	                (_this._callbacks.pop())();
	            }
	        });
	    };
	    Testability.prototype.whenStable = function (callback) {
	        this._callbacks.push(callback);
	        this._runCallbacksIfReady();
	    };
	    Testability.prototype.getPendingRequestCount = function () { return this._pendingCount; };
	    // This only accounts for ngZone, and not pending counts. Use `whenStable` to
	    // check for stability.
	    Testability.prototype.isAngularEventPending = function () { return this._isAngularEventPending; };
	    Testability.prototype.findBindings = function (using, binding, exactMatch) {
	        // TODO(juliemr): implement.
	        return [];
	    };
	    Testability = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [ng_zone_1.NgZone])
	    ], Testability);
	    return Testability;
	})();
	exports.Testability = Testability;
	var TestabilityRegistry = (function () {
	    function TestabilityRegistry() {
	        this._applications = new collection_1.Map();
	        getTestabilityModule.GetTestability.addToWindow(this);
	    }
	    TestabilityRegistry.prototype.registerApplication = function (token, testability) {
	        this._applications.set(token, testability);
	    };
	    TestabilityRegistry.prototype.getAllTestabilities = function () { return collection_1.MapWrapper.values(this._applications); };
	    TestabilityRegistry.prototype.findTestabilityInTree = function (elem, findInAncestors) {
	        if (findInAncestors === void 0) { findInAncestors = true; }
	        if (elem == null) {
	            return null;
	        }
	        if (this._applications.has(elem)) {
	            return this._applications.get(elem);
	        }
	        else if (!findInAncestors) {
	            return null;
	        }
	        if (dom_adapter_1.DOM.isShadowRoot(elem)) {
	            return this.findTestabilityInTree(dom_adapter_1.DOM.getHost(elem));
	        }
	        return this.findTestabilityInTree(dom_adapter_1.DOM.parentElement(elem));
	    };
	    TestabilityRegistry = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [])
	    ], TestabilityRegistry);
	    return TestabilityRegistry;
	})();
	exports.TestabilityRegistry = TestabilityRegistry;
	//# sourceMappingURL=testability.js.map

/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var PublicTestability = (function () {
	    function PublicTestability(testability) {
	        this._testability = testability;
	    }
	    PublicTestability.prototype.whenStable = function (callback) { this._testability.whenStable(callback); };
	    PublicTestability.prototype.findBindings = function (using, binding, exactMatch) {
	        return this._testability.findBindings(using, binding, exactMatch);
	    };
	    return PublicTestability;
	})();
	var GetTestability = (function () {
	    function GetTestability() {
	    }
	    GetTestability.addToWindow = function (registry) {
	        lang_1.global.getAngularTestability = function (elem, findInAncestors) {
	            if (findInAncestors === void 0) { findInAncestors = true; }
	            var testability = registry.findTestabilityInTree(elem, findInAncestors);
	            if (testability == null) {
	                throw new Error('Could not find testability for element.');
	            }
	            return new PublicTestability(testability);
	        };
	        lang_1.global.getAllAngularTestabilities = function () {
	            var testabilities = registry.getAllTestabilities();
	            return testabilities.map(function (testability) { return new PublicTestability(testability); });
	        };
	    };
	    return GetTestability;
	})();
	exports.GetTestability = GetTestability;
	//# sourceMappingURL=get_testability.js.map

/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    __.prototype = b.prototype;
	    d.prototype = new __();
	};
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var dom_adapter_1 = __webpack_require__(386);
	var element_schema_registry_1 = __webpack_require__(427);
	var DomElementSchemaRegistry = (function (_super) {
	    __extends(DomElementSchemaRegistry, _super);
	    function DomElementSchemaRegistry() {
	        _super.apply(this, arguments);
	        this._protoElements = new Map();
	    }
	    DomElementSchemaRegistry.prototype._getProtoElement = function (tagName) {
	        var element = this._protoElements.get(tagName);
	        if (lang_1.isBlank(element)) {
	            element = dom_adapter_1.DOM.createElement(tagName);
	            this._protoElements.set(tagName, element);
	        }
	        return element;
	    };
	    DomElementSchemaRegistry.prototype.hasProperty = function (tagName, propName) {
	        if (tagName.indexOf('-') !== -1) {
	            // can't tell now as we don't know which properties a custom element will get
	            // once it is instantiated
	            return true;
	        }
	        else {
	            var elm = this._getProtoElement(tagName);
	            return dom_adapter_1.DOM.hasProperty(elm, propName);
	        }
	    };
	    DomElementSchemaRegistry.prototype.getMappedPropName = function (propName) {
	        var mappedPropName = collection_1.StringMapWrapper.get(dom_adapter_1.DOM.attrToPropMap, propName);
	        return lang_1.isPresent(mappedPropName) ? mappedPropName : propName;
	    };
	    return DomElementSchemaRegistry;
	})(element_schema_registry_1.ElementSchemaRegistry);
	exports.DomElementSchemaRegistry = DomElementSchemaRegistry;
	//# sourceMappingURL=dom_element_schema_registry.js.map

/***/ },
/* 451 */
/***/ function(module, exports) {

	/**
	 * This is here because DART requires it. It is noop in JS.
	 */
	function wtfInit() { }
	exports.wtfInit = wtfInit;
	//# sourceMappingURL=wtf_init.js.map

/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	var di_1 = __webpack_require__(160);
	var exceptions_1 = __webpack_require__(168);
	var dom_adapter_1 = __webpack_require__(386);
	exports.EXCEPTION_BINDING = di_1.bind(exceptions_1.ExceptionHandler).toFactory(function () { return new exceptions_1.ExceptionHandler(dom_adapter_1.DOM, false); }, []);
	//# sourceMappingURL=platform_bindings.js.map

/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for Services
	var app_root_url_1 = __webpack_require__(402);
	exports.AppRootUrl = app_root_url_1.AppRootUrl;
	var url_resolver_1 = __webpack_require__(401);
	exports.UrlResolver = url_resolver_1.UrlResolver;
	//# sourceMappingURL=services.js.map

/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for LifeCycle
	var life_cycle_1 = __webpack_require__(442);
	exports.LifeCycle = life_cycle_1.LifeCycle;
	//# sourceMappingURL=lifecycle.js.map

/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	// Public API for Zone
	var ng_zone_1 = __webpack_require__(432);
	exports.NgZone = ng_zone_1.NgZone;
	//# sourceMappingURL=zone.js.map

/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * Common directives shipped with Angular.
	 */
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var lang_1 = __webpack_require__(159);
	var ng_class_1 = __webpack_require__(457);
	var ng_for_1 = __webpack_require__(458);
	var ng_if_1 = __webpack_require__(459);
	var ng_non_bindable_1 = __webpack_require__(460);
	var ng_switch_1 = __webpack_require__(461);
	__export(__webpack_require__(457));
	__export(__webpack_require__(458));
	__export(__webpack_require__(459));
	__export(__webpack_require__(460));
	__export(__webpack_require__(462));
	__export(__webpack_require__(461));
	/**
	 * A collection of the Angular core directives that are likely to be used in each and every Angular
	 * application.
	 *
	 * This collection can be used to quickly enumerate all the built-in directives in the `@View`
	 * annotation. For example,
	 * instead of writing:
	 *
	 * ```
	 * import {NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';
	 * import {OtherDirective} from 'myDirectives';
	 *
	 * @Component({
	 *  selector: 'my-component'
	 * })
	 * @View({
	 *   templateUrl: 'myComponent.html',
	 *   directives: [NgClass, NgIf, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 * one could import all the core directives at once:
	 *
	 * ```
	 * import {CORE_DIRECTIVES} from 'angular2/angular2';
	 * import {OtherDirective} from 'myDirectives';
	 *
	 * @Component({
	 *  selector: 'my-component'
	 * })
	 * @View({
	 *   templateUrl: 'myComponent.html',
	 *   directives: [CORE_DIRECTIVES, OtherDirective]
	 * })
	 * export class MyComponent {
	 *   ...
	 * }
	 * ```
	 *
	 */
	exports.CORE_DIRECTIVES = lang_1.CONST_EXPR([ng_class_1.NgClass, ng_for_1.NgFor, ng_if_1.NgIf, ng_non_bindable_1.NgNonBindable, ng_switch_1.NgSwitch, ng_switch_1.NgSwitchWhen, ng_switch_1.NgSwitchDefault]);
	//# sourceMappingURL=directives.js.map

/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var metadata_1 = __webpack_require__(157);
	var compiler_1 = __webpack_require__(377);
	var change_detection_1 = __webpack_require__(178);
	var render_1 = __webpack_require__(404);
	var collection_1 = __webpack_require__(166);
	/**
	 * Adds and removes CSS classes based on an {expression} value.
	 *
	 * The result of expression is used to add and remove CSS classes using the following logic,
	 * based on expression's value type:
	 * - {string} - all the CSS classes (space - separated) are added
	 * - {Array} - all the CSS classes (Array elements) are added
	 * - {Object} - each key corresponds to a CSS class name while values
	 * are interpreted as {boolean} expression. If a given expression
	 * evaluates to {true} a corresponding CSS class is added - otherwise
	 * it is removed.
	 *
	 * # Example:
	 *
	 * ```
	 * <div class="message" [ng-class]="{error: errorCount > 0}">
	 *     Please check errors.
	 * </div>
	 * ```
	 */
	var NgClass = (function () {
	    function NgClass(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
	        this._iterableDiffers = _iterableDiffers;
	        this._keyValueDiffers = _keyValueDiffers;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	        this._initialClasses = [];
	    }
	    Object.defineProperty(NgClass.prototype, "initialClasses", {
	        set: function (v) {
	            this._applyInitialClasses(true);
	            this._initialClasses = lang_1.isPresent(v) && lang_1.isString(v) ? v.split(' ') : [];
	            this._applyInitialClasses(false);
	            this._applyClasses(this._rawClass, false);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NgClass.prototype, "rawClass", {
	        set: function (v) {
	            this._cleanupClasses(this._rawClass);
	            if (lang_1.isString(v)) {
	                v = v.split(' ');
	            }
	            this._rawClass = v;
	            if (lang_1.isPresent(v)) {
	                if (collection_1.isListLikeIterable(v)) {
	                    this._differ = this._iterableDiffers.find(v).create(null);
	                    this._mode = 'iterable';
	                }
	                else {
	                    this._differ = this._keyValueDiffers.find(v).create(null);
	                    this._mode = 'keyValue';
	                }
	            }
	            else {
	                this._differ = null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgClass.prototype.doCheck = function () {
	        if (lang_1.isPresent(this._differ)) {
	            var changes = this._differ.diff(this._rawClass);
	            if (lang_1.isPresent(changes)) {
	                if (this._mode == 'iterable') {
	                    this._applyIterableChanges(changes);
	                }
	                else {
	                    this._applyKeyValueChanges(changes);
	                }
	            }
	        }
	    };
	    NgClass.prototype.onDestroy = function () { this._cleanupClasses(this._rawClass); };
	    NgClass.prototype._cleanupClasses = function (rawClassVal) {
	        this._applyClasses(rawClassVal, true);
	        this._applyInitialClasses(false);
	    };
	    NgClass.prototype._applyKeyValueChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
	        changes.forEachChangedItem(function (record) { _this._toggleClass(record.key, record.currentValue); });
	        changes.forEachRemovedItem(function (record) {
	            if (record.previousValue) {
	                _this._toggleClass(record.key, false);
	            }
	        });
	    };
	    NgClass.prototype._applyIterableChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) { _this._toggleClass(record.item, true); });
	        changes.forEachRemovedItem(function (record) { _this._toggleClass(record.item, false); });
	    };
	    NgClass.prototype._applyInitialClasses = function (isCleanup) {
	        var _this = this;
	        collection_1.ListWrapper.forEach(this._initialClasses, function (className) { _this._toggleClass(className, !isCleanup); });
	    };
	    NgClass.prototype._applyClasses = function (rawClassVal, isCleanup) {
	        var _this = this;
	        if (lang_1.isPresent(rawClassVal)) {
	            if (collection_1.isListLikeIterable(rawClassVal)) {
	                collection_1.ListWrapper.forEach(rawClassVal, function (className) { return _this._toggleClass(className, !isCleanup); });
	            }
	            else {
	                collection_1.StringMapWrapper.forEach(rawClassVal, function (expVal, className) {
	                    if (expVal)
	                        _this._toggleClass(className, !isCleanup);
	                });
	            }
	        }
	    };
	    NgClass.prototype._toggleClass = function (className, enabled) {
	        this._renderer.setElementClass(this._ngEl, className, enabled);
	    };
	    NgClass = __decorate([
	        metadata_1.Directive({ selector: '[ng-class]', properties: ['rawClass: ng-class', 'initialClasses: class'] }), 
	        __metadata('design:paramtypes', [change_detection_1.IterableDiffers, change_detection_1.KeyValueDiffers, compiler_1.ElementRef, render_1.Renderer])
	    ], NgClass);
	    return NgClass;
	})();
	exports.NgClass = NgClass;
	//# sourceMappingURL=ng_class.js.map

/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var metadata_1 = __webpack_require__(157);
	var change_detection_1 = __webpack_require__(178);
	var compiler_1 = __webpack_require__(377);
	var lang_1 = __webpack_require__(159);
	/**
	 * The `NgFor` directive instantiates a template once per item from an iterable. The context for
	 * each instantiated template inherits from the outer context with the given loop variable set
	 * to the current item from the iterable.
	 *
	 * It is possible to alias the `index` to a local variable that will be set to the current loop
	 * iteration in the template context, and also to alias the 'last' to a local variable that will
	 * be set to a boolean indicating if the item is the last one in the iteration
	 *
	 * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
	 *
	 * * When an item is added, a new instance of the template is added to the DOM.
	 * * When an item is removed, its template instance is removed from the DOM.
	 * * When items are reordered, their respective templates are reordered in the DOM.
	 *
	 * # Example
	 *
	 * ```
	 * <ul>
	 *   <li *ng-for="#error of errors; #i = index">
	 *     Error {{i}} of {{errors.length}}: {{error.message}}
	 *   </li>
	 * </ul>
	 * ```
	 *
	 * # Syntax
	 *
	 * - `<li *ng-for="#item of items; #i = index">...</li>`
	 * - `<li template="ng-for #item of items; #i = index">...</li>`
	 * - `<template ng-for #item [ng-for-of]="items" #i="index"><li>...</li></template>`
	 */
	var NgFor = (function () {
	    function NgFor(_viewContainer, _templateRef, _iterableDiffers, _cdr) {
	        this._viewContainer = _viewContainer;
	        this._templateRef = _templateRef;
	        this._iterableDiffers = _iterableDiffers;
	        this._cdr = _cdr;
	    }
	    Object.defineProperty(NgFor.prototype, "ngForOf", {
	        set: function (value) {
	            this._ngForOf = value;
	            if (lang_1.isBlank(this._differ) && lang_1.isPresent(value)) {
	                this._differ = this._iterableDiffers.find(value).create(this._cdr);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgFor.prototype.doCheck = function () {
	        if (lang_1.isPresent(this._differ)) {
	            var changes = this._differ.diff(this._ngForOf);
	            if (lang_1.isPresent(changes))
	                this._applyChanges(changes);
	        }
	    };
	    NgFor.prototype._applyChanges = function (changes) {
	        // TODO(rado): check if change detection can produce a change record that is
	        // easier to consume than current.
	        var recordViewTuples = [];
	        changes.forEachRemovedItem(function (removedRecord) {
	            return recordViewTuples.push(new RecordViewTuple(removedRecord, null));
	        });
	        changes.forEachMovedItem(function (movedRecord) {
	            return recordViewTuples.push(new RecordViewTuple(movedRecord, null));
	        });
	        var insertTuples = NgFor.bulkRemove(recordViewTuples, this._viewContainer);
	        changes.forEachAddedItem(function (addedRecord) {
	            return insertTuples.push(new RecordViewTuple(addedRecord, null));
	        });
	        NgFor.bulkInsert(insertTuples, this._viewContainer, this._templateRef);
	        for (var i = 0; i < insertTuples.length; i++) {
	            this._perViewChange(insertTuples[i].view, insertTuples[i].record);
	        }
	        for (var i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
	            this._viewContainer.get(i).setLocal('last', i === ilen - 1);
	        }
	    };
	    NgFor.prototype._perViewChange = function (view, record) {
	        view.setLocal('\$implicit', record.item);
	        view.setLocal('index', record.currentIndex);
	    };
	    NgFor.bulkRemove = function (tuples, viewContainer) {
	        tuples.sort(function (a, b) { return a.record.previousIndex - b.record.previousIndex; });
	        var movedTuples = [];
	        for (var i = tuples.length - 1; i >= 0; i--) {
	            var tuple = tuples[i];
	            // separate moved views from removed views.
	            if (lang_1.isPresent(tuple.record.currentIndex)) {
	                tuple.view = viewContainer.detach(tuple.record.previousIndex);
	                movedTuples.push(tuple);
	            }
	            else {
	                viewContainer.remove(tuple.record.previousIndex);
	            }
	        }
	        return movedTuples;
	    };
	    NgFor.bulkInsert = function (tuples, viewContainer, templateRef) {
	        tuples.sort(function (a, b) { return a.record.currentIndex - b.record.currentIndex; });
	        for (var i = 0; i < tuples.length; i++) {
	            var tuple = tuples[i];
	            if (lang_1.isPresent(tuple.view)) {
	                viewContainer.insert(tuple.view, tuple.record.currentIndex);
	            }
	            else {
	                tuple.view = viewContainer.createEmbeddedView(templateRef, tuple.record.currentIndex);
	            }
	        }
	        return tuples;
	    };
	    NgFor = __decorate([
	        metadata_1.Directive({ selector: '[ng-for][ng-for-of]', properties: ['ngForOf'] }), 
	        __metadata('design:paramtypes', [compiler_1.ViewContainerRef, compiler_1.TemplateRef, change_detection_1.IterableDiffers, change_detection_1.ChangeDetectorRef])
	    ], NgFor);
	    return NgFor;
	})();
	exports.NgFor = NgFor;
	var RecordViewTuple = (function () {
	    function RecordViewTuple(record, view) {
	        this.record = record;
	        this.view = view;
	    }
	    return RecordViewTuple;
	})();
	exports.RecordViewTuple = RecordViewTuple;
	//# sourceMappingURL=ng_for.js.map

/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var metadata_1 = __webpack_require__(157);
	var compiler_1 = __webpack_require__(377);
	var lang_1 = __webpack_require__(159);
	/**
	 * Removes or recreates a portion of the DOM tree based on an {expression}.
	 *
	 * If the expression assigned to `ng-if` evaluates to a false value then the element
	 * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
	 *
	 * # Example:
	 *
	 * ```
	 * <div *ng-if="errorCount > 0" class="error">
	 *   <!-- Error message displayed when the errorCount property on the current context is greater
	 * than 0. -->
	 *   {{errorCount}} errors detected
	 * </div>
	 * ```
	 *
	 * # Syntax
	 *
	 * - `<div *ng-if="condition">...</div>`
	 * - `<div template="ng-if condition">...</div>`
	 * - `<template [ng-if]="condition"><div>...</div></template>`
	 */
	var NgIf = (function () {
	    function NgIf(_viewContainer, _templateRef) {
	        this._viewContainer = _viewContainer;
	        this._templateRef = _templateRef;
	        this._prevCondition = null;
	    }
	    Object.defineProperty(NgIf.prototype, "ngIf", {
	        set: function (newCondition /* boolean */) {
	            if (newCondition && (lang_1.isBlank(this._prevCondition) || !this._prevCondition)) {
	                this._prevCondition = true;
	                this._viewContainer.createEmbeddedView(this._templateRef);
	            }
	            else if (!newCondition && (lang_1.isBlank(this._prevCondition) || this._prevCondition)) {
	                this._prevCondition = false;
	                this._viewContainer.clear();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgIf = __decorate([
	        metadata_1.Directive({ selector: '[ng-if]', properties: ['ngIf'] }), 
	        __metadata('design:paramtypes', [compiler_1.ViewContainerRef, compiler_1.TemplateRef])
	    ], NgIf);
	    return NgIf;
	})();
	exports.NgIf = NgIf;
	//# sourceMappingURL=ng_if.js.map

/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var metadata_1 = __webpack_require__(157);
	/**
	 * The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current
	 * DOM element. This is useful if the element contains what appears to be Angular directives and
	 * bindings but which should be ignored by Angular. This could be the case if you have a site that
	 * displays snippets of code, for instance.
	 *
	 * Example:
	 *
	 * ```
	 * <div>Normal: {{1 + 2}}</div> // output "Normal: 3"
	 * <div ng-non-bindable>Ignored: {{1 + 2}}</div> // output "Ignored: {{1 + 2}}"
	 * ```
	 */
	var NgNonBindable = (function () {
	    function NgNonBindable() {
	    }
	    NgNonBindable = __decorate([
	        metadata_1.Directive({ selector: '[ng-non-bindable]', compileChildren: false }), 
	        __metadata('design:paramtypes', [])
	    ], NgNonBindable);
	    return NgNonBindable;
	})();
	exports.NgNonBindable = NgNonBindable;
	//# sourceMappingURL=ng_non_bindable.js.map

/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var __param = (this && this.__param) || function (paramIndex, decorator) {
	    return function (target, key) { decorator(target, key, paramIndex); }
	};
	var metadata_1 = __webpack_require__(157);
	var di_1 = __webpack_require__(160);
	var compiler_1 = __webpack_require__(377);
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var _WHEN_DEFAULT = lang_1.CONST_EXPR(new Object());
	var SwitchView = (function () {
	    function SwitchView(_viewContainerRef, _templateRef) {
	        this._viewContainerRef = _viewContainerRef;
	        this._templateRef = _templateRef;
	    }
	    SwitchView.prototype.create = function () { this._viewContainerRef.createEmbeddedView(this._templateRef); };
	    SwitchView.prototype.destroy = function () { this._viewContainerRef.clear(); };
	    return SwitchView;
	})();
	exports.SwitchView = SwitchView;
	/**
	 * The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a
	 * scope expression.
	 * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be
	 * preserved at the location as specified in the template.
	 *
	 * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches
	 * the value obtained from the evaluated expression. In other words, you define a container element
	 * (where you place the directive), place an expression on the **`[ng-switch]="..."` attribute**),
	 * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per
	 * element.
	 * The when attribute is used to inform NgSwitch which element to display when the expression is
	 * evaluated. If a matching expression is not found via a when attribute then an element with the
	 * default attribute is displayed.
	 *
	 * # Example:
	 *
	 * ```
	 * <ANY [ng-switch]="expression">
	 *   <template [ng-switch-when]="whenExpression1">...</template>
	 *   <template [ng-switch-when]="whenExpression1">...</template>
	 *   <template ng-switch-default>...</template>
	 * </ANY>
	 * ```
	 */
	var NgSwitch = (function () {
	    function NgSwitch() {
	        this._useDefault = false;
	        this._valueViews = new collection_1.Map();
	        this._activeViews = [];
	    }
	    Object.defineProperty(NgSwitch.prototype, "ngSwitch", {
	        set: function (value) {
	            // Empty the currently active ViewContainers
	            this._emptyAllActiveViews();
	            // Add the ViewContainers matching the value (with a fallback to default)
	            this._useDefault = false;
	            var views = this._valueViews.get(value);
	            if (lang_1.isBlank(views)) {
	                this._useDefault = true;
	                views = lang_1.normalizeBlank(this._valueViews.get(_WHEN_DEFAULT));
	            }
	            this._activateViews(views);
	            this._switchValue = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgSwitch.prototype._onWhenValueChanged = function (oldWhen, newWhen, view) {
	        this._deregisterView(oldWhen, view);
	        this._registerView(newWhen, view);
	        if (oldWhen === this._switchValue) {
	            view.destroy();
	            collection_1.ListWrapper.remove(this._activeViews, view);
	        }
	        else if (newWhen === this._switchValue) {
	            if (this._useDefault) {
	                this._useDefault = false;
	                this._emptyAllActiveViews();
	            }
	            view.create();
	            this._activeViews.push(view);
	        }
	        // Switch to default when there is no more active ViewContainers
	        if (this._activeViews.length === 0 && !this._useDefault) {
	            this._useDefault = true;
	            this._activateViews(this._valueViews.get(_WHEN_DEFAULT));
	        }
	    };
	    NgSwitch.prototype._emptyAllActiveViews = function () {
	        var activeContainers = this._activeViews;
	        for (var i = 0; i < activeContainers.length; i++) {
	            activeContainers[i].destroy();
	        }
	        this._activeViews = [];
	    };
	    NgSwitch.prototype._activateViews = function (views) {
	        // TODO(vicb): assert(this._activeViews.length === 0);
	        if (lang_1.isPresent(views)) {
	            for (var i = 0; i < views.length; i++) {
	                views[i].create();
	            }
	            this._activeViews = views;
	        }
	    };
	    NgSwitch.prototype._registerView = function (value, view) {
	        var views = this._valueViews.get(value);
	        if (lang_1.isBlank(views)) {
	            views = [];
	            this._valueViews.set(value, views);
	        }
	        views.push(view);
	    };
	    NgSwitch.prototype._deregisterView = function (value, view) {
	        // `_WHEN_DEFAULT` is used a marker for non-registered whens
	        if (value === _WHEN_DEFAULT)
	            return;
	        var views = this._valueViews.get(value);
	        if (views.length == 1) {
	            this._valueViews.delete(value);
	        }
	        else {
	            collection_1.ListWrapper.remove(views, view);
	        }
	    };
	    NgSwitch = __decorate([
	        metadata_1.Directive({ selector: '[ng-switch]', properties: ['ngSwitch'] }), 
	        __metadata('design:paramtypes', [])
	    ], NgSwitch);
	    return NgSwitch;
	})();
	exports.NgSwitch = NgSwitch;
	/**
	 * Defines a case statement as an expression.
	 *
	 * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.
	 *
	 * Example:
	 *
	 * ```
	 * // match against a context variable
	 * <template [ng-switch-when]="contextVariable">...</template>
	 *
	 * // match against a constant string
	 * <template ng-switch-when="stringValue">...</template>
	 * ```
	 */
	var NgSwitchWhen = (function () {
	    function NgSwitchWhen(viewContainer, templateRef, _switch) {
	        this._switch = _switch;
	        // `_WHEN_DEFAULT` is used as a marker for a not yet initialized value
	        this._value = _WHEN_DEFAULT;
	        this._view = new SwitchView(viewContainer, templateRef);
	    }
	    Object.defineProperty(NgSwitchWhen.prototype, "ngSwitchWhen", {
	        set: function (value) {
	            this._switch._onWhenValueChanged(this._value, value, this._view);
	            this._value = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgSwitchWhen = __decorate([
	        metadata_1.Directive({ selector: '[ng-switch-when]', properties: ['ngSwitchWhen'] }),
	        __param(2, di_1.Host()), 
	        __metadata('design:paramtypes', [compiler_1.ViewContainerRef, compiler_1.TemplateRef, NgSwitch])
	    ], NgSwitchWhen);
	    return NgSwitchWhen;
	})();
	exports.NgSwitchWhen = NgSwitchWhen;
	/**
	 * Defines a default case statement.
	 *
	 * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.
	 *
	 * Example:
	 *
	 * ```
	 * <template ng-switch-default>...</template>
	 * ```
	 */
	var NgSwitchDefault = (function () {
	    function NgSwitchDefault(viewContainer, templateRef, sswitch) {
	        sswitch._registerView(_WHEN_DEFAULT, new SwitchView(viewContainer, templateRef));
	    }
	    NgSwitchDefault = __decorate([
	        metadata_1.Directive({ selector: '[ng-switch-default]' }),
	        __param(2, di_1.Host()), 
	        __metadata('design:paramtypes', [compiler_1.ViewContainerRef, compiler_1.TemplateRef, NgSwitch])
	    ], NgSwitchDefault);
	    return NgSwitchDefault;
	})();
	exports.NgSwitchDefault = NgSwitchDefault;
	//# sourceMappingURL=ng_switch.js.map

/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var change_detection_1 = __webpack_require__(178);
	var compiler_1 = __webpack_require__(377);
	var metadata_1 = __webpack_require__(157);
	var render_1 = __webpack_require__(404);
	var lang_1 = __webpack_require__(159);
	/**
	 * Adds or removes styles based on an {expression}.
	 *
	 * When the expression assigned to `ng-style` evaluates to an object, the corresponding element
	 * styles are updated. Style names to update are taken from the object keys and values - from the
	 * corresponding object values.
	 *
	 * # Example:
	 *
	 * ```
	 * <div [ng-style]="{'text-align': alignExp}"></div>
	 * ```
	 *
	 * In the above example the `text-align` style will be updated based on the `alignExp` value
	 * changes.
	 *
	 * # Syntax
	 *
	 * - `<div [ng-style]="{'text-align': alignExp}"></div>`
	 * - `<div [ng-style]="styleExp"></div>`
	 */
	var NgStyle = (function () {
	    function NgStyle(_differs, _ngEl, _renderer) {
	        this._differs = _differs;
	        this._ngEl = _ngEl;
	        this._renderer = _renderer;
	    }
	    Object.defineProperty(NgStyle.prototype, "rawStyle", {
	        set: function (v) {
	            this._rawStyle = v;
	            if (lang_1.isBlank(this._differ) && lang_1.isPresent(v)) {
	                this._differ = this._differs.find(this._rawStyle).create(null);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NgStyle.prototype.doCheck = function () {
	        if (lang_1.isPresent(this._differ)) {
	            var changes = this._differ.diff(this._rawStyle);
	            if (lang_1.isPresent(changes)) {
	                this._applyChanges(changes);
	            }
	        }
	    };
	    NgStyle.prototype._applyChanges = function (changes) {
	        var _this = this;
	        changes.forEachAddedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
	        changes.forEachChangedItem(function (record) { _this._setStyle(record.key, record.currentValue); });
	        changes.forEachRemovedItem(function (record) { _this._setStyle(record.key, null); });
	    };
	    NgStyle.prototype._setStyle = function (name, val) {
	        this._renderer.setElementStyle(this._ngEl, name, val);
	    };
	    NgStyle = __decorate([
	        metadata_1.Directive({ selector: '[ng-style]', properties: ['rawStyle: ng-style'] }), 
	        __metadata('design:paramtypes', [change_detection_1.KeyValueDiffers, compiler_1.ElementRef, render_1.Renderer])
	    ], NgStyle);
	    return NgStyle;
	})();
	exports.NgStyle = NgStyle;
	//# sourceMappingURL=ng_style.js.map

/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(464));
	var debug_element_view_listener_1 = __webpack_require__(465);
	exports.inspectNativeElement = debug_element_view_listener_1.inspectNativeElement;
	exports.ELEMENT_PROBE_BINDINGS = debug_element_view_listener_1.ELEMENT_PROBE_BINDINGS;
	//# sourceMappingURL=debug.js.map

/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var dom_adapter_1 = __webpack_require__(386);
	var view_ref_1 = __webpack_require__(384);
	/**
	 * A DebugElement contains information from the Angular compiler about an
	 * element and provides access to the corresponding ElementInjector and
	 * underlying dom Element, as well as a way to query for children.
	 */
	var DebugElement = (function () {
	    function DebugElement(_parentView, _boundElementIndex) {
	        this._parentView = _parentView;
	        this._boundElementIndex = _boundElementIndex;
	        this._elementInjector = this._parentView.elementInjectors[this._boundElementIndex];
	    }
	    DebugElement.create = function (elementRef) {
	        return new DebugElement(view_ref_1.internalView(elementRef.parentView), elementRef.boundElementIndex);
	    };
	    Object.defineProperty(DebugElement.prototype, "componentInstance", {
	        get: function () {
	            if (!lang_1.isPresent(this._elementInjector)) {
	                return null;
	            }
	            return this._elementInjector.getComponent();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugElement.prototype, "nativeElement", {
	        get: function () { return this.elementRef.nativeElement; },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugElement.prototype, "elementRef", {
	        get: function () { return this._parentView.elementRefs[this._boundElementIndex]; },
	        enumerable: true,
	        configurable: true
	    });
	    DebugElement.prototype.getDirectiveInstance = function (directiveIndex) {
	        return this._elementInjector.getDirectiveAtIndex(directiveIndex);
	    };
	    Object.defineProperty(DebugElement.prototype, "children", {
	        /**
	         * Get child DebugElements from within the Light DOM.
	         *
	         * @return {DebugElement[]}
	         */
	        get: function () {
	            return this._getChildElements(this._parentView, this._boundElementIndex);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DebugElement.prototype, "componentViewChildren", {
	        /**
	         * Get the root DebugElement children of a component. Returns an empty
	         * list if the current DebugElement is not a component root.
	         *
	         * @return {DebugElement[]}
	         */
	        get: function () {
	            var shadowView = this._parentView.getNestedView(this._boundElementIndex);
	            if (!lang_1.isPresent(shadowView)) {
	                // The current element is not a component.
	                return [];
	            }
	            return this._getChildElements(shadowView, null);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DebugElement.prototype.triggerEventHandler = function (eventName, eventObj) {
	        this._parentView.triggerEventHandlers(eventName, eventObj, this._boundElementIndex);
	    };
	    DebugElement.prototype.hasDirective = function (type) {
	        if (!lang_1.isPresent(this._elementInjector)) {
	            return false;
	        }
	        return this._elementInjector.hasDirective(type);
	    };
	    DebugElement.prototype.inject = function (type) {
	        if (!lang_1.isPresent(this._elementInjector)) {
	            return null;
	        }
	        return this._elementInjector.get(type);
	    };
	    DebugElement.prototype.getLocal = function (name) { return this._parentView.locals.get(name); };
	    /**
	     * Return the first descendant TestElement matching the given predicate
	     * and scope.
	     *
	     * @param {Function: boolean} predicate
	     * @param {Scope} scope
	     *
	     * @return {DebugElement}
	     */
	    DebugElement.prototype.query = function (predicate, scope) {
	        if (scope === void 0) { scope = Scope.all; }
	        var results = this.queryAll(predicate, scope);
	        return results.length > 0 ? results[0] : null;
	    };
	    /**
	     * Return descendant TestElememts matching the given predicate
	     * and scope.
	     *
	     * @param {Function: boolean} predicate
	     * @param {Scope} scope
	     *
	     * @return {DebugElement[]}
	     */
	    DebugElement.prototype.queryAll = function (predicate, scope) {
	        if (scope === void 0) { scope = Scope.all; }
	        var elementsInScope = scope(this);
	        return collection_1.ListWrapper.filter(elementsInScope, predicate);
	    };
	    DebugElement.prototype._getChildElements = function (view, parentBoundElementIndex) {
	        var _this = this;
	        var els = [];
	        var parentElementBinder = null;
	        if (lang_1.isPresent(parentBoundElementIndex)) {
	            parentElementBinder = view.proto.elementBinders[parentBoundElementIndex - view.elementOffset];
	        }
	        for (var i = 0; i < view.proto.elementBinders.length; ++i) {
	            var binder = view.proto.elementBinders[i];
	            if (binder.parent == parentElementBinder) {
	                els.push(new DebugElement(view, view.elementOffset + i));
	                var views = view.viewContainers[view.elementOffset + i];
	                if (lang_1.isPresent(views)) {
	                    collection_1.ListWrapper.forEach(views.views, function (nextView) {
	                        els = els.concat(_this._getChildElements(nextView, null));
	                    });
	                }
	            }
	        }
	        return els;
	    };
	    return DebugElement;
	})();
	exports.DebugElement = DebugElement;
	/**
	 * Returns a DebugElement for a ElementRef.
	 *
	 * @param {ElementRef}: elementRef
	 * @return {DebugElement}
	 */
	function inspectElement(elementRef) {
	    return DebugElement.create(elementRef);
	}
	exports.inspectElement = inspectElement;
	function asNativeElements(arr) {
	    return arr.map(function (debugEl) { return debugEl.nativeElement; });
	}
	exports.asNativeElements = asNativeElements;
	var Scope = (function () {
	    function Scope() {
	    }
	    Scope.all = function (debugElement) {
	        var scope = [];
	        scope.push(debugElement);
	        collection_1.ListWrapper.forEach(debugElement.children, function (child) { scope = scope.concat(Scope.all(child)); });
	        collection_1.ListWrapper.forEach(debugElement.componentViewChildren, function (child) { scope = scope.concat(Scope.all(child)); });
	        return scope;
	    };
	    Scope.light = function (debugElement) {
	        var scope = [];
	        collection_1.ListWrapper.forEach(debugElement.children, function (child) {
	            scope.push(child);
	            scope = scope.concat(Scope.light(child));
	        });
	        return scope;
	    };
	    Scope.view = function (debugElement) {
	        var scope = [];
	        collection_1.ListWrapper.forEach(debugElement.componentViewChildren, function (child) {
	            scope.push(child);
	            scope = scope.concat(Scope.light(child));
	        });
	        return scope;
	    };
	    return Scope;
	})();
	exports.Scope = Scope;
	var By = (function () {
	    function By() {
	    }
	    By.all = function () { return function (debugElement) { return true; }; };
	    By.css = function (selector) {
	        return function (debugElement) {
	            return lang_1.isPresent(debugElement.nativeElement) ?
	                dom_adapter_1.DOM.elementMatches(debugElement.nativeElement, selector) :
	                false;
	        };
	    };
	    By.directive = function (type) {
	        return function (debugElement) { return debugElement.hasDirective(type); };
	    };
	    return By;
	})();
	exports.By = By;
	//# sourceMappingURL=debug_element.js.map

/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") return Reflect.decorate(decorators, target, key, desc);
	    switch (arguments.length) {
	        case 2: return decorators.reduceRight(function(o, d) { return (d && d(o)) || o; }, target);
	        case 3: return decorators.reduceRight(function(o, d) { return (d && d(target, key)), void 0; }, void 0);
	        case 4: return decorators.reduceRight(function(o, d) { return (d && d(target, key, o)) || o; }, desc);
	    }
	};
	var __metadata = (this && this.__metadata) || function (k, v) {
	    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
	};
	var lang_1 = __webpack_require__(159);
	var collection_1 = __webpack_require__(166);
	var di_1 = __webpack_require__(160);
	var view_listener_1 = __webpack_require__(393);
	var dom_adapter_1 = __webpack_require__(386);
	var api_1 = __webpack_require__(212);
	var debug_element_1 = __webpack_require__(464);
	var NG_ID_PROPERTY = 'ngid';
	var INSPECT_GLOBAL_NAME = 'ng.probe';
	var NG_ID_SEPARATOR = '#';
	// Need to keep the views in a global Map so that multiple angular apps are supported
	var _allIdsByView = new collection_1.Map();
	var _allViewsById = new collection_1.Map();
	var _nextId = 0;
	function _setElementId(element, indices) {
	    if (lang_1.isPresent(element)) {
	        dom_adapter_1.DOM.setData(element, NG_ID_PROPERTY, collection_1.ListWrapper.join(indices, NG_ID_SEPARATOR));
	    }
	}
	function _getElementId(element) {
	    var elId = dom_adapter_1.DOM.getData(element, NG_ID_PROPERTY);
	    if (lang_1.isPresent(elId)) {
	        return collection_1.ListWrapper.map(elId.split(NG_ID_SEPARATOR), function (partStr) { return lang_1.NumberWrapper.parseInt(partStr, 10); });
	    }
	    else {
	        return null;
	    }
	}
	function inspectNativeElement(element) {
	    var elId = _getElementId(element);
	    if (lang_1.isPresent(elId)) {
	        var view = _allViewsById.get(elId[0]);
	        if (lang_1.isPresent(view)) {
	            return new debug_element_1.DebugElement(view, elId[1]);
	        }
	    }
	    return null;
	}
	exports.inspectNativeElement = inspectNativeElement;
	var DebugElementViewListener = (function () {
	    function DebugElementViewListener(_renderer) {
	        this._renderer = _renderer;
	        dom_adapter_1.DOM.setGlobalVar(INSPECT_GLOBAL_NAME, inspectNativeElement);
	    }
	    DebugElementViewListener.prototype.viewCreated = function (view) {
	        var viewId = _nextId++;
	        _allViewsById.set(viewId, view);
	        _allIdsByView.set(view, viewId);
	        for (var i = 0; i < view.elementRefs.length; i++) {
	            var el = view.elementRefs[i];
	            _setElementId(this._renderer.getNativeElementSync(el), [viewId, i]);
	        }
	    };
	    DebugElementViewListener.prototype.viewDestroyed = function (view) {
	        var viewId = _allIdsByView.get(view);
	        collection_1.MapWrapper.delete(_allIdsByView, view);
	        collection_1.MapWrapper.delete(_allViewsById, viewId);
	    };
	    DebugElementViewListener = __decorate([
	        di_1.Injectable(), 
	        __metadata('design:paramtypes', [api_1.Renderer])
	    ], DebugElementViewListener);
	    return DebugElementViewListener;
	})();
	exports.DebugElementViewListener = DebugElementViewListener;
	exports.ELEMENT_PROBE_BINDINGS = lang_1.CONST_EXPR([
	    DebugElementViewListener,
	    lang_1.CONST_EXPR(new di_1.Binding(view_listener_1.AppViewListener, { toAlias: DebugElementViewListener })),
	]);
	//# sourceMappingURL=debug_element_view_listener.js.map

/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	var profile_1 = __webpack_require__(190);
	exports.wtfCreateScope = profile_1.wtfCreateScope;
	exports.wtfLeave = profile_1.wtfLeave;
	exports.wtfStartTimeRange = profile_1.wtfStartTimeRange;
	exports.wtfEndTimeRange = profile_1.wtfEndTimeRange;
	//# sourceMappingURL=profile.js.map

/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module
	 * @description
	 * Defines interfaces to be implemented by directives when they need to hook into the change
	 * detection mechanism.
	 */
	var interfaces_1 = __webpack_require__(378);
	exports.AfterContentInit = interfaces_1.AfterContentInit;
	exports.AfterContentChecked = interfaces_1.AfterContentChecked;
	exports.AfterViewInit = interfaces_1.AfterViewInit;
	exports.AfterViewChecked = interfaces_1.AfterViewChecked;
	exports.OnChanges = interfaces_1.OnChanges;
	exports.OnDestroy = interfaces_1.OnDestroy;
	exports.OnInit = interfaces_1.OnInit;
	exports.DoCheck = interfaces_1.DoCheck;
	//# sourceMappingURL=lifecycle_hooks.js.map

/***/ },
/* 468 */
/***/ function(module, exports) {

	/**
	 * This file is only used for dart applications and for internal examples
	 * that compile with both JavaScript and Dart.
	 */
	// var bootstrap_1 = require('angular2/src/core/bootstrap');
	// exports.bootstrap = bootstrap_1.bootstrap;
	//# sourceMappingURL=bootstrap.js.map

/***/ }
/******/ ])));